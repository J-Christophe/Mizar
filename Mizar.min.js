(function (root, factory) {
    if (typeof define === 'function' && define.amd) {
        //Allow using this built library as an AMD module
        //in another project. That other project will only
        //see this AMD call, not the internal modules in
        //the closure below.
        define([], factory);
    } else {
        //Browser globals case. Just assign the
        //result to a property on the global.
        root.libGlobalName = factory();
    }
}(this, function () {
/**
 * almond 0.2.5 Copyright (c) 2011-2012, The Dojo Foundation All Rights Reserved.
 * Available via the MIT or new BSD license.
 * see: http://github.com/jrburke/almond for details
 */
//Going sloppy to avoid 'use strict' string cost, but strict practices should
//be followed.
/*jslint sloppy: true */
/*global setTimeout: false */

var requirejs, require, define;
(function (undef) {
    var main, req, makeMap, handlers,
        defined = {},
        waiting = {},
        config = {},
        defining = {},
        hasOwn = Object.prototype.hasOwnProperty,
        aps = [].slice;

    function hasProp(obj, prop) {
        return hasOwn.call(obj, prop);
    }

    /**
     * Given a relative module name, like ./something, normalize it to
     * a real name that can be mapped to a path.
     * @param {String} name the relative name
     * @param {String} baseName a real name that the name arg is relative
     * to.
     * @returns {String} normalized name
     */
    function normalize(name, baseName) {
        var nameParts, nameSegment, mapValue, foundMap,
            foundI, foundStarMap, starI, i, j, part,
            baseParts = baseName && baseName.split("/"),
            map = config.map,
            starMap = (map && map['*']) || {};

        //Adjust any relative paths.
        if (name && name.charAt(0) === ".") {
            //If have a base name, try to normalize against it,
            //otherwise, assume it is a top-level require that will
            //be relative to baseUrl in the end.
            if (baseName) {
                //Convert baseName to array, and lop off the last part,
                //so that . matches that "directory" and not name of the baseName's
                //module. For instance, baseName of "one/two/three", maps to
                //"one/two/three.js", but we want the directory, "one/two" for
                //this normalization.
                baseParts = baseParts.slice(0, baseParts.length - 1);

                name = baseParts.concat(name.split("/"));

                //start trimDots
                for (i = 0; i < name.length; i += 1) {
                    part = name[i];
                    if (part === ".") {
                        name.splice(i, 1);
                        i -= 1;
                    } else if (part === "..") {
                        if (i === 1 && (name[2] === '..' || name[0] === '..')) {
                            //End of the line. Keep at least one non-dot
                            //path segment at the front so it can be mapped
                            //correctly to disk. Otherwise, there is likely
                            //no path mapping for a path starting with '..'.
                            //This can still fail, but catches the most reasonable
                            //uses of ..
                            break;
                        } else if (i > 0) {
                            name.splice(i - 1, 2);
                            i -= 2;
                        }
                    }
                }
                //end trimDots

                name = name.join("/");
            } else if (name.indexOf('./') === 0) {
                // No baseName, so this is ID is resolved relative
                // to baseUrl, pull off the leading dot.
                name = name.substring(2);
            }
        }

        //Apply map config if available.
        if ((baseParts || starMap) && map) {
            nameParts = name.split('/');

            for (i = nameParts.length; i > 0; i -= 1) {
                nameSegment = nameParts.slice(0, i).join("/");

                if (baseParts) {
                    //Find the longest baseName segment match in the config.
                    //So, do joins on the biggest to smallest lengths of baseParts.
                    for (j = baseParts.length; j > 0; j -= 1) {
                        mapValue = map[baseParts.slice(0, j).join('/')];

                        //baseName segment has  config, find if it has one for
                        //this name.
                        if (mapValue) {
                            mapValue = mapValue[nameSegment];
                            if (mapValue) {
                                //Match, update name to the new value.
                                foundMap = mapValue;
                                foundI = i;
                                break;
                            }
                        }
                    }
                }

                if (foundMap) {
                    break;
                }

                //Check for a star map match, but just hold on to it,
                //if there is a shorter segment match later in a matching
                //config, then favor over this star map.
                if (!foundStarMap && starMap && starMap[nameSegment]) {
                    foundStarMap = starMap[nameSegment];
                    starI = i;
                }
            }

            if (!foundMap && foundStarMap) {
                foundMap = foundStarMap;
                foundI = starI;
            }

            if (foundMap) {
                nameParts.splice(0, foundI, foundMap);
                name = nameParts.join('/');
            }
        }

        return name;
    }

    function makeRequire(relName, forceSync) {
        return function () {
            //A version of a require function that passes a moduleName
            //value for items that may need to
            //look up paths relative to the moduleName
            return req.apply(undef, aps.call(arguments, 0).concat([relName, forceSync]));
        };
    }

    function makeNormalize(relName) {
        return function (name) {
            return normalize(name, relName);
        };
    }

    function makeLoad(depName) {
        return function (value) {
            defined[depName] = value;
        };
    }

    function callDep(name) {
        if (hasProp(waiting, name)) {
            var args = waiting[name];
            delete waiting[name];
            defining[name] = true;
            main.apply(undef, args);
        }

        if (!hasProp(defined, name) && !hasProp(defining, name)) {
            throw new Error('No ' + name);
        }
        return defined[name];
    }

    //Turns a plugin!resource to [plugin, resource]
    //with the plugin being undefined if the name
    //did not have a plugin prefix.
    function splitPrefix(name) {
        var prefix,
            index = name ? name.indexOf('!') : -1;
        if (index > -1) {
            prefix = name.substring(0, index);
            name = name.substring(index + 1, name.length);
        }
        return [prefix, name];
    }

    /**
     * Makes a name map, normalizing the name, and using a plugin
     * for normalization if necessary. Grabs a ref to plugin
     * too, as an optimization.
     */
    makeMap = function (name, relName) {
        var plugin,
            parts = splitPrefix(name),
            prefix = parts[0];

        name = parts[1];

        if (prefix) {
            prefix = normalize(prefix, relName);
            plugin = callDep(prefix);
        }

        //Normalize according
        if (prefix) {
            if (plugin && plugin.normalize) {
                name = plugin.normalize(name, makeNormalize(relName));
            } else {
                name = normalize(name, relName);
            }
        } else {
            name = normalize(name, relName);
            parts = splitPrefix(name);
            prefix = parts[0];
            name = parts[1];
            if (prefix) {
                plugin = callDep(prefix);
            }
        }

        //Using ridiculous property names for space reasons
        return {
            f: prefix ? prefix + '!' + name : name, //fullName
            n: name,
            pr: prefix,
            p: plugin
        };
    };

    function makeConfig(name) {
        return function () {
            return (config && config.config && config.config[name]) || {};
        };
    }

    handlers = {
        require: function (name) {
            return makeRequire(name);
        },
        exports: function (name) {
            var e = defined[name];
            if (typeof e !== 'undefined') {
                return e;
            } else {
                return (defined[name] = {});
            }
        },
        module: function (name) {
            return {
                id: name,
                uri: '',
                exports: defined[name],
                config: makeConfig(name)
            };
        }
    };

    main = function (name, deps, callback, relName) {
        var cjsModule, depName, ret, map, i,
            args = [],
            usingExports;

        //Use name if no relName
        relName = relName || name;

        //Call the callback to define the module, if necessary.
        if (typeof callback === 'function') {

            //Pull out the defined dependencies and pass the ordered
            //values to the callback.
            //Default to [require, exports, module] if no deps
            deps = !deps.length && callback.length ? ['require', 'exports', 'module'] : deps;
            for (i = 0; i < deps.length; i += 1) {
                map = makeMap(deps[i], relName);
                depName = map.f;

                //Fast path CommonJS standard dependencies.
                if (depName === "require") {
                    args[i] = handlers.require(name);
                } else if (depName === "exports") {
                    //CommonJS module spec 1.1
                    args[i] = handlers.exports(name);
                    usingExports = true;
                } else if (depName === "module") {
                    //CommonJS module spec 1.1
                    cjsModule = args[i] = handlers.module(name);
                } else if (hasProp(defined, depName) ||
                           hasProp(waiting, depName) ||
                           hasProp(defining, depName)) {
                    args[i] = callDep(depName);
                } else if (map.p) {
                    map.p.load(map.n, makeRequire(relName, true), makeLoad(depName), {});
                    args[i] = defined[depName];
                } else {
                    throw new Error(name + ' missing ' + depName);
                }
            }

            ret = callback.apply(defined[name], args);

            if (name) {
                //If setting exports via "module" is in play,
                //favor that over return value and exports. After that,
                //favor a non-undefined return value over exports use.
                if (cjsModule && cjsModule.exports !== undef &&
                        cjsModule.exports !== defined[name]) {
                    defined[name] = cjsModule.exports;
                } else if (ret !== undef || !usingExports) {
                    //Use the return value from the function.
                    defined[name] = ret;
                }
            }
        } else if (name) {
            //May just be an object definition for the module. Only
            //worry about defining if have a module name.
            defined[name] = callback;
        }
    };

    requirejs = require = req = function (deps, callback, relName, forceSync, alt) {
        if (typeof deps === "string") {
            if (handlers[deps]) {
                //callback in this case is really relName
                return handlers[deps](callback);
            }
            //Just return the module wanted. In this scenario, the
            //deps arg is the module name, and second arg (if passed)
            //is just the relName.
            //Normalize module name, if it contains . or ..
            return callDep(makeMap(deps, callback).f);
        } else if (!deps.splice) {
            //deps is a config object, not an array.
            config = deps;
            if (callback.splice) {
                //callback is an array, which means it is a dependency list.
                //Adjust args if there are dependencies
                deps = callback;
                callback = relName;
                relName = null;
            } else {
                deps = undef;
            }
        }

        //Support require(['a'])
        callback = callback || function () {};

        //If relName is a function, it is an errback handler,
        //so remove it.
        if (typeof relName === 'function') {
            relName = forceSync;
            forceSync = alt;
        }

        //Simulate async callback;
        if (forceSync) {
            main(undef, deps, callback, relName);
        } else {
            //Using a non-zero value because of concern for what old browsers
            //do, and latest browsers "upgrade" to 4 if lower value is used:
            //http://www.whatwg.org/specs/web-apps/current-work/multipage/timers.html#dom-windowtimers-settimeout:
            //If want a value immediately, use require('id') instead -- something
            //that works in almond on the global level, but not guaranteed and
            //unlikely to work in other AMD implementations.
            setTimeout(function () {
                main(undef, deps, callback, relName);
            }, 4);
        }

        return req;
    };

    /**
     * Just drops the config on the floor, but returns req in case
     * the config return value is used.
     */
    req.config = function (cfg) {
        config = cfg;
        if (config.deps) {
            req(config.deps, config.callback);
        }
        return req;
    };

    define = function (name, deps, callback) {

        //This module may not have dependencies
        if (!deps.splice) {
            //deps is not an array, so probably means
            //an object literal or factory function for
            //the value. Adjust args.
            callback = deps;
            deps = [];
        }

        if (!hasProp(defined, name) && !hasProp(waiting, name)) {
            waiting[name] = [name, deps, callback];
        }
    };

    define.amd = {
        jQuery: true
    };
}());

define("../build/almond", function(){});

/*! jQuery v3.2.1 | (c) JS Foundation and other contributors | jquery.org/license */
!function(a,b){"use strict";"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){"use strict";var c=[],d=a.document,e=Object.getPrototypeOf,f=c.slice,g=c.concat,h=c.push,i=c.indexOf,j={},k=j.toString,l=j.hasOwnProperty,m=l.toString,n=m.call(Object),o={};function p(a,b){b=b||d;var c=b.createElement("script");c.text=a,b.head.appendChild(c).parentNode.removeChild(c)}var q="3.2.1",r=function(a,b){return new r.fn.init(a,b)},s=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,t=/^-ms-/,u=/-([a-z])/g,v=function(a,b){return b.toUpperCase()};r.fn=r.prototype={jquery:q,constructor:r,length:0,toArray:function(){return f.call(this)},get:function(a){return null==a?f.call(this):a<0?this[a+this.length]:this[a]},pushStack:function(a){var b=r.merge(this.constructor(),a);return b.prevObject=this,b},each:function(a){return r.each(this,a)},map:function(a){return this.pushStack(r.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(f.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(a<0?b:0);return this.pushStack(c>=0&&c<b?[this[c]]:[])},end:function(){return this.prevObject||this.constructor()},push:h,sort:c.sort,splice:c.splice},r.extend=r.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||r.isFunction(g)||(g={}),h===i&&(g=this,h--);h<i;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(r.isPlainObject(d)||(e=Array.isArray(d)))?(e?(e=!1,f=c&&Array.isArray(c)?c:[]):f=c&&r.isPlainObject(c)?c:{},g[b]=r.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},r.extend({expando:"jQuery"+(q+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===r.type(a)},isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){var b=r.type(a);return("number"===b||"string"===b)&&!isNaN(a-parseFloat(a))},isPlainObject:function(a){var b,c;return!(!a||"[object Object]"!==k.call(a))&&(!(b=e(a))||(c=l.call(b,"constructor")&&b.constructor,"function"==typeof c&&m.call(c)===n))},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?j[k.call(a)]||"object":typeof a},globalEval:function(a){p(a)},camelCase:function(a){return a.replace(t,"ms-").replace(u,v)},each:function(a,b){var c,d=0;if(w(a)){for(c=a.length;d<c;d++)if(b.call(a[d],d,a[d])===!1)break}else for(d in a)if(b.call(a[d],d,a[d])===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(s,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(w(Object(a))?r.merge(c,"string"==typeof a?[a]:a):h.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:i.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;d<c;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;f<g;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,e,f=0,h=[];if(w(a))for(d=a.length;f<d;f++)e=b(a[f],f,c),null!=e&&h.push(e);else for(f in a)e=b(a[f],f,c),null!=e&&h.push(e);return g.apply([],h)},guid:1,proxy:function(a,b){var c,d,e;if("string"==typeof b&&(c=a[b],b=a,a=c),r.isFunction(a))return d=f.call(arguments,2),e=function(){return a.apply(b||this,d.concat(f.call(arguments)))},e.guid=a.guid=a.guid||r.guid++,e},now:Date.now,support:o}),"function"==typeof Symbol&&(r.fn[Symbol.iterator]=c[Symbol.iterator]),r.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "),function(a,b){j["[object "+b+"]"]=b.toLowerCase()});function w(a){var b=!!a&&"length"in a&&a.length,c=r.type(a);return"function"!==c&&!r.isWindow(a)&&("array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a)}var x=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=ha(),z=ha(),A=ha(),B=function(a,b){return a===b&&(l=!0),0},C={}.hasOwnProperty,D=[],E=D.pop,F=D.push,G=D.push,H=D.slice,I=function(a,b){for(var c=0,d=a.length;c<d;c++)if(a[c]===b)return c;return-1},J="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",K="[\\x20\\t\\r\\n\\f]",L="(?:\\\\.|[\\w-]|[^\0-\\xa0])+",M="\\["+K+"*("+L+")(?:"+K+"*([*^$|!~]?=)"+K+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+L+"))|)"+K+"*\\]",N=":("+L+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+M+")*)|.*)\\)|)",O=new RegExp(K+"+","g"),P=new RegExp("^"+K+"+|((?:^|[^\\\\])(?:\\\\.)*)"+K+"+$","g"),Q=new RegExp("^"+K+"*,"+K+"*"),R=new RegExp("^"+K+"*([>+~]|"+K+")"+K+"*"),S=new RegExp("="+K+"*([^\\]'\"]*?)"+K+"*\\]","g"),T=new RegExp(N),U=new RegExp("^"+L+"$"),V={ID:new RegExp("^#("+L+")"),CLASS:new RegExp("^\\.("+L+")"),TAG:new RegExp("^("+L+"|[*])"),ATTR:new RegExp("^"+M),PSEUDO:new RegExp("^"+N),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+K+"*(even|odd|(([+-]|)(\\d*)n|)"+K+"*(?:([+-]|)"+K+"*(\\d+)|))"+K+"*\\)|)","i"),bool:new RegExp("^(?:"+J+")$","i"),needsContext:new RegExp("^"+K+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+K+"*((?:-\\d)?\\d*)"+K+"*\\)|)(?=[^-]|$)","i")},W=/^(?:input|select|textarea|button)$/i,X=/^h\d$/i,Y=/^[^{]+\{\s*\[native \w/,Z=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,$=/[+~]/,_=new RegExp("\\\\([\\da-f]{1,6}"+K+"?|("+K+")|.)","ig"),aa=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:d<0?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)},ba=/([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,ca=function(a,b){return b?"\0"===a?"\ufffd":a.slice(0,-1)+"\\"+a.charCodeAt(a.length-1).toString(16)+" ":"\\"+a},da=function(){m()},ea=ta(function(a){return a.disabled===!0&&("form"in a||"label"in a)},{dir:"parentNode",next:"legend"});try{G.apply(D=H.call(v.childNodes),v.childNodes),D[v.childNodes.length].nodeType}catch(fa){G={apply:D.length?function(a,b){F.apply(a,H.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function ga(a,b,d,e){var f,h,j,k,l,o,r,s=b&&b.ownerDocument,w=b?b.nodeType:9;if(d=d||[],"string"!=typeof a||!a||1!==w&&9!==w&&11!==w)return d;if(!e&&((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,p)){if(11!==w&&(l=Z.exec(a)))if(f=l[1]){if(9===w){if(!(j=b.getElementById(f)))return d;if(j.id===f)return d.push(j),d}else if(s&&(j=s.getElementById(f))&&t(b,j)&&j.id===f)return d.push(j),d}else{if(l[2])return G.apply(d,b.getElementsByTagName(a)),d;if((f=l[3])&&c.getElementsByClassName&&b.getElementsByClassName)return G.apply(d,b.getElementsByClassName(f)),d}if(c.qsa&&!A[a+" "]&&(!q||!q.test(a))){if(1!==w)s=b,r=a;else if("object"!==b.nodeName.toLowerCase()){(k=b.getAttribute("id"))?k=k.replace(ba,ca):b.setAttribute("id",k=u),o=g(a),h=o.length;while(h--)o[h]="#"+k+" "+sa(o[h]);r=o.join(","),s=$.test(a)&&qa(b.parentNode)||b}if(r)try{return G.apply(d,s.querySelectorAll(r)),d}catch(x){}finally{k===u&&b.removeAttribute("id")}}}return i(a.replace(P,"$1"),b,d,e)}function ha(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function ia(a){return a[u]=!0,a}function ja(a){var b=n.createElement("fieldset");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function ka(a,b){var c=a.split("|"),e=c.length;while(e--)d.attrHandle[c[e]]=b}function la(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&a.sourceIndex-b.sourceIndex;if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function ma(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function na(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function oa(a){return function(b){return"form"in b?b.parentNode&&b.disabled===!1?"label"in b?"label"in b.parentNode?b.parentNode.disabled===a:b.disabled===a:b.isDisabled===a||b.isDisabled!==!a&&ea(b)===a:b.disabled===a:"label"in b&&b.disabled===a}}function pa(a){return ia(function(b){return b=+b,ia(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function qa(a){return a&&"undefined"!=typeof a.getElementsByTagName&&a}c=ga.support={},f=ga.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return!!b&&"HTML"!==b.nodeName},m=ga.setDocument=function(a){var b,e,g=a?a.ownerDocument||a:v;return g!==n&&9===g.nodeType&&g.documentElement?(n=g,o=n.documentElement,p=!f(n),v!==n&&(e=n.defaultView)&&e.top!==e&&(e.addEventListener?e.addEventListener("unload",da,!1):e.attachEvent&&e.attachEvent("onunload",da)),c.attributes=ja(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ja(function(a){return a.appendChild(n.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=Y.test(n.getElementsByClassName),c.getById=ja(function(a){return o.appendChild(a).id=u,!n.getElementsByName||!n.getElementsByName(u).length}),c.getById?(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){return a.getAttribute("id")===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c=b.getElementById(a);return c?[c]:[]}}):(d.filter.ID=function(a){var b=a.replace(_,aa);return function(a){var c="undefined"!=typeof a.getAttributeNode&&a.getAttributeNode("id");return c&&c.value===b}},d.find.ID=function(a,b){if("undefined"!=typeof b.getElementById&&p){var c,d,e,f=b.getElementById(a);if(f){if(c=f.getAttributeNode("id"),c&&c.value===a)return[f];e=b.getElementsByName(a),d=0;while(f=e[d++])if(c=f.getAttributeNode("id"),c&&c.value===a)return[f]}return[]}}),d.find.TAG=c.getElementsByTagName?function(a,b){return"undefined"!=typeof b.getElementsByTagName?b.getElementsByTagName(a):c.qsa?b.querySelectorAll(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){if("undefined"!=typeof b.getElementsByClassName&&p)return b.getElementsByClassName(a)},r=[],q=[],(c.qsa=Y.test(n.querySelectorAll))&&(ja(function(a){o.appendChild(a).innerHTML="<a id='"+u+"'></a><select id='"+u+"-\r\\' msallowcapture=''><option selected=''></option></select>",a.querySelectorAll("[msallowcapture^='']").length&&q.push("[*^$]="+K+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+K+"*(?:value|"+J+")"),a.querySelectorAll("[id~="+u+"-]").length||q.push("~="),a.querySelectorAll(":checked").length||q.push(":checked"),a.querySelectorAll("a#"+u+"+*").length||q.push(".#.+[+~]")}),ja(function(a){a.innerHTML="<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";var b=n.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+K+"*[*^$|!~]?="),2!==a.querySelectorAll(":enabled").length&&q.push(":enabled",":disabled"),o.appendChild(a).disabled=!0,2!==a.querySelectorAll(":disabled").length&&q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=Y.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ja(function(a){c.disconnectedMatch=s.call(a,"*"),s.call(a,"[s!='']:x"),r.push("!=",N)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=Y.test(o.compareDocumentPosition),t=b||Y.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===n||a.ownerDocument===v&&t(v,a)?-1:b===n||b.ownerDocument===v&&t(v,b)?1:k?I(k,a)-I(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,e=a.parentNode,f=b.parentNode,g=[a],h=[b];if(!e||!f)return a===n?-1:b===n?1:e?-1:f?1:k?I(k,a)-I(k,b):0;if(e===f)return la(a,b);c=a;while(c=c.parentNode)g.unshift(c);c=b;while(c=c.parentNode)h.unshift(c);while(g[d]===h[d])d++;return d?la(g[d],h[d]):g[d]===v?-1:h[d]===v?1:0},n):n},ga.matches=function(a,b){return ga(a,null,null,b)},ga.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(S,"='$1']"),c.matchesSelector&&p&&!A[b+" "]&&(!r||!r.test(b))&&(!q||!q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return ga(b,n,null,[a]).length>0},ga.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},ga.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&C.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},ga.escape=function(a){return(a+"").replace(ba,ca)},ga.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},ga.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=ga.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=ga.selectors={cacheLength:50,createPseudo:ia,match:V,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(_,aa),a[3]=(a[3]||a[4]||a[5]||"").replace(_,aa),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||ga.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&ga.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return V.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&T.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(_,aa).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+K+")"+a+"("+K+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||"undefined"!=typeof a.getAttribute&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=ga.attr(d,a);return null==e?"!="===b:!b||(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e.replace(O," ")+" ").indexOf(c)>-1:"|="===b&&(e===c||e.slice(0,c.length+1)===c+"-"))}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h,t=!1;if(q){if(f){while(p){m=b;while(m=m[p])if(h?m.nodeName.toLowerCase()===r:1===m.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){m=q,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n&&j[2],m=n&&q.childNodes[n];while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if(1===m.nodeType&&++t&&m===b){k[a]=[w,n,t];break}}else if(s&&(m=b,l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),j=k[a]||[],n=j[0]===w&&j[1],t=n),t===!1)while(m=++n&&m&&m[p]||(t=n=0)||o.pop())if((h?m.nodeName.toLowerCase()===r:1===m.nodeType)&&++t&&(s&&(l=m[u]||(m[u]={}),k=l[m.uniqueID]||(l[m.uniqueID]={}),k[a]=[w,t]),m===b))break;return t-=e,t===d||t%d===0&&t/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||ga.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?ia(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=I(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:ia(function(a){var b=[],c=[],d=h(a.replace(P,"$1"));return d[u]?ia(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),b[0]=null,!c.pop()}}),has:ia(function(a){return function(b){return ga(a,b).length>0}}),contains:ia(function(a){return a=a.replace(_,aa),function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:ia(function(a){return U.test(a||"")||ga.error("unsupported lang: "+a),a=a.replace(_,aa).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:oa(!1),disabled:oa(!0),checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return X.test(a.nodeName)},input:function(a){return W.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:pa(function(){return[0]}),last:pa(function(a,b){return[b-1]}),eq:pa(function(a,b,c){return[c<0?c+b:c]}),even:pa(function(a,b){for(var c=0;c<b;c+=2)a.push(c);return a}),odd:pa(function(a,b){for(var c=1;c<b;c+=2)a.push(c);return a}),lt:pa(function(a,b,c){for(var d=c<0?c+b:c;--d>=0;)a.push(d);return a}),gt:pa(function(a,b,c){for(var d=c<0?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=ma(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=na(b);function ra(){}ra.prototype=d.filters=d.pseudos,d.setFilters=new ra,g=ga.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){c&&!(e=Q.exec(h))||(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=R.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(P," ")}),h=h.slice(c.length));for(g in d.filter)!(e=V[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?ga.error(a):z(a,i).slice(0)};function sa(a){for(var b=0,c=a.length,d="";b<c;b++)d+=a[b].value;return d}function ta(a,b,c){var d=b.dir,e=b.next,f=e||d,g=c&&"parentNode"===f,h=x++;return b.first?function(b,c,e){while(b=b[d])if(1===b.nodeType||g)return a(b,c,e);return!1}:function(b,c,i){var j,k,l,m=[w,h];if(i){while(b=b[d])if((1===b.nodeType||g)&&a(b,c,i))return!0}else while(b=b[d])if(1===b.nodeType||g)if(l=b[u]||(b[u]={}),k=l[b.uniqueID]||(l[b.uniqueID]={}),e&&e===b.nodeName.toLowerCase())b=b[d]||b;else{if((j=k[f])&&j[0]===w&&j[1]===h)return m[2]=j[2];if(k[f]=m,m[2]=a(b,c,i))return!0}return!1}}function ua(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function va(a,b,c){for(var d=0,e=b.length;d<e;d++)ga(a,b[d],c);return c}function wa(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;h<i;h++)(f=a[h])&&(c&&!c(f,d,e)||(g.push(f),j&&b.push(h)));return g}function xa(a,b,c,d,e,f){return d&&!d[u]&&(d=xa(d)),e&&!e[u]&&(e=xa(e,f)),ia(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||va(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:wa(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=wa(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?I(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=wa(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):G.apply(g,r)})}function ya(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=ta(function(a){return a===b},h,!0),l=ta(function(a){return I(b,a)>-1},h,!0),m=[function(a,c,d){var e=!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d));return b=null,e}];i<f;i++)if(c=d.relative[a[i].type])m=[ta(ua(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;e<f;e++)if(d.relative[a[e].type])break;return xa(i>1&&ua(m),i>1&&sa(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(P,"$1"),c,i<e&&ya(a.slice(i,e)),e<f&&ya(a=a.slice(e)),e<f&&sa(a))}m.push(c)}return ua(m)}function za(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,o,q,r=0,s="0",t=f&&[],u=[],v=j,x=f||e&&d.find.TAG("*",k),y=w+=null==v?1:Math.random()||.1,z=x.length;for(k&&(j=g===n||g||k);s!==z&&null!=(l=x[s]);s++){if(e&&l){o=0,g||l.ownerDocument===n||(m(l),h=!p);while(q=a[o++])if(q(l,g||n,h)){i.push(l);break}k&&(w=y)}c&&((l=!q&&l)&&r--,f&&t.push(l))}if(r+=s,c&&s!==r){o=0;while(q=b[o++])q(t,u,g,h);if(f){if(r>0)while(s--)t[s]||u[s]||(u[s]=E.call(i));u=wa(u)}G.apply(i,u),k&&!f&&u.length>0&&r+b.length>1&&ga.uniqueSort(i)}return k&&(w=y,j=v),t};return c?ia(f):f}return h=ga.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=ya(b[c]),f[u]?d.push(f):e.push(f);f=A(a,za(e,d)),f.selector=a}return f},i=ga.select=function(a,b,c,e){var f,i,j,k,l,m="function"==typeof a&&a,n=!e&&g(a=m.selector||a);if(c=c||[],1===n.length){if(i=n[0]=n[0].slice(0),i.length>2&&"ID"===(j=i[0]).type&&9===b.nodeType&&p&&d.relative[i[1].type]){if(b=(d.find.ID(j.matches[0].replace(_,aa),b)||[])[0],!b)return c;m&&(b=b.parentNode),a=a.slice(i.shift().value.length)}f=V.needsContext.test(a)?0:i.length;while(f--){if(j=i[f],d.relative[k=j.type])break;if((l=d.find[k])&&(e=l(j.matches[0].replace(_,aa),$.test(i[0].type)&&qa(b.parentNode)||b))){if(i.splice(f,1),a=e.length&&sa(i),!a)return G.apply(c,e),c;break}}}return(m||h(a,n))(e,b,!p,c,!b||$.test(a)&&qa(b.parentNode)||b),c},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ja(function(a){return 1&a.compareDocumentPosition(n.createElement("fieldset"))}),ja(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||ka("type|href|height|width",function(a,b,c){if(!c)return a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ja(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||ka("value",function(a,b,c){if(!c&&"input"===a.nodeName.toLowerCase())return a.defaultValue}),ja(function(a){return null==a.getAttribute("disabled")})||ka(J,function(a,b,c){var d;if(!c)return a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),ga}(a);r.find=x,r.expr=x.selectors,r.expr[":"]=r.expr.pseudos,r.uniqueSort=r.unique=x.uniqueSort,r.text=x.getText,r.isXMLDoc=x.isXML,r.contains=x.contains,r.escapeSelector=x.escape;var y=function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&r(a).is(c))break;d.push(a)}return d},z=function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c},A=r.expr.match.needsContext;function B(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()}var C=/^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i,D=/^.[^:#\[\.,]*$/;function E(a,b,c){return r.isFunction(b)?r.grep(a,function(a,d){return!!b.call(a,d,a)!==c}):b.nodeType?r.grep(a,function(a){return a===b!==c}):"string"!=typeof b?r.grep(a,function(a){return i.call(b,a)>-1!==c}):D.test(b)?r.filter(b,a,c):(b=r.filter(b,a),r.grep(a,function(a){return i.call(b,a)>-1!==c&&1===a.nodeType}))}r.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?r.find.matchesSelector(d,a)?[d]:[]:r.find.matches(a,r.grep(b,function(a){return 1===a.nodeType}))},r.fn.extend({find:function(a){var b,c,d=this.length,e=this;if("string"!=typeof a)return this.pushStack(r(a).filter(function(){for(b=0;b<d;b++)if(r.contains(e[b],this))return!0}));for(c=this.pushStack([]),b=0;b<d;b++)r.find(a,e[b],c);return d>1?r.uniqueSort(c):c},filter:function(a){return this.pushStack(E(this,a||[],!1))},not:function(a){return this.pushStack(E(this,a||[],!0))},is:function(a){return!!E(this,"string"==typeof a&&A.test(a)?r(a):a||[],!1).length}});var F,G=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,H=r.fn.init=function(a,b,c){var e,f;if(!a)return this;if(c=c||F,"string"==typeof a){if(e="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:G.exec(a),!e||!e[1]&&b)return!b||b.jquery?(b||c).find(a):this.constructor(b).find(a);if(e[1]){if(b=b instanceof r?b[0]:b,r.merge(this,r.parseHTML(e[1],b&&b.nodeType?b.ownerDocument||b:d,!0)),C.test(e[1])&&r.isPlainObject(b))for(e in b)r.isFunction(this[e])?this[e](b[e]):this.attr(e,b[e]);return this}return f=d.getElementById(e[2]),f&&(this[0]=f,this.length=1),this}return a.nodeType?(this[0]=a,this.length=1,this):r.isFunction(a)?void 0!==c.ready?c.ready(a):a(r):r.makeArray(a,this)};H.prototype=r.fn,F=r(d);var I=/^(?:parents|prev(?:Until|All))/,J={children:!0,contents:!0,next:!0,prev:!0};r.fn.extend({has:function(a){var b=r(a,this),c=b.length;return this.filter(function(){for(var a=0;a<c;a++)if(r.contains(this,b[a]))return!0})},closest:function(a,b){var c,d=0,e=this.length,f=[],g="string"!=typeof a&&r(a);if(!A.test(a))for(;d<e;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&r.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?r.uniqueSort(f):f)},index:function(a){return a?"string"==typeof a?i.call(r(a),this[0]):i.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(r.uniqueSort(r.merge(this.get(),r(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function K(a,b){while((a=a[b])&&1!==a.nodeType);return a}r.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return y(a,"parentNode")},parentsUntil:function(a,b,c){return y(a,"parentNode",c)},next:function(a){return K(a,"nextSibling")},prev:function(a){return K(a,"previousSibling")},nextAll:function(a){return y(a,"nextSibling")},prevAll:function(a){return y(a,"previousSibling")},nextUntil:function(a,b,c){return y(a,"nextSibling",c)},prevUntil:function(a,b,c){return y(a,"previousSibling",c)},siblings:function(a){return z((a.parentNode||{}).firstChild,a)},children:function(a){return z(a.firstChild)},contents:function(a){return B(a,"iframe")?a.contentDocument:(B(a,"template")&&(a=a.content||a),r.merge([],a.childNodes))}},function(a,b){r.fn[a]=function(c,d){var e=r.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=r.filter(d,e)),this.length>1&&(J[a]||r.uniqueSort(e),I.test(a)&&e.reverse()),this.pushStack(e)}});var L=/[^\x20\t\r\n\f]+/g;function M(a){var b={};return r.each(a.match(L)||[],function(a,c){b[c]=!0}),b}r.Callbacks=function(a){a="string"==typeof a?M(a):r.extend({},a);var b,c,d,e,f=[],g=[],h=-1,i=function(){for(e=e||a.once,d=b=!0;g.length;h=-1){c=g.shift();while(++h<f.length)f[h].apply(c[0],c[1])===!1&&a.stopOnFalse&&(h=f.length,c=!1)}a.memory||(c=!1),b=!1,e&&(f=c?[]:"")},j={add:function(){return f&&(c&&!b&&(h=f.length-1,g.push(c)),function d(b){r.each(b,function(b,c){r.isFunction(c)?a.unique&&j.has(c)||f.push(c):c&&c.length&&"string"!==r.type(c)&&d(c)})}(arguments),c&&!b&&i()),this},remove:function(){return r.each(arguments,function(a,b){var c;while((c=r.inArray(b,f,c))>-1)f.splice(c,1),c<=h&&h--}),this},has:function(a){return a?r.inArray(a,f)>-1:f.length>0},empty:function(){return f&&(f=[]),this},disable:function(){return e=g=[],f=c="",this},disabled:function(){return!f},lock:function(){return e=g=[],c||b||(f=c=""),this},locked:function(){return!!e},fireWith:function(a,c){return e||(c=c||[],c=[a,c.slice?c.slice():c],g.push(c),b||i()),this},fire:function(){return j.fireWith(this,arguments),this},fired:function(){return!!d}};return j};function N(a){return a}function O(a){throw a}function P(a,b,c,d){var e;try{a&&r.isFunction(e=a.promise)?e.call(a).done(b).fail(c):a&&r.isFunction(e=a.then)?e.call(a,b,c):b.apply(void 0,[a].slice(d))}catch(a){c.apply(void 0,[a])}}r.extend({Deferred:function(b){var c=[["notify","progress",r.Callbacks("memory"),r.Callbacks("memory"),2],["resolve","done",r.Callbacks("once memory"),r.Callbacks("once memory"),0,"resolved"],["reject","fail",r.Callbacks("once memory"),r.Callbacks("once memory"),1,"rejected"]],d="pending",e={state:function(){return d},always:function(){return f.done(arguments).fail(arguments),this},"catch":function(a){return e.then(null,a)},pipe:function(){var a=arguments;return r.Deferred(function(b){r.each(c,function(c,d){var e=r.isFunction(a[d[4]])&&a[d[4]];f[d[1]](function(){var a=e&&e.apply(this,arguments);a&&r.isFunction(a.promise)?a.promise().progress(b.notify).done(b.resolve).fail(b.reject):b[d[0]+"With"](this,e?[a]:arguments)})}),a=null}).promise()},then:function(b,d,e){var f=0;function g(b,c,d,e){return function(){var h=this,i=arguments,j=function(){var a,j;if(!(b<f)){if(a=d.apply(h,i),a===c.promise())throw new TypeError("Thenable self-resolution");j=a&&("object"==typeof a||"function"==typeof a)&&a.then,r.isFunction(j)?e?j.call(a,g(f,c,N,e),g(f,c,O,e)):(f++,j.call(a,g(f,c,N,e),g(f,c,O,e),g(f,c,N,c.notifyWith))):(d!==N&&(h=void 0,i=[a]),(e||c.resolveWith)(h,i))}},k=e?j:function(){try{j()}catch(a){r.Deferred.exceptionHook&&r.Deferred.exceptionHook(a,k.stackTrace),b+1>=f&&(d!==O&&(h=void 0,i=[a]),c.rejectWith(h,i))}};b?k():(r.Deferred.getStackHook&&(k.stackTrace=r.Deferred.getStackHook()),a.setTimeout(k))}}return r.Deferred(function(a){c[0][3].add(g(0,a,r.isFunction(e)?e:N,a.notifyWith)),c[1][3].add(g(0,a,r.isFunction(b)?b:N)),c[2][3].add(g(0,a,r.isFunction(d)?d:O))}).promise()},promise:function(a){return null!=a?r.extend(a,e):e}},f={};return r.each(c,function(a,b){var g=b[2],h=b[5];e[b[1]]=g.add,h&&g.add(function(){d=h},c[3-a][2].disable,c[0][2].lock),g.add(b[3].fire),f[b[0]]=function(){return f[b[0]+"With"](this===f?void 0:this,arguments),this},f[b[0]+"With"]=g.fireWith}),e.promise(f),b&&b.call(f,f),f},when:function(a){var b=arguments.length,c=b,d=Array(c),e=f.call(arguments),g=r.Deferred(),h=function(a){return function(c){d[a]=this,e[a]=arguments.length>1?f.call(arguments):c,--b||g.resolveWith(d,e)}};if(b<=1&&(P(a,g.done(h(c)).resolve,g.reject,!b),"pending"===g.state()||r.isFunction(e[c]&&e[c].then)))return g.then();while(c--)P(e[c],h(c),g.reject);return g.promise()}});var Q=/^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;r.Deferred.exceptionHook=function(b,c){a.console&&a.console.warn&&b&&Q.test(b.name)&&a.console.warn("jQuery.Deferred exception: "+b.message,b.stack,c)},r.readyException=function(b){a.setTimeout(function(){throw b})};var R=r.Deferred();r.fn.ready=function(a){return R.then(a)["catch"](function(a){r.readyException(a)}),this},r.extend({isReady:!1,readyWait:1,ready:function(a){(a===!0?--r.readyWait:r.isReady)||(r.isReady=!0,a!==!0&&--r.readyWait>0||R.resolveWith(d,[r]))}}),r.ready.then=R.then;function S(){d.removeEventListener("DOMContentLoaded",S),
a.removeEventListener("load",S),r.ready()}"complete"===d.readyState||"loading"!==d.readyState&&!d.documentElement.doScroll?a.setTimeout(r.ready):(d.addEventListener("DOMContentLoaded",S),a.addEventListener("load",S));var T=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===r.type(c)){e=!0;for(h in c)T(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,r.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(r(a),c)})),b))for(;h<i;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f},U=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function V(){this.expando=r.expando+V.uid++}V.uid=1,V.prototype={cache:function(a){var b=a[this.expando];return b||(b={},U(a)&&(a.nodeType?a[this.expando]=b:Object.defineProperty(a,this.expando,{value:b,configurable:!0}))),b},set:function(a,b,c){var d,e=this.cache(a);if("string"==typeof b)e[r.camelCase(b)]=c;else for(d in b)e[r.camelCase(d)]=b[d];return e},get:function(a,b){return void 0===b?this.cache(a):a[this.expando]&&a[this.expando][r.camelCase(b)]},access:function(a,b,c){return void 0===b||b&&"string"==typeof b&&void 0===c?this.get(a,b):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d=a[this.expando];if(void 0!==d){if(void 0!==b){Array.isArray(b)?b=b.map(r.camelCase):(b=r.camelCase(b),b=b in d?[b]:b.match(L)||[]),c=b.length;while(c--)delete d[b[c]]}(void 0===b||r.isEmptyObject(d))&&(a.nodeType?a[this.expando]=void 0:delete a[this.expando])}},hasData:function(a){var b=a[this.expando];return void 0!==b&&!r.isEmptyObject(b)}};var W=new V,X=new V,Y=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,Z=/[A-Z]/g;function $(a){return"true"===a||"false"!==a&&("null"===a?null:a===+a+""?+a:Y.test(a)?JSON.parse(a):a)}function _(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(Z,"-$&").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c=$(c)}catch(e){}X.set(a,b,c)}else c=void 0;return c}r.extend({hasData:function(a){return X.hasData(a)||W.hasData(a)},data:function(a,b,c){return X.access(a,b,c)},removeData:function(a,b){X.remove(a,b)},_data:function(a,b,c){return W.access(a,b,c)},_removeData:function(a,b){W.remove(a,b)}}),r.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=X.get(f),1===f.nodeType&&!W.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=r.camelCase(d.slice(5)),_(f,d,e[d])));W.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){X.set(this,a)}):T(this,function(b){var c;if(f&&void 0===b){if(c=X.get(f,a),void 0!==c)return c;if(c=_(f,a),void 0!==c)return c}else this.each(function(){X.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){X.remove(this,a)})}}),r.extend({queue:function(a,b,c){var d;if(a)return b=(b||"fx")+"queue",d=W.get(a,b),c&&(!d||Array.isArray(c)?d=W.access(a,b,r.makeArray(c)):d.push(c)),d||[]},dequeue:function(a,b){b=b||"fx";var c=r.queue(a,b),d=c.length,e=c.shift(),f=r._queueHooks(a,b),g=function(){r.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return W.get(a,c)||W.access(a,c,{empty:r.Callbacks("once memory").add(function(){W.remove(a,[b+"queue",c])})})}}),r.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?r.queue(this[0],a):void 0===b?this:this.each(function(){var c=r.queue(this,a,b);r._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&r.dequeue(this,a)})},dequeue:function(a){return this.each(function(){r.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=r.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=W.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var aa=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,ba=new RegExp("^(?:([+-])=|)("+aa+")([a-z%]*)$","i"),ca=["Top","Right","Bottom","Left"],da=function(a,b){return a=b||a,"none"===a.style.display||""===a.style.display&&r.contains(a.ownerDocument,a)&&"none"===r.css(a,"display")},ea=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};function fa(a,b,c,d){var e,f=1,g=20,h=d?function(){return d.cur()}:function(){return r.css(a,b,"")},i=h(),j=c&&c[3]||(r.cssNumber[b]?"":"px"),k=(r.cssNumber[b]||"px"!==j&&+i)&&ba.exec(r.css(a,b));if(k&&k[3]!==j){j=j||k[3],c=c||[],k=+i||1;do f=f||".5",k/=f,r.style(a,b,k+j);while(f!==(f=h()/i)&&1!==f&&--g)}return c&&(k=+k||+i||0,e=c[1]?k+(c[1]+1)*c[2]:+c[2],d&&(d.unit=j,d.start=k,d.end=e)),e}var ga={};function ha(a){var b,c=a.ownerDocument,d=a.nodeName,e=ga[d];return e?e:(b=c.body.appendChild(c.createElement(d)),e=r.css(b,"display"),b.parentNode.removeChild(b),"none"===e&&(e="block"),ga[d]=e,e)}function ia(a,b){for(var c,d,e=[],f=0,g=a.length;f<g;f++)d=a[f],d.style&&(c=d.style.display,b?("none"===c&&(e[f]=W.get(d,"display")||null,e[f]||(d.style.display="")),""===d.style.display&&da(d)&&(e[f]=ha(d))):"none"!==c&&(e[f]="none",W.set(d,"display",c)));for(f=0;f<g;f++)null!=e[f]&&(a[f].style.display=e[f]);return a}r.fn.extend({show:function(){return ia(this,!0)},hide:function(){return ia(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){da(this)?r(this).show():r(this).hide()})}});var ja=/^(?:checkbox|radio)$/i,ka=/<([a-z][^\/\0>\x20\t\r\n\f]+)/i,la=/^$|\/(?:java|ecma)script/i,ma={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ma.optgroup=ma.option,ma.tbody=ma.tfoot=ma.colgroup=ma.caption=ma.thead,ma.th=ma.td;function na(a,b){var c;return c="undefined"!=typeof a.getElementsByTagName?a.getElementsByTagName(b||"*"):"undefined"!=typeof a.querySelectorAll?a.querySelectorAll(b||"*"):[],void 0===b||b&&B(a,b)?r.merge([a],c):c}function oa(a,b){for(var c=0,d=a.length;c<d;c++)W.set(a[c],"globalEval",!b||W.get(b[c],"globalEval"))}var pa=/<|&#?\w+;/;function qa(a,b,c,d,e){for(var f,g,h,i,j,k,l=b.createDocumentFragment(),m=[],n=0,o=a.length;n<o;n++)if(f=a[n],f||0===f)if("object"===r.type(f))r.merge(m,f.nodeType?[f]:f);else if(pa.test(f)){g=g||l.appendChild(b.createElement("div")),h=(ka.exec(f)||["",""])[1].toLowerCase(),i=ma[h]||ma._default,g.innerHTML=i[1]+r.htmlPrefilter(f)+i[2],k=i[0];while(k--)g=g.lastChild;r.merge(m,g.childNodes),g=l.firstChild,g.textContent=""}else m.push(b.createTextNode(f));l.textContent="",n=0;while(f=m[n++])if(d&&r.inArray(f,d)>-1)e&&e.push(f);else if(j=r.contains(f.ownerDocument,f),g=na(l.appendChild(f),"script"),j&&oa(g),c){k=0;while(f=g[k++])la.test(f.type||"")&&c.push(f)}return l}!function(){var a=d.createDocumentFragment(),b=a.appendChild(d.createElement("div")),c=d.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),o.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",o.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var ra=d.documentElement,sa=/^key/,ta=/^(?:mouse|pointer|contextmenu|drag|drop)|click/,ua=/^([^.]*)(?:\.(.+)|)/;function va(){return!0}function wa(){return!1}function xa(){try{return d.activeElement}catch(a){}}function ya(a,b,c,d,e,f){var g,h;if("object"==typeof b){"string"!=typeof c&&(d=d||c,c=void 0);for(h in b)ya(a,h,c,d,b[h],f);return a}if(null==d&&null==e?(e=c,d=c=void 0):null==e&&("string"==typeof c?(e=d,d=void 0):(e=d,d=c,c=void 0)),e===!1)e=wa;else if(!e)return a;return 1===f&&(g=e,e=function(a){return r().off(a),g.apply(this,arguments)},e.guid=g.guid||(g.guid=r.guid++)),a.each(function(){r.event.add(this,b,e,d,c)})}r.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.get(a);if(q){c.handler&&(f=c,c=f.handler,e=f.selector),e&&r.find.matchesSelector(ra,e),c.guid||(c.guid=r.guid++),(i=q.events)||(i=q.events={}),(g=q.handle)||(g=q.handle=function(b){return"undefined"!=typeof r&&r.event.triggered!==b.type?r.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(L)||[""],j=b.length;while(j--)h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n&&(l=r.event.special[n]||{},n=(e?l.delegateType:l.bindType)||n,l=r.event.special[n]||{},k=r.extend({type:n,origType:p,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&r.expr.match.needsContext.test(e),namespace:o.join(".")},f),(m=i[n])||(m=i[n]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,o,g)!==!1||a.addEventListener&&a.addEventListener(n,g)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),r.event.global[n]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,n,o,p,q=W.hasData(a)&&W.get(a);if(q&&(i=q.events)){b=(b||"").match(L)||[""],j=b.length;while(j--)if(h=ua.exec(b[j])||[],n=p=h[1],o=(h[2]||"").split(".").sort(),n){l=r.event.special[n]||{},n=(d?l.delegateType:l.bindType)||n,m=i[n]||[],h=h[2]&&new RegExp("(^|\\.)"+o.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&p!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,o,q.handle)!==!1||r.removeEvent(a,n,q.handle),delete i[n])}else for(n in i)r.event.remove(a,n+b[j],c,d,!0);r.isEmptyObject(i)&&W.remove(a,"handle events")}},dispatch:function(a){var b=r.event.fix(a),c,d,e,f,g,h,i=new Array(arguments.length),j=(W.get(this,"events")||{})[b.type]||[],k=r.event.special[b.type]||{};for(i[0]=b,c=1;c<arguments.length;c++)i[c]=arguments[c];if(b.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,b)!==!1){h=r.event.handlers.call(this,b,j),c=0;while((f=h[c++])&&!b.isPropagationStopped()){b.currentTarget=f.elem,d=0;while((g=f.handlers[d++])&&!b.isImmediatePropagationStopped())b.rnamespace&&!b.rnamespace.test(g.namespace)||(b.handleObj=g,b.data=g.data,e=((r.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(b.result=e)===!1&&(b.preventDefault(),b.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,b),b.result}},handlers:function(a,b){var c,d,e,f,g,h=[],i=b.delegateCount,j=a.target;if(i&&j.nodeType&&!("click"===a.type&&a.button>=1))for(;j!==this;j=j.parentNode||this)if(1===j.nodeType&&("click"!==a.type||j.disabled!==!0)){for(f=[],g={},c=0;c<i;c++)d=b[c],e=d.selector+" ",void 0===g[e]&&(g[e]=d.needsContext?r(e,this).index(j)>-1:r.find(e,this,null,[j]).length),g[e]&&f.push(d);f.length&&h.push({elem:j,handlers:f})}return j=this,i<b.length&&h.push({elem:j,handlers:b.slice(i)}),h},addProp:function(a,b){Object.defineProperty(r.Event.prototype,a,{enumerable:!0,configurable:!0,get:r.isFunction(b)?function(){if(this.originalEvent)return b(this.originalEvent)}:function(){if(this.originalEvent)return this.originalEvent[a]},set:function(b){Object.defineProperty(this,a,{enumerable:!0,configurable:!0,writable:!0,value:b})}})},fix:function(a){return a[r.expando]?a:new r.Event(a)},special:{load:{noBubble:!0},focus:{trigger:function(){if(this!==xa()&&this.focus)return this.focus(),!1},delegateType:"focusin"},blur:{trigger:function(){if(this===xa()&&this.blur)return this.blur(),!1},delegateType:"focusout"},click:{trigger:function(){if("checkbox"===this.type&&this.click&&B(this,"input"))return this.click(),!1},_default:function(a){return B(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}}},r.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c)},r.Event=function(a,b){return this instanceof r.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?va:wa,this.target=a.target&&3===a.target.nodeType?a.target.parentNode:a.target,this.currentTarget=a.currentTarget,this.relatedTarget=a.relatedTarget):this.type=a,b&&r.extend(this,b),this.timeStamp=a&&a.timeStamp||r.now(),void(this[r.expando]=!0)):new r.Event(a,b)},r.Event.prototype={constructor:r.Event,isDefaultPrevented:wa,isPropagationStopped:wa,isImmediatePropagationStopped:wa,isSimulated:!1,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=va,a&&!this.isSimulated&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=va,a&&!this.isSimulated&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=va,a&&!this.isSimulated&&a.stopImmediatePropagation(),this.stopPropagation()}},r.each({altKey:!0,bubbles:!0,cancelable:!0,changedTouches:!0,ctrlKey:!0,detail:!0,eventPhase:!0,metaKey:!0,pageX:!0,pageY:!0,shiftKey:!0,view:!0,"char":!0,charCode:!0,key:!0,keyCode:!0,button:!0,buttons:!0,clientX:!0,clientY:!0,offsetX:!0,offsetY:!0,pointerId:!0,pointerType:!0,screenX:!0,screenY:!0,targetTouches:!0,toElement:!0,touches:!0,which:function(a){var b=a.button;return null==a.which&&sa.test(a.type)?null!=a.charCode?a.charCode:a.keyCode:!a.which&&void 0!==b&&ta.test(a.type)?1&b?1:2&b?3:4&b?2:0:a.which}},r.event.addProp),r.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){r.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return e&&(e===d||r.contains(d,e))||(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),r.fn.extend({on:function(a,b,c,d){return ya(this,a,b,c,d)},one:function(a,b,c,d){return ya(this,a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,r(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return b!==!1&&"function"!=typeof b||(c=b,b=void 0),c===!1&&(c=wa),this.each(function(){r.event.remove(this,a,c,b)})}});var za=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,Aa=/<script|<style|<link/i,Ba=/checked\s*(?:[^=]|=\s*.checked.)/i,Ca=/^true\/(.*)/,Da=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;function Ea(a,b){return B(a,"table")&&B(11!==b.nodeType?b:b.firstChild,"tr")?r(">tbody",a)[0]||a:a}function Fa(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function Ga(a){var b=Ca.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function Ha(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(W.hasData(a)&&(f=W.access(a),g=W.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;c<d;c++)r.event.add(b,e,j[e][c])}X.hasData(a)&&(h=X.access(a),i=r.extend({},h),X.set(b,i))}}function Ia(a,b){var c=b.nodeName.toLowerCase();"input"===c&&ja.test(a.type)?b.checked=a.checked:"input"!==c&&"textarea"!==c||(b.defaultValue=a.defaultValue)}function Ja(a,b,c,d){b=g.apply([],b);var e,f,h,i,j,k,l=0,m=a.length,n=m-1,q=b[0],s=r.isFunction(q);if(s||m>1&&"string"==typeof q&&!o.checkClone&&Ba.test(q))return a.each(function(e){var f=a.eq(e);s&&(b[0]=q.call(this,e,f.html())),Ja(f,b,c,d)});if(m&&(e=qa(b,a[0].ownerDocument,!1,a,d),f=e.firstChild,1===e.childNodes.length&&(e=f),f||d)){for(h=r.map(na(e,"script"),Fa),i=h.length;l<m;l++)j=e,l!==n&&(j=r.clone(j,!0,!0),i&&r.merge(h,na(j,"script"))),c.call(a[l],j,l);if(i)for(k=h[h.length-1].ownerDocument,r.map(h,Ga),l=0;l<i;l++)j=h[l],la.test(j.type||"")&&!W.access(j,"globalEval")&&r.contains(k,j)&&(j.src?r._evalUrl&&r._evalUrl(j.src):p(j.textContent.replace(Da,""),k))}return a}function Ka(a,b,c){for(var d,e=b?r.filter(b,a):a,f=0;null!=(d=e[f]);f++)c||1!==d.nodeType||r.cleanData(na(d)),d.parentNode&&(c&&r.contains(d.ownerDocument,d)&&oa(na(d,"script")),d.parentNode.removeChild(d));return a}r.extend({htmlPrefilter:function(a){return a.replace(za,"<$1></$2>")},clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=r.contains(a.ownerDocument,a);if(!(o.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||r.isXMLDoc(a)))for(g=na(h),f=na(a),d=0,e=f.length;d<e;d++)Ia(f[d],g[d]);if(b)if(c)for(f=f||na(a),g=g||na(h),d=0,e=f.length;d<e;d++)Ha(f[d],g[d]);else Ha(a,h);return g=na(h,"script"),g.length>0&&oa(g,!i&&na(a,"script")),h},cleanData:function(a){for(var b,c,d,e=r.event.special,f=0;void 0!==(c=a[f]);f++)if(U(c)){if(b=c[W.expando]){if(b.events)for(d in b.events)e[d]?r.event.remove(c,d):r.removeEvent(c,d,b.handle);c[W.expando]=void 0}c[X.expando]&&(c[X.expando]=void 0)}}}),r.fn.extend({detach:function(a){return Ka(this,a,!0)},remove:function(a){return Ka(this,a)},text:function(a){return T(this,function(a){return void 0===a?r.text(this):this.empty().each(function(){1!==this.nodeType&&11!==this.nodeType&&9!==this.nodeType||(this.textContent=a)})},null,a,arguments.length)},append:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.appendChild(a)}})},prepend:function(){return Ja(this,arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=Ea(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return Ja(this,arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(r.cleanData(na(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null!=a&&a,b=null==b?a:b,this.map(function(){return r.clone(this,a,b)})},html:function(a){return T(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!Aa.test(a)&&!ma[(ka.exec(a)||["",""])[1].toLowerCase()]){a=r.htmlPrefilter(a);try{for(;c<d;c++)b=this[c]||{},1===b.nodeType&&(r.cleanData(na(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=[];return Ja(this,arguments,function(b){var c=this.parentNode;r.inArray(this,a)<0&&(r.cleanData(na(this)),c&&c.replaceChild(b,this))},a)}}),r.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){r.fn[a]=function(a){for(var c,d=[],e=r(a),f=e.length-1,g=0;g<=f;g++)c=g===f?this:this.clone(!0),r(e[g])[b](c),h.apply(d,c.get());return this.pushStack(d)}});var La=/^margin/,Ma=new RegExp("^("+aa+")(?!px)[a-z%]+$","i"),Na=function(b){var c=b.ownerDocument.defaultView;return c&&c.opener||(c=a),c.getComputedStyle(b)};!function(){function b(){if(i){i.style.cssText="box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%",i.innerHTML="",ra.appendChild(h);var b=a.getComputedStyle(i);c="1%"!==b.top,g="2px"===b.marginLeft,e="4px"===b.width,i.style.marginRight="50%",f="4px"===b.marginRight,ra.removeChild(h),i=null}}var c,e,f,g,h=d.createElement("div"),i=d.createElement("div");i.style&&(i.style.backgroundClip="content-box",i.cloneNode(!0).style.backgroundClip="",o.clearCloneStyle="content-box"===i.style.backgroundClip,h.style.cssText="border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute",h.appendChild(i),r.extend(o,{pixelPosition:function(){return b(),c},boxSizingReliable:function(){return b(),e},pixelMarginRight:function(){return b(),f},reliableMarginLeft:function(){return b(),g}}))}();function Oa(a,b,c){var d,e,f,g,h=a.style;return c=c||Na(a),c&&(g=c.getPropertyValue(b)||c[b],""!==g||r.contains(a.ownerDocument,a)||(g=r.style(a,b)),!o.pixelMarginRight()&&Ma.test(g)&&La.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function Pa(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}var Qa=/^(none|table(?!-c[ea]).+)/,Ra=/^--/,Sa={position:"absolute",visibility:"hidden",display:"block"},Ta={letterSpacing:"0",fontWeight:"400"},Ua=["Webkit","Moz","ms"],Va=d.createElement("div").style;function Wa(a){if(a in Va)return a;var b=a[0].toUpperCase()+a.slice(1),c=Ua.length;while(c--)if(a=Ua[c]+b,a in Va)return a}function Xa(a){var b=r.cssProps[a];return b||(b=r.cssProps[a]=Wa(a)||a),b}function Ya(a,b,c){var d=ba.exec(b);return d?Math.max(0,d[2]-(c||0))+(d[3]||"px"):b}function Za(a,b,c,d,e){var f,g=0;for(f=c===(d?"border":"content")?4:"width"===b?1:0;f<4;f+=2)"margin"===c&&(g+=r.css(a,c+ca[f],!0,e)),d?("content"===c&&(g-=r.css(a,"padding"+ca[f],!0,e)),"margin"!==c&&(g-=r.css(a,"border"+ca[f]+"Width",!0,e))):(g+=r.css(a,"padding"+ca[f],!0,e),"padding"!==c&&(g+=r.css(a,"border"+ca[f]+"Width",!0,e)));return g}function $a(a,b,c){var d,e=Na(a),f=Oa(a,b,e),g="border-box"===r.css(a,"boxSizing",!1,e);return Ma.test(f)?f:(d=g&&(o.boxSizingReliable()||f===a.style[b]),"auto"===f&&(f=a["offset"+b[0].toUpperCase()+b.slice(1)]),f=parseFloat(f)||0,f+Za(a,b,c||(g?"border":"content"),d,e)+"px")}r.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=Oa(a,"opacity");return""===c?"1":c}}}},cssNumber:{animationIterationCount:!0,columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=r.camelCase(b),i=Ra.test(b),j=a.style;return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:j[b]:(f=typeof c,"string"===f&&(e=ba.exec(c))&&e[1]&&(c=fa(a,b,e),f="number"),null!=c&&c===c&&("number"===f&&(c+=e&&e[3]||(r.cssNumber[h]?"":"px")),o.clearCloneStyle||""!==c||0!==b.indexOf("background")||(j[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i?j.setProperty(b,c):j[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=r.camelCase(b),i=Ra.test(b);return i||(b=Xa(h)),g=r.cssHooks[b]||r.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=Oa(a,b,d)),"normal"===e&&b in Ta&&(e=Ta[b]),""===c||c?(f=parseFloat(e),c===!0||isFinite(f)?f||0:e):e}}),r.each(["height","width"],function(a,b){r.cssHooks[b]={get:function(a,c,d){if(c)return!Qa.test(r.css(a,"display"))||a.getClientRects().length&&a.getBoundingClientRect().width?$a(a,b,d):ea(a,Sa,function(){return $a(a,b,d)})},set:function(a,c,d){var e,f=d&&Na(a),g=d&&Za(a,b,d,"border-box"===r.css(a,"boxSizing",!1,f),f);return g&&(e=ba.exec(c))&&"px"!==(e[3]||"px")&&(a.style[b]=c,c=r.css(a,b)),Ya(a,c,g)}}}),r.cssHooks.marginLeft=Pa(o.reliableMarginLeft,function(a,b){if(b)return(parseFloat(Oa(a,"marginLeft"))||a.getBoundingClientRect().left-ea(a,{marginLeft:0},function(){return a.getBoundingClientRect().left}))+"px"}),r.each({margin:"",padding:"",border:"Width"},function(a,b){r.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];d<4;d++)e[a+ca[d]+b]=f[d]||f[d-2]||f[0];return e}},La.test(a)||(r.cssHooks[a+b].set=Ya)}),r.fn.extend({css:function(a,b){return T(this,function(a,b,c){var d,e,f={},g=0;if(Array.isArray(b)){for(d=Na(a),e=b.length;g<e;g++)f[b[g]]=r.css(a,b[g],!1,d);return f}return void 0!==c?r.style(a,b,c):r.css(a,b)},a,b,arguments.length>1)}});function _a(a,b,c,d,e){return new _a.prototype.init(a,b,c,d,e)}r.Tween=_a,_a.prototype={constructor:_a,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||r.easing._default,this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(r.cssNumber[c]?"":"px")},cur:function(){var a=_a.propHooks[this.prop];return a&&a.get?a.get(this):_a.propHooks._default.get(this)},run:function(a){var b,c=_a.propHooks[this.prop];return this.options.duration?this.pos=b=r.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):this.pos=b=a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):_a.propHooks._default.set(this),this}},_a.prototype.init.prototype=_a.prototype,_a.propHooks={_default:{get:function(a){var b;return 1!==a.elem.nodeType||null!=a.elem[a.prop]&&null==a.elem.style[a.prop]?a.elem[a.prop]:(b=r.css(a.elem,a.prop,""),b&&"auto"!==b?b:0)},set:function(a){r.fx.step[a.prop]?r.fx.step[a.prop](a):1!==a.elem.nodeType||null==a.elem.style[r.cssProps[a.prop]]&&!r.cssHooks[a.prop]?a.elem[a.prop]=a.now:r.style(a.elem,a.prop,a.now+a.unit)}}},_a.propHooks.scrollTop=_a.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},r.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2},_default:"swing"},r.fx=_a.prototype.init,r.fx.step={};var ab,bb,cb=/^(?:toggle|show|hide)$/,db=/queueHooks$/;function eb(){bb&&(d.hidden===!1&&a.requestAnimationFrame?a.requestAnimationFrame(eb):a.setTimeout(eb,r.fx.interval),r.fx.tick())}function fb(){return a.setTimeout(function(){ab=void 0}),ab=r.now()}function gb(a,b){var c,d=0,e={height:a};for(b=b?1:0;d<4;d+=2-b)c=ca[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function hb(a,b,c){for(var d,e=(kb.tweeners[b]||[]).concat(kb.tweeners["*"]),f=0,g=e.length;f<g;f++)if(d=e[f].call(c,b,a))return d}function ib(a,b,c){var d,e,f,g,h,i,j,k,l="width"in b||"height"in b,m=this,n={},o=a.style,p=a.nodeType&&da(a),q=W.get(a,"fxshow");c.queue||(g=r._queueHooks(a,"fx"),null==g.unqueued&&(g.unqueued=0,h=g.empty.fire,g.empty.fire=function(){g.unqueued||h()}),g.unqueued++,m.always(function(){m.always(function(){g.unqueued--,r.queue(a,"fx").length||g.empty.fire()})}));for(d in b)if(e=b[d],cb.test(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}n[d]=q&&q[d]||r.style(a,d)}if(i=!r.isEmptyObject(b),i||!r.isEmptyObject(n)){l&&1===a.nodeType&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=q&&q.display,null==j&&(j=W.get(a,"display")),k=r.css(a,"display"),"none"===k&&(j?k=j:(ia([a],!0),j=a.style.display||j,k=r.css(a,"display"),ia([a]))),("inline"===k||"inline-block"===k&&null!=j)&&"none"===r.css(a,"float")&&(i||(m.done(function(){o.display=j}),null==j&&(k=o.display,j="none"===k?"":k)),o.display="inline-block")),c.overflow&&(o.overflow="hidden",m.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]})),i=!1;for(d in n)i||(q?"hidden"in q&&(p=q.hidden):q=W.access(a,"fxshow",{display:j}),f&&(q.hidden=!p),p&&ia([a],!0),m.done(function(){p||ia([a]),W.remove(a,"fxshow");for(d in n)r.style(a,d,n[d])})),i=hb(p?q[d]:0,d,m),d in q||(q[d]=i.start,p&&(i.end=i.start,i.start=0))}}function jb(a,b){var c,d,e,f,g;for(c in a)if(d=r.camelCase(c),e=b[d],f=a[c],Array.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=r.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function kb(a,b,c){var d,e,f=0,g=kb.prefilters.length,h=r.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=ab||fb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;g<i;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),f<1&&i?c:(i||h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:r.extend({},b),opts:r.extend(!0,{specialEasing:{},easing:r.easing._default},c),originalProperties:b,originalOptions:c,startTime:ab||fb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=r.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;c<d;c++)j.tweens[c].run(1);return b?(h.notifyWith(a,[j,1,0]),h.resolveWith(a,[j,b])):h.rejectWith(a,[j,b]),this}}),k=j.props;for(jb(k,j.opts.specialEasing);f<g;f++)if(d=kb.prefilters[f].call(j,a,k,j.opts))return r.isFunction(d.stop)&&(r._queueHooks(j.elem,j.opts.queue).stop=r.proxy(d.stop,d)),d;return r.map(k,hb,j),r.isFunction(j.opts.start)&&j.opts.start.call(a,j),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always),r.fx.timer(r.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j}r.Animation=r.extend(kb,{tweeners:{"*":[function(a,b){var c=this.createTween(a,b);return fa(c.elem,a,ba.exec(b),c),c}]},tweener:function(a,b){r.isFunction(a)?(b=a,a=["*"]):a=a.match(L);for(var c,d=0,e=a.length;d<e;d++)c=a[d],kb.tweeners[c]=kb.tweeners[c]||[],kb.tweeners[c].unshift(b)},prefilters:[ib],prefilter:function(a,b){b?kb.prefilters.unshift(a):kb.prefilters.push(a)}}),r.speed=function(a,b,c){var d=a&&"object"==typeof a?r.extend({},a):{complete:c||!c&&b||r.isFunction(a)&&a,duration:a,easing:c&&b||b&&!r.isFunction(b)&&b};return r.fx.off?d.duration=0:"number"!=typeof d.duration&&(d.duration in r.fx.speeds?d.duration=r.fx.speeds[d.duration]:d.duration=r.fx.speeds._default),null!=d.queue&&d.queue!==!0||(d.queue="fx"),d.old=d.complete,d.complete=function(){r.isFunction(d.old)&&d.old.call(this),d.queue&&r.dequeue(this,d.queue)},d},r.fn.extend({fadeTo:function(a,b,c,d){return this.filter(da).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=r.isEmptyObject(a),f=r.speed(b,c,d),g=function(){var b=kb(this,r.extend({},a),f);(e||W.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=r.timers,g=W.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&db.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));!b&&c||r.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=W.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=r.timers,g=d?d.length:0;for(c.finish=!0,r.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;b<g;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),r.each(["toggle","show","hide"],function(a,b){var c=r.fn[b];r.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(gb(b,!0),a,d,e)}}),r.each({slideDown:gb("show"),slideUp:gb("hide"),slideToggle:gb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){r.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),r.timers=[],r.fx.tick=function(){var a,b=0,c=r.timers;for(ab=r.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||r.fx.stop(),ab=void 0},r.fx.timer=function(a){r.timers.push(a),r.fx.start()},r.fx.interval=13,r.fx.start=function(){bb||(bb=!0,eb())},r.fx.stop=function(){bb=null},r.fx.speeds={slow:600,fast:200,_default:400},r.fn.delay=function(b,c){return b=r.fx?r.fx.speeds[b]||b:b,c=c||"fx",this.queue(c,function(c,d){var e=a.setTimeout(c,b);d.stop=function(){a.clearTimeout(e)}})},function(){var a=d.createElement("input"),b=d.createElement("select"),c=b.appendChild(d.createElement("option"));a.type="checkbox",o.checkOn=""!==a.value,o.optSelected=c.selected,a=d.createElement("input"),a.value="t",a.type="radio",o.radioValue="t"===a.value}();var lb,mb=r.expr.attrHandle;r.fn.extend({attr:function(a,b){return T(this,r.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){r.removeAttr(this,a)})}}),r.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return"undefined"==typeof a.getAttribute?r.prop(a,b,c):(1===f&&r.isXMLDoc(a)||(e=r.attrHooks[b.toLowerCase()]||(r.expr.match.bool.test(b)?lb:void 0)),void 0!==c?null===c?void r.removeAttr(a,b):e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:(a.setAttribute(b,c+""),c):e&&"get"in e&&null!==(d=e.get(a,b))?d:(d=r.find.attr(a,b),
null==d?void 0:d))},attrHooks:{type:{set:function(a,b){if(!o.radioValue&&"radio"===b&&B(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}},removeAttr:function(a,b){var c,d=0,e=b&&b.match(L);if(e&&1===a.nodeType)while(c=e[d++])a.removeAttribute(c)}}),lb={set:function(a,b,c){return b===!1?r.removeAttr(a,c):a.setAttribute(c,c),c}},r.each(r.expr.match.bool.source.match(/\w+/g),function(a,b){var c=mb[b]||r.find.attr;mb[b]=function(a,b,d){var e,f,g=b.toLowerCase();return d||(f=mb[g],mb[g]=e,e=null!=c(a,b,d)?g:null,mb[g]=f),e}});var nb=/^(?:input|select|textarea|button)$/i,ob=/^(?:a|area)$/i;r.fn.extend({prop:function(a,b){return T(this,r.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[r.propFix[a]||a]})}}),r.extend({prop:function(a,b,c){var d,e,f=a.nodeType;if(3!==f&&8!==f&&2!==f)return 1===f&&r.isXMLDoc(a)||(b=r.propFix[b]||b,e=r.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){var b=r.find.attr(a,"tabindex");return b?parseInt(b,10):nb.test(a.nodeName)||ob.test(a.nodeName)&&a.href?0:-1}}},propFix:{"for":"htmlFor","class":"className"}}),o.optSelected||(r.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null},set:function(a){var b=a.parentNode;b&&(b.selectedIndex,b.parentNode&&b.parentNode.selectedIndex)}}),r.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){r.propFix[this.toLowerCase()]=this});function pb(a){var b=a.match(L)||[];return b.join(" ")}function qb(a){return a.getAttribute&&a.getAttribute("class")||""}r.fn.extend({addClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).addClass(a.call(this,b,qb(this)))});if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])d.indexOf(" "+f+" ")<0&&(d+=f+" ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},removeClass:function(a){var b,c,d,e,f,g,h,i=0;if(r.isFunction(a))return this.each(function(b){r(this).removeClass(a.call(this,b,qb(this)))});if(!arguments.length)return this.attr("class","");if("string"==typeof a&&a){b=a.match(L)||[];while(c=this[i++])if(e=qb(c),d=1===c.nodeType&&" "+pb(e)+" "){g=0;while(f=b[g++])while(d.indexOf(" "+f+" ")>-1)d=d.replace(" "+f+" "," ");h=pb(d),e!==h&&c.setAttribute("class",h)}}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):r.isFunction(a)?this.each(function(c){r(this).toggleClass(a.call(this,c,qb(this),b),b)}):this.each(function(){var b,d,e,f;if("string"===c){d=0,e=r(this),f=a.match(L)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else void 0!==a&&"boolean"!==c||(b=qb(this),b&&W.set(this,"__className__",b),this.setAttribute&&this.setAttribute("class",b||a===!1?"":W.get(this,"__className__")||""))})},hasClass:function(a){var b,c,d=0;b=" "+a+" ";while(c=this[d++])if(1===c.nodeType&&(" "+pb(qb(c))+" ").indexOf(b)>-1)return!0;return!1}});var rb=/\r/g;r.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=r.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,r(this).val()):a,null==e?e="":"number"==typeof e?e+="":Array.isArray(e)&&(e=r.map(e,function(a){return null==a?"":a+""})),b=r.valHooks[this.type]||r.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=r.valHooks[e.type]||r.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(rb,""):null==c?"":c)}}}),r.extend({valHooks:{option:{get:function(a){var b=r.find.attr(a,"value");return null!=b?b:pb(r.text(a))}},select:{get:function(a){var b,c,d,e=a.options,f=a.selectedIndex,g="select-one"===a.type,h=g?null:[],i=g?f+1:e.length;for(d=f<0?i:g?f:0;d<i;d++)if(c=e[d],(c.selected||d===f)&&!c.disabled&&(!c.parentNode.disabled||!B(c.parentNode,"optgroup"))){if(b=r(c).val(),g)return b;h.push(b)}return h},set:function(a,b){var c,d,e=a.options,f=r.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=r.inArray(r.valHooks.option.get(d),f)>-1)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),r.each(["radio","checkbox"],function(){r.valHooks[this]={set:function(a,b){if(Array.isArray(b))return a.checked=r.inArray(r(a).val(),b)>-1}},o.checkOn||(r.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})});var sb=/^(?:focusinfocus|focusoutblur)$/;r.extend(r.event,{trigger:function(b,c,e,f){var g,h,i,j,k,m,n,o=[e||d],p=l.call(b,"type")?b.type:b,q=l.call(b,"namespace")?b.namespace.split("."):[];if(h=i=e=e||d,3!==e.nodeType&&8!==e.nodeType&&!sb.test(p+r.event.triggered)&&(p.indexOf(".")>-1&&(q=p.split("."),p=q.shift(),q.sort()),k=p.indexOf(":")<0&&"on"+p,b=b[r.expando]?b:new r.Event(p,"object"==typeof b&&b),b.isTrigger=f?2:3,b.namespace=q.join("."),b.rnamespace=b.namespace?new RegExp("(^|\\.)"+q.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=e),c=null==c?[b]:r.makeArray(c,[b]),n=r.event.special[p]||{},f||!n.trigger||n.trigger.apply(e,c)!==!1)){if(!f&&!n.noBubble&&!r.isWindow(e)){for(j=n.delegateType||p,sb.test(j+p)||(h=h.parentNode);h;h=h.parentNode)o.push(h),i=h;i===(e.ownerDocument||d)&&o.push(i.defaultView||i.parentWindow||a)}g=0;while((h=o[g++])&&!b.isPropagationStopped())b.type=g>1?j:n.bindType||p,m=(W.get(h,"events")||{})[b.type]&&W.get(h,"handle"),m&&m.apply(h,c),m=k&&h[k],m&&m.apply&&U(h)&&(b.result=m.apply(h,c),b.result===!1&&b.preventDefault());return b.type=p,f||b.isDefaultPrevented()||n._default&&n._default.apply(o.pop(),c)!==!1||!U(e)||k&&r.isFunction(e[p])&&!r.isWindow(e)&&(i=e[k],i&&(e[k]=null),r.event.triggered=p,e[p](),r.event.triggered=void 0,i&&(e[k]=i)),b.result}},simulate:function(a,b,c){var d=r.extend(new r.Event,c,{type:a,isSimulated:!0});r.event.trigger(d,null,b)}}),r.fn.extend({trigger:function(a,b){return this.each(function(){r.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];if(c)return r.event.trigger(a,b,c,!0)}}),r.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "),function(a,b){r.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),r.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)}}),o.focusin="onfocusin"in a,o.focusin||r.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){r.event.simulate(b,a.target,r.event.fix(a))};r.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=W.access(d,b);e||d.addEventListener(a,c,!0),W.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=W.access(d,b)-1;e?W.access(d,b,e):(d.removeEventListener(a,c,!0),W.remove(d,b))}}});var tb=a.location,ub=r.now(),vb=/\?/;r.parseXML=function(b){var c;if(!b||"string"!=typeof b)return null;try{c=(new a.DOMParser).parseFromString(b,"text/xml")}catch(d){c=void 0}return c&&!c.getElementsByTagName("parsererror").length||r.error("Invalid XML: "+b),c};var wb=/\[\]$/,xb=/\r?\n/g,yb=/^(?:submit|button|image|reset|file)$/i,zb=/^(?:input|select|textarea|keygen)/i;function Ab(a,b,c,d){var e;if(Array.isArray(b))r.each(b,function(b,e){c||wb.test(a)?d(a,e):Ab(a+"["+("object"==typeof e&&null!=e?b:"")+"]",e,c,d)});else if(c||"object"!==r.type(b))d(a,b);else for(e in b)Ab(a+"["+e+"]",b[e],c,d)}r.param=function(a,b){var c,d=[],e=function(a,b){var c=r.isFunction(b)?b():b;d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(null==c?"":c)};if(Array.isArray(a)||a.jquery&&!r.isPlainObject(a))r.each(a,function(){e(this.name,this.value)});else for(c in a)Ab(c,a[c],b,e);return d.join("&")},r.fn.extend({serialize:function(){return r.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=r.prop(this,"elements");return a?r.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!r(this).is(":disabled")&&zb.test(this.nodeName)&&!yb.test(a)&&(this.checked||!ja.test(a))}).map(function(a,b){var c=r(this).val();return null==c?null:Array.isArray(c)?r.map(c,function(a){return{name:b.name,value:a.replace(xb,"\r\n")}}):{name:b.name,value:c.replace(xb,"\r\n")}}).get()}});var Bb=/%20/g,Cb=/#.*$/,Db=/([?&])_=[^&]*/,Eb=/^(.*?):[ \t]*([^\r\n]*)$/gm,Fb=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,Gb=/^(?:GET|HEAD)$/,Hb=/^\/\//,Ib={},Jb={},Kb="*/".concat("*"),Lb=d.createElement("a");Lb.href=tb.href;function Mb(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(L)||[];if(r.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function Nb(a,b,c,d){var e={},f=a===Jb;function g(h){var i;return e[h]=!0,r.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function Ob(a,b){var c,d,e=r.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&r.extend(!0,a,d),a}function Pb(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}if(f)return f!==i[0]&&i.unshift(f),c[f]}function Qb(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}r.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:tb.href,type:"GET",isLocal:Fb.test(tb.protocol),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":Kb,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/\bxml\b/,html:/\bhtml/,json:/\bjson\b/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":JSON.parse,"text xml":r.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?Ob(Ob(a,r.ajaxSettings),b):Ob(r.ajaxSettings,a)},ajaxPrefilter:Mb(Ib),ajaxTransport:Mb(Jb),ajax:function(b,c){"object"==typeof b&&(c=b,b=void 0),c=c||{};var e,f,g,h,i,j,k,l,m,n,o=r.ajaxSetup({},c),p=o.context||o,q=o.context&&(p.nodeType||p.jquery)?r(p):r.event,s=r.Deferred(),t=r.Callbacks("once memory"),u=o.statusCode||{},v={},w={},x="canceled",y={readyState:0,getResponseHeader:function(a){var b;if(k){if(!h){h={};while(b=Eb.exec(g))h[b[1].toLowerCase()]=b[2]}b=h[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return k?g:null},setRequestHeader:function(a,b){return null==k&&(a=w[a.toLowerCase()]=w[a.toLowerCase()]||a,v[a]=b),this},overrideMimeType:function(a){return null==k&&(o.mimeType=a),this},statusCode:function(a){var b;if(a)if(k)y.always(a[y.status]);else for(b in a)u[b]=[u[b],a[b]];return this},abort:function(a){var b=a||x;return e&&e.abort(b),A(0,b),this}};if(s.promise(y),o.url=((b||o.url||tb.href)+"").replace(Hb,tb.protocol+"//"),o.type=c.method||c.type||o.method||o.type,o.dataTypes=(o.dataType||"*").toLowerCase().match(L)||[""],null==o.crossDomain){j=d.createElement("a");try{j.href=o.url,j.href=j.href,o.crossDomain=Lb.protocol+"//"+Lb.host!=j.protocol+"//"+j.host}catch(z){o.crossDomain=!0}}if(o.data&&o.processData&&"string"!=typeof o.data&&(o.data=r.param(o.data,o.traditional)),Nb(Ib,o,c,y),k)return y;l=r.event&&o.global,l&&0===r.active++&&r.event.trigger("ajaxStart"),o.type=o.type.toUpperCase(),o.hasContent=!Gb.test(o.type),f=o.url.replace(Cb,""),o.hasContent?o.data&&o.processData&&0===(o.contentType||"").indexOf("application/x-www-form-urlencoded")&&(o.data=o.data.replace(Bb,"+")):(n=o.url.slice(f.length),o.data&&(f+=(vb.test(f)?"&":"?")+o.data,delete o.data),o.cache===!1&&(f=f.replace(Db,"$1"),n=(vb.test(f)?"&":"?")+"_="+ub++ +n),o.url=f+n),o.ifModified&&(r.lastModified[f]&&y.setRequestHeader("If-Modified-Since",r.lastModified[f]),r.etag[f]&&y.setRequestHeader("If-None-Match",r.etag[f])),(o.data&&o.hasContent&&o.contentType!==!1||c.contentType)&&y.setRequestHeader("Content-Type",o.contentType),y.setRequestHeader("Accept",o.dataTypes[0]&&o.accepts[o.dataTypes[0]]?o.accepts[o.dataTypes[0]]+("*"!==o.dataTypes[0]?", "+Kb+"; q=0.01":""):o.accepts["*"]);for(m in o.headers)y.setRequestHeader(m,o.headers[m]);if(o.beforeSend&&(o.beforeSend.call(p,y,o)===!1||k))return y.abort();if(x="abort",t.add(o.complete),y.done(o.success),y.fail(o.error),e=Nb(Jb,o,c,y)){if(y.readyState=1,l&&q.trigger("ajaxSend",[y,o]),k)return y;o.async&&o.timeout>0&&(i=a.setTimeout(function(){y.abort("timeout")},o.timeout));try{k=!1,e.send(v,A)}catch(z){if(k)throw z;A(-1,z)}}else A(-1,"No Transport");function A(b,c,d,h){var j,m,n,v,w,x=c;k||(k=!0,i&&a.clearTimeout(i),e=void 0,g=h||"",y.readyState=b>0?4:0,j=b>=200&&b<300||304===b,d&&(v=Pb(o,y,d)),v=Qb(o,v,y,j),j?(o.ifModified&&(w=y.getResponseHeader("Last-Modified"),w&&(r.lastModified[f]=w),w=y.getResponseHeader("etag"),w&&(r.etag[f]=w)),204===b||"HEAD"===o.type?x="nocontent":304===b?x="notmodified":(x=v.state,m=v.data,n=v.error,j=!n)):(n=x,!b&&x||(x="error",b<0&&(b=0))),y.status=b,y.statusText=(c||x)+"",j?s.resolveWith(p,[m,x,y]):s.rejectWith(p,[y,x,n]),y.statusCode(u),u=void 0,l&&q.trigger(j?"ajaxSuccess":"ajaxError",[y,o,j?m:n]),t.fireWith(p,[y,x]),l&&(q.trigger("ajaxComplete",[y,o]),--r.active||r.event.trigger("ajaxStop")))}return y},getJSON:function(a,b,c){return r.get(a,b,c,"json")},getScript:function(a,b){return r.get(a,void 0,b,"script")}}),r.each(["get","post"],function(a,b){r[b]=function(a,c,d,e){return r.isFunction(c)&&(e=e||d,d=c,c=void 0),r.ajax(r.extend({url:a,type:b,dataType:e,data:c,success:d},r.isPlainObject(a)&&a))}}),r._evalUrl=function(a){return r.ajax({url:a,type:"GET",dataType:"script",cache:!0,async:!1,global:!1,"throws":!0})},r.fn.extend({wrapAll:function(a){var b;return this[0]&&(r.isFunction(a)&&(a=a.call(this[0])),b=r(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this},wrapInner:function(a){return r.isFunction(a)?this.each(function(b){r(this).wrapInner(a.call(this,b))}):this.each(function(){var b=r(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=r.isFunction(a);return this.each(function(c){r(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(a){return this.parent(a).not("body").each(function(){r(this).replaceWith(this.childNodes)}),this}}),r.expr.pseudos.hidden=function(a){return!r.expr.pseudos.visible(a)},r.expr.pseudos.visible=function(a){return!!(a.offsetWidth||a.offsetHeight||a.getClientRects().length)},r.ajaxSettings.xhr=function(){try{return new a.XMLHttpRequest}catch(b){}};var Rb={0:200,1223:204},Sb=r.ajaxSettings.xhr();o.cors=!!Sb&&"withCredentials"in Sb,o.ajax=Sb=!!Sb,r.ajaxTransport(function(b){var c,d;if(o.cors||Sb&&!b.crossDomain)return{send:function(e,f){var g,h=b.xhr();if(h.open(b.type,b.url,b.async,b.username,b.password),b.xhrFields)for(g in b.xhrFields)h[g]=b.xhrFields[g];b.mimeType&&h.overrideMimeType&&h.overrideMimeType(b.mimeType),b.crossDomain||e["X-Requested-With"]||(e["X-Requested-With"]="XMLHttpRequest");for(g in e)h.setRequestHeader(g,e[g]);c=function(a){return function(){c&&(c=d=h.onload=h.onerror=h.onabort=h.onreadystatechange=null,"abort"===a?h.abort():"error"===a?"number"!=typeof h.status?f(0,"error"):f(h.status,h.statusText):f(Rb[h.status]||h.status,h.statusText,"text"!==(h.responseType||"text")||"string"!=typeof h.responseText?{binary:h.response}:{text:h.responseText},h.getAllResponseHeaders()))}},h.onload=c(),d=h.onerror=c("error"),void 0!==h.onabort?h.onabort=d:h.onreadystatechange=function(){4===h.readyState&&a.setTimeout(function(){c&&d()})},c=c("abort");try{h.send(b.hasContent&&b.data||null)}catch(i){if(c)throw i}},abort:function(){c&&c()}}}),r.ajaxPrefilter(function(a){a.crossDomain&&(a.contents.script=!1)}),r.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/\b(?:java|ecma)script\b/},converters:{"text script":function(a){return r.globalEval(a),a}}}),r.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),r.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(e,f){b=r("<script>").prop({charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&f("error"===a.type?404:200,a.type)}),d.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Tb=[],Ub=/(=)\?(?=&|$)|\?\?/;r.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Tb.pop()||r.expando+"_"+ub++;return this[a]=!0,a}}),r.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Ub.test(b.url)?"url":"string"==typeof b.data&&0===(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Ub.test(b.data)&&"data");if(h||"jsonp"===b.dataTypes[0])return e=b.jsonpCallback=r.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Ub,"$1"+e):b.jsonp!==!1&&(b.url+=(vb.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||r.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){void 0===f?r(a).removeProp(e):a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Tb.push(e)),g&&r.isFunction(f)&&f(g[0]),g=f=void 0}),"script"}),o.createHTMLDocument=function(){var a=d.implementation.createHTMLDocument("").body;return a.innerHTML="<form></form><form></form>",2===a.childNodes.length}(),r.parseHTML=function(a,b,c){if("string"!=typeof a)return[];"boolean"==typeof b&&(c=b,b=!1);var e,f,g;return b||(o.createHTMLDocument?(b=d.implementation.createHTMLDocument(""),e=b.createElement("base"),e.href=d.location.href,b.head.appendChild(e)):b=d),f=C.exec(a),g=!c&&[],f?[b.createElement(f[1])]:(f=qa([a],b,g),g&&g.length&&r(g).remove(),r.merge([],f.childNodes))},r.fn.load=function(a,b,c){var d,e,f,g=this,h=a.indexOf(" ");return h>-1&&(d=pb(a.slice(h)),a=a.slice(0,h)),r.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&r.ajax({url:a,type:e||"GET",dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?r("<div>").append(r.parseHTML(a)).find(d):a)}).always(c&&function(a,b){g.each(function(){c.apply(this,f||[a.responseText,b,a])})}),this},r.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){r.fn[b]=function(a){return this.on(b,a)}}),r.expr.pseudos.animated=function(a){return r.grep(r.timers,function(b){return a===b.elem}).length},r.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=r.css(a,"position"),l=r(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=r.css(a,"top"),i=r.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),r.isFunction(b)&&(b=b.call(a,c,r.extend({},h))),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},r.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){r.offset.setOffset(this,a,b)});var b,c,d,e,f=this[0];if(f)return f.getClientRects().length?(d=f.getBoundingClientRect(),b=f.ownerDocument,c=b.documentElement,e=b.defaultView,{top:d.top+e.pageYOffset-c.clientTop,left:d.left+e.pageXOffset-c.clientLeft}):{top:0,left:0}},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===r.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),B(a[0],"html")||(d=a.offset()),d={top:d.top+r.css(a[0],"borderTopWidth",!0),left:d.left+r.css(a[0],"borderLeftWidth",!0)}),{top:b.top-d.top-r.css(c,"marginTop",!0),left:b.left-d.left-r.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent;while(a&&"static"===r.css(a,"position"))a=a.offsetParent;return a||ra})}}),r.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(a,b){var c="pageYOffset"===b;r.fn[a]=function(d){return T(this,function(a,d,e){var f;return r.isWindow(a)?f=a:9===a.nodeType&&(f=a.defaultView),void 0===e?f?f[b]:a[d]:void(f?f.scrollTo(c?f.pageXOffset:e,c?e:f.pageYOffset):a[d]=e)},a,d,arguments.length)}}),r.each(["top","left"],function(a,b){r.cssHooks[b]=Pa(o.pixelPosition,function(a,c){if(c)return c=Oa(a,b),Ma.test(c)?r(a).position()[b]+"px":c})}),r.each({Height:"height",Width:"width"},function(a,b){r.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){r.fn[d]=function(e,f){var g=arguments.length&&(c||"boolean"!=typeof e),h=c||(e===!0||f===!0?"margin":"border");return T(this,function(b,c,e){var f;return r.isWindow(b)?0===d.indexOf("outer")?b["inner"+a]:b.document.documentElement["client"+a]:9===b.nodeType?(f=b.documentElement,Math.max(b.body["scroll"+a],f["scroll"+a],b.body["offset"+a],f["offset"+a],f["client"+a])):void 0===e?r.css(b,c,h):r.style(b,c,e,h)},b,g?e:void 0,g)}})}),r.fn.extend({bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}}),r.holdReady=function(a){a?r.readyWait++:r.ready(!0)},r.isArray=Array.isArray,r.parseJSON=JSON.parse,r.nodeName=B,"function"==typeof define&&define.amd&&define("jquery",[],function(){return r});var Vb=a.jQuery,Wb=a.$;return r.noConflict=function(b){return a.$===r&&(a.$=Wb),b&&a.jQuery===r&&(a.jQuery=Vb),r},b||(a.jQuery=a.$=r),r});

//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.
(function(){function n(n){function t(t,r,e,u,i,o){for(;i>=0&&o>i;i+=n){var a=u?u[i]:i;e=r(e,t[a],a,t)}return e}return function(r,e,u,i){e=b(e,i,4);var o=!k(r)&&m.keys(r),a=(o||r).length,c=n>0?0:a-1;return arguments.length<3&&(u=r[o?o[c]:c],c+=n),t(r,e,u,o,c,a)}}function t(n){return function(t,r,e){r=x(r,e);for(var u=O(t),i=n>0?0:u-1;i>=0&&u>i;i+=n)if(r(t[i],i,t))return i;return-1}}function r(n,t,r){return function(e,u,i){var o=0,a=O(e);if("number"==typeof i)n>0?o=i>=0?i:Math.max(i+a,o):a=i>=0?Math.min(i+1,a):i+a+1;else if(r&&i&&a)return i=r(e,u),e[i]===u?i:-1;if(u!==u)return i=t(l.call(e,o,a),m.isNaN),i>=0?i+o:-1;for(i=n>0?o:a-1;i>=0&&a>i;i+=n)if(e[i]===u)return i;return-1}}function e(n,t){var r=I.length,e=n.constructor,u=m.isFunction(e)&&e.prototype||a,i="constructor";for(m.has(n,i)&&!m.contains(t,i)&&t.push(i);r--;)i=I[r],i in n&&n[i]!==u[i]&&!m.contains(t,i)&&t.push(i)}var u=this,i=u._,o=Array.prototype,a=Object.prototype,c=Function.prototype,f=o.push,l=o.slice,s=a.toString,p=a.hasOwnProperty,h=Array.isArray,v=Object.keys,g=c.bind,y=Object.create,d=function(){},m=function(n){return n instanceof m?n:this instanceof m?void(this._wrapped=n):new m(n)};"undefined"!=typeof exports?("undefined"!=typeof module&&module.exports&&(exports=module.exports=m),exports._=m):u._=m,m.VERSION="1.8.3";var b=function(n,t,r){if(t===void 0)return n;switch(null==r?3:r){case 1:return function(r){return n.call(t,r)};case 2:return function(r,e){return n.call(t,r,e)};case 3:return function(r,e,u){return n.call(t,r,e,u)};case 4:return function(r,e,u,i){return n.call(t,r,e,u,i)}}return function(){return n.apply(t,arguments)}},x=function(n,t,r){return null==n?m.identity:m.isFunction(n)?b(n,t,r):m.isObject(n)?m.matcher(n):m.property(n)};m.iteratee=function(n,t){return x(n,t,1/0)};var _=function(n,t){return function(r){var e=arguments.length;if(2>e||null==r)return r;for(var u=1;e>u;u++)for(var i=arguments[u],o=n(i),a=o.length,c=0;a>c;c++){var f=o[c];t&&r[f]!==void 0||(r[f]=i[f])}return r}},j=function(n){if(!m.isObject(n))return{};if(y)return y(n);d.prototype=n;var t=new d;return d.prototype=null,t},w=function(n){return function(t){return null==t?void 0:t[n]}},A=Math.pow(2,53)-1,O=w("length"),k=function(n){var t=O(n);return"number"==typeof t&&t>=0&&A>=t};m.each=m.forEach=function(n,t,r){t=b(t,r);var e,u;if(k(n))for(e=0,u=n.length;u>e;e++)t(n[e],e,n);else{var i=m.keys(n);for(e=0,u=i.length;u>e;e++)t(n[i[e]],i[e],n)}return n},m.map=m.collect=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=Array(u),o=0;u>o;o++){var a=e?e[o]:o;i[o]=t(n[a],a,n)}return i},m.reduce=m.foldl=m.inject=n(1),m.reduceRight=m.foldr=n(-1),m.find=m.detect=function(n,t,r){var e;return e=k(n)?m.findIndex(n,t,r):m.findKey(n,t,r),e!==void 0&&e!==-1?n[e]:void 0},m.filter=m.select=function(n,t,r){var e=[];return t=x(t,r),m.each(n,function(n,r,u){t(n,r,u)&&e.push(n)}),e},m.reject=function(n,t,r){return m.filter(n,m.negate(x(t)),r)},m.every=m.all=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(!t(n[o],o,n))return!1}return!0},m.some=m.any=function(n,t,r){t=x(t,r);for(var e=!k(n)&&m.keys(n),u=(e||n).length,i=0;u>i;i++){var o=e?e[i]:i;if(t(n[o],o,n))return!0}return!1},m.contains=m.includes=m.include=function(n,t,r,e){return k(n)||(n=m.values(n)),("number"!=typeof r||e)&&(r=0),m.indexOf(n,t,r)>=0},m.invoke=function(n,t){var r=l.call(arguments,2),e=m.isFunction(t);return m.map(n,function(n){var u=e?t:n[t];return null==u?u:u.apply(n,r)})},m.pluck=function(n,t){return m.map(n,m.property(t))},m.where=function(n,t){return m.filter(n,m.matcher(t))},m.findWhere=function(n,t){return m.find(n,m.matcher(t))},m.max=function(n,t,r){var e,u,i=-1/0,o=-1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],e>i&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(u>o||u===-1/0&&i===-1/0)&&(i=n,o=u)});return i},m.min=function(n,t,r){var e,u,i=1/0,o=1/0;if(null==t&&null!=n){n=k(n)?n:m.values(n);for(var a=0,c=n.length;c>a;a++)e=n[a],i>e&&(i=e)}else t=x(t,r),m.each(n,function(n,r,e){u=t(n,r,e),(o>u||1/0===u&&1/0===i)&&(i=n,o=u)});return i},m.shuffle=function(n){for(var t,r=k(n)?n:m.values(n),e=r.length,u=Array(e),i=0;e>i;i++)t=m.random(0,i),t!==i&&(u[i]=u[t]),u[t]=r[i];return u},m.sample=function(n,t,r){return null==t||r?(k(n)||(n=m.values(n)),n[m.random(n.length-1)]):m.shuffle(n).slice(0,Math.max(0,t))},m.sortBy=function(n,t,r){return t=x(t,r),m.pluck(m.map(n,function(n,r,e){return{value:n,index:r,criteria:t(n,r,e)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),"value")};var F=function(n){return function(t,r,e){var u={};return r=x(r,e),m.each(t,function(e,i){var o=r(e,i,t);n(u,e,o)}),u}};m.groupBy=F(function(n,t,r){m.has(n,r)?n[r].push(t):n[r]=[t]}),m.indexBy=F(function(n,t,r){n[r]=t}),m.countBy=F(function(n,t,r){m.has(n,r)?n[r]++:n[r]=1}),m.toArray=function(n){return n?m.isArray(n)?l.call(n):k(n)?m.map(n,m.identity):m.values(n):[]},m.size=function(n){return null==n?0:k(n)?n.length:m.keys(n).length},m.partition=function(n,t,r){t=x(t,r);var e=[],u=[];return m.each(n,function(n,r,i){(t(n,r,i)?e:u).push(n)}),[e,u]},m.first=m.head=m.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:m.initial(n,n.length-t)},m.initial=function(n,t,r){return l.call(n,0,Math.max(0,n.length-(null==t||r?1:t)))},m.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:m.rest(n,Math.max(0,n.length-t))},m.rest=m.tail=m.drop=function(n,t,r){return l.call(n,null==t||r?1:t)},m.compact=function(n){return m.filter(n,m.identity)};var S=function(n,t,r,e){for(var u=[],i=0,o=e||0,a=O(n);a>o;o++){var c=n[o];if(k(c)&&(m.isArray(c)||m.isArguments(c))){t||(c=S(c,t,r));var f=0,l=c.length;for(u.length+=l;l>f;)u[i++]=c[f++]}else r||(u[i++]=c)}return u};m.flatten=function(n,t){return S(n,t,!1)},m.without=function(n){return m.difference(n,l.call(arguments,1))},m.uniq=m.unique=function(n,t,r,e){m.isBoolean(t)||(e=r,r=t,t=!1),null!=r&&(r=x(r,e));for(var u=[],i=[],o=0,a=O(n);a>o;o++){var c=n[o],f=r?r(c,o,n):c;t?(o&&i===f||u.push(c),i=f):r?m.contains(i,f)||(i.push(f),u.push(c)):m.contains(u,c)||u.push(c)}return u},m.union=function(){return m.uniq(S(arguments,!0,!0))},m.intersection=function(n){for(var t=[],r=arguments.length,e=0,u=O(n);u>e;e++){var i=n[e];if(!m.contains(t,i)){for(var o=1;r>o&&m.contains(arguments[o],i);o++);o===r&&t.push(i)}}return t},m.difference=function(n){var t=S(arguments,!0,!0,1);return m.filter(n,function(n){return!m.contains(t,n)})},m.zip=function(){return m.unzip(arguments)},m.unzip=function(n){for(var t=n&&m.max(n,O).length||0,r=Array(t),e=0;t>e;e++)r[e]=m.pluck(n,e);return r},m.object=function(n,t){for(var r={},e=0,u=O(n);u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},m.findIndex=t(1),m.findLastIndex=t(-1),m.sortedIndex=function(n,t,r,e){r=x(r,e,1);for(var u=r(t),i=0,o=O(n);o>i;){var a=Math.floor((i+o)/2);r(n[a])<u?i=a+1:o=a}return i},m.indexOf=r(1,m.findIndex,m.sortedIndex),m.lastIndexOf=r(-1,m.findLastIndex),m.range=function(n,t,r){null==t&&(t=n||0,n=0),r=r||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=Array(e),i=0;e>i;i++,n+=r)u[i]=n;return u};var E=function(n,t,r,e,u){if(!(e instanceof t))return n.apply(r,u);var i=j(n.prototype),o=n.apply(i,u);return m.isObject(o)?o:i};m.bind=function(n,t){if(g&&n.bind===g)return g.apply(n,l.call(arguments,1));if(!m.isFunction(n))throw new TypeError("Bind must be called on a function");var r=l.call(arguments,2),e=function(){return E(n,e,t,this,r.concat(l.call(arguments)))};return e},m.partial=function(n){var t=l.call(arguments,1),r=function(){for(var e=0,u=t.length,i=Array(u),o=0;u>o;o++)i[o]=t[o]===m?arguments[e++]:t[o];for(;e<arguments.length;)i.push(arguments[e++]);return E(n,r,this,this,i)};return r},m.bindAll=function(n){var t,r,e=arguments.length;if(1>=e)throw new Error("bindAll must be passed function names");for(t=1;e>t;t++)r=arguments[t],n[r]=m.bind(n[r],n);return n},m.memoize=function(n,t){var r=function(e){var u=r.cache,i=""+(t?t.apply(this,arguments):e);return m.has(u,i)||(u[i]=n.apply(this,arguments)),u[i]};return r.cache={},r},m.delay=function(n,t){var r=l.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},m.defer=m.partial(m.delay,m,1),m.throttle=function(n,t,r){var e,u,i,o=null,a=0;r||(r={});var c=function(){a=r.leading===!1?0:m.now(),o=null,i=n.apply(e,u),o||(e=u=null)};return function(){var f=m.now();a||r.leading!==!1||(a=f);var l=t-(f-a);return e=this,u=arguments,0>=l||l>t?(o&&(clearTimeout(o),o=null),a=f,i=n.apply(e,u),o||(e=u=null)):o||r.trailing===!1||(o=setTimeout(c,l)),i}},m.debounce=function(n,t,r){var e,u,i,o,a,c=function(){var f=m.now()-o;t>f&&f>=0?e=setTimeout(c,t-f):(e=null,r||(a=n.apply(i,u),e||(i=u=null)))};return function(){i=this,u=arguments,o=m.now();var f=r&&!e;return e||(e=setTimeout(c,t)),f&&(a=n.apply(i,u),i=u=null),a}},m.wrap=function(n,t){return m.partial(t,n)},m.negate=function(n){return function(){return!n.apply(this,arguments)}},m.compose=function(){var n=arguments,t=n.length-1;return function(){for(var r=t,e=n[t].apply(this,arguments);r--;)e=n[r].call(this,e);return e}},m.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},m.before=function(n,t){var r;return function(){return--n>0&&(r=t.apply(this,arguments)),1>=n&&(t=null),r}},m.once=m.partial(m.before,2);var M=!{toString:null}.propertyIsEnumerable("toString"),I=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"];m.keys=function(n){if(!m.isObject(n))return[];if(v)return v(n);var t=[];for(var r in n)m.has(n,r)&&t.push(r);return M&&e(n,t),t},m.allKeys=function(n){if(!m.isObject(n))return[];var t=[];for(var r in n)t.push(r);return M&&e(n,t),t},m.values=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},m.mapObject=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=u.length,o={},a=0;i>a;a++)e=u[a],o[e]=t(n[e],e,n);return o},m.pairs=function(n){for(var t=m.keys(n),r=t.length,e=Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},m.invert=function(n){for(var t={},r=m.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},m.functions=m.methods=function(n){var t=[];for(var r in n)m.isFunction(n[r])&&t.push(r);return t.sort()},m.extend=_(m.allKeys),m.extendOwn=m.assign=_(m.keys),m.findKey=function(n,t,r){t=x(t,r);for(var e,u=m.keys(n),i=0,o=u.length;o>i;i++)if(e=u[i],t(n[e],e,n))return e},m.pick=function(n,t,r){var e,u,i={},o=n;if(null==o)return i;m.isFunction(t)?(u=m.allKeys(o),e=b(t,r)):(u=S(arguments,!1,!1,1),e=function(n,t,r){return t in r},o=Object(o));for(var a=0,c=u.length;c>a;a++){var f=u[a],l=o[f];e(l,f,o)&&(i[f]=l)}return i},m.omit=function(n,t,r){if(m.isFunction(t))t=m.negate(t);else{var e=m.map(S(arguments,!1,!1,1),String);t=function(n,t){return!m.contains(e,t)}}return m.pick(n,t,r)},m.defaults=_(m.allKeys,!0),m.create=function(n,t){var r=j(n);return t&&m.extendOwn(r,t),r},m.clone=function(n){return m.isObject(n)?m.isArray(n)?n.slice():m.extend({},n):n},m.tap=function(n,t){return t(n),n},m.isMatch=function(n,t){var r=m.keys(t),e=r.length;if(null==n)return!e;for(var u=Object(n),i=0;e>i;i++){var o=r[i];if(t[o]!==u[o]||!(o in u))return!1}return!0};var N=function(n,t,r,e){if(n===t)return 0!==n||1/n===1/t;if(null==n||null==t)return n===t;n instanceof m&&(n=n._wrapped),t instanceof m&&(t=t._wrapped);var u=s.call(n);if(u!==s.call(t))return!1;switch(u){case"[object RegExp]":case"[object String]":return""+n==""+t;case"[object Number]":return+n!==+n?+t!==+t:0===+n?1/+n===1/t:+n===+t;case"[object Date]":case"[object Boolean]":return+n===+t}var i="[object Array]"===u;if(!i){if("object"!=typeof n||"object"!=typeof t)return!1;var o=n.constructor,a=t.constructor;if(o!==a&&!(m.isFunction(o)&&o instanceof o&&m.isFunction(a)&&a instanceof a)&&"constructor"in n&&"constructor"in t)return!1}r=r||[],e=e||[];for(var c=r.length;c--;)if(r[c]===n)return e[c]===t;if(r.push(n),e.push(t),i){if(c=n.length,c!==t.length)return!1;for(;c--;)if(!N(n[c],t[c],r,e))return!1}else{var f,l=m.keys(n);if(c=l.length,m.keys(t).length!==c)return!1;for(;c--;)if(f=l[c],!m.has(t,f)||!N(n[f],t[f],r,e))return!1}return r.pop(),e.pop(),!0};m.isEqual=function(n,t){return N(n,t)},m.isEmpty=function(n){return null==n?!0:k(n)&&(m.isArray(n)||m.isString(n)||m.isArguments(n))?0===n.length:0===m.keys(n).length},m.isElement=function(n){return!(!n||1!==n.nodeType)},m.isArray=h||function(n){return"[object Array]"===s.call(n)},m.isObject=function(n){var t=typeof n;return"function"===t||"object"===t&&!!n},m.each(["Arguments","Function","String","Number","Date","RegExp","Error"],function(n){m["is"+n]=function(t){return s.call(t)==="[object "+n+"]"}}),m.isArguments(arguments)||(m.isArguments=function(n){return m.has(n,"callee")}),"function"!=typeof/./&&"object"!=typeof Int8Array&&(m.isFunction=function(n){return"function"==typeof n||!1}),m.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},m.isNaN=function(n){return m.isNumber(n)&&n!==+n},m.isBoolean=function(n){return n===!0||n===!1||"[object Boolean]"===s.call(n)},m.isNull=function(n){return null===n},m.isUndefined=function(n){return n===void 0},m.has=function(n,t){return null!=n&&p.call(n,t)},m.noConflict=function(){return u._=i,this},m.identity=function(n){return n},m.constant=function(n){return function(){return n}},m.noop=function(){},m.property=w,m.propertyOf=function(n){return null==n?function(){}:function(t){return n[t]}},m.matcher=m.matches=function(n){return n=m.extendOwn({},n),function(t){return m.isMatch(t,n)}},m.times=function(n,t,r){var e=Array(Math.max(0,n));t=b(t,r,1);for(var u=0;n>u;u++)e[u]=t(u);return e},m.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))},m.now=Date.now||function(){return(new Date).getTime()};var B={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},T=m.invert(B),R=function(n){var t=function(t){return n[t]},r="(?:"+m.keys(n).join("|")+")",e=RegExp(r),u=RegExp(r,"g");return function(n){return n=null==n?"":""+n,e.test(n)?n.replace(u,t):n}};m.escape=R(B),m.unescape=R(T),m.result=function(n,t,r){var e=null==n?void 0:n[t];return e===void 0&&(e=r),m.isFunction(e)?e.call(n):e};var q=0;m.uniqueId=function(n){var t=++q+"";return n?n+t:t},m.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g};var K=/(.)^/,z={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},D=/\\|'|\r|\n|\u2028|\u2029/g,L=function(n){return"\\"+z[n]};m.template=function(n,t,r){!t&&r&&(t=r),t=m.defaults({},t,m.templateSettings);var e=RegExp([(t.escape||K).source,(t.interpolate||K).source,(t.evaluate||K).source].join("|")+"|$","g"),u=0,i="__p+='";n.replace(e,function(t,r,e,o,a){return i+=n.slice(u,a).replace(D,L),u=a+t.length,r?i+="'+\n((__t=("+r+"))==null?'':_.escape(__t))+\n'":e?i+="'+\n((__t=("+e+"))==null?'':__t)+\n'":o&&(i+="';\n"+o+"\n__p+='"),t}),i+="';\n",t.variable||(i="with(obj||{}){\n"+i+"}\n"),i="var __t,__p='',__j=Array.prototype.join,"+"print=function(){__p+=__j.call(arguments,'');};\n"+i+"return __p;\n";try{var o=new Function(t.variable||"obj","_",i)}catch(a){throw a.source=i,a}var c=function(n){return o.call(this,n,m)},f=t.variable||"obj";return c.source="function("+f+"){\n"+i+"}",c},m.chain=function(n){var t=m(n);return t._chain=!0,t};var P=function(n,t){return n._chain?m(t).chain():t};m.mixin=function(n){m.each(m.functions(n),function(t){var r=m[t]=n[t];m.prototype[t]=function(){var n=[this._wrapped];return f.apply(n,arguments),P(this,r.apply(m,n))}})},m.mixin(m),m.each(["pop","push","reverse","shift","sort","splice","unshift"],function(n){var t=o[n];m.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),"shift"!==n&&"splice"!==n||0!==r.length||delete r[0],P(this,r)}}),m.each(["concat","join","slice"],function(n){var t=o[n];m.prototype[n]=function(){return P(this,t.apply(this._wrapped,arguments))}}),m.prototype.value=function(){return this._wrapped},m.prototype.valueOf=m.prototype.toJSON=m.prototype.value,m.prototype.toString=function(){return""+this._wrapped},"function"==typeof define&&define.amd&&define("underscore",[],function(){return m})}).call(this);
//# sourceMappingURL=underscore-min.map;
define("underscore-min", (function (global) {
    return function () {
        var ret, fn;
       fn = function () {
                return _.noConflict();
            };
        ret = fn.apply(global, arguments);
        return ret || global._;
    };
}(this)));

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/Constants',[],function () {

    var Constants = function () {
    };


    /**
     * @namespace
     * ANIMATION
     * @property {String} Inertia - Inertia animation
     * @property {String} Interpolated - Interpolated animation
     * @property {String} Path - Path animation
     * @property {String} Segmented - Segmented animation
     */
    Constants.ANIMATION = {
        "Inertia": "Inertia",
        "Interpolated": "Interpolated",
        "Path": "Path",
        "Segmented": "Segmented"
    };


    /**
     * @namespace
     * CONTEXT
     * @property {String} Planet - Planet context
     * @property {String} Sky - Sky context
     * @property {String} Ground - Ground context
     */
    Constants.CONTEXT = {
        "Planet": "Planet",
        "Sky": "Sky",
        "Ground": "Ground"
    };

    /**
     * @namespace
     * GLOBE
     * @property {String} Planet - Planet
     * @property {String} Sky - Sky
     */
    Constants.GLOBE = {
        "Planet": "Planet",
        "Sky": "Sky"
    };

    /**
     * @namespace
     * LAYER
     * @property {String} WMS - Web Map Service
     * @property {String} WMTS - Web Map Tile Service
     * @property {String} WMSElevation - Web Map Service for elevation
     * @property {String} WCSElevation - Web Map Coverage for elevation
     * @property {String} GeoJSON - GeoJSON
     * @property {String} Vector - Vector
     * @property {String} Atmosphere - Atmosphere
     * @property {String} Bing - Microsoft BING
     * @property {String} GroundOverlay - GroundOverlay
     * @property {String} OSM - Open Street Map
     * @property {String} TileWireframe - TileWireframe
     * @property {String} HipsGrid - HipsGrid
     * @property {String} CoordinateGrid - CoordinateGrid
     * @property {String} Hips - Hierarchical Progressive Survey for images
     * @property {String} HipsCat - Hierarchical Progressive Survey for catalogue
     * @property {String} HipsFits - Hierarchical Progressive Survey for FITS
     * @property {String} Moc - Multiple Order Coverage
     * @property {String} OpenSearch - Open Search
     */
    Constants.LAYER = {
        "WMS": "WMS",
        "WMTS": "WMTS",
        "WMSElevation": "WMSElevation",
        "WCSElevation": "WCSElevation",
        "GeoJSON": "GeoJSON",
        "Vector": "Vector",
        "Atmosphere": "Atmosphere",
        "Bing": "Bing",
        "GroundOverlay": "GroundOverlay",
        "OSM": "OSM",
        "TileWireframe": "TileWireframe",
        "HipsGrid": "HipsGrid",
        "CoordinateGrid": "CoordinateGrid",
        "HipsFits": "HipsFits",
        "Hips": "Hips",
        "HipsCat": "HipsCat",
        "Moc": "Moc",
        "OpenSearch": "OpenSearch"
    };

    /**
     * @namespace
     * GEOMETRY
     * @property {String} Point - Point
     * @property {String} MultiPoint - MultiPoint
     * @property {String} LineString - LineString
     * @property {String} MultiLineString - MultiLineString
     * @property {String} Polygon - Polygon
     * @property {String} MultiPolygon - MultiPolygon
     * @property {String} GeometryCollection - GeometryCollection
     */
    Constants.GEOMETRY = {
        "Point": "Point",
        "MultiPoint": "MultiPoint",
        "LineString": "LineString",
        "MultiLineString": "MultiLineString",
        "Polygon": "Polygon",
        "MultiPolygon": "MultiPolygon",
        "GeometryCollection": "GeometryCollection"
    };

    /**
     * @namespace
     * PROJECTION
     * @property {String} Aitoff - Aitoff projection
     * @property {String} August - August projection
     * @property {String} Mercator - Mercator projection
     * @property {String} Mollweide - Mollweide projection
     * @property {String} Plate - Plate Carrée projection
     * @property {String} Azimuth - Azimuthal projection
     */
    Constants.PROJECTION = {
        "Aitoff": "Aitoff",
        "August": "August",
        "Mercator": "Mercator",
        "Mollweide": "Mollweide",
        "Plate": "Plate Carrée",
        "Azimuth": "Azimuth"
    };

    /**
     * @namespace
     * CRS
     * @property {String} Equatorial - Equatorial coordinate reference system
     * @property {String} Galactic - Galactic coordinate reference system
     * @property {String} WGS84 - EPSG:4326 coordinate reference system
     * @property {String} Mars_2000 - IAU2000:49901 coordinate reference system
     * @property {String} Mars_2000_old - IAU2000:49900 coordinate reference system
     * @property {String} Moon_2000 - IAU2000:30101 coordinate reference system
     * @property {String} Moon_2000_old - IAU2000:30100 coordinate reference system
     * @property {String} HorizontalLocal - Local reference system based on horizontal coordinates
     */
    Constants.CRS = {
        "Equatorial": "Equatorial",
        "Galactic": "Galactic",
        "WGS84": "EPSG:4326",
        "Mars_2000": "IAU2000:49901",
        "Mars_2000_old": "IAU2000:49900",
        "Moon_2000": "IAU2000:30101",
        "Moon_2000_old": "IAU2000:30100",
        "HorizontalLocal": "HorizontalLocal"
    };

    /**
     * @namespace
     * NAVIGATION
     * @property {String} AstroNavigation - 3D Navigation for sky
     * @property {String} PlanetNavigation - 3D Navigation for planet
     * @property {String} FlatNavigation - 2D Navigation for planet
     * @property {String} GroundNavigation - 3D Navigation for ground visualization
     */
    Constants.NAVIGATION = {
        "AstroNavigation": "AstroNavigation",
        "PlanetNavigation": "PlanetNavigation",
        "FlatNavigation": "FlatNavigation",
        "GroundNavigation": "GroundNavigation"
    };

    /**
     * @namespace
     * SERVICE
     * @property {String} FitsVisu - FITS visualization
     * @property {String} Histogram - Histogram values from a FITS file
     * @property {String} ImageProcessing - Image processing
     * @property {String} MeasureToolSky - Tool to measure the distance between two points on the sky
     * @property {String} MeasureToolPlanet - Tool to measure the distance between two points on a planet
     * @property {String} MocBase - MOC service
     * @property {String} MollweideViewer - Mollweide Viewer
     * @property {String} PickingManager - Picking Manager
     * @property {String} Samp - Samp
     * @property {String} SelectionTool - Selection Tool
     * @property {String} NameResolver - NameResolver
     * @property {String} ReverseNameResolver - ReverseNameResolver
     * @property {String} ExportTool - ExportTool
     */
    Constants.SERVICE = {
        "FitsVisu": "FitsVisu",
        "Histogram": "Histogram",
        "ImageProcessing" : "ImageProcessing",
        "MeasureToolSky" : "MeasureToolSky",
        "MeasureToolPlanet" : "MeasureToolPlanet",
        "MocBase" : "MocBase",
        "MollweideViewer" : "MollweideViewer",
        "PickingManager" : "PickingManager",
        "Samp" : "Samp",
        "SelectionTool" : "SelectionTool",
        "NameResolver" : "NameResolver",
        "ReverseNameResolver" : "ReverseNameResolver",
        "ExportTool" : "ExportTool"
    };

    /**
     * @namespace
     * HANDLER
     * @property {String} Touch - Touch device
     * @property {String} Keyboard - Keyboard device
     * @property {String} Mouse - Mouse device
     * @property {String} GoogleMouse - GoogleMouse device
     */
    Constants.HANDLER = {
        "Touch" : "Touch",
        "Keyboard" : "Keyboard",
        "Mouse" : "Mouse",
        "GoogleMouse" : "GoogleMouse"
    };

    /**
     * @namespace
     * PROVIDER
     * @property {String} Constellation - Constellation
     * @property {String} Json - Json
     * @property {String} OpenSearch - OpenSearch
     * @property {String} Planet - Planet
     * @property {String} Star - Star
     */
    Constants.PROVIDER = {
        "Constellation" : "Constellation",
        "OpenSearch" : "OpenSearch",
        "Planet" : "Planet",
        "Star" : "Star",
        "Crater" : "Crater"
    };

    /**
     * @namespace
     * MappingCrsHips2Mizar
     * @property {String} equatorial - Equatorial
     * @property {String} galactic - Galactic
     * @property {String} ecliptic - Ecliptic
     */
    Constants.MappingCrsHips2Mizar = {
        "equatorial": "Equatorial",
        "galactic": "Galactic",
        "ecliptic": "Ecliptic",
        "mars-panstimson": "Equatorial"
    };

    /**
     * @namespace
     * UTILITY
     * @property {String} Fits - Fits utility
     * @property {String} Intersection - Intersection utility
     * @property {String} CreateStyle - CreateStyle utility
     * @property {String} FeatureStyle - FeatureStyle utility
     */
    Constants.UTILITY = {
        "Fits" : "Fits",
        "Intersection" : "Intersection",
        "Numeric" : "Numeric",
        "CreateStyle" : "CreateStyle",
        "FeatureStyle" : "FeatureStyle"
    };

    /**
     * @namespace
     * ANIMATION_STATUS
     * @property {String} STOPPED - animation is stopped
     * @property {String} RUNNING - animation is running
     * @property {String} PAUSED - animation is paused
     */
    Constants.ANIMATION_STATUS = {
        "STOPPED" : "STOPPED",
        "RUNNING" : "RUNNING",
        "PAUSED" : "PAUSED"
    };

    /**************************************************************************************************************/

    return Constants;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Utils',[],function () {

    var Utils = {};

    /**
     * Inherits from an object
     */
    Utils.inherits = function (base, sub) {
        function tempCtor() {
        }

        tempCtor.prototype = base.prototype;
        sub.prototype = new tempCtor();
        sub.prototype.constructor = sub;
    };

    /**
     *    HSV values in [0..1[
     *    returns [r, g, b] values from 0 to 255
     */
    function hsv_to_rgb(h, s, v) {
        var h_i = Math.floor(h * 6);
        var f = h * 6 - h_i;
        var p = v * (1 - s);
        var q = v * (1 - f * s);
        var t = v * (1 - (1 - f) * s);
        var r;
        var g;
        var b;
        switch (h_i) {
            case 0:
                r = v;
                g = t;
                b = p;
                break;
            case 1:
                r = q;
                g = v;
                b = p;
                break;
            case 2:
                r = p;
                g = v;
                b = t;
                break;
            case 3:
                r = p;
                g = q;
                b = v;
                break;
            case 4:
                r = t;
                g = p;
                b = v;
                break;
            case 5:
                r = v;
                g = p;
                b = q;
                break;
            default:
                r = 1;
                g = 1;
                b = 1;
        }
        return [r, g, b];
    }

    /**
     *    Generate eye-friendly color based on hsv
     */
    Utils.generateColor = function () {
        //use golden ratio
        var golden_ratio_conjugate = 0.618033988749895;
        var h = Math.random();
        h += golden_ratio_conjugate;
        h %= 1;
        return hsv_to_rgb(h, 0.5, 0.95);
    };

    return Utils;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Event',[],function () {

    /**************************************************************************************************************/

    /**
     @name Event
     @class
         A light-weight event object.
     */
    var Event = function () {
        // Event callbacks
        this.callbacks = {};
    };

    /**************************************************************************************************************/

    /**
     Subscribe to an event

     @param name Event name
     <ul>
     <li>startNavigation : called when navigation is started (by the user or through animation)</li>
     <li>endNavigation : called when navigation is ended (by the user or through animation)t</li>
     <li>baseLayersReady : called when the base layers are ready to be displayed</li>
     <li>baseLayersError : called when the base layers are not valid, or not accessible, in that case nothing is displayed so this event is useful to provide an error message to the user</li>
     <li>startBackgroundLoad : called when background layers (imagery and/or elevation) start to be loaded</li>
     <li>endBackgroundLoad : called when background layers (imagery and/or elevation) end loading</li>
     <li>startLoad : called when a layer start to be loaded</li>
     <li>endLoad : called when layer end loading</li>
     </ul>
     @param callback Callback function
     */
    Event.prototype.subscribe = function (name, callback) {
        if (!this.callbacks[name]) {
            this.callbacks[name] = [callback];
        } else {
            this.callbacks[name].push(callback);
        }
    };

    /**************************************************************************************************************/

    /**
     Unsubscribe to an event

     @param name Event name {@link Globe#subscribe}
     @param callback Callback function
     */
    Event.prototype.unsubscribe = function (name, callback) {
        if (this.callbacks[name]) {
            var i = this.callbacks[name].indexOf(callback);
            if (i !== -1) {
                this.callbacks[name].splice(i, 1);
            }
        }
    };

    /**************************************************************************************************************/

    /**
     Publish an event

     @param name Event name
     @param context Context
     */
    Event.prototype.publish = function (name, context) {
        if (this.callbacks[name]) {
            var cbs = this.callbacks[name];
            for (var i = 0; i < cbs.length; i++) {
                cbs[i](context);
            }
        }
    };

    /**************************************************************************************************************/

    return Event;

});

// Generated by CoffeeScript 1.3.3
(function() {
  var WCS,
    __bind = function(fn, me){
      return function(){
        return fn.apply(me, arguments);
      };
    },
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  WCS = (typeof exports !== "undefined" && exports !== null) && this || (this.WCS = {});

  WCS.Math = {};

  WCS.Math.R2D = 180 / Math.PI;

  WCS.Math.D2R = Math.PI / 180;

  WCS.Math.WCSTRIG_TOL = 1e-10;

  WCS.Math.cosd = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.cos(angle * WCS.Math.D2R);
  };

  WCS.Math.sind = function(angle) {
    var i;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 - 0.5)) % 4;
      switch (i) {
        case 0:
          return 1;
        case 1:
          return 0;
        case 2:
          return -1;
        case 3:
          return 0;
      }
    }
    return Math.sin(angle * WCS.Math.D2R);
  };

  WCS.Math.sincosd = function(angle) {
    var c, i, s, _ref, _ref1;
    if (angle % 90 === 0) {
      i = Math.abs(Math.floor(angle / 90 + 0.5)) % 4;
      switch (i) {
        case 0:
          s = 0;
          c = 1;
          break;
        case 1:
          s = (_ref = angle > 0) != null ? _ref : {
            1: -1
          };
          c = 0;
          break;
        case 2:
          s = 0;
          c = -1;
          break;
        case 3:
          s = (_ref1 = angle > 0) != null ? _ref1 : -{
            1: 1
          };
          c = 0;
      }
      return s * c;
    }
    s = Math.sin(angle * WCS.Math.D2R);
    c = Math.cos(angle * WCS.Math.D2R);
    return s * c;
  };

  WCS.Math.tand = function(angle) {
    var resid;
    resid = angle & 360;
    if (resid === 0 || Math.abs(resid) === 180) {
      return 0;
    } else if (resid === 45 || resid === 225) {
      return 1;
    } else if (resid === -135 || resid === -315) {
      return -1;
    }
    return Math.tan(angle * WCS.Math.D2R);
  };

  WCS.Math.acosd = function(v) {
    if (v >= 1) {
      if (v - 1 < WCS.Math.WCSTRIG_TOL) {
        return 0;
      }
    } else if (v === 0) {
      return 90;
    } else if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return 180;
      }
    }
    return Math.acos(v) * WCS.Math.R2D;
  };

  WCS.Math.asind = function(v) {
    if (v <= -1) {
      if (v + 1 > -WCS.Math.WCSTRIG_TOL) {
        return -90;
      } else if (v === 0) {
        return 0;
      } else if (v >= 1) {
        if (v - 1 < WCS.Math.WCSTRIG_TOL) {
          return 90;
        }
      }
    }
    return Math.asin(v) * WCS.Math.R2D;
  };

  WCS.Math.atand = function(v) {
    if (v === -1) {
      return -45;
    } else if (v === 0) {
      return 0;
    } else if (v === 1) {
      return 45;
    }
    return Math.atan(v) * WCS.Math.R2D;
  };

  WCS.Math.atan2d = function(y, x) {
    if (y === 0) {
      if (x >= 0) {
        return 0;
      } else if (x < 0) {
        return 180;
      }
    } else if (x === 0) {
      if (y > 0) {
        return 90;
      } else if (y < 0) {
        return -90;
      }
    }
    return Math.atan2(y, x) * WCS.Math.R2D;
  };

  WCS.Math.toRightTriangular = function(mat) {
    var els, i, j, k, kp, multiplier, n, np, p;
    n = mat.length;
    k = n;
    kp = mat[0].length;
    while (true) {
      i = k - n;
      if (mat[i][i] === 0) {
        j = i + 1;
        while (j < k) {
          if (mat[j][i] !== 0) {
            els = [];
            np = kp;
            while (true) {
              p = kp - np;
              els.push(mat[i][p] + mat[j][p]);
              if (!--np) {
                break;
              }
            }
            mat[i] = els;
            break;
          }
          j += 1;
        }
      }
      if (mat[i][i] !== 0) {
        j = i + 1;
        while (j < k) {
          multiplier = mat[j][i] / mat[i][i];
          els = [];
          np = kp;
          while (true) {
            p = kp - np;
            els.push((p <= i ? 0 : mat[j][p] - mat[i][p] * multiplier));
            if (!--np) {
              break;
            }
          }
          mat[j] = els;
          j += 1;
        }
      }
      if (!--n) {
        break;
      }
    }
    return mat;
  };

  WCS.Math.determinant = function(mat) {
    var det, i, k, m, n;
    m = WCS.Math.toRightTriangular(mat);
    det = m[0][0];
    n = m.length - 1;
    k = n;
    while (true) {
      i = k - n + 1;
      det = det * m[i][i];
      if (!--n) {
        break;
      }
    }
    return det;
  };

  WCS.Math.matrixInverse = function(m) {
    var I, h, i, inv, j, mat, temp, w;
    w = m[0].length;
    h = m.length;
    I = new Array(h);
    inv = new Array(h);
    temp = [];
    mat = [];
    j = 0;
    while (j < h) {
      mat[j] = [];
      i = 0;
      while (i < w) {
        mat[j][i] = m[j][i];
        i += 1;
      }
      j += 1;
    }
    j = 0;
    while (j < h) {
      I[j] = new Array(w);
      inv[j] = new Array(w);
      i = 0;
      while (i < w) {
        I[j][i] = (i === j ? 1 : 0);
        i += 1;
      }
      temp[j] = mat[j].concat(I[j]);
      j += 1;
    }
    WCS.Math.gaussJordan(temp);
    j = 0;
    while (j < h) {
      inv[j] = temp[j].slice(w, 2 * w);
      j += 1;
    }
    return inv;
  };

  WCS.Math.gaussJordan = function (m, eps) {
  if (!eps) eps = 1e-10;
  var h, w, y, y2, x, maxrow, tmp, c;
  h = m.length;
  w = m[0].length;
  y = -1;

  while (++y < h) {
    maxrow = y;

    // Find max pivot.
    y2 = y;
    while (++y2 < h) {
      if (Math.abs(m[y2][y]) > Math.abs(m[maxrow][y]))
        maxrow = y2;
    }

    // Swap.
    tmp = m[y];
    m[y] = m[maxrow];
    m[maxrow] = tmp;

    // Singular?
    if (Math.abs(m[y][y]) <= eps)
      return false;

    // Eliminate column y.
    y2 = y;
    while (++y2 < h) {
      c = m[y2][y] / m[y][y];
      x = y - 1;
      while (++x < w) {
        m[y2][x] -= m[y][x] * c;
      }
    }
  }

  // Backsubstitute.
  y = h;
  while (--y >= 0) {
    c = m[y][y];
    y2 = -1;
    while (++y2 < y) {
      x = w;
      while (--x >= y) {
        m[y2][x] -=  m[y][x] * m[y2][y] / c;
      }
    }
    m[y][y] /= c;
    // Normalize row y.
    x = h - 1;
    while (++x < w) {
      m[y][x] /= c;
    }
  }
  return true;
};;

  WCS.Mapper = (function() {

    function Mapper(header) {
      this.coordinateToPixel = __bind(this.coordinateToPixel, this);

      this.pixelToCoordinate = __bind(this.pixelToCoordinate, this);

      this.fromCelestial = __bind(this.fromCelestial, this);

      this.toCelestial = __bind(this.toCelestial, this);

      this.fromIntermediate = __bind(this.fromIntermediate, this);

      this.toIntermediate = __bind(this.toIntermediate, this);

      this.computeCelestialParameters = __bind(this.computeCelestialParameters, this);

      this.getSipCoefficients = __bind(this.getSipCoefficients, this);

      this.setProjection = __bind(this.setProjection, this);

      this.derivePC = __bind(this.derivePC, this);

      this.checkCard = __bind(this.checkCard, this);

      this.verifyHeader = __bind(this.verifyHeader, this);
      this.wcsobj = {};
      this.projection = void 0;
      this.longitudeAxis = void 0;
      this.latitudeAxis = void 0;
      this.sip = void 0;
      this.verifyHeader(header);
      this.setProjection(header);
    }

    Mapper.prototype.verifyHeader = function(header) {
      var arrayName, axis, date, j, key, naxis, requiredCards, _i, _j, _k, _ref;
      this.wcsobj.naxis = naxis = header['NAXIS'] || header['WCSAXES'] || 2;
      this.wcsobj.radesys = header['RADESYS'] || 'ICRS';
      requiredCards = ['CRPIX', 'CRVAL', 'CTYPE'];
      this.wcsobj.crpix = [];
      this.wcsobj.crval = [];
      this.wcsobj.ctype = [];
      for (axis = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; axis = 1 <= naxis ? ++_i : --_i) {
        for (j = _j = 0, _ref = requiredCards.length - 1; 0 <= _ref ? _j <= _ref : _j >= _ref; j = 0 <= _ref ? ++_j : --_j) {
          key = requiredCards[j] + axis;
          if (!header.hasOwnProperty(key)) {
            throw "Not enough information to compute WCS, missing required keyword " + key;
          }
          arrayName = requiredCards[j].toLowerCase();
          this.wcsobj[arrayName].push(header[key]);
        }
      }
      this.wcsobj.cunit = [];
      this.wcsobj.cdelt = [];
      for (axis = _k = 1; 1 <= naxis ? _k <= naxis : _k >= naxis; axis = 1 <= naxis ? ++_k : --_k) {
        key = 'CUNIT' + axis;
        this.wcsobj.cunit.push(header[key] || 'deg');
        key = 'CDELT' + axis;
        this.wcsobj.cdelt.push(header[key] || 1);
      }
      this.wcsobj.lonpole = header['LONPOLE'] || 0;
      this.wcsobj.latpole = header['LATPOLE'] || 0;
      this.wcsobj.equinox = header['EQUINOX'] || 2000;
      date = new Date();
      this.wcsobj.dateObs = header['DATE_OBS'] || (date.getFullYear() + '-' + (date.getMonth() + 1) + '-' + date.getDate());
      this.wcsobj.dateObs = header['DATE_OBS'] || ("" + (date.getFullYear()) + "-" + (date.getMonth() + 1) + "-" + (date.getDate()));
      this.wcsobj.pc = this.checkCard(header, 'PC', naxis) || this.derivePC(header);
      this.wcsobj.pcInv = WCS.Math.matrixInverse(this.wcsobj.pc);
      this.wcsobj.cd = this.checkCard(header, 'CD', naxis);
      if (this.wcsobj.cd != null) {
        return this.wcsobj.cdInv = WCS.Math.matrixInverse(this.wcsobj.cd);
      }
    };

    Mapper.prototype.checkCard = function(header, key, dimensions) {
      var fullKey, i, j, obj, _i, _j;
      obj = [];
      for (i = _i = 1; 1 <= dimensions ? _i <= dimensions : _i >= dimensions; i = 1 <= dimensions ? ++_i : --_i) {
        obj[i - 1] = [];
        for (j = _j = 1; 1 <= dimensions ? _j <= dimensions : _j >= dimensions; j = 1 <= dimensions ? ++_j : --_j) {
          fullKey = "" + key + i + "_" + j;
          if (!header.hasOwnProperty(fullKey)) {
            return;
          }
          obj[i - 1].push(header[fullKey]);
        }
      }
      return obj;
    };

    Mapper.prototype.derivePC = function(header) {
      var cd, cd11, cd12, cd21, cd22, cos_rho, crota, lambda, rho_a, rho_b, _ref;
      if (header.hasOwnProperty('CROTA2')) {
        crota = header['CROTA2'];
        lambda = this.wcsobj.cdelt[1] / this.wcsobj.cdelt[0];
      } else {
        cd = this.checkCard(header, 'CD', this.wcsobj.naxis);
        if (cd == null) {
          _ref = [0, 1], crota = _ref[0], lambda = _ref[1];
        } else {
          cd11 = cd[0][0];
          cd12 = cd[0][1];
          cd21 = cd[1][0];
          cd22 = cd[1][1];
          if (cd21 > 0) {
            rho_a = Math.atan2(cd21, cd11);
          } else if (cd21 === 0) {
            rho_a = 0;
          } else {
            rho_a = Math.atan2(-cd21, -cd11);
          }
          if (cd12 > 0) {
            rho_b = Math.atan2(cd12, -cd22);
          } else if (cd12 === 0) {
            rho_b = 0;
          } else {
            rho_b = Math.atan2(-cd21, cd22);
          }
          crota = 0.5 * (rho_a + rho_b);
          cos_rho = Math.cos(crota);
          this.wcsobj.cdelt1 = cd11 / cos_rho;
          this.wcsobj.cdelt2 = cd22 / cos_rho;
          lambda = this.wcsobj.cdelt2 / this.wcsobj.cdelt1;
        }
      }
      return cd;
    };

    Mapper.prototype.setProjection = function(header) {
      var conic, cylindrical, key, key1, key2, key3, polyConic, quadCube, zenithal, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8,
        _this = this;
      zenithal = ['AIR', 'ARC', 'AZP', 'NCP', 'SIN', 'STG', 'SZP', 'TAN', 'TAN-SIP', 'ZEA', 'ZPN'];
      cylindrical = ['CYP', 'CEA', 'CAR', 'MER', 'SFL', 'PAR', 'MOL', 'AIT'];
      conic = ['COP', 'COE', 'COD', 'COO'];
      polyConic = ['BON', 'PCO'];
      quadCube = ['TSC', 'CSC', 'QSC'];
      this.projection = this.wcsobj.ctype[0].slice(5);
      this.longitudeAxis = this.wcsobj.ctype[0].match("RA|GLON|ELON|HLON|SLON") ? 1 : 2;
      this.latitudeAxis = this.wcsobj.ctype[1].match("DEC|GLAT|ELAT|HLAT|SLAT") ? 2 : 1;
      if (_ref = this.projection, __indexOf.call(zenithal, _ref) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 90;
        this.wcsobj.alphaP = this.wcsobj.crval[0];
        this.wcsobj.deltaP = this.wcsobj.crval[1];
        this.wcsobj.lonpole = this.wcsobj.crval[1] >= this.wcsobj.theta0 ? 0 : 180;
        switch (this.projection) {
          case 'AIR':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.thetaB = header.hasOwnProperty(key) ? parseFloat(header[key]) : 90;
            this.wcsobj.etaB = (90 - this.wcsobj.thetaB) / 2;
            ({
              toSpherical: function(x, y) {
                throw 'Sorry, not yet implemented!';
              },
              fromSpherical: function(phi, theta) {
                throw 'Sorry, not yet implemented!';
              }
            });
            break;
          case 'ARC':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - r;
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 90 - theta;
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'AZP':
            _ref1 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref1[0], key2 = _ref1[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.gamma = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'NCP':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
            break;
          case 'SIN':
            _ref2 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2"], key1 = _ref2[0], key2 = _ref2[1];
            this.wcsobj.eta = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.nu = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.acosd(Math.PI * r / 180);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / Math.PI * WCS.Math.cosd(theta);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'STG':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.atand(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.tand((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'SZP':
            _ref3 = ["PV" + this.latitudeAxis + "_1", "PV" + this.latitudeAxis + "_2", "PV" + this.latitudeAxis + "_3"], key1 = _ref3[0], key2 = _ref3[1], key3 = _ref3[2];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 0;
            this.wcsobj.phiC = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 0;
            this.wcsobj.thetaC = header.hasOwnProperty(key3) ? parseFloat(header[key3]) : 90;
            this.wcsobj.xp = -this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.sind(this.wcsobj.phiC);
            this.wcsobj.yp = this.wcsobj.mu * WCS.Math.cosd(this.wcsobj.thetaC) * WCS.Math.cosd(this.wcsobj.phiC);
            this.wcsobj.zp = this.wcsobj.mu * WCS.Math.sind(this.wcsobj.thetaC) + 1;
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented';
            };
            this.fromSpherical = function(phi, theta) {
              var divisor, x, y;
              throw 'Sorry, not yet implemented';
              divisor = _this.wcsobj.zp - 1 + WCS.Math.sind(theta);
              x = (180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.sind(phi) - _this.wcsobj.xp * (1 - WCS.Math.sind(theta))) / divisor;
              y = (-180 / Math.PI) * (_this.wcsobj.zp * WCS.Math.cosd(theta) * WCS.Math.cosd(phi) + _this.wcsobj.yp * (1 - WCS.Math.sind(theta))) / divisor;
              return [x, y];
            };
            break;
          case 'TAN':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'TAN-SIP':
            this.getSipCoefficients(header);
            this.f = function(u, v, coeffs) {
              var order, p, q, value, _i, _j;
              value = 0;
              order = coeffs[0].length - 1;
              for (p = _i = 0; 0 <= order ? _i <= order : _i >= order; p = 0 <= order ? ++_i : --_i) {
                for (q = _j = 0; 0 <= order ? _j <= order : _j >= order; q = 0 <= order ? ++_j : --_j) {
                  value += coeffs[p][q] * Math.pow(u, p) * Math.pow(v, q);
                }
              }
              return value;
            };
            this.toIntermediate = function(points) {
              var dx, dy, i, j, proj, u, v, _i, _j, _ref4, _ref5;
              proj = [];
              u = points[0] - _this.wcsobj.crpix[0];
              v = points[1] - _this.wcsobj.crpix[1];
              dx = dy = 0;
              dx = _this.f(u, v, _this.sip.aCoeffs);
              dy = _this.f(u, v, _this.sip.bCoeffs);
              points[0] = points[0] + dx;
              points[1] = points[1] + dy;
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                proj[i] = 0;
                points[i] -= _this.wcsobj.crpix[i];
                for (j = _j = 0, _ref5 = _this.wcsobj - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  proj[i] += _this.wcsobj.cd[i][j] * points[j];
                }
              }
              return proj;
            };
            this.fromIntermediate = function(proj) {
              var dx, dy, i, j, points, tmp, _i, _j, _ref4, _ref5;
              tmp = [];
              for (i = _i = 0, _ref4 = _this.wcsobj.naxis - 1; 0 <= _ref4 ? _i <= _ref4 : _i >= _ref4; i = 0 <= _ref4 ? ++_i : --_i) {
                tmp[i] = 0;
                for (j = _j = 0, _ref5 = _this.wcsobj.naxis - 1; 0 <= _ref5 ? _j <= _ref5 : _j >= _ref5; j = 0 <= _ref5 ? ++_j : --_j) {
                  tmp[i] += _this.wcsobj.cdInv[i][j] * proj[j];
                }
                tmp[i] += _this.wcsobj.crpix[i];
              }
              dx = dy = 0;
              dx = _this.f(tmp[0], tmp[1], _this.sip.apCoeffs);
              dy = _this.f(tmp[0], tmp[1], _this.sip.bpCoeffs);
              points = [];
              points[0] = tmp[0] + dx;
              points[1] = tmp[1] + dy;
              points[0] += _this.wcsobj.crpix[0];
              points[1] += _this.wcsobj.crpix[1];
              return points;
            };
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = WCS.Math.atand(180 / (Math.PI * r));
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 180 / (Math.PI * WCS.Math.tand(theta));
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZEA':
            this.toSpherical = function(x, y) {
              var phi, r, theta;
              r = Math.sqrt(x * x + y * y);
              theta = _this.wcsobj.theta0 - 2 * WCS.Math.asind(Math.PI * r / 360);
              phi = WCS.Math.atan2d(x, -y);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var r, x, y;
              r = 360 / Math.PI * WCS.Math.sind((90 - theta) / 2);
              x = r * WCS.Math.sind(phi);
              y = -r * WCS.Math.cosd(phi);
              return [x, y];
            };
            break;
          case 'ZPN':
            this.toSpherical = function(x, y) {
              throw 'Sorry, not yet implemented!';
            };
            this.fromSpherical = function(phi, theta) {
              throw 'Sorry, not yet implemented!';
            };
        }
      }
      if (_ref4 = this.projection, __indexOf.call(cylindrical, _ref4) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        this.computeCelestialParameters(this.wcsobj.phi0, this.wcsobj.theta0);
        switch (this.projection) {
          case 'CYP':
            _ref5 = ["PV" + this.latitudeAxis + "_1,", "PV" + this.latitudeAxis + "_2"], key1 = _ref5[0], key2 = _ref5[1];
            this.wcsobj.mu = header.hasOwnProperty(key1) ? parseFloat(header[key1]) : 1;
            this.wcsobj.lambda = header.hasOwnProperty(key2) ? parseFloat(header[key2]) : 1;
            if (this.wcsobj.mu + this.wcsobj.lambda === 0) {
              raise("Divide by zero error");
            }
            this.toSpherical = function(x, y) {
              var nu, phi, theta;
              nu = (Math.PI * y) / (180 * (_this.wcsobj.mu + _this.wcsobj.lambda));
              theta = WCS.Math.atan2d(nu, 1) + WCS.Math.asind(nu * _this.wcsobj.mu / Math.sqrt(nu * nu + 1));
              phi = x / _this.wcsobj.lambda;
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = _this.wcsobj.lambda * phi;
              y = (180 / Math.PI) * ((_this.wcsobj.mu + _this.wcsobj.lambda) / (_this.wcsobj.mu + WCS.Math.cosd(theta))) * WCS.Math.sind(theta);
              return [x, y];
            };
            break;
          case 'CEA':
            key = "PV" + this.latitudeAxis + "_1";
            this.wcsobj.lambda = header.hasOwnProperty(key) ? parseFloat(header[key]) : 1;
            this.toSpherical = function(x, y) {
              var theta;
              theta = WCS.Math.asind(Math.PI * _this.wcsobj.lambda * y / 180);
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = 180 / Math.PI * WCS.Math.sind(theta) / _this.wcsobj.lambda;
              return [phi, y];
            };
            break;
          case 'CAR':
            this.toSpherical = function(x, y) {
              return [x, y];
            };
            this.fromSpherical = function(phi, theta) {
              return [phi, theta];
            };
            break;
          case 'MER':
            this.toSpherical = function(x, y) {
              var theta;
              theta = 2 * WCS.Math.atand(Math.exp(y * Math.PI / 180)) - 90;
              return [x, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var y;
              y = (180 / Math.PI) * Math.log(WCS.Math.tand((90 + theta) / 2));
              return [phi, y];
            };
            break;
          case 'SFL':
            this.toSpherical = function(x, y) {
              var phi;
              phi = x / WCS.Math.cosd(y);
              return [phi, y];
            };
            this.fromSpherical = function(phi, theta) {
              var x;
              x = phi * WCS.Math.cosd(theta);
              return [x, theta];
            };
            break;
          case 'PAR':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = 3 * WCS.Math.asind(y / 180);
              phi = x / (1 - 4 * Math.pow(y / 180, 2));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              x = phi * (2 * WCS.Math.cosd(2 * theta / 3) - 1);
              y = 180 * WCS.Math.sind(theta / 3);
              return [x, y];
            };
            break;
          case 'MOL':
            this.toSpherical = function(x, y) {
              var phi, theta;
              theta = WCS.Math.asind(WCS.Math.asind((Math.PI * y) / (180 * Math.sqrt(2))) / 90 + (y / 180) * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              phi = (Math.PI * x) / (2 * Math.sqrt(2 - Math.pow(Math.PI * y / 180, 2)));
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var x, y;
              throw 'Sorry, not yet implemented!';
              x = 2 * Math.sqrt(2) / Math.PI * phi * WCS.Math.cosd(gamma);
              y = Math.sqrt(2) * 180 / Math.PI * WCS.Math.sind(gamma);
              return [x, y];
            };
            break;
          case 'AIT':
            this.toSpherical = function(x, y) {
              var phi, theta, x_z, y_z, z;
              x_z = Math.pow((Math.PI * x) / (4 * 180), 2);
              y_z = Math.pow((Math.PI * y) / (2 * 180), 2);
              z = Math.sqrt(1 - x_z - y_z);
              theta = WCS.Math.asind(Math.PI * y * z / 180);
              phi = 2 * WCS.Math.atan2d(Math.PI * z * x / (2 * 180), 2 * z * z - 1);
              return [phi, theta];
            };
            this.fromSpherical = function(phi, theta) {
              var gamma, x, y;
              gamma = 180 / Math.PI * Math.sqrt(2 / (1 + WCS.Math.cosd(theta) * WCS.Math.cosd(phi / 2)));
              x = 2 * gamma * WCS.Math.cosd(theta) * WCS.Math.sind(phi / 2);
              y = gamma * WCS.Math.sind(theta);
              return [x, y];
            };
        }
      }
      if (_ref6 = this.projection, __indexOf.call(conic, _ref6) >= 0) {
        key = "PV" + this.latitudeAxis + "_1";
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = header.hasOwnProperty(key) ? header[key] : 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref7 = this.projection, __indexOf.call(polyConic, _ref7) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
      if (_ref8 = this.projection, __indexOf.call(quadCube, _ref8) >= 0) {
        this.wcsobj.phi0 = 0;
        this.wcsobj.theta0 = 0;
        throw 'Sorry, not yet implemented!';
      }
    };

    Mapper.prototype.getSipCoefficients = function(header) {
      var i, j, key, _i, _j, _k, _l, _m, _n, _o, _p, _ref, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7;
      if (!(header.hasOwnProperty('A_ORDER') || header.hasOwnProperty('B_ORDER'))) {
        throw "What's the polynomial order, man!";
      }
      this.sip = {};
      this.sip.aOrder = header.A_ORDER;
      this.sip.bOrder = header.B_ORDER;
      this.sip.apOrder = header.AP_ORDER || 0;
      this.sip.bpOrder = header.BP_ORDER || 0;
      this.sip.aCoeffs = [];
      this.sip.bCoeffs = [];
      this.sip.apCoeffs = [];
      this.sip.bpCoeffs = [];
      for (i = _i = 0, _ref = this.sip.aOrder; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.sip.aCoeffs[i] = [];
        for (j = _j = 0, _ref1 = this.sip.aOrder; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          key = "A_" + i + "_" + j;
          this.sip.aCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _k = 0, _ref2 = this.sip.bOrder; 0 <= _ref2 ? _k <= _ref2 : _k >= _ref2; i = 0 <= _ref2 ? ++_k : --_k) {
        this.sip.bCoeffs[i] = [];
        for (j = _l = 0, _ref3 = this.sip.bOrder; 0 <= _ref3 ? _l <= _ref3 : _l >= _ref3; j = 0 <= _ref3 ? ++_l : --_l) {
          key = "B_" + i + "_" + j;
          this.sip.bCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _m = 0, _ref4 = this.sip.apOrder; 0 <= _ref4 ? _m <= _ref4 : _m >= _ref4; i = 0 <= _ref4 ? ++_m : --_m) {
        this.sip.apCoeffs[i] = [];
        for (j = _n = 0, _ref5 = this.sip.apOrder; 0 <= _ref5 ? _n <= _ref5 : _n >= _ref5; j = 0 <= _ref5 ? ++_n : --_n) {
          key = "AP_" + i + "_" + j;
          this.sip.apCoeffs[i][j] = header[key] || 0;
        }
      }
      for (i = _o = 0, _ref6 = this.sip.bpOrder; 0 <= _ref6 ? _o <= _ref6 : _o >= _ref6; i = 0 <= _ref6 ? ++_o : --_o) {
        this.sip.bpCoeffs[i] = [];
        for (j = _p = 0, _ref7 = this.sip.bpOrder; 0 <= _ref7 ? _p <= _ref7 : _p >= _ref7; j = 0 <= _ref7 ? ++_p : --_p) {
          key = "BP_" + i + "_" + j;
          this.sip.bpCoeffs[i][j] = header[key] || 0;
        }
      }
      if (!(this.sip.aCoeffs || this.sip.bCoeffs)) {
        throw "Where are the coefficients dude!";
      }
    };

    Mapper.prototype.computeCelestialParameters = function(phi0, theta0) {
      var alpha0, delta0, deltaP1, deltaP2, dist1, dist2, phiP, sol1, sol2, thetaP, _ref, _ref1;
      _ref = this.wcsobj.crval, alpha0 = _ref[0], delta0 = _ref[1];
      _ref1 = [this.wcsobj.lonpole, this.wcsobj.latpole], phiP = _ref1[0], thetaP = _ref1[1];
      deltaP1 = WCS.Math.atan2d(WCS.Math.sind(this.wcsobj.theta0), WCS.Math.cosd(this.wcsobj.theta0 * WCS.Math.cosd(phiP - this.wcsobj.phi0)));
      deltaP2 = WCS.Math.acosd(WCS.Math.sind(delta0) / Math.sqrt(1 - Math.pow(WCS.Math.cosd(this.wcsobj.theta0), 2) * Math.pow(WCS.Math.sind(phiP - this.wcsobj.phi0), 2)));
      sol1 = sol2 = false;
      if (deltaP1 + deltaP2 >= -90 && deltaP1 + deltaP2 <= 90) {
        sol1 = true;
      }
      if (deltaP1 - deltaP2 >= -90 && deltaP1 - deltaP2 <= 90) {
        sol2 = true;
      }
      if (sol1 && sol2) {
        dist1 = Math.abs(deltaP1 + deltaP2 - thetaP);
        dist2 = Math.abs(deltaP1 - deltaP2 - thetaP);
        this.wcsobj.deltaP = dist1 < dist2 ? deltaP1 + deltaP2 : deltaP1 - deltaP2;
      } else if (sol1) {
        this.wcsobj.deltaP = deltaP1 + deltaP2;
      } else if (sol2) {
        this.wcsobj.deltaP = deltaP1 - deltaP2;
      } else {
        this.wcsobj.deltaP = thetaP;
      }
      return this.wcsobj.alphaP = Math.abs(delta0) === 90 ? alpha0 : alpha0 - WCS.Math.asind(WCS.Math.sind(phiP - this.wcsobj.phi0) * WCS.Math.cosd(this.wcsobj.theta0) / WCS.Math.cosd(delta0));
    };

    Mapper.prototype.toIntermediate = function(points) {
      var i, j, proj, _i, _j, _ref, _ref1;
      proj = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        proj[i] = 0;
        points[i] -= this.wcsobj.crpix[i];
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          proj[i] += this.wcsobj.cdelt[i] * this.wcsobj.pc[i][j] * points[j];
        }
      }
      return proj;
    };

    Mapper.prototype.fromIntermediate = function(proj) {
      var i, j, points, _i, _j, _ref, _ref1;
      points = [];
      for (i = _i = 0, _ref = this.wcsobj.naxis - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        points[i] = 0;
        for (j = _j = 0, _ref1 = this.wcsobj.naxis - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          points[i] += this.wcsobj.pcInv[i][j] * proj[j] / this.wcsobj.cdelt[i];
        }
        points[i] += this.wcsobj.crpix[i];
      }
      return points;
    };

    Mapper.prototype.toCelestial = function(phi, theta) {
      var cosDecP, cosDphi, cosTheta, dec, ra, sinDecP, sinDphi, sinTheta, xTemp, yTemp, zTemp;
      sinTheta = WCS.Math.sind(theta);
      cosTheta = WCS.Math.cosd(theta);
      sinDphi = WCS.Math.sind(phi - this.wcsobj.lonpole);
      cosDphi = WCS.Math.cosd(phi - this.wcsobj.lonpole);
      sinDecP = WCS.Math.sind(this.wcsobj.deltaP);
      cosDecP = WCS.Math.cosd(this.wcsobj.deltaP);
      xTemp = sinTheta * cosDecP - cosTheta * sinDecP * cosDphi;
      yTemp = -cosTheta * sinDphi;
      zTemp = sinTheta * sinDecP + cosTheta * cosDecP * cosDphi;
      ra = WCS.Math.atan2d(yTemp, xTemp) + this.wcsobj.alphaP;
      ra = (ra + 360) % 360;
      dec = WCS.Math.asind(zTemp);
      return [ra, dec];
    };

    Mapper.prototype.fromCelestial = function(ra, dec) {
      var cosDalpha, cosDelta, cosDp, phi, sinDalpha, sinDelta, sinDp, theta, xTemp, yTemp;
      sinDelta = WCS.Math.sind(dec);
      cosDelta = WCS.Math.cosd(dec);
      sinDp = WCS.Math.sind(this.wcsobj.deltaP);
      cosDp = WCS.Math.cosd(this.wcsobj.deltaP);
      sinDalpha = WCS.Math.sind(ra - this.wcsobj.alphaP);
      cosDalpha = WCS.Math.cosd(ra - this.wcsobj.alphaP);
      xTemp = sinDelta * cosDp - cosDelta * sinDp * cosDalpha;
      yTemp = -cosDelta * sinDalpha;
      phi = this.wcsobj.lonpole + WCS.Math.atan2d(yTemp, xTemp);
      theta = WCS.Math.asind(sinDelta * sinDp + cosDelta * cosDp * cosDalpha);
      return [phi, theta];
    };

    Mapper.prototype.pixelToCoordinate = function() {
      var coords;
      coords = this.toIntermediate(arguments[0], arguments[1]);
      coords = this.toSpherical(coords[0], coords[1]);
      coords = this.toCelestial(coords[0], coords[1]);
      return {
        ra: coords[this.longitudeAxis - 1],
        dec: coords[this.latitudeAxis - 1]
      };
    };

    Mapper.prototype.coordinateToPixel = function() {
      var coords;
      coords = this.fromCelestial(arguments[0], arguments[1]);
      coords = this.fromSpherical(coords[0], coords[1]);
      coords = this.fromIntermediate(coords);
      return {
        x: coords[0],
        y: coords[1]
      };
    };

    return Mapper;

  })();

}).call(this);

define("wcs", function(){});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/UtilsFits',["wcs"],function (wcs) {

    var UtilsFits = {};

    function createCoordinate(x, y) {
        var coordinate = wcs.pixelToCoordinate([x, y]);
        return [coordinate.ra, coordinate.dec];
    }
    
    /**
     *    Get GeoJson polygon coordinates representing fits using wcs data from header
     */
    UtilsFits.getPolygonCoordinatesFromFits = function (fits) {
        var hdu = fits.getHDU();
        var fitsData = hdu.data;

        // Create mapper
        wcs = new WCS.Mapper(hdu.header);
        var coords = [];

        // Find coordinates of coming fits
        coords.push(createCoordinate(0, fitsData.height));
        coords.push(createCoordinate(fitsData.width, fitsData.height));
        coords.push(createCoordinate(fitsData.width, 0));
        coords.push(createCoordinate(0, 0));
        // Close the polygon
        coords.push(coords[0]);
        return coords;
    };

    return UtilsFits;
});
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Numeric',[],function () {

    /**************************************************************************************************************/

    /**
     Declare namespace for Numeric functions.
     TODO : Should be put into GlobWeb
     */
    var Numeric = {};

    /**************************************************************************************************************/

    /**
     Linear interpolation between [a, b], t must be [0, 1]
     */
    Numeric.lerp = function (t, a, b) {
        return a + ((b - a) * t);
    };

    /**************************************************************************************************************/

    /**
     Cosine interpolation between [a, b], t must be [0, 1]
     */
    Numeric.coserp = function (t, a, b) {
        var t2 = (1 - Math.cos(t * Math.PI)) / 2;
        return a + ((b - a) * t2);
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolation = function (t, startPos, startVel, endPos, endVel) {
        var t2 = t * t;
        var t3 = t2 * t;

        // Evaluate the position

        var M00 = 2 * startPos[0] - 2 * endPos[0] + startVel[0] + endVel[0];
        var M10 = 2 * startPos[1] - 2 * endPos[1] + startVel[1] + endVel[1];
        var M20 = 2 * startPos[2] - 2 * endPos[2] + startVel[2] + endVel[2];

        var M01 = -3 * startPos[0] + 3 * endPos[0] - 2 * startVel[0] - endVel[0];
        var M11 = -3 * startPos[1] + 3 * endPos[1] - 2 * startVel[1] - endVel[1];
        var M21 = -3 * startPos[2] + 3 * endPos[2] - 2 * startVel[2] - endVel[2];

        var position = vec3.create();
        position[0] = M00 * t3 + M01 * t2 + startVel[0] * t + startPos[0];
        position[1] = M10 * t3 + M11 * t2 + startVel[1] * t + startPos[1];
        position[2] = M20 * t3 + M21 * t2 + startVel[2] * t + startPos[2];

        return position;
    };

    /**************************************************************************************************************/

    /**
     Cubic interpolation between [a, b], t must be [0, 1]
     */
    Numeric.cubicInterpolationDerivative = function (t, startPos, startVel, endPos, endVel) {
        var t2 = t * t;

        // Evaluates the direction

        var M01 = 6 * startPos[0] - 6 * endPos[0] + 3 * startVel[0] + 3 * endVel[0];
        var M11 = 6 * startPos[1] - 6 * endPos[1] + 3 * startVel[1] + 3 * endVel[1];
        var M21 = 6 * startPos[2] - 6 * endPos[2] + 3 * startVel[2] + 3 * endVel[2];

        var M02 = -6 * startPos[0] + 6 * endPos[0] - 4 * startVel[0] - 2 * endVel[0];
        var M12 = -6 * startPos[1] + 6 * endPos[1] - 4 * startVel[1] - 2 * endVel[1];
        var M22 = -6 * startPos[2] + 6 * endPos[2] - 4 * startVel[2] - 2 * endVel[2];

        var direction = vec3.create();
        direction[0] = M01 * t2 + M02 * t + startVel[0];
        direction[1] = M11 * t2 + M12 * t + startVel[1];
        direction[2] = M21 * t2 + M22 * t + startVel[2];

        return direction;
    };

    /**************************************************************************************************************/

    /**
     Map x between [xMin, xMax] to [0, 1]
     */
    Numeric.map01 = function (x, xMin, xMax) {
        return (xMin !== xMax) ? (x - xMin) / (xMax - xMin) : 0;
    };

    /**************************************************************************************************************/

    /*
     Map x between [xMin, xMax] to [outMin, outMax]
     */
    Numeric.mapLinear = function (x, xMin, xMax, outMin, outMax) {
        return Numeric.lerp(Numeric.map01(x, xMin, xMax), outMin, outMax);
    };

    /**************************************************************************************************************/

    Numeric.easeInQuad = function (t) {
        return t * t;
    };

    /**************************************************************************************************************/

    Numeric.easeOutQuad = function (t) {
        // use 1-(t^2) with input [-1, 0]
        var v = t - 1; // map [0 1] to [-1 0]
        return 1.0 - (v * v);
    };

    /**************************************************************************************************************/

    /**
     Remap input t ([0, 1]) to a curve starting slowly
     and accelerating till 0.5 an decelerating till 1
     */
    Numeric.easeInOutQuad = function (t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*t^2) with input [0, 1]
            out = out + out; // map [0 0.5] outo [0 1]
            out = 0.5 * (out * out);
        }
        else {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = (out + out) - 2.0; // map [0.5 1] to [-1 0]
            out = 0.5 * (1.0 - (out * out));
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /*
     */
    Numeric.easeOutInQuad = function (t) {
        var out = t;
        if (out < 0.5) {
            // use (0.5*(1-t)^2) with input [-1, 0]
            out = (out + out) - 1.0; // map [0 0.5] to [-1 0]
            out = 0.5 * (1.0 - (out * out));
        }
        else {
            // use (0.5*t^2) with input [0, 1]
            out = (out + out) - 1.0; // map [0.5 1] outo [0 1]
            out = 0.5 * (out * out);
            out = 0.5 + out;
        }
        return out;
    };

    /**************************************************************************************************************/

    /**
     Convert the given degree value in radian
     */
    Numeric.toRadian = function (degree) {
        return degree * Math.PI / 180.0;
    };

    /**************************************************************************************************************/

    /**
     Convert the given radian value in degree
     */
    Numeric.toDegree = function (radian) {
        return radian * 180.0 / Math.PI;
    };

    /**************************************************************************************************************/

    /**
     Line-line intersection
     rayDirection must be normalized.
     Returns t at which intersection occurs or -1 if no intersection.
     */

    Numeric.lineIntersection = function (x1, y1, x2, y2, x3, y3, x4, y4) {
        var det = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
        if (det === 0) {
            return [-1, -1];
        }

        var ua = (x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3);
        var ub = (x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3);

        ua /= det;
        ub /= det;

        return [ua, ub];
        //return ua > 0.0 && ua < 1.0 && ub > 0.0 && ub < 1.0;
    };

    /**************************************************************************************************************/

    /**
     *    Round the given number
     *
     *    @param num Number to round
     *    @param dec Number of decimals
     */
    Numeric.roundNumber = function (num, dec) {
        return Math.round(num * Math.pow(10, dec)) / Math.pow(10, dec);
    };
    

    /**
     * Return the sign of a value
     */
    Numeric.sign = function(v) {
        if (v < 0)
            return -1 ;
        else { if (v > 0) return 1; else return 0; }
    };

    /**************************************************************************************************************/

    return Numeric;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 *    Module with constants
 */
define('Tiling/HEALPixTables',[],function () {

    /**************************************************************************************************************/

    var HealPixTables = {
        ctab: [
            0, 1, 256, 257, 2, 3, 258, 259, 512, 513, 768, 769, 514, 515, 770, 771, 4, 5, 260, 261, 6, 7, 262,
            263, 516, 517, 772, 773, 518, 519, 774, 775, 1024, 1025, 1280, 1281, 1026, 1027, 1282, 1283,
            1536, 1537, 1792, 1793, 1538, 1539, 1794, 1795, 1028, 1029, 1284, 1285, 1030, 1031, 1286,
            1287, 1540, 1541, 1796, 1797, 1542, 1543, 1798, 1799, 8, 9, 264, 265, 10, 11, 266, 267, 520,
            521, 776, 777, 522, 523, 778, 779, 12, 13, 268, 269, 14, 15, 270, 271, 524, 525, 780, 781, 526,
            527, 782, 783, 1032, 1033, 1288, 1289, 1034, 1035, 1290, 1291, 1544, 1545, 1800, 1801, 1546,
            1547, 1802, 1803, 1036, 1037, 1292, 1293, 1038, 1039, 1294, 1295, 1548, 1549, 1804, 1805,
            1550, 1551, 1806, 1807, 2048, 2049, 2304, 2305, 2050, 2051, 2306, 2307, 2560, 2561, 2816,
            2817, 2562, 2563, 2818, 2819, 2052, 2053, 2308, 2309, 2054, 2055, 2310, 2311, 2564, 2565,
            2820, 2821, 2566, 2567, 2822, 2823, 3072, 3073, 3328, 3329, 3074, 3075, 3330, 3331, 3584,
            3585, 3840, 3841, 3586, 3587, 3842, 3843, 3076, 3077, 3332, 3333, 3078, 3079, 3334, 3335,
            3588, 3589, 3844, 3845, 3590, 3591, 3846, 3847, 2056, 2057, 2312, 2313, 2058, 2059, 2314,
            2315, 2568, 2569, 2824, 2825, 2570, 2571, 2826, 2827, 2060, 2061, 2316, 2317, 2062, 2063,
            2318, 2319, 2572, 2573, 2828, 2829, 2574, 2575, 2830, 2831, 3080, 3081, 3336, 3337, 3082,
            3083, 3338, 3339, 3592, 3593, 3848, 3849, 3594, 3595, 3850, 3851, 3084, 3085, 3340, 3341,
            3086, 3087, 3342, 3343, 3596, 3597, 3852, 3853, 3598, 3599, 3854, 3855],
        utab: [
            0, 1, 4, 5, 16, 17, 20, 21, 64, 65, 68, 69, 80, 81, 84, 85, 256, 257, 260, 261, 272, 273, 276, 277,
            320, 321, 324, 325, 336, 337, 340, 341, 1024, 1025, 1028, 1029, 1040, 1041, 1044, 1045, 1088,
            1089, 1092, 1093, 1104, 1105, 1108, 1109, 1280, 1281, 1284, 1285, 1296, 1297, 1300, 1301,
            1344, 1345, 1348, 1349, 1360, 1361, 1364, 1365, 4096, 4097, 4100, 4101, 4112, 4113, 4116,
            4117, 4160, 4161, 4164, 4165, 4176, 4177, 4180, 4181, 4352, 4353, 4356, 4357, 4368, 4369,
            4372, 4373, 4416, 4417, 4420, 4421, 4432, 4433, 4436, 4437, 5120, 5121, 5124, 5125, 5136,
            5137, 5140, 5141, 5184, 5185, 5188, 5189, 5200, 5201, 5204, 5205, 5376, 5377, 5380, 5381,
            5392, 5393, 5396, 5397, 5440, 5441, 5444, 5445, 5456, 5457, 5460, 5461, 16384, 16385, 16388,
            16389, 16400, 16401, 16404, 16405, 16448, 16449, 16452, 16453, 16464, 16465, 16468, 16469,
            16640, 16641, 16644, 16645, 16656, 16657, 16660, 16661, 16704, 16705, 16708, 16709, 16720,
            16721, 16724, 16725, 17408, 17409, 17412, 17413, 17424, 17425, 17428, 17429, 17472, 17473,
            17476, 17477, 17488, 17489, 17492, 17493, 17664, 17665, 17668, 17669, 17680, 17681, 17684,
            17685, 17728, 17729, 17732, 17733, 17744, 17745, 17748, 17749, 20480, 20481, 20484, 20485,
            20496, 20497, 20500, 20501, 20544, 20545, 20548, 20549, 20560, 20561, 20564, 20565, 20736,
            20737, 20740, 20741, 20752, 20753, 20756, 20757, 20800, 20801, 20804, 20805, 20816, 20817,
            20820, 20821, 21504, 21505, 21508, 21509, 21520, 21521, 21524, 21525, 21568, 21569, 21572,
            21573, 21584, 21585, 21588, 21589, 21760, 21761, 21764, 21765, 21776, 21777, 21780, 21781,
            21824, 21825, 21828, 21829, 21840, 21841, 21844, 21845],

        // coordinate of the lowest corner of each face
        jrll: [2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4],
        jpll: [1, 3, 5, 7, 0, 2, 4, 6, 1, 3, 5, 7],

        xoffset: [-1, -1, 0, 1, 1, 1, 0, -1],
        yoffset: [0, 1, 1, 1, 0, -1, -1, -1],
        facearray: [[8, 9, 10, 11, -1, -1, -1, -1, 10, 11, 8, 9],   // S
            [5, 6, 7, 4, 8, 9, 10, 11, 9, 10, 11, 8],   // SE
            [-1, -1, -1, -1, 5, 6, 7, 4, -1, -1, -1, -1],   // E
            [4, 5, 6, 7, 11, 8, 9, 10, 11, 8, 9, 10],   // SW
            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11],   // center
            [1, 2, 3, 0, 0, 1, 2, 3, 5, 6, 7, 4],   // NE
            [-1, -1, -1, -1, 7, 4, 5, 6, -1, -1, -1, -1],   // W
            [3, 0, 1, 2, 3, 0, 1, 2, 4, 5, 6, 7],   // NW
            [2, 3, 0, 1, -1, -1, -1, -1, 0, 1, 2, 3]], // N
        swaparray: [[0, 0, 3],   // S
            [0, 0, 6],   // SE
            [0, 0, 0],   // E
            [0, 0, 5],   // SW
            [0, 0, 0],   // center
            [5, 0, 0],   // NE
            [0, 0, 0],   // W
            [6, 0, 0],   // NW
            [3, 0, 0]], // N

        swap_cycle: [
            [],
            [0, 1, 8, 12, 16, 21, 40],
            [0, 1, 2, 40, 114],
            [0, 4, 160, 263],
            [0, 4, 30, 49, 51, 87, 526, 1027, 1105, 1387, 1807, 2637],
            [0, 8, 10, 18, 39, 74, 146, 307, 452, 4737],
            [0, 1, 2, 7, 9, 17, 80, 410, 1526, 1921, 32859, 33566, 38931],
            [0, 5, 6, 10, 12, 24, 27, 95, 372, 494, 924, 1409, 3492, 4248, 9137, 66043, 103369, 156899],
            [0, 1, 2, 3, 4, 45, 125, 351, 697, 24337, 102940, 266194, 341855, 419857],
            [0, 1, 2, 3, 9, 16, 1705, 2082, 2126, 8177, 12753, 15410, 52642, 80493, 83235, 88387, 99444,
                1675361, 2495125],
            [0, 2, 6, 8, 9, 11, 20, 50, 93, 152, 183, 2137, 13671, 44794, 486954, 741908, 4803258,
                5692573],
            [0, 1, 5, 6, 44, 53, 470, 2847, 3433, 4906, 13654, 14710, 400447, 1797382, 2744492,
                18775974, 23541521],
            [0, 4, 9, 10, 16, 33, 83, 117, 318, 451, 5759, 10015, 128975, 171834, 211256, 347608,
                1278690, 2154097, 2590798, 3427694, 5581717, 21012301, 27023976, 72522811,
                95032729, 139166747, 171822389],
            [0, 5, 10, 267, 344, 363, 2968, 3159, 9083, 18437, 76602, 147614, 1246902, 1593138,
                2035574, 6529391, 9511830, 11340287, 29565945, 281666026, 677946848]]
    };

    return HealPixTables;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Long',[],function () {
     /**
      * @name Long
      * @class
      *   Long class for only unsigned integers
      *  Constructs a 64-bit two's-complement integer, given its low and high 32-bit
      *  values as *signed* integers.  See the from* functions below for more
      *  convenient ways of constructing Longs.
      *
      *  The internal representation of a long is the two given signed, 32-bit values.
      *  We use 32-bit pieces because these are the size of integers on which
      *  Javascript performs bit-operations.  For operations like addition and
      *  multiplication, we split each number into 16-bit pieces, which can easily be
      *  multiplied within Javascript's floating-point representation without overflow
      *  or change in sign.
      *
      *  In the algorithms below, we frequently reduce the negative case to the
      *  positive case by negating the input(s) and then post-processing the result.
      *  Note that we must ALWAYS check specially whether those values are MIN_VALUE
      *  (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as
      *  a positive number, it overflows back into a negative).  Not handling this
      * case would often result in infinite recursion.
      * @constructor
      * @param {number} low  The low (signed) 32 bits of the long.
      * @param {number} high  The high (signed) 32 bits of the long.
     */
    var Long = function (low, high) {
        /**
         * @type {number}
         * @private
         */
        this.low_ = low | 0;  // force into 32 signed bits.

        /**
         * @type {number}
         * @private
         */
        this.high_ = high | 0;  // force into 32 signed bits.
    };

    /**
     * A cache of the Long representations of small integer values.
     * @type {!Object}
     * @private
     */
    Long.IntCache_ = {};

    /**
     * Returns a Long representing the given (32-bit) integer value.
     * @function fromInt
     * @memberof Long
     * @param {number} value The 32-bit integer in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromInt = function (value) {
        if (-128 <= value && value < 128) {
            var cachedObj = Long.IntCache_[value];
            if (cachedObj) {
                return cachedObj;
            }
        }

        var obj = new Long(value | 0, value < 0 ? -1 : 0);
        if (-128 <= value && value < 128) {
            Long.IntCache_[value] = obj;
        }
        return obj;
    };

    /**
     * Returns a Long representing the given value, provided that it is a finite
     * number.  Otherwise, zero is returned.
     * @function fromNumber
     * @memberof Long
     * @param {number} value The number in question.
     * @return {!Long} The corresponding Long value.
     */
    Long.fromNumber = function (value) {
        if (isNaN(value) || !isFinite(value)) {
            return Long.ZERO;
        } else if (value <= -Long.TWO_PWR_63_DBL_) {
            return Long.MIN_VALUE;
        } else if (value + 1 >= Long.TWO_PWR_63_DBL_) {
            return Long.MAX_VALUE;
        } else if (value < 0) {
            return Long.fromNumber(-value).negate();
        } else {
            return new Long(
                (value % Long.TWO_PWR_32_DBL_) | 0,
                (value / Long.TWO_PWR_32_DBL_) | 0);
        }
    };

     /**
      * Returns a Long representing the 64-bit integer that comes by concatenating
      * the given high and low bits.  Each is assumed to use 32 bits.
      * @function fromBits
      * @memberof Long
      * @param {number} lowBits The low 32-bits.
      * @param {number} highBits The high 32-bits.
      * @return {!Long} The corresponding Long value.
      */
    Long.fromBits = function (lowBits, highBits) {
        return new Long(lowBits, highBits);
    };

    /**
     * Number used repeated below in calculations.  This must appear before the
     * first call to any from* function below.
     * @type {number}
     * @private
     */
    Long.TWO_PWR_16_DBL_ = 1 << 16;


    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_24_DBL_ = 1 << 24;


    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_32_DBL_ =
        Long.TWO_PWR_16_DBL_ * Long.TWO_PWR_16_DBL_;


    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_64_DBL_ =
        Long.TWO_PWR_32_DBL_ * Long.TWO_PWR_32_DBL_;


    /**
     * @type {number}
     * @private
     */
    Long.TWO_PWR_63_DBL_ =
        Long.TWO_PWR_64_DBL_ / 2;


    /** @type {!Long} */
    Long.ZERO = Long.fromInt(0);


    /** @type {!Long} */
    Long.ONE = Long.fromInt(1);

    /** @type {!Long} */
    Long.MAX_VALUE =
        Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);


    /** @type {!Long} */
    Long.MIN_VALUE = Long.fromBits(0, 0x80000000 | 0);

    /**
     * @type {!Long}
     * @private
     */
    Long.TWO_PWR_24_ = Long.fromInt(1 << 24);


    /** @return {number} The value, assuming it is a 32-bit integer. */
    Long.prototype.toInt = function () {
        return this.low_;
    };

    /** @return {number} The closest floating-point representation to this value. */
    Long.prototype.toNumber = function () {
        return this.high_ * Long.TWO_PWR_32_DBL_ +
            this.getLowBitsUnsigned();
    };

    /** @return {number} The low 32-bits as an unsigned value. */
    Long.prototype.getLowBitsUnsigned = function () {
        return (this.low_ >= 0) ?
            this.low_ : Long.TWO_PWR_32_DBL_ + this.low_;
    };

    /** @return {boolean} Whether this value is zero. */
    Long.prototype.isZero = function () {
        return this.high_ === 0 && this.low_ === 0;
    };


    /** @return {boolean} Whether this value is negative. */
    Long.prototype.isNegative = function () {
        return this.high_ < 0;
    };


    /** @return {boolean} Whether this value is odd. */
    Long.prototype.isOdd = function () {
        return (this.low_ & 1) === 1;
    };


    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long equals the other.
     */
    Long.prototype.equals = function (other) {
        return (this.high_ === other.high_) && (this.low_ === other.low_);
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is less than the other.
     */
    Long.prototype.lessThan = function (other) {
        return this.compare(other) < 0;
    };

    /**
     * @param {Long} other Long to compare against.
     * @return {boolean} Whether this Long is greater than or equal to the other.
     */
    Long.prototype.greaterThanOrEqual = function (other) {
        return this.compare(other) >= 0;
    };

     /**
      * Compares this Long with the given one.
      * @function compare
      * @memberof Long.prototype
      * @return {number} 0 if they are the same, 1 if the this is greater, and -1
      *     if the given one is greater.
      */
    Long.prototype.compare = function (other) {
        if (this.equals(other)) {
            return 0;
        }

        var thisNeg = this.isNegative();
        var otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) {
            return -1;
        }
        if (!thisNeg && otherNeg) {
            return 1;
        }

        // at this point, the signs are the same, so subtraction will not overflow
        if (this.subtract(other).isNegative()) {
            return -1;
        } else {
            return 1;
        }
    };

    /**
     * Return the negation
     * @function negate
     * @memberof Long.prototype
     * @return {!Long} The negation of this value.
    */
    Long.prototype.negate = function () {
        if (this.equals(Long.MIN_VALUE)) {
            return Long.MIN_VALUE;
        } else {
            return this.not().add(Long.ONE);
        }
    };

     /**
      * Returns the sum of this and the given Long.
      * @function add
      * @memberof Long.prototype
      * @param {Long} other Long to add to this one.
      * @return {!Long} The sum of this and the given Long.
     */
    Long.prototype.add = function (other) {
        // Divide each number into 4 chunks of 16 bits, and then sum the chunks.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xFFFF;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xFFFF;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xFFFF;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 + b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

     /**
      * Returns the difference of this and the given Long.
      * @function subtract
      * @memberof Long.prototype
      * @param {Long} other Long to subtract from this.
      * @return {!Long} The difference of this and the given Long.
     */
    Long.prototype.subtract = function (other) {
        return this.add(other.negate());
    };

    /**
     * Returns the product of this and the given long.
     * @function multiply
     * @memberof Long.prototype
     * @param {Long} other Long to multiply with this.
     * @return {!Long} The product of this and the other.
    */
    Long.prototype.multiply = function (other) {
        if (this.isZero()) {
            return Long.ZERO;
        } else if (other.isZero()) {
            return Long.ZERO;
        }

        if (this.equals(Long.MIN_VALUE)) {
            return other.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        } else if (other.equals(Long.MIN_VALUE)) {
            return this.isOdd() ? Long.MIN_VALUE : Long.ZERO;
        }

        if (this.isNegative()) {
            if (other.isNegative()) {
                return this.negate().multiply(other.negate());
            } else {
                return this.negate().multiply(other).negate();
            }
        } else if (other.isNegative()) {
            return this.multiply(other.negate()).negate();
        }

        // If both longs are small, use float multiplication
        if (this.lessThan(Long.TWO_PWR_24_) &&
            other.lessThan(Long.TWO_PWR_24_)) {
            return Long.fromNumber(this.toNumber() * other.toNumber());
        }

        // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.
        // We can skip products that would overflow.

        var a48 = this.high_ >>> 16;
        var a32 = this.high_ & 0xFFFF;
        var a16 = this.low_ >>> 16;
        var a00 = this.low_ & 0xFFFF;

        var b48 = other.high_ >>> 16;
        var b32 = other.high_ & 0xFFFF;
        var b16 = other.low_ >>> 16;
        var b00 = other.low_ & 0xFFFF;

        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 0xFFFF;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 0xFFFF;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 0xFFFF;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 0xFFFF;
        return Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);
    };

    /** @return {!Long} The bitwise-NOT of this value. */
    Long.prototype.not = function () {
        return Long.fromBits(~this.low_, ~this.high_);
    };

     /**
      * Returns the bitwise-AND of this Long and the given one.
      * @function and
      * @memberof Long.prototype
      * @param {Long} other The Long with which to AND.
      * @return {!Long} The bitwise-AND of this and the other.
      */
    Long.prototype.and = function (other) {
        return Long.fromBits(this.low_ & other.low_,
            this.high_ & other.high_);
    };

     /**
      * Returns the bitwise-OR of this Long and the given one.
      * @function or
      * @memberof Long.prototype
      * @param {Long} other The Long with which to OR.
      * @return {!Long} The bitwise-OR of this and the other.
      */
    Long.prototype.or = function (other) {
        return Long.fromBits(this.low_ | other.low_,
            this.high_ | other.high_);
    };

     /**
      * Returns this Long with bits shifted to the right by the given amount, with
      * the new top bits matching the current sign bit.
      * @function shiftRightUnsigned
      * @memberof Long.prototype
      * @param {number} numBits The number of bits by which to shift.
      * @return {!Long} This shifted to the right by the given amount, with
      *     zeros placed into the new leading bits.
      */
    Long.prototype.shiftRightUnsigned = function (numBits) {
        numBits &= 63;
        if (numBits === 0) {
            return this;
        } else {
            var high = this.high_;
            if (numBits < 32) {
                var low = this.low_;
                return Long.fromBits(
                    (low >>> numBits) | (high << (32 - numBits)),
                    high >>> numBits);
            } else if (numBits === 32) {
                return Long.fromBits(high, 0);
            } else {
                return Long.fromBits(high >>> (numBits - 32), 0);
            }
        }
    };

    /**************************************************************************************************************/

    return Long;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/CircleFinder',[],
    function () {

        /**************************************************************************************************************/

        var center, cosrad;

        var CircleFinder = function (point) {

            //CircleFinder.prototype.constructor.call(this, point);

            np = point.length;
            //HealpixUtils.check(np >= 3, "too few points");

            center = vec3.add2(point[0], point[1]);
            center = vec3.normalize2(center);
            cosrad = vec3.dot2(point[0], center);
            for (i = 2; i < np; ++i) {
                if (vec3.dot2(point[i], center) < cosrad) {
                    // point outside the current circle
                    this.getCircle(point, i);
                }
            }
        };

        /**************************************************************************************************************/

        CircleFinder.prototype.getCircle = function (point, q1, q2) {
            center = vec3.add2(point[q1], point[q2]);
            center = vec3.normalize2(center);
            cosrad = vec3.dot2(point[q1],center);
            for (i = 0; i < q1; ++i) {
                if (vec3.dot2(point[i], center) < cosrad) // point outside the current circle
                {
                    var subPoint = vec3.subtract2(point[q1], point[i]);
                    var subPoint2 = vec3.subtract2(point[q2], point[i]);
                    center = vec3.cross2(subPoint, subPoint2);
                    center = vec3.normalize2(center);
                    cosrad = vec3.dot2(point[q1],center);
                    if (cosrad < 0) {
                        center = vec3.flip(center);
                        cosrad = -cosrad;
                    }
                }
            }
        };

        /**************************************************************************************************************/

        CircleFinder.prototype.getCircle = function (point, q) {
            center = vec3.add2(point[0], point[q]);
            center = vec3.normalize2(center);
            cosrad = vec3.dot2(point[0], center);
            for (i = 1; i < q; ++i) {
                if (vec3.dot2(point[i], center) < cosrad) {
                    // point outside the current circle
                    this.getCircle(point, i, q);
                }
            }
        };

        /**************************************************************************************************************/

        CircleFinder.prototype.getCenter = function () {
            return center;
        };

        CircleFinder.prototype.getCosRad = function () {
            return cosrad;
        };

        return CircleFinder;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/HEALPixBase',['./HEALPixTables', '../Utils/Long', '../Utils/CircleFinder'],
 function (HealPixTables, Long, CircleFinder) {

    /**************************************************************************************************************/

    var HALF_PI = 3.14159265 / 2;

    var lonLat2ang = function (lon, lat) {
        if (lon < 0) {
            lon += 360;
        }

        var phi = lon * Math.PI / 180.0;

        var theta = ( -lat + 90.0 ) * Math.PI / 180.0;
        return [phi, theta];
    };

    /**************************************************************************************************************/

    /** Returns the remainder of the division {@code v1/v2}.
     The result is non-negative.
     @param v1 dividend; can be positive or negative
     @param v2 divisor; must be positive
     @return Remainder of the division; positive and smaller than {@code v2} */
    var fmodulo = function (v1, v2) {
        if (v1 >= 0.0) {
            return (v1 < v2) ? v1 : v1 % v2;
        }
        var tmp = v1 % v2 + v2;
        return (tmp === v2) ? 0.0 : tmp;
    };

    /**************************************************************************************************************/

    var spread_bits = function (v) {
        return (HealPixTables.utab[v & 0xff]) | ((HealPixTables.utab[(v >>> 8) & 0xff]) << 16)
            | ((HealPixTables.utab[(v >>> 16) & 0xff]) << 32) | ((HealPixTables.utab[(v >>> 24) & 0xff]) << 48);
    };

    /**************************************************************************************************************/

    var xyf2nest = function (ix, iy, face_num, order) {
        return ((face_num) << (2 * order)) +
            spread_bits(ix) + (spread_bits(iy) << 1);
    };

    /**************************************************************************************************************/

    var loc2pix = function (order, phi, theta) {
        var nside2 = Math.pow(2, order);
        var z = Math.cos(theta);
        //var phi = phi;

        var loc = {
            phi: phi,
            theta: theta,
            z: z
        };

        if (Math.abs(z) > (9.0 / 10.0)) {
            loc.sth = Math.sin(theta);
            loc.have_sth = true;
        }

        var inv_halfpi = 2.0 / Math.PI;
        var tt = fmodulo((phi * inv_halfpi), 4.0);// in [0,4)
        var jp,jm,nSideMinusOne;
        var za = Math.abs(z);
        if (za <= 2.0 / 3.0) // Equatorial region
        {
            var temp1 = nside2 * (0.5 + tt);
            var temp2 = nside2 * (z * 0.75);

            jp = Long.fromNumber(temp1 - temp2);
            jm = Long.fromNumber(temp1 + temp2);
            var ifp = jp.shiftRightUnsigned(order);
            var ifm = jm.shiftRightUnsigned(order);
            var face_num;
            if (ifp.equals(ifm)) {
                face_num = ifp.or(Long.fromInt(4));
            }
            else {
                if (ifp.lessThan(ifm)) {
                    face_num = ifp;
                }
                else {
                    face_num = ifm.add(Long.fromInt(8));
                }
            }

            nSideMinusOne = Long.fromNumber(nside2 - 1);
            var ix = jm.and(nSideMinusOne);
            var iy = nSideMinusOne.subtract(jp.and(nSideMinusOne));

            return xyf2nest(ix.toInt(), iy.toInt(), face_num.toInt(), order);

        }
        else // polar region, za > 2/3
        {
            var ntt = parseInt(Math.min(3, parseInt(tt, 10)), 10);
            var tp = tt - ntt;
            var tmp = ( (za < (9.0 / 10.0)) || (!loc.have_sth) ) ?
            nside2 * Math.sqrt(3 * (1 - za)) :
            nside2 * loc.sth / Math.sqrt((1.0 + za) / 3.0);

            jp = Long.fromNumber(tp * tmp);
            jm = Long.fromNumber((1.0 - tp) * tmp);
            var lNside = Long.fromNumber(nside2);
            nSideMinusOne = Long.fromNumber(nside2 - 1.0);
            var lOne = Long.fromInt(1);
            if (jp.greaterThanOrEqual(lNside)) {
                jp = nSideMinusOne;
            }
            if (jm.greaterThanOrEqual(lNside)) {
                jm = nSideMinusOne;
            }

            if (z >= 0) {
                return xyf2nest(lNside.subtract(jm).subtract(lOne).toInt(), lNside.subtract(jp).subtract(lOne).toInt(), ntt, order);
            }
            else {
                return xyf2nest(jp.toInt(), jm.toInt(), ntt + 8, order);
            }
        }
    };

    var pstack = function (sz) {
        this.p = new Array(sz);
        this.o = new Array(sz);

        for (var i = 0; i < this.p.length; i++) {
            //this.p[i] = Long.fromInt(0);
            this.p[i] = 0;
            this.o[i] = 0;
        }

        this.s = this.m = 0;
    };

    pstack.prototype.push = function (p_, o_) {
        this.p[this.s] = p_;
        this.o[this.s] = o_;
        ++this.s;
    };

    pstack.prototype.otop = function () {
        return this.o[this.s - 1];
    };

    pstack.prototype.ptop = function () {
        return this.p[this.s - 1];
    };

    pstack.prototype.pop = function () {
        this.s--;
    };

    pstack.prototype.popToMark = function () {
        this.s = this.m;
    };

    pstack.prototype.mark = function () {
        this.m = this.s;
    };

    pstack.prototype.size = function () {
        return this.s;
    };

    /**************************************************************************************************************/

    var HEALPixBase = {

        init: function (options) {

            this.order_max = 29;
            this.bn = [];
            this.nside = null;

            try {
                for (var i = 0; i <= this.order_max; ++i) {
                    this.bn[i] = this.createBoundaries(1.0 << i, "NESTED");
                }
            }
            catch (ex) {/*doesn't happen*/
            }
        },

        createBoundaries: function (nside_in, scheme_in) {
            this.nside = nside_in - 1;
            return this.calculateBoundaries(nside_in, scheme_in);
        },

        compress_bits: function (v) {

            var longV = Long.fromNumber(v);
            var longMask = Long.fromNumber(0x5555555555555);
            var raw = longV.and(longMask);
            var dec = raw.shiftRightUnsigned(15);
            raw = raw.or(dec);
            var raw1 = (raw.and(Long.fromNumber(0xffff))).toInt();
            var dec2 = raw.shiftRightUnsigned(32);
            var raw2 = (dec2.and(Long.fromNumber(0xffff))).toInt();


            return HealPixTables.ctab[raw1 & 0xff] | (HealPixTables.ctab[raw1 >>> 8] << 4)
                | (HealPixTables.ctab[raw2 & 0xff] << 16) | (HealPixTables.ctab[raw2 >>> 8] << 20);
        },

        /**
         *    Function describing a location on the sphere
         */
        fxyf: function (_fx, _fy, _face) {
            var jr = HealPixTables.jrll[_face] - _fx - _fy;
            var z = 0;
            var phi = 0;
            var sth = 0;
            var have_sth = false;

            var nr,tmp;
            if (jr < 1) {
                nr = jr;
                tmp = nr * nr / 3.0;
                z = 1 - tmp;
                if (z > 0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else if (jr > 3) {
                nr = 4 - jr;
                tmp = nr * nr / 3.0;
                z = tmp - 1;
                if (z < -0.99) {
                    sth = Math.sqrt(tmp * (2.0 - tmp));
                    have_sth = true;
                }
            } else {
                nr = 1;
                z = (2 - jr) * 2.0 / 3.0;
            }

             tmp = HealPixTables.jpll[_face] * nr + _fx - _fy;
            if (tmp < 0) {
              tmp += 8;
            }
            if (tmp >= 8) {
              tmp -= 8;
            }

            phi = (nr < 1e-15) ? 0 : (0.5 * HALF_PI * tmp) / nr;

            var st = (have_sth) ? sth : Math.sqrt((1.0 - z) * (1.0 + z));
            return [st * Math.cos(phi), st * Math.sin(phi), z];
        },

        /** Returns the maximum angular distance between a pixel center and its
         corners.
         @return number angular distance between a pixel center and its
         corners. */
        maxPixrad: function (order, nl4) {
            var nside2 = Math.pow(2, order);
            var va = vec3.createZPhi(2.0 / 3.0, Math.PI / nl4);
            var t1 = 1.0 - 1.0 / nside2;
            t1 *= t1;
            var vb = vec3.createZPhi(1 - t1 / 3, 0);
            return vec3.angle2(va, vb);
        },

        pix2vec: function (pix, boundaries) {
            var loc = this.pix2loc(pix, boundaries);
            var st = loc.have_sth ? loc.sth : Math.sqrt((1.0 - loc.z) * (1.0 + loc.z));
            return vec3.createFrom(st * Math.cos(loc.phi), st * Math.sin(loc.phi), loc.z);
        },

        pix2loc: function (pix, boundaries) {
            var z, phi, sth, have_sth;

            //var fact2 = 4.0 / pix;
            //var fact1 = (nside << 1) * fact2;
            //var nl2 = 2 * nside;
            //var nl3 = 3 * nside;
            //var nl4 = 4 * nside;
            //var npface = nside * nside;
            //var ncap = 2 * nside * (nside - 1); // pixels in each polar cap
            //var npix = 12 * npface;
            //var fact2 = 4.0 / npix;
            //var fact1 = (nside << 1) * fact2;

            var loc = {
                phi: null,
                sth: 0.0,
                have_sth: false,
                z: null
            };

            var xyf = this.nest2xyf(pix, boundaries.npface, boundaries.order);

            var jr = (HealPixTables.jrll[xyf.face] << boundaries.order) - xyf.ix - xyf.iy - 1;

            var nr,tmp;
            if (jr < boundaries.nside) {
                nr = jr;
                tmp = (nr * nr) * boundaries.fact2;
                loc.z = 1 - tmp;
                if (loc.z > 0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            }
            else if (jr > boundaries.nl3) {
                nr = boundaries.nl4 - jr;
                tmp = (nr * nr) * boundaries.fact2;
                loc.z = tmp - 1;
                if (loc.z < -0.99) {
                    loc.sth = Math.sqrt(tmp * (2.0 - tmp));
                    loc.have_sth = true;
                }
            }
            else {
                nr = boundaries.nside;
                loc.z = (boundaries.nl2 - jr) * boundaries.fact1;
            }

            tmp = HealPixTables.jpll[xyf.face] * nr + xyf.ix - xyf.iy;
            //assert (tmp < 8 * nr); // must not happen

            if (tmp < 0) {
                tmp += 8 * nr;
            }

            loc.phi = (nr === boundaries.nside) ? 0.75 * HALF_PI * tmp * boundaries.fact1 : (0.5 * HALF_PI * tmp) / nr;
            return loc;
        },

        nest2xyf : function (ipix, npface, order) {
            var pix = ipix & (npface - 1);

            var ix = HEALPixBase.compress_bits(pix);
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            var face = ipix >>> (2 * order);

            return {
                ix : ix,
                iy : iy,
                face : face
            };
        },

        /**
         *    Static function
         *    Convert nside to order
         *    (ilog2(nside))
         */
        nside2order: function (arg) {
            var res = 0;
            while (arg > 0x0000FFFF) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000FF) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000F) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },


        calculateBoundaries: function (nside_in, scheme_in) {

            if (this.nside === nside_in) {
                return;
            }
            this.nside = nside_in;

            var order = this.nside2order(nside_in);

            if (scheme_in === "NESTED" && order < 0) {
                throw new Exception("Nside must be a power of 2 for NESTED scheme");
            }

            var nl2 = 2 * this.nside;
            var nl3 = 3 * this.nside;
            var nl4 = 4 * this.nside;
            var npface = this.nside * this.nside;
            var ncap = 2 * this.nside * (this.nside - 1); // pixels in each polar cap
            var npix = 12 * npface;
            var fact2 = 4.0 / npix;
            var fact1 = (this.nside << 1) * fact2;

            return {
                order: order,
                nside: this.nside,
                scheme: scheme_in,
                nl2: nl2,
                nl3: nl3,
                nl4: nl4,
                npface: npface,
                ncap: ncap,
                npix: npix,
                fact1: fact1,
                fact2: fact2
            };
        },

        // MATH lib from Java Astro lib

        convertPolygonToHealpixOrder: function (coordinates, fact, order) {

            var vertex = [];
            var factor = fact || 4;
            var healpixOrder = order || 5;

            _.each(coordinates, function (point) {

                var cPr = Math.PI / 180;

                var cd = Math.cos(point[1] * cPr);
                var x = Math.cos(point[0] * cPr) * cd;
                var y = Math.sin(point[0] * cPr) * cd;
                var z = Math.sin(point[1] * cPr);

                var theta = Math.atan2(Math.sqrt(x * x + y * y), z);
                var phi = Math.atan2(y, x);
                if (phi < 0.0) {
                    phi += 2 * Math.PI;
                }
                if (phi >= 2 * Math.PI) {
                    phi -= 2 * Math.PI;
                }

                vertex.push({
                    "theta": theta,
                    "phi": phi
                });
            });

            return this.queryPolygonInclusive(vertex, factor, healpixOrder);
        },

        queryPolygonInclusive: function (vertex, fact, healpixOrder) {

            Math.PI = 3.14159265358979323846;
            var halfpi = Math.PI / 2.0;

            var inclusive = (fact !== 0);
            var nv = vertex.length;
            var ncirc = inclusive ? nv + 1 : nv;

            if (nv < 3) {
                console.error("not enough vertices in polygon");
                return;
            }

            var vv = new Array(nv);
            var i;
            for (i = 0; i < nv; ++i) {
                vv[i] = vec3.createPhiTheta(vertex[i].phi, vertex[i].theta);
            }

            var normal = new Array(ncirc);
            var flip = 0;

            for (i = 0; i < nv; ++i) {
                normal[i] = vec3.cross2(vv[i], vv[(i + 1) % nv]);

                //var hnd = normal[i].dot(vv[(i + 2) % nv]);
                var hnd = vec3.dot2(normal[i], vv[(i + 2) % nv]);

                if (i === 0) {
                    flip = (hnd < 0.0) ? -1 : 1;
                }

                normal[i] = vec3.scale2(normal[i], flip / vec3.length2(normal[i]));
            }

            var rad = new Array(ncirc);
            this.fill(rad, halfpi);


            if (inclusive) {
                var cf = new CircleFinder(vv);

                normal[nv] = cf.getCenter();
                rad[nv] = Math.acos(cf.getCosRad());
            }

            var res = this.queryMultiDisc(normal, rad, fact, healpixOrder);
            console.dir(res);
            return res;
        },

        fill: function (a, val) {
            for (var i = 0, len = a.length; i < len; i++) {
                a[i] = val;
            }
        },

        queryMultiDisc: function (norm, rad, fact, healpixOrder) {
            var order = healpixOrder;
            var inclusive = (fact !== 0);
            var nv = norm.length;
            //HealpixUtils.check(nv == rad.length, "inconsistent input arrays");
            var res = [];

            var oplus = 0;
            if (inclusive) {
                //HealpixUtils.check((1L << (order_max - order)) >= fact, "invalid oversampling factor");
                //HealpixUtils.check((fact & (fact - 1)) == 0, "oversampling factor must be a power of 2");
                oplus = this.ilog2(fact);
            }
            var omax = order + oplus; // the order up to which we test
            var currentBoundaries;

            // TODO: ignore all disks with radius>=pi

            // building 3 dimensions array
            var crlimit = new Array(omax + 1);
            for (var i = 0; i < omax + 1; i++) {
                crlimit[i] = new Array(nv);
                for (var j = 0; j < nv; j++) {
                    crlimit[i][j] = new Array(3);
                }
            }

            var options = {
                order: order
            };
            HEALPixBase.init(options); // set variables nl2, nl3, npix, nface...
            var o;
            for (o = 0; o <= omax; ++o) // prepare data at the required orders
            {

                currentBoundaries = HEALPixBase.bn[o];
                var dr = HEALPixBase.maxPixrad(o, currentBoundaries.nl4); // safety distance

                for (i = 0; i < nv; ++i) {
                    crlimit[o][i][0] = (rad[i] + dr > Math.PI) ? -1 : Math.cos(rad[i] + dr);
                    crlimit[o][i][1] = (o === 0) ? Math.cos(rad[i]) : crlimit[0][i][1];
                    crlimit[o][i][2] = (rad[i] - dr < 0.0) ? 1.0 : Math.cos(rad[i] - dr);
                }
            }

            var stk = new pstack(12 + 3 * omax);
            for (i = 0; i < 12; i++) {// insert the 12 base pixels in reverse order
                stk.push(11 - i, 0);
            }

            while (stk.size() > 0) { // as long as there are pixels on the stack
                // pop current pixel number and order from the stack
                var pix = stk.ptop();
                o = stk.otop();
                stk.pop();

                currentBoundaries = HEALPixBase.bn[o];

                var pv = HEALPixBase.pix2vec(pix, currentBoundaries);

                var zone = 3;
                for (i = 0; (i < nv) && (zone > 0); ++i) {
                    var crad = vec3.dot2(pv, norm[i]);

                    for (var iz = 0; iz < zone; ++iz) {
                        if (crad < crlimit[o][i][iz]) {
                            zone = iz;
                            //console.log("zone :" + zone + " pix:" + pix + " crad:" + crad);
                        }
                    }
                }

                if (zone > 0) {
                    this.check_pixel(o, omax, zone, res, pix, stk, inclusive, healpixOrder);
                }
            }
            return res;
        },


        check_pixel: function (o, omax, zone, pixset, pix, stk, inclusive, healpixOrder) {
            var order = healpixOrder;
            var i;
            if (zone === 0) {
                return;
            }

            if (o < order) {
                if (zone >= 3) // output all subpixels
                {
                    var sdist = 2 * (order - o); // the "bit-shift distance" between map orders
                    var start = pix << sdist;
                    var end = ((pix + 1) << sdist);
                    for (i = start; i <= end; i++) {
                        pixset.push(i);
                    }
                } else {
                    // (zone>=1)
                    for (i = 0; i < 4; ++i) {
                        stk.push(4 * pix + 3 - i, o + 1); // add children
                    }
                }
            }
            else if (o > order) // this implies that inclusive==true
            {
                if (zone >= 2) // pixel center in shape
                {
                    pixset.push(pix >>> (2 * (o - order))); // output the parent pixel at order
                    stk.popToMark(); // unwind the stack
                }
                else // (zone>=1): pixel center in safety range
                {
                    if (o < omax) // check sublevels
                    {
                        for (i = 0; i < 4; ++i) { // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix >>> (2 * (o - order)));// output the parent pixel at order
                        stk.popToMark(); // unwind the stack
                    }
                }
            }
            else // o==order
            {
                if (zone >= 2) {
                    pixset.push(pix);
                }
                else if (inclusive) // and (zone>=1)
                {
                    if (order < omax) // check sublevels
                    {
                        stk.mark(); // remember current stack position
                        for (i = 0; i < 4; ++i) { // add children in reverse order
                            stk.push(4 * pix + 3 - i, o + 1); // add children
                        }
                    } else {
                        // at resolution limit
                        pixset.push(pix); // output the pixel
                    }
                }
            }
        },

        ilog2: function (arg) {
            var res = 0;
            while (arg > 0x0000FFFF) {
                res += 16;
                arg >>>= 16;
            }
            if (arg > 0x000000FF) {
                res |= 8;
                arg >>>= 8;
            }
            if (arg > 0x0000000F) {
                res |= 4;
                arg >>>= 4;
            }
            if (arg > 0x00000003) {
                res |= 2;
                arg >>>= 2;
            }
            if (arg > 0x00000001) {
                res |= 1;
            }
            return res;
        },
        /**
         *    Returns pixel index of point on sphere
         *
         *    @param order Tile order
         *    @param lon Longitude
         *    @param lat Latitude
         */
        lonLat2pix: function (order, lon, lat) {
            var loc = lonLat2ang(lon, lat);
            return loc2pix(order, loc[0], loc[1]);
        },

        /**
         Create the children of the given pixel
         */
        getChildren: function (npix) {
            return [npix * 4, npix * 4 + 1, npix * 4 + 2, npix * 4 + 3];
        },

        uniq2hpix: function (uniq, hpix) {
            if (hpix === null) {
                hpix = [];
            }
            hpix[0] = HEALPixBase.log2(uniq / 4) / 2;
            var nside = HEALPixBase.pow2(hpix[0]);
            hpix[1] = uniq - 4 * nside * nside;
            hpix[0] = parseInt(hpix[0], 10);
            return hpix;
        },

        log2: function (nside) {
            var i = 0;
            while ((nside >>> (++i)) > 0) {
              // nop
            }
            return --i;
        },

        pow2: function (order) {
            return 1 << order;
        },

        /**
         * calculates angular resolution of the pixel map in arc seconds.
         *
         * @param nside
         * @return double resolution in arcsec
         */
        getPixRes: function(nside) {
            var rad2arcsec=180.0*60.0*60.0/Math.PI;
            return rad2arcsec*Math.sqrt(4*Math.PI/(12*nside*nside));
        }
    };

    /**************************************************************************************************************/

    return HEALPixBase;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Utils/UtilsIntersection',["./Numeric", "../Tiling/HEALPixBase"], function (Numeric, HEALPixBase) {

    var UtilsIntersection = {};


    UtilsIntersection.convertPolygonToHealpixOrder = function (coordinates, fact, order) {
          return HEALPixBase.convertPolygonToHealpixOrder(coordinates, fact, order);
    };

    /**
     * Check if a point lies on a line
     * @param point
     * @param segmentStart
     * @param segmentEnd
     * @returns {boolean}
     */
    UtilsIntersection.pointInLine = function (point, segmentStart, segmentEnd) {
        var deltax = segmentEnd[0] - segmentStart[0];
        var deltay, t;
        var liesInXDir = false;

        if (deltax === 0) {
            liesInXDir = (point[0] === segmentStart[0]);
        } else {
            t = (point[0] - segmentStart[0]) / deltax;
            liesInXDir = (t >= 0 && t <= 1);
        }

        if (liesInXDir) {
            deltay = segmentEnd[1] - segmentStart[1];
            if (deltax === 0) {
                return (point[1] === segmentStart[1]);
            } else {
                t = (point[1] - segmentStart[1]) / deltay;
                return (t >= 0 && t <= 1);
            }
        } else {
            return false;
        }
    };

    /**
     *    Determine if a point lies inside a sphere of radius depending on viewport
     */
    UtilsIntersection.pointInSphere = function (ctx, point, sphere, pointTextureHeight) {
        var point3D = [];
        var sphere3D = [];

        // Compute pixel size vector to offset the points from the earth
        var pixelSizeVector = ctx.getRenderContext().computePixelSizeVector();

        ctx.getCoordinateSystem().get3DFromWorld(point, point3D);
        ctx.getCoordinateSystem().get3DFromWorld(sphere, sphere3D);

        var radius = pointTextureHeight * (pixelSizeVector[0] * sphere3D[0] + pixelSizeVector[1] * sphere3D[1] + pixelSizeVector[2] * sphere3D[2] + pixelSizeVector[3]);

        //Calculate the squared distance from the point to the center of the sphere
        var vecDist = [];
        vec3.subtract(point3D, sphere3D, vecDist);
        vecDist = vec3.dot(vecDist, vecDist);

        //Calculate if the squared distance between the sphere's center and the point
        //is less than the squared radius of the sphere
        if (vecDist < radius * radius) {
            return true;
        }

        //If not, return false
        return false;
    };

    /**
     * Convert spherical coordinate to cartesian
     */
    function to3D(pt) {
        var lon = pt[0] * Math.PI / 180;
        var lat = pt[1] * Math.PI / 180;
        var x = Math.cos(lat) * Math.cos(lon);
        var y = Math.cos(lat) * Math.sin(lon);
        var z = Math.sin(lat);
        return [x,y,z];
    }

    function greatArcIntersection (a0,a1,b0,b1) {
        var p = vec3.cross(a0,a1,[]);
        var q = vec3.cross(b0,b1,[]);
        var t = vec3.normalize(vec3.cross(p,q,[]));

        var s1 = vec3.dot(vec3.cross(a0,p,[]),t);
        var s2 = vec3.dot(vec3.cross(a1,p,[]),t);
        var s3 = vec3.dot(vec3.cross(b0,q,[]),t);
        var s4 = vec3.dot(vec3.cross(b1,q,[]),t);

        var st =  Numeric.sign(-s1) + Numeric.sign(s2) + Numeric.sign(-s3) + Numeric.sign(s4);
        return Math.abs(st) === 4;
    }

    /**
     * Point in ring with spherical geometry
     */
    UtilsIntersection.pointInRing = function (point, ring) {
        var nvert = ring.length;
        var nbinter = 0;

        var p0 = to3D(point);
        var p1 = to3D([point[0],point[1]+90]);

        for (var i = 0; i < nvert-1; i++) {
            if (greatArcIntersection(to3D(ring[i]),to3D(ring[i+1]),p0,p1)) {
                nbinter++;
            }
        }
        return (nbinter % 2) === 1;
    };

    return UtilsIntersection;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/FeatureStyle',[],function () {


// Simple colors
    var simple_colors = {
        aliceblue: 'f0f8ff',
        antiquewhite: 'faebd7',
        aqua: '00ffff',
        aquamarine: '7fffd4',
        azure: 'f0ffff',
        beige: 'f5f5dc',
        bisque: 'ffe4c4',
        black: '000000',
        blanchedalmond: 'ffebcd',
        blue: '0000ff',
        blueviolet: '8a2be2',
        brown: 'a52a2a',
        burlywood: 'deb887',
        cadetblue: '5f9ea0',
        chartreuse: '7fff00',
        chocolate: 'd2691e',
        coral: 'ff7f50',
        cornflowerblue: '6495ed',
        cornsilk: 'fff8dc',
        crimson: 'dc143c',
        cyan: '00ffff',
        darkblue: '00008b',
        darkcyan: '008b8b',
        darkgoldenrod: 'b8860b',
        darkgray: 'a9a9a9',
        darkgreen: '006400',
        darkkhaki: 'bdb76b',
        darkmagenta: '8b008b',
        darkolivegreen: '556b2f',
        darkorange: 'ff8c00',
        darkorchid: '9932cc',
        darkred: '8b0000',
        darksalmon: 'e9967a',
        darkseagreen: '8fbc8f',
        darkslateblue: '483d8b',
        darkslategray: '2f4f4f',
        darkturquoise: '00ced1',
        darkviolet: '9400d3',
        deeppink: 'ff1493',
        deepskyblue: '00bfff',
        dimgray: '696969',
        dodgerblue: '1e90ff',
        feldspar: 'd19275',
        firebrick: 'b22222',
        floralwhite: 'fffaf0',
        forestgreen: '228b22',
        fuchsia: 'ff00ff',
        gainsboro: 'dcdcdc',
        ghostwhite: 'f8f8ff',
        gold: 'ffd700',
        goldenrod: 'daa520',
        gray: '808080',
        green: '008000',
        greenyellow: 'adff2f',
        honeydew: 'f0fff0',
        hotpink: 'ff69b4',
        indianred: 'cd5c5c',
        indigo: '4b0082',
        ivory: 'fffff0',
        khaki: 'f0e68c',
        lavender: 'e6e6fa',
        lavenderblush: 'fff0f5',
        lawngreen: '7cfc00',
        lemonchiffon: 'fffacd',
        lightblue: 'add8e6',
        lightcoral: 'f08080',
        lightcyan: 'e0ffff',
        lightgoldenrodyellow: 'fafad2',
        lightgrey: 'd3d3d3',
        lightgreen: '90ee90',
        lightpink: 'ffb6c1',
        lightsalmon: 'ffa07a',
        lightseagreen: '20b2aa',
        lightskyblue: '87cefa',
        lightslateblue: '8470ff',
        lightslategray: '778899',
        lightsteelblue: 'b0c4de',
        lightyellow: 'ffffe0',
        lime: '00ff00',
        limegreen: '32cd32',
        linen: 'faf0e6',
        magenta: 'ff00ff',
        maroon: '800000',
        mediumaquamarine: '66cdaa',
        mediumblue: '0000cd',
        mediumorchid: 'ba55d3',
        mediumpurple: '9370d8',
        mediumseagreen: '3cb371',
        mediumslateblue: '7b68ee',
        mediumspringgreen: '00fa9a',
        mediumturquoise: '48d1cc',
        mediumvioletred: 'c71585',
        midnightblue: '191970',
        mintcream: 'f5fffa',
        mistyrose: 'ffe4e1',
        moccasin: 'ffe4b5',
        navajowhite: 'ffdead',
        navy: '000080',
        oldlace: 'fdf5e6',
        olive: '808000',
        olivedrab: '6b8e23',
        orange: 'ffa500',
        orangered: 'ff4500',
        orchid: 'da70d6',
        palegoldenrod: 'eee8aa',
        palegreen: '98fb98',
        paleturquoise: 'afeeee',
        palevioletred: 'd87093',
        papayawhip: 'ffefd5',
        peachpuff: 'ffdab9',
        peru: 'cd853f',
        pink: 'ffc0cb',
        plum: 'dda0dd',
        powderblue: 'b0e0e6',
        purple: '800080',
        red: 'ff0000',
        rosybrown: 'bc8f8f',
        royalblue: '4169e1',
        saddlebrown: '8b4513',
        salmon: 'fa8072',
        sandybrown: 'f4a460',
        seagreen: '2e8b57',
        seashell: 'fff5ee',
        sienna: 'a0522d',
        silver: 'c0c0c0',
        skyblue: '87ceeb',
        slateblue: '6a5acd',
        slategray: '708090',
        snow: 'fffafa',
        springgreen: '00ff7f',
        steelblue: '4682b4',
        tan: 'd2b48c',
        teal: '008080',
        thistle: 'd8bfd8',
        tomato: 'ff6347',
        turquoise: '40e0d0',
        violet: 'ee82ee',
        violetred: 'd02090',
        wheat: 'f5deb3',
        white: 'ffffff',
        whitesmoke: 'f5f5f5',
        yellow: 'ffff00',
        yellowgreen: '9acd32'
    };

    var parseHex = /^(\w{2})(\w{2})(\w{2})$/;
    var parseRgb = /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/;
    var parseRgba = /^rgba\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3},\s*(\d{1,3}))\)$/;

    /**************************************************************************************************************/

    /**
     @name FeatureStyle
     @class
         The style to display a Feature
     @param {JSON} style an object containing the following style properties
     <ul>
     <li>strokeColor : the color for line, or polygon outline</li>
     <li>strokeWidth : the width of a line</li>
     <li>fillColor : the color for solid polygon or point</li>
     <li>fillTextureUrl : the texture for solid polygon</li>
     <li>iconUrl : the icon to be used for point</li>
     <li>pointMaxSize : Distance maximum (in meter) from the ground to the camera for which a point is displayed</li>
     <li>extrusionScale : extrusion scale (in meter)</li>
     </ul>
     @constructor
     */
    var FeatureStyle = function (style) {
        // Color used for lines or polygon outline
        this.strokeColor = [1.0, 0.0, 0.0, 1.0];
        // Color used to full polygon
        this.fillColor = [1.0, 0.0, 0.0, 1.0];
        this.fillTextureUrl = null;
        this.fillTexture = null;
        this.fillShader = null;
        this.strokeWidth = 1;
        this.iconUrl = null;
        this.icon = null;
        this.label = null;
        this.textColor = [1.0, 1.0, 1.0, 1.0];
        this.fill = false;
        this.pointMaxSize = 40;
        this.opacity = 1.0;
        this.zIndex = 0;
        this.extrusionScale = 1.0;

        if (style) {
            for (var s in style) {
                if((style.hasOwnProperty(s))) {
                    this[s] = style[s];
                }
            }
        }
    };

    /**
     Convert a color from a string to RGB
     @function fromStringToColor
     @memberof FeatureStyle
     @param {String} color_string Color string
     @return {float[]} array with [r,g,b,alpha]
     */
    FeatureStyle.fromStringToColor = function (color_string) {
        var r = 0, g = 0, b = 0, a = 255;
        var match;

        color_string = color_string.trim();
        color_string = color_string.toLowerCase();
        // strip any leading #
        if (color_string.charAt(0) === '#') { // remove # if any
            color_string = color_string.substr(1, 6);
        }

        // Convert a litteral color to rgb string
        if (simple_colors.hasOwnProperty(color_string)) {
            color_string = simple_colors[color_string];
        }

        match = parseHex.exec(color_string);
        if (match) {
            r = parseInt(match[1], 16);
            g = parseInt(match[2], 16);
            b = parseInt(match[3], 16);
        }

        match = parseRgb.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
        }

        match = parseRgba.exec(color_string);
        if (match) {
            r = parseInt(match[1], 10);
            g = parseInt(match[2], 10);
            b = parseInt(match[3], 10);
            a = parseInt(match[4], 10);
        }

        // validate/cleanup values
        r = (r < 0) ? 0 : ((r > 255) ? 255 : r);
        g = (g < 0) ? 0 : ((g > 255) ? 255 : g);
        b = (b < 0) ? 0 : ((b > 255) ? 255 : b);
        a = (a < 0) ? 0 : ((a > 255) ? 255 : a);

        return [r / 255.0, g / 255.0, b / 255.0, a / 255.0];
    };

    /**************************************************************************************************************/

    /**
     Convert an internal color to a string based color representation
     @function fromColorToString
     @memberof FeatureStyle
     @param {float[]} color array with [r,g,b]
     @return {String}Color string
     */
    FeatureStyle.fromColorToString = function (color) {
        var hashColor = '#';
        for (var i = 0; i < 3; i++) {
            var component = parseInt(color[i] * 255.0, 10).toString(16);
            hashColor += (component < 10) ? '0' + component : component;
        }

        return hashColor;
    };

    /**
     * Get extrusion scale
     * @function getExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @return {float} Extrusion scale
     */
    FeatureStyle.prototype.getExtrusionScale = function () {
        return this.extrusionScale;
    };

    /**
     * Set extrusion scale
     * @function setExtrusionScale
     * @memberof FeatureStyle.prototype
     *
     * @param {float} value Extrusion scale
     */
    FeatureStyle.prototype.setExtrusionScale = function (value) {
        this.extrusionScale = value;
    };

    /**************************************************************************************************************/

    return FeatureStyle;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Utils/UtilityFactory',["./Constants","./UtilsFits", "./Numeric", "./UtilsIntersection", "../Renderer/FeatureStyle"],
    function(Constants, UtilsFits, Numeric, UtilsIntersection, FeatureStyle) {
    
    return {
        
        create : function(type, options) {
            var obj;
            switch (type) {
                case Constants.UTILITY.Fits:
                    obj = UtilsFits;
                    break;
                case Constants.UTILITY.Intersection:
                    obj = UtilsIntersection;
                    break;
                case Constants.UTILITY.Numeric:
                    obj = Numeric;
                    break;
                case Constants.UTILITY.CreateStyle:
                    obj = new FeatureStyle(options);
                    break;
                case Constants.UTILITY.FeatureStyle:
                    obj = FeatureStyle;
                    break;
                default:
                    throw new RangeError("Cannot create the utility "+type, "UtilityFactory.js");
            }
            return obj;
        }
        
    }
    
});

var xmlToJSON = function () { this.version = "1.3.5"; var e = { mergeCDATA: !0, grokAttr: !0, grokText: !0, normalize: !0, xmlns: !0, namespaceKey: "_ns", textKey: "_text", valueKey: "_value", attrKey: "_attr", cdataKey: "_cdata", attrsAsObject: !0, stripAttrPrefix: !0, stripElemPrefix: !0, childrenAsArray: !0 }, t = new RegExp(/(?!xmlns)^.*:/), r = new RegExp(/^\s+|\s+$/g); return this.grokType = function (e) { return /^\s*$/.test(e) ? null : /^(?:true|false)$/i.test(e) ? "true" === e.toLowerCase() : isFinite(e) ? parseFloat(e) : e }, this.parseString = function (e, t) { return this.parseXML(this.stringToXML(e), t) }, this.parseXML = function (a, n) { for (var s in n) e[s] = n[s]; var l = {}, i = 0, o = ""; if (e.xmlns && a.namespaceURI && (l[e.namespaceKey] = a.namespaceURI), a.attributes && a.attributes.length > 0) { var c = {}; for (i; i < a.attributes.length; i++) { var u = a.attributes.item(i); m = {}; var p = ""; p = e.stripAttrPrefix ? u.name.replace(t, "") : u.name, e.grokAttr ? m[e.valueKey] = this.grokType(u.value.replace(r, "")) : m[e.valueKey] = u.value.replace(r, ""), e.xmlns && u.namespaceURI && (m[e.namespaceKey] = u.namespaceURI), e.attrsAsObject ? c[p] = m : l[e.attrKey + p] = m } e.attrsAsObject && (l[e.attrKey] = c) } if (a.hasChildNodes()) for (var y, d, m, h = 0; h < a.childNodes.length; h++)4 === (y = a.childNodes.item(h)).nodeType ? e.mergeCDATA ? o += y.nodeValue : l.hasOwnProperty(e.cdataKey) ? (l[e.cdataKey].constructor !== Array && (l[e.cdataKey] = [l[e.cdataKey]]), l[e.cdataKey].push(y.nodeValue)) : e.childrenAsArray ? (l[e.cdataKey] = [], l[e.cdataKey].push(y.nodeValue)) : l[e.cdataKey] = y.nodeValue : 3 === y.nodeType ? o += y.nodeValue : 1 === y.nodeType && (0 === i && (l = {}), d = e.stripElemPrefix ? y.nodeName.replace(t, "") : y.nodeName, m = xmlToJSON.parseXML(y), l.hasOwnProperty(d) ? (l[d].constructor !== Array && (l[d] = [l[d]]), l[d].push(m)) : (e.childrenAsArray ? (l[d] = [], l[d].push(m)) : l[d] = m, i++)); else o || (e.childrenAsArray ? (l[e.textKey] = [], l[e.textKey].push(null)) : l[e.textKey] = null); if (o) if (e.grokText) { var x = this.grokType(o.replace(r, "")); null !== x && void 0 !== x && (l[e.textKey] = x) } else e.normalize ? l[e.textKey] = o.replace(r, "").replace(/\s+/g, " ") : l[e.textKey] = o.replace(r, ""); return l }, this.xmlToString = function (e) { try { return e.xml ? e.xml : (new XMLSerializer).serializeToString(e) } catch (e) { return null } }, this.stringToXML = function (e) { try { var t = null; return window.DOMParser ? t = (new DOMParser).parseFromString(e, "text/xml") : (t = new ActiveXObject("Microsoft.XMLDOM"), t.async = !1, t.loadXML(e), t) } catch (e) { return null } }, this }.call({}); "undefined" != typeof module && null !== module && module.exports ? module.exports = xmlToJSON : "function" == typeof define && define.amd && define('xmltojson',[],function () { return xmlToJSON });
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/AbstractLayer',["jquery","underscore-min", "../Utils/Event", "../Utils/Utils", "../Utils/Constants", "../Utils/UtilityFactory","xmltojson"],
    function ($,_, Event, Utils, Constants, UtilityFactory,XmlToJson) {

        /**
         * AbstactLayer configuration
         * @typedef {Object} AbstractLayer.configuration
         * @property {String} [name=""] - Layer name
         * @property {String} [attribution=""] - Attribution
         * @property {String} [copyrightUrl=""] - Copyright URL
         * @property {String} [ack=""] - ack
         * @property {String} [icon=a default image] - An icon to represent the layer
         * @property {String} [description=""] - A description
         * @property {boolean} [visible=true] - A boolean flag to display the layer
         * @property {Object} [properties={}] properties
         * @property {boolean} [pickable=false] - Sets to true to make the layer pickable
         * @property {boolean} [service=[]] - List of services related to the layer
         * @property {GEOMETRY} dataType - the data type for vector layers
         * @property background
         * @property category
         * @param {Crs} coordinateSystem
         * @param {string} [format=""]
         * @param {string} [baseUrl=""]
         * @param {boolean} [deletable=""]
         * @param {Array} [color= a random color]
         * @param {float} [opacity=1.0] - An opacity value
         * @param {FeatureStyle} [style]
         * @param {Array} [availableServices=[]}
         * @param {layerCallback} callback - A callback that transfoms data.
         */

        /**
         * This callback allows to transform FeatureCollection from a GeoJson.
         * @callback layerCallback
         * @param {data} FeatureCollection
         */

        /**
         * @name AbstractLayer
         * @class
         *   Abstract class for creating layer.
         * @augments Event
         * @param {LAYER} type - layer type
         * @param {AbstractLayer.configuration} options - Layer Configuration
         * @constructor
         * @implements {Layer}
         */
        var AbstractLayer = function (type, options) {
            Event.prototype.constructor.call(this, options);

            this.globe = null;
            this.options = options || {};
            this.ID = "URN:Mizar:Layer:"+_.uniqueId(this.constructor.name + ':');
            this.name = this.options.hasOwnProperty('name') ? this.options.name : "";
            this.attribution = this.options.hasOwnProperty('attribution') ? this.options.attribution : "";
            this.copyrightUrl = this.options.hasOwnProperty('copyrightUrl') ? this.options.copyrightUrl : "";
            this.ack = this.options.hasOwnProperty('ack') ? this.options.ack : "";
            this.icon = this.options.hasOwnProperty('icon') ? this.options.icon : "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAoAAAAKCAYAAACNMs+9AAAAAXNSR0IArs4c6QAAAAZiS0dEAAAAAAAA+UO7fwAAAAlwSFlzAAALEwAACxMBAJqcGAAAAAd0SU1FB9wMBQkVBRMIQtMAAAAZdEVYdENvbW1lbnQAQ3JlYXRlZCB3aXRoIEdJTVBXgQ4XAAAAvklEQVQY012QMWpCURBFz3yfG7CIwSatpLGwsJJsQEHssr2UttapkkK0zRJEFPKLj5UYPGme8vgDt5l7uNwZKEYNdaZO1FR6VQkBT8AbMAGe1e7dTwXUB8bAFPgF9sBWPUXENbWgBTAELkCTw7bqMdR5kTQCehlogB/gE/iqcs9OVhT9I8v7EZU6UJfqh3pWa3WlvqsvakoRcVOPwCYnvQI1sM67Q0T8JYAWvAEOwDewj4jr4z0teJdf84AA/gF1uG92uhcfoAAAAABJRU5ErkJggg==";
            this.description = this.options.hasOwnProperty('description') ? this.options.description : "";
            this.visible = this.options.hasOwnProperty('visible') ? this.options.visible : false;
            this.properties = this.options.hasOwnProperty('properties') ? this.options.properties : {};
            this.type = type;
            this.pickable = this.options.hasOwnProperty('pickable') ? this.options.pickable : false;
            this.services = this.options.hasOwnProperty('services') ? this.options.services : [];
            this.dataType = this.options.dataType || "";
            this.background = options.background;
            this.category = this.options.background ? "background" : this.options.category;
            this.coordinateSystem = options.coordinateSystem;
            this.format = this.options.format || "";
            this.baseUrl = this.options.baseUrl || "";
            this.deletable = this.options.deletable || false;
            this.fitsSupported = false;

            // Update layer color
            this.color = _createColor.call(this, this.options);

            // Layer opacity must be in range [0, 1]
            this.opacity = _createOpacity.call(this, this.options);

            // Create style if needed
            this.style = _createStyle.call(this, this.options, this.opacity, this.icon, this.color, this.visible);

            // Ensure that the attribution link will be opened in new tab
            if (this.attribution && this.attribution.search('<a') >= 0 && this.attribution.search('target=') < 0) {
                this.attribution = this.attribution.replace(' ', ' target=_blank ');
            }

            this.availableServices = _createAvailableServices(this.options);
        };



        function _createAvailableServices(options) {
            var availableServices;
            if (options.hasOwnProperty('availableServices')) {
                availableServices = options.availableServices
            } else {
                availableServices = [];
            }
            return availableServices;
        }

        /**
         *
         * @param options
         * @param opacity
         * @param icon
         * @param color
         * @param visible
         * @returns {*}
         * @private
         */
        function _createStyle(options, opacity, icon, color, visible) {
            var style;
            if (!options.hasOwnProperty('style')) {
                style = UtilityFactory.create(Constants.UTILITY.CreateStyle, {
                    rendererHint: "Basic",
                    opacity: opacity,
                    iconUrl: icon,
                    fillColor: color,
                    strokeColor: color,
                    visible: visible
                });
            } else if (options.style === "FeatureStyle") {
                style = options.style;
            } else {
                style = UtilityFactory.create(Constants.UTILITY.CreateStyle, options.style);
            }
            return style;
        }

        /**
         *
         * @param options
         * @returns {*}
         * @private
         */
        function _createOpacity(options) {
            var opacity;
            if (options.hasOwnProperty('opacity')) {
                opacity = options.opacity / 100.0;
            } else {
                opacity = 1.0;
            }
            return opacity;
        }

        /**
         * Creates color.
         * @param options
         * @returns {*}
         * @private
         */
        function _createColor(options) {
            var color;
            if (options.hasOwnProperty('color')) {
                color = (options.color instanceof Array) ? options.color : UtilityFactory.create(Constants.UTILITY.FeatureStyle).fromStringToColor(options.color);
            }
            else {
                // Generate random color
                var rgb = Utils.generateColor();
                color = rgb.concat([1]);
            }
            return color
        }

        /**************************************************************************************************************/

        Utils.inherits(Event, AbstractLayer);

        /**************************************************************************************************************/

        /**
         * Add parameter to
         * @function addParameterTo
         * @memberOf AbstractLayer#
         * @param {String} url - parameter url
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         * @return {String} url updated
         */
        AbstractLayer.prototype.addParameterTo = function (url,name,value) {
            var separator = "&";
            if ((typeof url !== "string") || (url.indexOf('?', 0) === -1)) {
              separator = "?";
            }
            return url + separator + name + "=" + value;
        };

        /**************************************************************************************************************/

        /**
         * Add parameter to getCapabilities url
         * @function addGetCapabilitiesParameter
         * @memberOf AbstractLayer#
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         */
        AbstractLayer.prototype.addGetCapabilitiesParameter = function (name,value) {
            this.getCapabilitiesRaw = this.addParameterTo(this.getCapabilitiesRaw,name,value);
        };

        /**************************************************************************************************************/

        /**
         * Get getCapabilities url
         * @function getGetCapabilitiesUrl
         * @memberOf AbstractLayer#
         * @return {String} url
         */
        AbstractLayer.prototype.getGetCapabilitiesUrl = function () {
            this.getCapabilities = this.proxify(this.getCapabilitiesRaw);
            return this.getCapabilities;
        };

        /**
         * Add parameter to getMap url
         * @function addGetMapParameter
         * @memberOf AbstractLayer#
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         */
        AbstractLayer.prototype.addGetMapParameter = function (name,value) {
          this.getMapRaw = this.addParameterTo(this.getMapRaw,name,value);
        };

        /**************************************************************************************************************/

        /**
         * Get getMap url
         * @function getGetMapUrl
         * @memberOf AbstractLayer#
         * @return {String} url
         */
        AbstractLayer.prototype.getGetMapUrl = function () {
            this.getMap = this.proxify(this.getMapRaw);
            return this.getMap;
        };

        /**************************************************************************************************************/

        /**
         * Load the getCapabilities into json variable
         * @function loadGetCapabilities
         * @memberOf AbstractLayer
         * @param {function} callback Callback function
         * @param {String} paramUrl url (if ommited, reconstructed with getCapabilitiesUrl)
         * @param {Object} sourceObject source object
         * @return {JSON} data loaded
         */
        AbstractLayer.prototype.loadGetCapabilities = function (callback,paramUrl,sourceObject) {
          if (typeof paramUrl === 'undefined') {
            url = this.getGetCapabilitiesUrl();
            urlRaw = this.getCapabilitiesRaw;
          } else  {
            url = paramUrl;
            urlRaw = paramUrl;
          }
          $.ajax({
              type: "GET",
              url: url,
              dataType: 'text',
              success: function (response) {
                var myOptions = {
                    mergeCDATA: true,
                    xmlns: false,
                    attrsAsObject: false,
                    childrenAsArray: false
                }
                result = xmlToJSON.parseString(response,myOptions);
                callback(result,sourceObject);
              },
              error: function (xhr, ajaxOptions, thrownError) {
                  console.error("Unknow server "+urlRaw);
              }
          });
        };

        /**************************************************************************************************************/


        /**
         * Proxify an url
         * @function proxify
         * @memberOf AbstractLayer#
         * @param {String} url - URL
         * @return {String} Url proxified
         */
         AbstractLayer.prototype.proxify = function (url) {
           if (typeof url !== 'string') {
             return url;
           }
           var proxifiedUrl = url;
           var proxyDone = false;
           if ( (this.options) && (this.options.proxy) ) {
             if (this.options.proxy.use === true) {
              proxyDone = true;
               if (url.startsWith(this.options.proxy.url)) {
                 proxifiedUrl = url; // No change, proxy always set
               } else {
                 proxifiedUrl = this.options.proxy.url + encodeURIComponent(url); // Add proxy redirection
               }
            }
           }
           //console.log("Proxy done ? "+proxyDone);
           return proxifiedUrl;
         };

        /**
         * @function getGlobe
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getGlobe = function () {
            return this.globe;
        };


        /**
         * @function getID
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getID = function () {
            return this.ID;
        };


        /**
         * @function getName
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getName = function () {
            return this.name;
        };

        /**
         * @function getAttribution
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getAttribution = function () {
            return this.attribution;
        };

        /**
         * @function getCopyrightUrl
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getCopyrightUrl = function () {
            return this.copyrightUrl;
        };

        /**
         * @function getAck
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getAck = function () {
            return this.ack;
        };

        /**
         * @function getIcon
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getIcon = function () {
            return this.icon;
        };

        /**
         * @function getDescription
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getDescription = function () {
            return this.description;
        };

        /**
         * @function isVisible
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.isVisible = function () {
            return this.visible;
        };

        /**
         * @function setVisible
         * @memberOf AbstractLayer#
         * @throws {TypeError} - The parameter of setVisible should be a boolean
         */
        AbstractLayer.prototype.setVisible = function (arg) {
            if (typeof arg === "boolean") {
                if (this.visible !== arg && this.globe.attributionHandler) {
                    this.globe.attributionHandler.toggleAttribution(this);
                }
                this.visible = arg;
                if (this.globe) {
                    this.globe.renderContext.requestFrame();
                }
                this.publish("visibility:changed", this);
            } else {
                throw new TypeError("the parameter of setVisible should be a boolean", "AbstractLayer.js");
            }
        };

        /**
         * @function getOpacity
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getOpacity = function () {
            return this.opacity;
        };

        /**
         * @function setOpacity
         * @memberOf AbstractLayer#
         * @throws {RangeError} opacity - opacity value should be a value in [0..1]
         */
        AbstractLayer.prototype.setOpacity = function (arg) {
            if (typeof arg === "number" && arg >=0.0 && arg <=1.0) {
                this.opacity = arg;
                if (this.globe) {
                    this.globe.renderContext.requestFrame();
                }
                this.publish("opacity:changed", this);
            } else {
               throw new RangeError('opacity value should be a value in [0..1]', "AbstractLayer.js");
            }
        };

        /**
         * @function getProperties
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getProperties = function () {
            return this.properties;
        };

        /**
         * @function getType
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getType = function () {
            return this.type;
        };

        /**
         * @function isPickable
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.isPickable = function () {
            return this.pickable;
        };

        /**
         * @function isType
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.isType = function (type) {
            return this.type === type;
        };

        /**
         * @function getServices
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getServices = function () {
            return this.services;
        };

        /**
         * @function getCoordinateSystem
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getCoordinateSystem = function () {
            return this.coordinateSystem;
        };

        /**
         * @function _attach
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype._attach = function (g) {
            this.globe = g;
            if (this.attribution && this.globe.attributionHandler && this.isVisible()) {
                this.globe.attributionHandler.addAttribution(this);
            }
        };

        /**
         * @function _detach
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype._detach = function () {
            if (this.attribution && this.globe.attributionHandler) {
                this.globe.attributionHandler.removeAttribution(this);
            }
            this.globe = null;
        };

        /**
         * @function getBaseURl
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getBaseURl = function() {
            return this.baseUrl;
        };

        /**
         * @function getDataType
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getDataType = function() {
            return this.dataType;
        };

        /**
         * @function getFormat
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getFormat = function() {
            return this.format;
        };

        /**
         * @function isDeletable
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.isDeletable = function() {
            return this.deletable;
        };

        /**
         * @function getColor
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getColor = function() {
            return this.color;
        };

        /**
         * @function getStyle
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getStyle = function() {
            return this.style;
        };

        /**
         * @function getAvailableServices
         * @memberOf AbstractLayer#
         */
        AbstractLayer.prototype.getAvailableServices = function() {
            return this.availableServices;
        };

        AbstractLayer.prototype.isBackground = function() {
            return this.background;
        };

        /**
         * @function _proxifyUrl
         * @memberOf AbstractLayer#
         * @private
         */
        AbstractLayer.prototype._proxifyUrl = function (url) {
          if (this.options.proxy) {
            return this.options.proxy.url + url;
          } else {
            return url;
          }
        };

        return AbstractLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/Program',[],function() {

/**************************************************************************************************************/

 /**
	 @name Program
	 @class
	   Program constructor
	 @param renderContext
	 @constructor
	 */
var Program = function(renderContext)
{
	this.renderContext = renderContext;
    this.glProgram = null;
    this.attributes = {};
    this.uniforms = {};
	this.numActiveAttribArray = 0;
};

/**************************************************************************************************************/

/**
 * Creates a shader of the given type from the given source string
 * @function createShader
 * @memberof Program.prototype
 * @param type
 * @param source
 * @return Shader
*/
Program.prototype.createShader = function(type, source)
{
	var gl = this.renderContext.gl;
    var shader = gl.createShader(type);
    gl.shaderSource(shader, source);
	gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS))
    {
		console.log("Shader compilation error: " + gl.getShaderInfoLog(shader));
		console.log(source);
		gl.deleteShader(shader);
        return null;
    }

    return shader;
};

/**************************************************************************************************************/

/**
 * Create the program from source shaders
 * @function createFromSource
 * @memberof Program.prototype
 * @param vertexSource
 * @param fragmentSource
 * @return {Boolean}
 */
Program.prototype.createFromSource = function(vertexSource, fragmentSource)
{
	var gl = this.renderContext.gl;

  //  Create the gl shaders from the source
  var vertexShader = this.createShader(gl.VERTEX_SHADER, vertexSource);
  var fragmentShader = this.createShader(gl.FRAGMENT_SHADER, fragmentSource);
  if (vertexShader === null || fragmentShader === null)
  {
	   return false;
  }

  var i;

	// Create the program and attach the shaderss
	this.glProgram = gl.createProgram();
	gl.attachShader(this.glProgram, vertexShader);
	gl.attachShader(this.glProgram, fragmentShader);

	// Link and test the program is ok
	gl.linkProgram(this.glProgram);
    if (!gl.getProgramParameter(this.glProgram, gl.LINK_STATUS))
    {
        console.log("Program link error: " + gl.getProgramInfoLog(this.glProgram));
		gl.deleteShader(vertexShader);
		gl.deleteShader(fragmentShader);
		gl.deleteProgram(this.glProgram);
		this.glProgram = null;
        return false;
    }

    // Get vertex attributes used in the program, stored them in an attributes object
    var attributeCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_ATTRIBUTES);
	this.numActiveAttribArray = 0;
    for (i = 0; i < attributeCount; ++i)
    {
        var attribute = gl.getActiveAttrib(this.glProgram, i);
		var loc = gl.getAttribLocation(this.glProgram,attribute.name);
        this.attributes[attribute.name] = loc;

		if ( loc + 1 > this.numActiveAttribArray )
		{
			this.numActiveAttribArray = loc + 1;
		}
    }

    // Get uniforms used in the program, stored them in an uniforms object
    var uniformCount = gl.getProgramParameter(this.glProgram, gl.ACTIVE_UNIFORMS);
    for (i = 0; i < uniformCount; ++i)
    {
        var uniform = gl.getActiveUniform(this.glProgram, i);
        this.uniforms[uniform.name] = gl.getUniformLocation(this.glProgram,uniform.name);
    }

    return true;
};

/**************************************************************************************************************/

/**
 * Load from file (must be located on the server)
 * @function loadFromFile
 * @memberof Program.prototype
 * @param vertexFile
 * @param fragmentFile
 * @return {Boolean}
 */
Program.prototype.loadFromFile = function(vertexFile, fragmentFile)
{
  var xhr = new XMLHttpRequest();
	xhr.open("get", this.renderContext.shadersPath + vertexFile, false);
	xhr.send(null);

	var vertexSource = xhr.responseText;
	xhr.open("get", this.renderContext.shadersPath +  fragmentFile, false);
	xhr.send(null);
  var fragmentSource = xhr.responseText;



  return this.createFromSource(vertexSource, fragmentSource);
};

/**************************************************************************************************************/

/**
 * Apply the programs
 * @function apply
 * @memberof Program.prototype
 */
Program.prototype.apply = function()
{
	var rc = this.renderContext;
	var gl =  rc.gl;
  var i;

    // Bind program
	gl.useProgram(this.glProgram);

	for ( i = rc.numActiveAttribArray;
		i < this.numActiveAttribArray; i++ )
	{
		gl.enableVertexAttribArray(i);
	}
	for ( i = this.numActiveAttribArray;
		i < rc.numActiveAttribArray; i++ )
	{
		gl.disableVertexAttribArray(i);
	}
	rc.numActiveAttribArray = this.numActiveAttribArray;
};

/**************************************************************************************************************/

/**
 * Dispose the program
 * @function dispose
 * @memberof Program.prototype
 */
Program.prototype.dispose = function()
{
	this.renderContext.gl.deleteProgram(this.glProgram);
};

/**************************************************************************************************************/

return Program;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/BoundingBox',[],function() {
	/**
	 @name BoundingBox
	 @class
	  Bounding Box
	 @param {float[]} min Min corner as 3D point (array of 3 float)
	 @param {float[]} max Max corner as 3D point (array of 3 float)
	 @constructor
	 */
var BoundingBox = function(min,max)
{
	if (min)
	{
		this.min = vec3.create( min );
	}
	if (max)
	{
		this.max = vec3.create( max );
	}
};

/**
	Extent the bounding box with the given point
	@function extend
	@memberof BoundingBox.prototype
	@param {float} x Coord x of extent point
	@param {float} y Coord y of extent point
	@param {float} z Coord z of extent point
*/
BoundingBox.prototype.extend = function( x, y, z)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();

		this.min[0] = x;
		this.min[1] = y;
		this.min[2] = z;
		this.max[0] = x;
		this.max[1] = y;
		this.max[2] = z;
	}
	else
	{
		if ( x < this.min[0] )
		{
			this.min[0] = x;
		}
		if ( y < this.min[1] )
		{
			this.min[1] = y;
		}
		if ( z < this.min[2] )
		{
			this.min[2] = z;
		}
		if ( x > this.max[0] )
		{
			this.max[0] = x;
		}
		if ( y > this.max[1] )
		{
			this.max[1] = y;
		}
		if ( z > this.max[2] )
		{
			this.max[2] = z;
		}
	}
};
 /**
 	Compute the bounding box from an array of vertices
 	@function compute
 	@memberof BoundingBox.prototype
 	@param {float[]} vertices All coords as array of multiple of 3 float)
 	@param {float} length Vertices array length
 	@param {float} stride Stride (3 by default)
 */
BoundingBox.prototype.compute = function(vertices,length,stride)
{
	if (!this.min)
	{
		this.min = vec3.create();
		this.max = vec3.create();
	}

	this.min[0] = vertices[0];
	this.min[1] = vertices[1];
	this.min[2] = vertices[2];
	this.max[0] = vertices[0];
	this.max[1] = vertices[1];
	this.max[2] = vertices[2];

	var i,j;
	var st = stride || 3;
	var ll = length || vertices.length;

	for (i=st; i < ll; i += st)
	{
		for (j=0; j < 3; j++)
		{
			if ( vertices[i+j] < this.min[j] )
			{
				this.min[j] = vertices[i+j];
			}
			if ( vertices[i+j] > this.max[j] )
			{
				this.max[j] = vertices[i+j];
			}
		}
	}
};

 /**
 	Get the corner of a bounding box
 	@function getCorner
 	@memberof BoundingBox.prototype
 	@param {float} pos Position
 	@return {?} Corner
 */
BoundingBox.prototype.getCorner = function(pos)
{
	return [ pos&1 ? this.max[0] : this.min[0],
			pos&2 ? this.max[1] : this.min[1],
			pos&4 ? this.max[2] : this.min[2]	];
};

 /**
 	Get the center of a bounding box
 	@function getCenter
 	@memberof BoundingBox.prototype
 	@return {?} Center
 */
BoundingBox.prototype.getCenter = function()
{
	return [ (this.max[0] + this.min[0]) * 0.5,
			(this.max[1] + this.min[1]) * 0.5,
			(this.max[2] + this.min[2]) * 0.5	];
};

 /**
 	Get the radius of a bounding box
 	@function getRadius
 	@memberof BoundingBox.prototype
 	@return {float} Radius
 */
BoundingBox.prototype.getRadius = function()
{
	var vec = vec3.create();
	vec3.subtract( this.max, this.min, vec);
	return 0.5 * vec3.length(vec);
};

/**************************************************************************************************************/

return BoundingBox;

});

// jshint ignore: start

/*
 * Copyright (c) 2012 Brandon Jones, Colin MacKenzie IV
 *
 * This software is provided 'as-is', without any express or implied
 * warranty. In no event will the authors be held liable for any damages
 * arising from the use of this software.
 *
 * Permission is granted to anyone to use this software for any purpose,
 * including commercial applications, and to alter it and redistribute it
 * freely, subject to the following restrictions:
 *
 *    1. The origin of this software must not be misrepresented; you must not
 *    claim that you wrote the original software. If you use this software
 *    in a product, an acknowledgment in the product documentation would be
 *    appreciated but is not required.
 *
 *    2. Altered source versions must be plainly marked as such, and must not
 *    be misrepresented as being the original software.
 *
 *    3. This notice may not be removed or altered from any source
 *    distribution.
 */

// Modification to plain glMatrix
//	- Always use Array for MatrixType
//	- Remove export management
//	- Remove vec2, mat2, mat3, vec4
//	- Comments some not needed functions
//	- Add mat4.project and mat4.rotateVec3

define('Renderer/glMatrix',[], function () {

    // Tweak to your liking
    var FLOAT_EPSILON = 0.000001;

    /**
     * @class System-specific optimal array type
     * @name MatrixArray
     */
    var MatrixArray = Array;

    /**
     * @class 3 Dimensional Vector
     * @name vec3
     */
    var vec3 = {};

    /**
     * Creates a new instance of a vec3 using the default array type
     * Any javascript array-like objects containing at least 3 numeric elements can serve as a vec3
     *
     * @param {vec3} [vec] vec3 containing values to initialize with
     *
     * @returns {vec3} New vec3
     */
    vec3.create = function (vec) {
        var dest = new MatrixArray(3);

        if (vec) {
            dest[0] = vec[0];
            dest[1] = vec[1];
            dest[2] = vec[2];
        } else {
            dest[0] = dest[1] = dest[2] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a vec3, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value

     * @returns {vec3} New vec3
     */
    vec3.createFrom = function (x, y, z) {
        var dest = new MatrixArray(3);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;

        return dest;
    };

    /**
     * Copies the values of one vec3 to another
     *
     * @param {vec3} vec vec3 containing values to copy
     * @param {vec3} dest vec3 receiving copied values
     *
     * @returns {vec3} dest
     */
    vec3.set = function (vec, dest) {
        dest[0] = vec[0];
        dest[1] = vec[1];
        dest[2] = vec[2];

        return dest;
    };

    /**
     * Compares two vectors for equality within a certain margin of error
     *
     * @param {vec3} a First vector
     * @param {vec3} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    vec3.equal = function (a, b) {
        return a === b || (
                Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON
            );
    };

    /**
     * Performs a vector addition
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.add = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] += vec2[0];
            vec[1] += vec2[1];
            vec[2] += vec2[2];
            return vec;
        }

        dest[0] = vec[0] + vec2[0];
        dest[1] = vec[1] + vec2[1];
        dest[2] = vec[2] + vec2[2];
        return dest;
    };

    /**
     * Performs a vector subtraction
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.subtract = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] -= vec2[0];
            vec[1] -= vec2[1];
            vec[2] -= vec2[2];
            return vec;
        }

        dest[0] = vec[0] - vec2[0];
        dest[1] = vec[1] - vec2[1];
        dest[2] = vec[2] - vec2[2];
        return dest;
    };

    /**
     * Performs a vector multiplication
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.multiply = function (vec, vec2, dest) {
        if (!dest || vec === dest) {
            vec[0] *= vec2[0];
            vec[1] *= vec2[1];
            vec[2] *= vec2[2];
            return vec;
        }

        dest[0] = vec[0] * vec2[0];
        dest[1] = vec[1] * vec2[1];
        dest[2] = vec[2] * vec2[2];
        return dest;
    };

    /**
     * Negates the components of a vec3
     *
     * @param {vec3} vec vec3 to negate
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.negate = function (vec, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = -vec[0];
        dest[1] = -vec[1];
        dest[2] = -vec[2];
        return dest;
    };

    /**
     * Multiplies the components of a vec3 by a scalar value
     *
     * @param {vec3} vec vec3 to scale
     * @param {number} val Value to scale by
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.scale = function (vec, val, dest) {
        if (!dest || vec === dest) {
            vec[0] *= val;
            vec[1] *= val;
            vec[2] *= val;
            return vec;
        }

        dest[0] = vec[0] * val;
        dest[1] = vec[1] * val;
        dest[2] = vec[2] * val;
        return dest;
    };

    /**
     * Generates a unit vector of the same direction as the provided vec3
     * If vector length is 0, returns [0, 0, 0]
     *
     * @param {vec3} vec vec3 to normalize
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.normalize = function (vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2],
            len = Math.sqrt(x * x + y * y + z * z);

        if (!len) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            return dest;
        } else if (len === 1) {
            dest[0] = x;
            dest[1] = y;
            dest[2] = z;
            return dest;
        }

        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        return dest;
    };

    /**
     * Generates the cross product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.cross = function (vec, vec2, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2],
            x2 = vec2[0], y2 = vec2[1], z2 = vec2[2];

        dest[0] = y * z2 - z * y2;
        dest[1] = z * x2 - x * z2;
        dest[2] = x * y2 - y * x2;
        return dest;
    };

    /**
     * Caclulates the length of a vec3
     *
     * @param {vec3} vec vec3 to calculate length of
     *
     * @returns {number} Length of vec
     */
    vec3.length = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return Math.sqrt(x * x + y * y + z * z);
    };

    /**
     * Caclulates the squared length of a vec3
     *
     * @param {vec3} vec vec3 to calculate squared length of
     *
     * @returns {number} Squared Length of vec
     */
    vec3.squaredLength = function (vec) {
        var x = vec[0], y = vec[1], z = vec[2];
        return x * x + y * y + z * z;
    };

    /**
     * Caclulates the dot product of two vec3s
     *
     * @param {vec3} vec First operand
     * @param {vec3} vec2 Second operand
     *
     * @returns {number} Dot product of vec and vec2
     */
    vec3.dot = function (vec, vec2) {
        return vec[0] * vec2[0] + vec[1] * vec2[1] + vec[2] * vec2[2];
    };

    /**
     * Generates a unit vector pointing from one vector to another
     *
     * @param {vec3} vec Origin vec3
     * @param {vec3} vec2 vec3 to point to
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.direction = function (vec, vec2, dest) {
     if (!dest) { dest = vec; }

     var x = vec[0] - vec2[0],
     y = vec[1] - vec2[1],
     z = vec[2] - vec2[2],
     len = Math.sqrt(x * x + y * y + z * z);

     if (!len) {
     dest[0] = 0;
     dest[1] = 0;
     dest[2] = 0;
     return dest;
     }

     len = 1 / len;
     dest[0] = x * len;
     dest[1] = y * len;
     dest[2] = z * len;
     return dest;
     };*/

    /**
     * Performs a linear interpolation between two vec3
     *
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     * @param {number} lerp Interpolation amount between the two inputs
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    vec3.lerp = function (vec, vec2, lerp, dest) {
        if (!dest) {
            dest = vec;
        }

        dest[0] = vec[0] + lerp * (vec2[0] - vec[0]);
        dest[1] = vec[1] + lerp * (vec2[1] - vec[1]);
        dest[2] = vec[2] + lerp * (vec2[2] - vec[2]);

        return dest;
    };

    /**
     * Calculates the euclidian distance between two vec3
     *
     * Params:
     * @param {vec3} vec First vector
     * @param {vec3} vec2 Second vector
     *
     * @returns {number} Distance between vec and vec2
     */
    vec3.dist = function (vec, vec2) {
        var x = vec2[0] - vec[0],
            y = vec2[1] - vec[1],
            z = vec2[2] - vec[2];

        return Math.sqrt(x * x + y * y + z * z);
    };

    /** Vector cross product.
     @param v1 vector
     @param v2 another vector
     @return number vector cross product between this vector and {@code v}
     */
    vec3.angle = function (v1, v2) {
        return Math.atan2(vec3.length(vec3.cross(v1, v2)), vec3.dot(v1, v2));
    };

    // Pre-allocated to prevent unecessary garbage collection
    //var unprojectMat = null;
    //var unprojectVec = new MatrixArray(4);
    /**
     * Projects the specified vec3 from screen space into object space
     * Based on the <a href="http://webcvs.freedesktop.org/mesa/Mesa/src/glu/mesa/project.c?revision=1.4&view=markup">Mesa gluUnProject implementation</a>
     *
     * @param {vec3} vec Screen-space vector to project
     * @param {mat4} view View matrix
     * @param {mat4} proj Projection matrix
     * @param {vec4} viewport Viewport as given to gl.viewport [x, y, width, height]
     * @param {vec3} [dest] vec3 receiving unprojected result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    /*   vec3.unproject = function (vec, view, proj, viewport, dest) {
     if (!dest) { dest = vec; }

     if(!unprojectMat) {
     unprojectMat = mat4.create();
     }

     var m = unprojectMat;
     var v = unprojectVec;

     v[0] = (vec[0] - viewport[0]) * 2.0 / viewport[2] - 1.0;
     v[1] = (vec[1] - viewport[1]) * 2.0 / viewport[3] - 1.0;
     v[2] = 2.0 * vec[2] - 1.0;
     v[3] = 1.0;

     mat4.multiply(proj, view, m);
     if(!mat4.inverse(m)) { return null; }

     mat4.multiplyVec4(m, v);
     if(v[3] === 0.0) { return null; }

     dest[0] = v[0] / v[3];
     dest[1] = v[1] / v[3];
     dest[2] = v[2] / v[3];

     return dest;
     };*/

    /*    var xUnitVec3 = vec3.createFrom(1,0,0);
     var yUnitVec3 = vec3.createFrom(0,1,0);
     var zUnitVec3 = vec3.createFrom(0,0,1);

     var tmpvec3 = vec3.create();*/
    /**
     * Generates a quaternion of rotation between two given normalized vectors
     *
     * @param {vec3} a Normalized source vector
     * @param {vec3} b Normalized target vector
     * @param {quat4} [dest] quat4 receiving operation result.
     *
     * @returns {quat4} dest if specified, a new quat4 otherwise
     */
    /*    vec3.rotationTo = function (a, b, dest) {
     if (!dest) { dest = quat4.create(); }

     var d = vec3.dot(a, b);
     var axis = tmpvec3;
     if (d >= 1.0) {
     quat4.set(identityQuat4, dest);
     } else if (d < (0.000001 - 1.0)) {
     vec3.cross(xUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(yUnitVec3, a, axis);
     if (vec3.length(axis) < 0.000001)
     vec3.cross(zUnitVec3, a, axis);
     vec3.normalize(axis);
     quat4.fromAngleAxis(Math.PI, axis, dest);
     } else {
     var s = Math.sqrt((1.0 + d) * 2.0);
     var sInv = 1.0 / s;
     vec3.cross(a, b, axis);
     dest[0] = axis[0] * sInv;
     dest[1] = axis[1] * sInv;
     dest[2] = axis[2] * sInv;
     dest[3] = s * 0.5;
     quat4.normalize(dest);
     }
     if (dest[3] > 1.0) dest[3] = 1.0;
     else if (dest[3] < -1.0) dest[3] = -1.0;
     return dest;
     };*/

    /**
     * Returns a string representation of a vector
     *
     * @param {vec3} vec Vector to represent as a string
     *
     * @returns {string} String representation of vec
     */
    vec3.str = function (vec) {
        return '[' + vec[0] + ', ' + vec[1] + ', ' + vec[2] + ']';
    };


    // Vec3 lib used for Astro Math lib

    vec3.createZPhi = function (z, phi) {
        var sth = Math.sqrt((1.0 - z) * (1.0 + z));
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        return vec3.createFrom(x, y, z);
    };

    vec3.createPhiTheta = function (phi, theta) {
        var sth = Math.sin(theta);
        var x = sth * Math.cos(phi);
        var y = sth * Math.sin(phi);
        var z = sth * Math.cos(theta);
        return vec3.createFrom(x, y, z);
    };

    vec3.add2 = function (vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 + x2, y1 + y2, z1 + z2];
    };

    vec3.subtract2 = function (vec, vec2) {
        var x1 = vec[0];
        var y1 = vec[1];
        var z1 = vec[2];
        var x2 = vec2[0];
        var y2 = vec2[1];
        var z2 = vec2[2];

        return [x1 - x2, y1 - y2, z1 - z2];
    };

    vec3.flip = function (vec) {
        var x = vec[0];
        var y = vec[1];
        var z = vec[2];

        return [x = -x, y = -y, z = -z];
    };

    vec3.scale2 = function (vec, val) {
        var x = vec.x;
        var y = vec.y;
        var z = vec.z;

        return {
            x: x * val,
            y: y *= val,
            z: z *= val
        };
    };

    vec3.normalize2 = function (vec) {

        var x = vec[0];
        var y = vec[1];
        var z = vec[2];
        var d = 1.0 / Math.sqrt(x * x + y * y + z * z);

        return [x *= d, y *= d, z *= d];
    };

    vec3.cross2 = function (vec, vec2) {
        return {
            x: vec[1] * vec2[2] - vec2[1] * vec[2],
            y: vec[2] * vec2[0] - vec2[2] * vec[0],
            z: vec[0] * vec2[1] - vec2[0] * vec[1]
        };
    };

    vec3.length2 = function (vec) {
        var x = vec.x, y = vec.y, z = vec.z;
        return Math.sqrt(x * x + y * y + z * z);
    };

    vec3.dot2 = function (vec, vec2) {
        var x1 = (vec.x !== undefined) ? vec.x : vec[0];
        var y1 = (vec.y !== undefined) ? vec.y : vec[1];
        var z1 = (vec.z !== undefined) ? vec.z : vec[2];
        var x2 = (vec2.x !== undefined) ? vec2.x : vec2[0];
        var y2 = (vec2.y !== undefined) ? vec2.y : vec2[1];
        var z2 = (vec2.z !== undefined) ? vec2.z : vec2[2];

        return x1 * x2 + y1 * y2 + z1 * z2;
    };

    vec3.angle2 = function (v1, v2) {
        return Math.atan2(vec3.length2(vec3.cross2(v1, v2)), vec3.dot2(v1, v2));
    };
    //

    /**
     * @class 3x3 Matrix
     * @name mat3
     */
    var mat3 = {};

    /**
     * Creates a new isntance of mat3
     *
     * @param {mat3} [mat] mat3 containing values to initialize with
     *
     * @returns {mat3} a new 3x3 matrix
     */
    mat3.create = function (mat) {
        var dest = new MatrixArray(9);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
        }

        return dest;
    };

    /**
     * @class 4x4 Matrix
     * @name mat4
     */
    var mat4 = {};

    /**
     * Creates a new instance of a mat4 using the default array type
     * Any javascript array-like object containing at least 16 numeric elements can serve as a mat4
     *
     * @param {mat4} [mat] mat4 containing values to initialize with
     *
     * @returns {mat4} New mat4
     */
    mat4.create = function (mat) {
        var dest = new MatrixArray(16);

        if (mat) {
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        return dest;
    };

    /**
     * Creates a new instance of a mat4, initializing it with the given arguments
     *
     * @param {number} m00
     * @param {number} m01
     * @param {number} m02
     * @param {number} m03
     * @param {number} m10
     * @param {number} m11
     * @param {number} m12
     * @param {number} m13
     * @param {number} m20
     * @param {number} m21
     * @param {number} m22
     * @param {number} m23
     * @param {number} m30
     * @param {number} m31
     * @param {number} m32
     * @param {number} m33

     * @returns {mat4} New mat4
     */
    /*   mat4.createFrom = function (m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
     var dest = new MatrixArray(16);

     dest[0] = m00;
     dest[1] = m01;
     dest[2] = m02;
     dest[3] = m03;
     dest[4] = m10;
     dest[5] = m11;
     dest[6] = m12;
     dest[7] = m13;
     dest[8] = m20;
     dest[9] = m21;
     dest[10] = m22;
     dest[11] = m23;
     dest[12] = m30;
     dest[13] = m31;
     dest[14] = m32;
     dest[15] = m33;

     return dest;
     };*/

    /**
     * Copies the values of one mat4 to another
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} dest mat4 receiving copied values
     *
     * @returns {mat4} dest
     */
    mat4.set = function (mat, dest) {
        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Compares two matrices for equality within a certain margin of error
     *
     * @param {mat4} a First matrix
     * @param {mat4} b Second matrix
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    /*    mat4.equal = function (a, b) {
     return a === b || (
     Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
     Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
     Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
     Math.abs(a[3] - b[3]) < FLOAT_EPSILON &&
     Math.abs(a[4] - b[4]) < FLOAT_EPSILON &&
     Math.abs(a[5] - b[5]) < FLOAT_EPSILON &&
     Math.abs(a[6] - b[6]) < FLOAT_EPSILON &&
     Math.abs(a[7] - b[7]) < FLOAT_EPSILON &&
     Math.abs(a[8] - b[8]) < FLOAT_EPSILON &&
     Math.abs(a[9] - b[9]) < FLOAT_EPSILON &&
     Math.abs(a[10] - b[10]) < FLOAT_EPSILON &&
     Math.abs(a[11] - b[11]) < FLOAT_EPSILON &&
     Math.abs(a[12] - b[12]) < FLOAT_EPSILON &&
     Math.abs(a[13] - b[13]) < FLOAT_EPSILON &&
     Math.abs(a[14] - b[14]) < FLOAT_EPSILON &&
     Math.abs(a[15] - b[15]) < FLOAT_EPSILON
     );
     };*/

    /**
     * Sets a mat4 to an identity matrix
     *
     * @param {mat4} dest mat4 to set
     *
     * @returns {mat4} dest
     */
    mat4.identity = function (dest) {
        if (!dest) {
            dest = mat4.create();
        }
        dest[0] = 1;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 1;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = 1;
        dest[11] = 0;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;
        return dest;
    };

    /**
     * Transposes a mat4 (flips the values over the diagonal)
     *
     * @param {mat4} mat mat4 to transpose
     * @param {mat4} [dest] mat4 receiving transposed values. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise
     */
    mat4.transpose = function (mat, dest) {
        // If we are transposing ourselves we can skip a few steps but have to cache some values
        if (!dest || mat === dest) {
            var a01 = mat[1], a02 = mat[2], a03 = mat[3],
                a12 = mat[6], a13 = mat[7],
                a23 = mat[11];

            mat[1] = mat[4];
            mat[2] = mat[8];
            mat[3] = mat[12];
            mat[4] = a01;
            mat[6] = mat[9];
            mat[7] = mat[13];
            mat[8] = a02;
            mat[9] = a12;
            mat[11] = mat[14];
            mat[12] = a03;
            mat[13] = a13;
            mat[14] = a23;
            return mat;
        }

        dest[0] = mat[0];
        dest[1] = mat[4];
        dest[2] = mat[8];
        dest[3] = mat[12];
        dest[4] = mat[1];
        dest[5] = mat[5];
        dest[6] = mat[9];
        dest[7] = mat[13];
        dest[8] = mat[2];
        dest[9] = mat[6];
        dest[10] = mat[10];
        dest[11] = mat[14];
        dest[12] = mat[3];
        dest[13] = mat[7];
        dest[14] = mat[11];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Calculates the determinant of a mat4
     *
     * @param {mat4} mat mat4 to calculate determinant of
     *
     * @returns {number} determinant of mat
     */
    mat4.determinant = function (mat) {
        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        return (a30 * a21 * a12 * a03 - a20 * a31 * a12 * a03 - a30 * a11 * a22 * a03 + a10 * a31 * a22 * a03 +
        a20 * a11 * a32 * a03 - a10 * a21 * a32 * a03 - a30 * a21 * a02 * a13 + a20 * a31 * a02 * a13 +
        a30 * a01 * a22 * a13 - a00 * a31 * a22 * a13 - a20 * a01 * a32 * a13 + a00 * a21 * a32 * a13 +
        a30 * a11 * a02 * a23 - a10 * a31 * a02 * a23 - a30 * a01 * a12 * a23 + a00 * a31 * a12 * a23 +
        a10 * a01 * a32 * a23 - a00 * a11 * a32 * a23 - a20 * a11 * a02 * a33 + a10 * a21 * a02 * a33 +
        a20 * a01 * a12 * a33 - a00 * a21 * a12 * a33 - a10 * a01 * a22 * a33 + a00 * a11 * a22 * a33);
    };

    /**
     * Calculates the inverse matrix of a mat4
     *
     * @param {mat4} mat mat4 to calculate inverse of
     * @param {mat4} [dest] mat4 receiving inverse matrix. If not specified result is written to mat
     *
     * @param {mat4} dest is specified, mat otherwise, null if matrix cannot be inverted
     */
    mat4.inverse = function (mat, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3],
            a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7],
            a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11],
            a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15],

            b00 = a00 * a11 - a01 * a10,
            b01 = a00 * a12 - a02 * a10,
            b02 = a00 * a13 - a03 * a10,
            b03 = a01 * a12 - a02 * a11,
            b04 = a01 * a13 - a03 * a11,
            b05 = a02 * a13 - a03 * a12,
            b06 = a20 * a31 - a21 * a30,
            b07 = a20 * a32 - a22 * a30,
            b08 = a20 * a33 - a23 * a30,
            b09 = a21 * a32 - a22 * a31,
            b10 = a21 * a33 - a23 * a31,
            b11 = a22 * a33 - a23 * a32,

            d = (b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06),
            invDet;

        // Calculate the determinant
        if (!d) {
            return null;
        }
        invDet = 1 / d;

        dest[0] = (a11 * b11 - a12 * b10 + a13 * b09) * invDet;
        dest[1] = (-a01 * b11 + a02 * b10 - a03 * b09) * invDet;
        dest[2] = (a31 * b05 - a32 * b04 + a33 * b03) * invDet;
        dest[3] = (-a21 * b05 + a22 * b04 - a23 * b03) * invDet;
        dest[4] = (-a10 * b11 + a12 * b08 - a13 * b07) * invDet;
        dest[5] = (a00 * b11 - a02 * b08 + a03 * b07) * invDet;
        dest[6] = (-a30 * b05 + a32 * b02 - a33 * b01) * invDet;
        dest[7] = (a20 * b05 - a22 * b02 + a23 * b01) * invDet;
        dest[8] = (a10 * b10 - a11 * b08 + a13 * b06) * invDet;
        dest[9] = (-a00 * b10 + a01 * b08 - a03 * b06) * invDet;
        dest[10] = (a30 * b04 - a31 * b02 + a33 * b00) * invDet;
        dest[11] = (-a20 * b04 + a21 * b02 - a23 * b00) * invDet;
        dest[12] = (-a10 * b09 + a11 * b07 - a12 * b06) * invDet;
        dest[13] = (a00 * b09 - a01 * b07 + a02 * b06) * invDet;
        dest[14] = (-a30 * b03 + a31 * b01 - a32 * b00) * invDet;
        dest[15] = (a20 * b03 - a21 * b01 + a22 * b00) * invDet;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into another mat4
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat4} [dest] mat4 receiving copied values
     *
     * @returns {mat4} dest is specified, a new mat4 otherwise
     */
    mat4.toRotationMat = function (mat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[3];
        dest[4] = mat[4];
        dest[5] = mat[5];
        dest[6] = mat[6];
        dest[7] = mat[7];
        dest[8] = mat[8];
        dest[9] = mat[9];
        dest[10] = mat[10];
        dest[11] = mat[11];
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Copies the upper 3x3 elements of a mat4 into a mat3
     *
     * @param {mat4} mat mat4 containing values to copy
     * @param {mat3} [dest] mat3 receiving copied values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise
     */
    mat4.toMat3 = function (mat, dest) {
        if (!dest) {
            dest = mat3.create();
        }

        dest[0] = mat[0];
        dest[1] = mat[1];
        dest[2] = mat[2];
        dest[3] = mat[4];
        dest[4] = mat[5];
        dest[5] = mat[6];
        dest[6] = mat[8];
        dest[7] = mat[9];
        dest[8] = mat[10];

        return dest;
    };

    /**
     * Calculates the inverse of the upper 3x3 elements of a mat4 and copies the result into a mat3
     * The resulting matrix is useful for calculating transformed normals
     *
     * Params:
     * @param {mat4} mat mat4 containing values to invert and copy
     * @param {mat3} [dest] mat3 receiving values
     *
     * @returns {mat3} dest is specified, a new mat3 otherwise, null if the matrix cannot be inverted
     */
    /*   mat4.toInverseMat3 = function (mat, dest) {
     // Cache the matrix values (makes for huge speed increases!)
     var a00 = mat[0], a01 = mat[1], a02 = mat[2],
     a10 = mat[4], a11 = mat[5], a12 = mat[6],
     a20 = mat[8], a21 = mat[9], a22 = mat[10],

     b01 = a22 * a11 - a12 * a21,
     b11 = -a22 * a10 + a12 * a20,
     b21 = a21 * a10 - a11 * a20,

     d = a00 * b01 + a01 * b11 + a02 * b21,
     id;

     if (!d) { return null; }
     id = 1 / d;

     if (!dest) { dest = mat3.create(); }

     dest[0] = b01 * id;
     dest[1] = (-a22 * a01 + a02 * a21) * id;
     dest[2] = (a12 * a01 - a02 * a11) * id;
     dest[3] = b11 * id;
     dest[4] = (a22 * a00 - a02 * a20) * id;
     dest[5] = (-a12 * a00 + a02 * a10) * id;
     dest[6] = b21 * id;
     dest[7] = (-a21 * a00 + a01 * a20) * id;
     dest[8] = (a11 * a00 - a01 * a10) * id;

     return dest;
     };*/

    /**
     * Performs a matrix multiplication
     *
     * @param {mat4} mat First operand
     * @param {mat4} mat2 Second operand
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.multiply = function (mat, mat2, dest) {
        if (!dest) {
            dest = mat;
        }

        // Cache the matrix values (makes for huge speed increases!)
        var a00 = mat[0], a01 = mat[1], a02 = mat[2], a03 = mat[3];
        var a10 = mat[4], a11 = mat[5], a12 = mat[6], a13 = mat[7];
        var a20 = mat[8], a21 = mat[9], a22 = mat[10], a23 = mat[11];
        var a30 = mat[12], a31 = mat[13], a32 = mat[14], a33 = mat[15];

        // Cache only the current line of the second matrix
        var b0 = mat2[0], b1 = mat2[1], b2 = mat2[2], b3 = mat2[3];
        dest[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[4];
        b1 = mat2[5];
        b2 = mat2[6];
        b3 = mat2[7];
        dest[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[8];
        b1 = mat2[9];
        b2 = mat2[10];
        b3 = mat2[11];
        dest[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        b0 = mat2[12];
        b1 = mat2[13];
        b2 = mat2[14];
        b3 = mat2[15];
        dest[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
        dest[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
        dest[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
        dest[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;

        return dest;
    };

    /**
     * Transforms a vec3 with the given matrix
     * 4th vector component is implicitly '1'
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec3} dest if specified, vec otherwise
     */
    mat4.multiplyVec3 = function (mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];

        return dest;
    };

    /**
     * Transforms a vec4 with the given matrix
     *
     * @param {mat4} mat mat4 to transform the vector with
     * @param {vec4} vec vec4 to transform
     * @param {vec4} [dest] vec4 receiving operation result. If not specified result is written to vec
     *
     * @returns {vec4} dest if specified, vec otherwise
     */
    mat4.multiplyVec4 = function (mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2], w = vec[3];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12] * w;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13] * w;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14] * w;
        dest[3] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15] * w;

        return dest;
    };

    /**
     Project a vec3
     */
    mat4.project = function (mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }
        mat4.multiplyVec4(mat, vec, dest);
        var iw = 1.0 / dest[3];
        dest[0] *= iw;
        dest[1] *= iw;
        dest[2] *= iw;
        return dest;
    };

    /**
     * mat4.rotateVec3
     * Rotate a vec3 with the given matrix
     *
     * Params:
     * mat - mat4 to transform the vector with
     * vec - vec3 to transform
     * dest - Optional, vec3 receiving operation result. If not specified result is written to vec
     *
     * Returns:
     * dest if specified, vec otherwise
     */
    mat4.rotateVec3 = function (mat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2];

        dest[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        dest[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        dest[2] = mat[2] * x + mat[6] * y + mat[10] * z;

        return dest;
    };

    /**
     * Translates a matrix by the given vector
     *
     * @param {mat4} mat mat4 to translate
     * @param {vec3} vec vec3 specifying the translation
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.translate = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2],
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23;

        if (!dest || mat === dest) {
            mat[12] = mat[0] * x + mat[4] * y + mat[8] * z + mat[12];
            mat[13] = mat[1] * x + mat[5] * y + mat[9] * z + mat[13];
            mat[14] = mat[2] * x + mat[6] * y + mat[10] * z + mat[14];
            mat[15] = mat[3] * x + mat[7] * y + mat[11] * z + mat[15];
            return mat;
        }

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        dest[0] = a00;
        dest[1] = a01;
        dest[2] = a02;
        dest[3] = a03;
        dest[4] = a10;
        dest[5] = a11;
        dest[6] = a12;
        dest[7] = a13;
        dest[8] = a20;
        dest[9] = a21;
        dest[10] = a22;
        dest[11] = a23;

        dest[12] = a00 * x + a10 * y + a20 * z + mat[12];
        dest[13] = a01 * x + a11 * y + a21 * z + mat[13];
        dest[14] = a02 * x + a12 * y + a22 * z + mat[14];
        dest[15] = a03 * x + a13 * y + a23 * z + mat[15];
        return dest;
    };

    /**
     * Scales a matrix by the given vector
     *
     * @param {mat4} mat mat4 to scale
     * @param {vec3} vec vec3 specifying the scale for each axis
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @param {mat4} dest if specified, mat otherwise
     */
    mat4.scale = function (mat, vec, dest) {
        var x = vec[0], y = vec[1], z = vec[2];

        if (!dest || mat === dest) {
            mat[0] *= x;
            mat[1] *= x;
            mat[2] *= x;
            mat[3] *= x;
            mat[4] *= y;
            mat[5] *= y;
            mat[6] *= y;
            mat[7] *= y;
            mat[8] *= z;
            mat[9] *= z;
            mat[10] *= z;
            mat[11] *= z;
            return mat;
        }

        dest[0] = mat[0] * x;
        dest[1] = mat[1] * x;
        dest[2] = mat[2] * x;
        dest[3] = mat[3] * x;
        dest[4] = mat[4] * y;
        dest[5] = mat[5] * y;
        dest[6] = mat[6] * y;
        dest[7] = mat[7] * y;
        dest[8] = mat[8] * z;
        dest[9] = mat[9] * z;
        dest[10] = mat[10] * z;
        dest[11] = mat[11] * z;
        dest[12] = mat[12];
        dest[13] = mat[13];
        dest[14] = mat[14];
        dest[15] = mat[15];
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the specified axis
     * If rotating around a primary axis (X,Y,Z) one of the specialized rotation functions should be used instead for performance
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {vec3} axis vec3 representing the axis to rotate around
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotate = function (mat, angle, axis, dest) {
        var x = axis[0], y = axis[1], z = axis[2],
            len = Math.sqrt(x * x + y * y + z * z),
            s, c, t,
            a00, a01, a02, a03,
            a10, a11, a12, a13,
            a20, a21, a22, a23,
            b00, b01, b02,
            b10, b11, b12,
            b20, b21, b22;

        if (!len) {
            return null;
        }
        if (len !== 1) {
            len = 1 / len;
            x *= len;
            y *= len;
            z *= len;
        }

        s = Math.sin(angle);
        c = Math.cos(angle);
        t = 1 - c;

        a00 = mat[0];
        a01 = mat[1];
        a02 = mat[2];
        a03 = mat[3];
        a10 = mat[4];
        a11 = mat[5];
        a12 = mat[6];
        a13 = mat[7];
        a20 = mat[8];
        a21 = mat[9];
        a22 = mat[10];
        a23 = mat[11];

        // Construct the elements of the rotation matrix
        b00 = x * x * t + c;
        b01 = y * x * t + z * s;
        b02 = z * x * t - y * s;
        b10 = x * y * t - z * s;
        b11 = y * y * t + c;
        b12 = z * y * t + x * s;
        b20 = x * z * t + y * s;
        b21 = y * z * t - x * s;
        b22 = z * z * t + c;

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform rotation-specific matrix multiplication
        dest[0] = a00 * b00 + a10 * b01 + a20 * b02;
        dest[1] = a01 * b00 + a11 * b01 + a21 * b02;
        dest[2] = a02 * b00 + a12 * b01 + a22 * b02;
        dest[3] = a03 * b00 + a13 * b01 + a23 * b02;

        dest[4] = a00 * b10 + a10 * b11 + a20 * b12;
        dest[5] = a01 * b10 + a11 * b11 + a21 * b12;
        dest[6] = a02 * b10 + a12 * b11 + a22 * b12;
        dest[7] = a03 * b10 + a13 * b11 + a23 * b12;

        dest[8] = a00 * b20 + a10 * b21 + a20 * b22;
        dest[9] = a01 * b20 + a11 * b21 + a21 * b22;
        dest[10] = a02 * b20 + a12 * b21 + a22 * b22;
        dest[11] = a03 * b20 + a13 * b21 + a23 * b22;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the X axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateX = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[0] = mat[0];
            dest[1] = mat[1];
            dest[2] = mat[2];
            dest[3] = mat[3];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[4] = a10 * c + a20 * s;
        dest[5] = a11 * c + a21 * s;
        dest[6] = a12 * c + a22 * s;
        dest[7] = a13 * c + a23 * s;

        dest[8] = a10 * -s + a20 * c;
        dest[9] = a11 * -s + a21 * c;
        dest[10] = a12 * -s + a22 * c;
        dest[11] = a13 * -s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Y axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateY = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a20 = mat[8],
            a21 = mat[9],
            a22 = mat[10],
            a23 = mat[11];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged rows
            dest[4] = mat[4];
            dest[5] = mat[5];
            dest[6] = mat[6];
            dest[7] = mat[7];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a20 * -s;
        dest[1] = a01 * c + a21 * -s;
        dest[2] = a02 * c + a22 * -s;
        dest[3] = a03 * c + a23 * -s;

        dest[8] = a00 * s + a20 * c;
        dest[9] = a01 * s + a21 * c;
        dest[10] = a02 * s + a22 * c;
        dest[11] = a03 * s + a23 * c;
        return dest;
    };

    /**
     * Rotates a matrix by the given angle around the Z axis
     *
     * @param {mat4} mat mat4 to rotate
     * @param {number} angle Angle (in radians) to rotate
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to mat
     *
     * @returns {mat4} dest if specified, mat otherwise
     */
    mat4.rotateZ = function (mat, angle, dest) {
        var s = Math.sin(angle),
            c = Math.cos(angle),
            a00 = mat[0],
            a01 = mat[1],
            a02 = mat[2],
            a03 = mat[3],
            a10 = mat[4],
            a11 = mat[5],
            a12 = mat[6],
            a13 = mat[7];

        if (!dest) {
            dest = mat;
        } else if (mat !== dest) { // If the source and destination differ, copy the unchanged last row
            dest[8] = mat[8];
            dest[9] = mat[9];
            dest[10] = mat[10];
            dest[11] = mat[11];

            dest[12] = mat[12];
            dest[13] = mat[13];
            dest[14] = mat[14];
            dest[15] = mat[15];
        }

        // Perform axis-specific matrix multiplication
        dest[0] = a00 * c + a10 * s;
        dest[1] = a01 * c + a11 * s;
        dest[2] = a02 * c + a12 * s;
        dest[3] = a03 * c + a13 * s;

        dest[4] = a00 * -s + a10 * c;
        dest[5] = a01 * -s + a11 * c;
        dest[6] = a02 * -s + a12 * c;
        dest[7] = a03 * -s + a13 * c;

        return dest;
    };

    /**
     * Generates a frustum matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.frustum = function (left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = (near * 2) / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = (near * 2) / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = (right + left) / rl;
        dest[9] = (top + bottom) / tb;
        dest[10] = -(far + near) / fn;
        dest[11] = -1;
        dest[12] = 0;
        dest[13] = 0;
        dest[14] = -(far * near * 2) / fn;
        dest[15] = 0;
        return dest;
    };

    /**
     * Generates a perspective projection matrix with the given bounds
     *
     * @param {number} fovy Vertical field of view
     * @param {number} aspect Aspect ratio. typically viewport width/height
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.perspective = function (fovy, aspect, near, far, dest) {
        var top = near * Math.tan(fovy * Math.PI / 360.0),
            right = top * aspect;
        return mat4.frustum(-right, right, -top, top, near, far, dest);
    };

    /**
     * Generates a orthogonal projection matrix with the given bounds
     *
     * @param {number} left Left bound of the frustum
     * @param {number} right Right bound of the frustum
     * @param {number} bottom Bottom bound of the frustum
     * @param {number} top Top bound of the frustum
     * @param {number} near Near bound of the frustum
     * @param {number} far Far bound of the frustum
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.ortho = function (left, right, bottom, top, near, far, dest) {
        if (!dest) {
            dest = mat4.create();
        }
        var rl = (right - left),
            tb = (top - bottom),
            fn = (far - near);
        dest[0] = 2 / rl;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 0;
        dest[4] = 0;
        dest[5] = 2 / tb;
        dest[6] = 0;
        dest[7] = 0;
        dest[8] = 0;
        dest[9] = 0;
        dest[10] = -2 / fn;
        dest[11] = 0;
        dest[12] = -(left + right) / rl;
        dest[13] = -(top + bottom) / tb;
        dest[14] = -(far + near) / fn;
        dest[15] = 1;
        return dest;
    };

    /**
     * Generates a look-at matrix with the given eye position, focal point, and up axis
     *
     * @param {vec3} eye Position of the viewer
     * @param {vec3} center Point the viewer is looking at
     * @param {vec3} up vec3 pointing "up"
     * @param {mat4} [dest] mat4 frustum matrix will be written into
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    mat4.lookAt = function (eye, center, up, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
            eyex = eye[0],
            eyey = eye[1],
            eyez = eye[2],
            upx = up[0],
            upy = up[1],
            upz = up[2],
            centerx = center[0],
            centery = center[1],
            centerz = center[2];

        if (eyex === centerx && eyey === centery && eyez === centerz) {
            return mat4.identity(dest);
        }

        //vec3.direction(eye, center, z);
        z0 = eyex - centerx;
        z1 = eyey - centery;
        z2 = eyez - centerz;

        // normalize (no check needed for 0 because of early return)
        len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
        z0 *= len;
        z1 *= len;
        z2 *= len;

        //vec3.normalize(vec3.cross(up, z, x));
        x0 = upy * z2 - upz * z1;
        x1 = upz * z0 - upx * z2;
        x2 = upx * z1 - upy * z0;
        len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
        if (!len) {
            x0 = 0;
            x1 = 0;
            x2 = 0;
        } else {
            len = 1 / len;
            x0 *= len;
            x1 *= len;
            x2 *= len;
        }

        //vec3.normalize(vec3.cross(z, x, y));
        y0 = z1 * x2 - z2 * x1;
        y1 = z2 * x0 - z0 * x2;
        y2 = z0 * x1 - z1 * x0;

        len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
        if (!len) {
            y0 = 0;
            y1 = 0;
            y2 = 0;
        } else {
            len = 1 / len;
            y0 *= len;
            y1 *= len;
            y2 *= len;
        }

        dest[0] = x0;
        dest[1] = y0;
        dest[2] = z0;
        dest[3] = 0;
        dest[4] = x1;
        dest[5] = y1;
        dest[6] = z1;
        dest[7] = 0;
        dest[8] = x2;
        dest[9] = y2;
        dest[10] = z2;
        dest[11] = 0;
        dest[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
        dest[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
        dest[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
        dest[15] = 1;

        return dest;
    };

    /**
     * Creates a matrix from a quaternion rotation and vector translation
     * This is equivalent to (but much faster than):
     *
     *     mat4.identity(dest);
     *     mat4.translate(dest, vec);
     *     var quatMat = mat4.create();
     *     quat4.toMat4(quat, quatMat);
     *     mat4.multiply(dest, quatMat);
     *
     * @param {quat4} quat Rotation quaternion
     * @param {vec3} vec Translation vector
     * @param {mat4} [dest] mat4 receiving operation result. If not specified result is written to a new mat4
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    /*    mat4.fromRotationTranslation = function (quat, vec, dest) {
     if (!dest) { dest = mat4.create(); }

     // Quaternion math
     var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
     x2 = x + x,
     y2 = y + y,
     z2 = z + z,

     xx = x * x2,
     xy = x * y2,
     xz = x * z2,
     yy = y * y2,
     yz = y * z2,
     zz = z * z2,
     wx = w * x2,
     wy = w * y2,
     wz = w * z2;

     dest[0] = 1 - (yy + zz);
     dest[1] = xy + wz;
     dest[2] = xz - wy;
     dest[3] = 0;
     dest[4] = xy - wz;
     dest[5] = 1 - (xx + zz);
     dest[6] = yz + wx;
     dest[7] = 0;
     dest[8] = xz + wy;
     dest[9] = yz - wx;
     dest[10] = 1 - (xx + yy);
     dest[11] = 0;
     dest[12] = vec[0];
     dest[13] = vec[1];
     dest[14] = vec[2];
     dest[15] = 1;

     return dest;
     };*/

    /**
     * Returns a string representation of a mat4
     *
     * @param {mat4} mat mat4 to represent as a string
     *
     * @returns {string} String representation of mat
     */
    mat4.str = function (mat) {
        return '[' + mat[0] + ', ' + mat[1] + ', ' + mat[2] + ', ' + mat[3] +
            ', ' + mat[4] + ', ' + mat[5] + ', ' + mat[6] + ', ' + mat[7] +
            ', ' + mat[8] + ', ' + mat[9] + ', ' + mat[10] + ', ' + mat[11] +
            ', ' + mat[12] + ', ' + mat[13] + ', ' + mat[14] + ', ' + mat[15] + ']';
    };

    /**
     * @class Quaternion
     * @name quat4
     */
    var quat4 = {};

    /**
     * Creates a new instance of a quat4 using the default array type
     * Any javascript array containing at least 4 numeric elements can serve as a quat4
     *
     * @param {quat4} [quat] quat4 containing values to initialize with
     *
     * @returns {quat4} New quat4
     */
    quat4.create = function (quat) {
        var dest = new MatrixArray(4);

        if (quat) {
            dest[0] = quat[0];
            dest[1] = quat[1];
            dest[2] = quat[2];
            dest[3] = quat[3];
        } else {
            dest[0] = dest[1] = dest[2] = dest[3] = 0;
        }

        return dest;
    };

    /**
     * Creates a new instance of a quat4, initializing it with the given arguments
     *
     * @param {number} x X value
     * @param {number} y Y value
     * @param {number} z Z value
     * @param {number} w W value

     * @returns {quat4} New quat4
     */
    quat4.createFrom = function (x, y, z, w) {
        var dest = new MatrixArray(4);

        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = w;

        return dest;
    };

    /**
     * Copies the values of one quat4 to another
     *
     * @param {quat4} quat quat4 containing values to copy
     * @param {quat4} dest quat4 receiving copied values
     *
     * @returns {quat4} dest
     */
    quat4.set = function (quat, dest) {
        dest[0] = quat[0];
        dest[1] = quat[1];
        dest[2] = quat[2];
        dest[3] = quat[3];

        return dest;
    };

    /**
     * Compares two quaternions for equality within a certain margin of error
     *
     * @param {quat4} a First vector
     * @param {quat4} b Second vector
     *
     * @returns {Boolean} True if a is equivalent to b
     */
    quat4.equal = function (a, b) {
        return a === b || (
                Math.abs(a[0] - b[0]) < FLOAT_EPSILON &&
                Math.abs(a[1] - b[1]) < FLOAT_EPSILON &&
                Math.abs(a[2] - b[2]) < FLOAT_EPSILON &&
                Math.abs(a[3] - b[3]) < FLOAT_EPSILON
            );
    };

    /**
     * Creates a new identity Quat4
     *
     * @param {quat4} [dest] quat4 receiving copied values
     *
     * @returns {quat4} dest is specified, new quat4 otherwise
     */
    quat4.identity = function (dest) {
        if (!dest) {
            dest = quat4.create();
        }
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    //var identityQuat4 = quat4.identity();

    /**
     * Calculates the W component of a quat4 from the X, Y, and Z components.
     * Assumes that quaternion is 1 unit in length.
     * Any existing W component will be ignored.
     *
     * @param {quat4} quat quat4 to calculate W component of
     * @param {quat4} [dest] quat4 receiving calculated values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.calculateW = function (quat, dest) {
        var x = quat[0], y = quat[1], z = quat[2];

        if (!dest || quat === dest) {
            quat[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
            return quat;
        }
        dest[0] = x;
        dest[1] = y;
        dest[2] = z;
        dest[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
        return dest;
    };

    /**
     * Calculates the dot product of two quaternions
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     *
     * @return {number} Dot product of quat and quat2
     */
    quat4.dot = function (quat, quat2) {
        return quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3];
    };

    /**
     * Calculates the inverse of a quat4
     *
     * @param {quat4} quat quat4 to calculate inverse of
     * @param {quat4} [dest] quat4 receiving inverse values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.inverse = function (quat, dest) {
        var q0 = quat[0], q1 = quat[1], q2 = quat[2], q3 = quat[3],
            dot = q0 * q0 + q1 * q1 + q2 * q2 + q3 * q3,
            invDot = dot ? 1.0 / dot : 0;

        // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

        if (!dest || quat === dest) {
            quat[0] *= -invDot;
            quat[1] *= -invDot;
            quat[2] *= -invDot;
            quat[3] *= invDot;
            return quat;
        }
        dest[0] = -quat[0] * invDot;
        dest[1] = -quat[1] * invDot;
        dest[2] = -quat[2] * invDot;
        dest[3] = quat[3] * invDot;
        return dest;
    };


    /**
     * Calculates the conjugate of a quat4
     * If the quaternion is normalized, this function is faster than quat4.inverse and produces the same result.
     *
     * @param {quat4} quat quat4 to calculate conjugate of
     * @param {quat4} [dest] quat4 receiving conjugate values. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.conjugate = function (quat, dest) {
        if (!dest || quat === dest) {
            quat[0] *= -1;
            quat[1] *= -1;
            quat[2] *= -1;
            return quat;
        }
        dest[0] = -quat[0];
        dest[1] = -quat[1];
        dest[2] = -quat[2];
        dest[3] = quat[3];
        return dest;
    };

    /**
     * Calculates the length of a quat4
     *
     * Params:
     * @param {quat4} quat quat4 to calculate length of
     *
     * @returns Length of quat
     */
    quat4.length = function (quat) {
        var x = quat[0], y = quat[1], z = quat[2], w = quat[3];
        return Math.sqrt(x * x + y * y + z * z + w * w);
    };

    /**
     * Generates a unit quaternion of the same direction as the provided quat4
     * If quaternion length is 0, returns [0, 0, 0, 0]
     *
     * @param {quat4} quat quat4 to normalize
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.normalize = function (quat, dest) {
        if (!dest) {
            dest = quat;
        }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            len = Math.sqrt(x * x + y * y + z * z + w * w);
        if (len === 0) {
            dest[0] = 0;
            dest[1] = 0;
            dest[2] = 0;
            dest[3] = 0;
            return dest;
        }
        len = 1 / len;
        dest[0] = x * len;
        dest[1] = y * len;
        dest[2] = z * len;
        dest[3] = w * len;

        return dest;
    };

    /**
     * Performs quaternion addition
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.add = function (quat, quat2, dest) {
        if (!dest || quat === dest) {
            quat[0] += quat2[0];
            quat[1] += quat2[1];
            quat[2] += quat2[2];
            quat[3] += quat2[3];
            return quat;
        }
        dest[0] = quat[0] + quat2[0];
        dest[1] = quat[1] + quat2[1];
        dest[2] = quat[2] + quat2[2];
        dest[3] = quat[3] + quat2[3];
        return dest;
    };

    /**
     * Performs a quaternion multiplication
     *
     * @param {quat4} quat First operand
     * @param {quat4} quat2 Second operand
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.multiply = function (quat, quat2, dest) {
        if (!dest) {
            dest = quat;
        }

        var qax = quat[0], qay = quat[1], qaz = quat[2], qaw = quat[3],
            qbx = quat2[0], qby = quat2[1], qbz = quat2[2], qbw = quat2[3];

        dest[0] = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
        dest[1] = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
        dest[2] = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
        dest[3] = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

        return dest;
    };

    /**
     * Transforms a vec3 with the given quaternion
     *
     * @param {quat4} quat quat4 to transform the vector with
     * @param {vec3} vec vec3 to transform
     * @param {vec3} [dest] vec3 receiving operation result. If not specified result is written to vec
     *
     * @returns dest if specified, vec otherwise
     */
    quat4.multiplyVec3 = function (quat, vec, dest) {
        if (!dest) {
            dest = vec;
        }

        var x = vec[0], y = vec[1], z = vec[2],
            qx = quat[0], qy = quat[1], qz = quat[2], qw = quat[3],

        // calculate quat * vec
            ix = qw * x + qy * z - qz * y,
            iy = qw * y + qz * x - qx * z,
            iz = qw * z + qx * y - qy * x,
            iw = -qx * x - qy * y - qz * z;

        // calculate result * inverse quat
        dest[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        dest[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        dest[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;

        return dest;
    };

    /**
     * Multiplies the components of a quaternion by a scalar value
     *
     * @param {quat4} quat to scale
     * @param {number} val Value to scale by
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.scale = function (quat, val, dest) {
        if (!dest || quat === dest) {
            quat[0] *= val;
            quat[1] *= val;
            quat[2] *= val;
            quat[3] *= val;
            return quat;
        }
        dest[0] = quat[0] * val;
        dest[1] = quat[1] * val;
        dest[2] = quat[2] * val;
        dest[3] = quat[3] * val;
        return dest;
    };

    /**
     * Calculates a 4x4 matrix from the given quat4
     *
     * @param {quat4} quat quat4 to create matrix from
     * @param {mat4} [dest] mat4 receiving operation result
     *
     * @returns {mat4} dest if specified, a new mat4 otherwise
     */
    quat4.toMat4 = function (quat, dest) {
        if (!dest) {
            dest = mat4.create();
        }

        var x = quat[0], y = quat[1], z = quat[2], w = quat[3],
            x2 = x + x,
            y2 = y + y,
            z2 = z + z,

            xx = x * x2,
            xy = x * y2,
            xz = x * z2,
            yy = y * y2,
            yz = y * z2,
            zz = z * z2,
            wx = w * x2,
            wy = w * y2,
            wz = w * z2;

        dest[0] = 1 - (yy + zz);
        dest[1] = xy + wz;
        dest[2] = xz - wy;
        dest[3] = 0;

        dest[4] = xy - wz;
        dest[5] = 1 - (xx + zz);
        dest[6] = yz + wx;
        dest[7] = 0;

        dest[8] = xz + wy;
        dest[9] = yz - wx;
        dest[10] = 1 - (xx + yy);
        dest[11] = 0;

        dest[12] = 0;
        dest[13] = 0;
        dest[14] = 0;
        dest[15] = 1;

        return dest;
    };

    /**
     * Performs a spherical linear interpolation between two quat4
     *
     * @param {quat4} quat First quaternion
     * @param {quat4} quat2 Second quaternion
     * @param {number} slerp Interpolation amount between the two inputs
     * @param {quat4} [dest] quat4 receiving operation result. If not specified result is written to quat
     *
     * @returns {quat4} dest if specified, quat otherwise
     */
    quat4.slerp = function (quat, quat2, slerp, dest) {
        if (!dest) {
            dest = quat;
        }

        var cosHalfTheta = quat[0] * quat2[0] + quat[1] * quat2[1] + quat[2] * quat2[2] + quat[3] * quat2[3],
            halfTheta,
            sinHalfTheta,
            ratioA,
            ratioB;

        if (Math.abs(cosHalfTheta) >= 1.0) {
            if (dest !== quat) {
                dest[0] = quat[0];
                dest[1] = quat[1];
                dest[2] = quat[2];
                dest[3] = quat[3];
            }
            return dest;
        }

        halfTheta = Math.acos(cosHalfTheta);
        sinHalfTheta = Math.sqrt(1.0 - cosHalfTheta * cosHalfTheta);

        if (Math.abs(sinHalfTheta) < 0.001) {
            dest[0] = (quat[0] * 0.5 + quat2[0] * 0.5);
            dest[1] = (quat[1] * 0.5 + quat2[1] * 0.5);
            dest[2] = (quat[2] * 0.5 + quat2[2] * 0.5);
            dest[3] = (quat[3] * 0.5 + quat2[3] * 0.5);
            return dest;
        }

        ratioA = Math.sin((1 - slerp) * halfTheta) / sinHalfTheta;
        ratioB = Math.sin(slerp * halfTheta) / sinHalfTheta;

        dest[0] = (quat[0] * ratioA + quat2[0] * ratioB);
        dest[1] = (quat[1] * ratioA + quat2[1] * ratioB);
        dest[2] = (quat[2] * ratioA + quat2[2] * ratioB);
        dest[3] = (quat[3] * ratioA + quat2[3] * ratioB);

        return dest;
    };

    /**
     * Creates a quaternion from the given 3x3 rotation matrix.
     * If dest is omitted, a new quaternion will be created.
     *
     * @param {mat3}  mat    the rotation matrix
     * @param {quat4} [dest] an optional receiving quaternion
     *
     * @returns {quat4} the quaternion constructed from the rotation matrix
     *
     */
    quat4.fromRotationMatrix = function (mat, dest) {
        if (!dest) dest = quat4.create();

        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
        // article "Quaternion Calculus and Fast Animation".

        var fTrace = mat[0] + mat[4] + mat[8];
        var fRoot;

        if (fTrace > 0.0) {
            // |w| > 1/2, may as well choose w > 1/2
            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
            dest[3] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;  // 1/(4w)
            dest[0] = (mat[7] - mat[5]) * fRoot;
            dest[1] = (mat[2] - mat[6]) * fRoot;
            dest[2] = (mat[3] - mat[1]) * fRoot;
        } else {
            // |w| <= 1/2
            var s_iNext = quat4.fromRotationMatrix.s_iNext = quat4.fromRotationMatrix.s_iNext || [1, 2, 0];
            var i = 0;
            if (mat[4] > mat[0])
                i = 1;
            if (mat[8] > mat[i * 3 + i])
                i = 2;
            var j = s_iNext[i];
            var k = s_iNext[j];

            fRoot = Math.sqrt(mat[i * 3 + i] - mat[j * 3 + j] - mat[k * 3 + k] + 1.0);
            dest[i] = 0.5 * fRoot;
            fRoot = 0.5 / fRoot;
            dest[3] = (mat[k * 3 + j] - mat[j * 3 + k]) * fRoot;
            dest[j] = (mat[j * 3 + i] + mat[i * 3 + j]) * fRoot;
            dest[k] = (mat[k * 3 + i] + mat[i * 3 + k]) * fRoot;
        }

        return dest;
    };


    /**
     * Sets a quat4 to the Identity and returns it.
     *
     * @param {quat4} [dest] quat4 to set. If omitted, a
     * new quat4 will be created.
     *
     * @returns {quat4} dest
     */
    quat4.identity = function (dest) {
        if (!dest) dest = quat4.create();
        dest[0] = 0;
        dest[1] = 0;
        dest[2] = 0;
        dest[3] = 1;
        return dest;
    };

    /**
     * Sets a quat4 from the given angle and rotation axis,
     * then returns it. If dest is not given, a new quat4 is created.
     *
     * @param {Number} angle  the angle in radians
     * @param {vec3}   axis   the axis around which to rotate
     * @param {quat4}  [dest] the optional quat4 to store the result
     *
     * @returns {quat4} dest
     **/
    quat4.fromAngleAxis = function (angle, axis, dest) {
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)
        if (!dest) dest = quat4.create();

        var half = angle * 0.5;
        var s = Math.sin(half);
        dest[3] = Math.cos(half);
        dest[0] = s * axis[0];
        dest[1] = s * axis[1];
        dest[2] = s * axis[2];

        return dest;
    };

    /**
     * Stores the angle and axis in a vec4, where the XYZ components represent
     * the axis and the W (4th) component is the angle in radians.
     *
     * If dest is not given, src will be modified in place and returned, after
     * which it should not be considered not a quaternion (just an axis and angle).
     *
     * @param {quat4} quat   the quaternion whose angle and axis to store
     * @param {vec4}  [dest] the optional vec4 to receive the data
     *
     * @returns {vec4} dest
     */
    quat4.toAngleAxis = function (src, dest) {
        if (!dest) dest = src;
        // The quaternion representing the rotation is
        //   q = cos(A/2)+sin(A/2)*(x*i+y*j+z*k)

        var sqrlen = src[0] * src[0] + src[1] * src[1] + src[2] * src[2];
        if (sqrlen > 0) {
            dest[3] = 2 * Math.acos(src[3]);
            var invlen = 1.0 / Math.sqrt(sqrlen);
            dest[0] = src[0] * invlen;
            dest[1] = src[1] * invlen;
            dest[2] = src[2] * invlen;
        } else {
            // angle is 0 (mod 2*pi), so any axis will do
            dest[3] = 0;
            dest[0] = 1;
            dest[1] = 0;
            dest[2] = 0;
        }

        return dest;
    };

    /**
     * Returns a string representation of a quaternion
     *
     * @param {quat4} quat quat4 to represent as a string
     *
     * @returns {string} String representation of quat
     */
    quat4.str = function (quat) {
        return '[' + quat[0] + ', ' + quat[1] + ', ' + quat[2] + ', ' + quat[3] + ']';
    };


    /*
     * Exports
     */

    window.vec3 = vec3;
    window.mat4 = mat4;
    window.quat4 = quat4;

    return mat4;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Tile',['../Renderer/BoundingBox', '../Renderer/glMatrix'],
    function (BoundingBox) {

        /**************************************************************************************************************/

        /**
         Tile constructor
         @name Tile
         @constructor
         */
        var Tile = function () {
            // Parent/child relationship
            this.parent = null;
            this.parentIndex = -1;
            this.children = null;

            // Graphics data to render the tile
            this.vertices = null;
            this.texture = null;
            this.vertexBuffer = null;
            this.texTransform = [1.0, 1.0, 0.0, 0.0];

            // Tile spatial data
            this.matrix = null;
            this.inverseMatrix = null;
            this.bbox = new BoundingBox();

            // For culling
            this.radius = 0.0;
            this.distance = 0.0;
            this.closestPointToEye = [0.0, 0.0, 0.0];

            // Specific object to store extension from renderers
            this.extension = {};

            // For debug
            //this.color = [ Math.random(), Math.random(), Math.random() ];

            this.state = Tile.State.NONE;

            // Tile configuration given by tile manager : contains if the tile uses skirt, the tesselation, etc...
            this.config = null;
            this.imageSize = 256;
        };

        /**************************************************************************************************************/

        /**
         *    Tile state enumerations
         */
        Tile.State =
        {
            ERROR: -10,
            NONE: 0,
            REQUESTED: 1,
            LOADING: 2,
            LOADED: 3
        };


        /**************************************************************************************************************/

        /**
         * Compute position on the tile using normalized coordinate between [0,size-1]
         */
        Tile.prototype.computePosition = function (u, v) {
            var size = this.config.tesselation;
            u = Math.min(size - 1, Math.max(0, u));
            v = Math.min(size - 1, Math.max(0, v));

            var vFloor = Math.floor(v);
            var vFrac = v - vFloor;
            var uFloor = Math.floor(u);
            var uFrac = u - uFloor;
            var vertexSize = this.config.vertexSize;
            var vertexOffset = vertexSize * ( vFloor * size + uFloor );
            var vec = [0.0, 0.0, 0.0];
            for (var i = 0; i < 3; i++) {
                vec[i] = (1.0 - vFrac) * (1.0 - uFrac) * this.vertices[vertexOffset + i] +
                    vFrac * (1.0 - uFrac) * this.vertices[vertexOffset + vertexSize * size + i] +
                    vFrac * uFrac * this.vertices[vertexOffset + vertexSize * size + vertexSize + i] +
                    (1.0 - vFrac) * uFrac * this.vertices[vertexOffset + vertexSize + i];
            }
            return vec;
        };


        /**************************************************************************************************************/

        /**
         *    Initialize the tile from its parent
         */
        Tile.prototype.initFromParent = function (parent, i, j) {
            this.parent = parent;
            this.parentIndex = j * 2 + i;
            this.matrix = parent.matrix;
            this.inverseMatrix = parent.inverseMatrix;
            this.texture = parent.texture;
            this.config = parent.config;

            this.vertexBuffer = parent.vertexBuffer;

            // Recompute the bounding box
            // Very fast and coarse version but it does not work with HEALPix tiling
            //var w = 0.5 * (parent.bbox.max[0] - parent.bbox.min[0]);
            //var h = -0.5 * (parent.bbox.max[1] - parent.bbox.min[1]);
            //var min = [  parent.bbox.min[0] + i * w, parent.bbox.max[1] + (j+1) * h, parent.bbox.min[2] ];
            //var max = [  parent.bbox.min[0] + (i+1) * w, parent.bbox.max[1] + j * h, parent.bbox.max[2] ];

            var size = this.config.tesselation;
            var halfTesselation = (size - 1) / 2;
            for (var n = 0; n <= halfTesselation; n++) {
                var offset = this.config.vertexSize * ( (n + j * halfTesselation) * size + i * halfTesselation );
                for (var k = 0; k <= halfTesselation; k++) {
                    this.bbox.extend(parent.vertices[offset], parent.vertices[offset + 1], parent.vertices[offset + 2]);
                    offset += this.config.vertexSize;
                }
            }

            // Compute the bounding box
            this.radius = this.bbox.getRadius();

            // Init extension
            for (var x in parent.extension) {
                if(parent.extension.hasOwnProperty(x)) {
                    var e = parent.extension[x];
                    if (e.initChild) {
                        e.initChild(this, i, j);
                    }
                }
            }

        };

        /**************************************************************************************************************/

        /**
         *    Test if the tile needs to be refined
         */
        Tile.prototype.needsToBeRefined = function (renderContext) {
            if (this.distance < this.radius) {
                return true;
            }
            // Approximate the radius of one texel : the radius of the tile divided by the image size
            // The radius is taken as the average of the bbox width and length, rather than the actual radius because at the pole, there is a large difference betwen width and length
            // and the radius (ie maximum width/length) is too pessimistic
            var radius = 0.25 * ( (this.bbox.max[0] - this.bbox.min[0]) + (this.bbox.max[1] - this.bbox.min[1]) ) / this.imageSize;

            // Transform the closest point from the eye in world coordinates
            var mat = this.matrix;
            var c = this.closestPointToEye;
            var px = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
            var py = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
            var pz = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

            // Compute the pixel size of the radius texel
            var pixelSizeVector = renderContext.pixelSizeVector;
            var pixelSize = radius / ( px * pixelSizeVector[0] + py * pixelSizeVector[1] +
                pz * pixelSizeVector[2] + pixelSizeVector[3] );
            // Check if pixel radius of a texel is superior to the treshold
            // The pixel size can be negative when the closest point is close to the near plane, so take absolute value
            return Math.abs(pixelSize) > renderContext.tileErrorTreshold;
        };

        /**************************************************************************************************************/

        /**
         *    Test if the tile is culled given the current view parameters
         */
        Tile.prototype.isCulled = function (renderContext) {
            // Compute the eye in tile local space
            var mat = this.inverseMatrix;
            var c = renderContext.eyePosition;
            var ex = mat[0] * c[0] + mat[4] * c[1] + mat[8] * c[2] + mat[12];
            var ey = mat[1] * c[0] + mat[5] * c[1] + mat[9] * c[2] + mat[13];
            var ez = mat[2] * c[0] + mat[6] * c[1] + mat[10] * c[2] + mat[14];

            // If the eye is in the radius of the tile, consider the tile is not culled
            this.distance = Math.sqrt(ex * ex + ey * ey + ez * ez);
            if (this.distance < this.radius) {
                this.distance = 0.0;
                return false;
            }
            else {
                var pt = this.closestPointToEye;

                // Compute closest point to eye with the bbox of the tile
                pt[0] = Math.min(Math.max(ex, this.bbox.min[0]), this.bbox.max[0]);
                pt[1] = Math.min(Math.max(ey, this.bbox.min[1]), this.bbox.max[1]);
                pt[2] = Math.min(Math.max(ez, this.bbox.min[2]), this.bbox.max[2]);

                // Compute horizontal culling only if the eye is "behind" the tile
                // and the coordinate system is not a plane(no need to compute horizon culling on plane)
                if (ez < 0.0 && !this.config.coordinateSystem.isFlat()) {
                    // Compute vertical at the closest point. The earth center is [0, 0, -radius] in tile local space.
                    var vx = pt[0];
                    var vy = pt[1];
                    var vz = pt[2] + this.config.coordinateSystem.geoide.radius;
                    var vl = Math.sqrt(vx * vx + vy * vy + vz * vz);
                    vx /= vl;
                    vy /= vl;
                    vz /= vl;

                    // Compute eye direction at the closest point (clampled on earth to avoid problem with mountains)
                    // The position clamp to earth is Vertical * Radius + EarthCenter. The EarthCenter being 0,0,-radius a lot of simplification is done.
                    var edx = ex - vx * this.config.coordinateSystem.geoide.radius;
                    var edy = ey - vy * this.config.coordinateSystem.geoide.radius;
                    var edz = ez - (vz - 1.0) * this.config.coordinateSystem.geoide.radius;

                    // Compute dot product between eye direction and the vertical at the point
                    var el = Math.sqrt(edx * edx + edy * edy + edz * edz);
                    var eDv = (edx * vx + edy * vy + edz * vz) / el;

                    eDv *= this.config.cullSign;

                    if (eDv < -0.05) {
                        return true;
                    }
                }

                // Compute local frustum
                var localFrustum = renderContext.localFrustum;
                localFrustum.inverseTransform(renderContext.worldFrustum, this.matrix);

                // Check if the tile is inside the frustum
                return !localFrustum.containsBoundingBox(this.bbox);
            }
        };

        /**************************************************************************************************************/

        /**
         *    Dispose the tile
         */
        Tile.prototype.dispose = function (renderContext, tilePool) {
            // Dispose extension even if tile isn't loaded because it can be culled
            for (var x in this.extension) {
                if (this.extension[x].dispose) {
                    this.extension[x].dispose(renderContext, tilePool);
                  }
            }

            if (this.state === Tile.State.LOADED) {
                tilePool.disposeGLBuffer(this.vertexBuffer);
                if (this.texture) {
                  tilePool.disposeGLTexture(this.texture);
                }

                this.vertexBuffer = null;
                this.texture = null;
                this.parent = null;

                this.state = Tile.State.NONE;
            }
        };

        /**************************************************************************************************************/

        /**
         *    Delete the children
         */
        Tile.prototype.deleteChildren = function (renderContext, tilePool) {
            if (this.children) {
                for (var i = 0; i < 4; i++) {
                    // Recursively delete its children
                    this.children[i].deleteChildren(renderContext, tilePool);
                    // Dispose its ressources (WebGL)
                    this.children[i].dispose(renderContext, tilePool);
                }

                // Cleanup the tile
                this.children = null;
            }
        };

        /**************************************************************************************************************/

        /**
         *    Build skirt vertices
         */
        Tile.prototype.buildSkirtVertices = function (center, srcOffset, srcStep, dstOffset) {
            var vertices = this.vertices;
            var skirtHeight = this.radius * 0.05;

            var size = this.config.tesselation;
            for (var i = 0; i < size; i++) {
                /*		//Not optimized version of skirt computation
                 var srcPos = [ vertices[srcOffset], vertices[srcOffset+1], vertices[srcOffset+2] ];
                 var dir = vec3.subtract( srcPos, center, vec3.create() );
                 vec3.normalize(dir);
                 vec3.scale( dir, skirtHeight );
                 vec3.subtract( srcPos, dir );*/

                // Optimized version of skirt computation
                var x = vertices[srcOffset] - center[0];
                var y = vertices[srcOffset + 1] - center[1];
                var z = vertices[srcOffset + 2] - center[2];
                var scale = skirtHeight / Math.sqrt(x * x + y * y + z * z);
                x *= scale;
                y *= scale;
                z *= scale;

                vertices[dstOffset] = vertices[srcOffset] - x;
                vertices[dstOffset + 1] = vertices[srcOffset + 1] - y;
                vertices[dstOffset + 2] = vertices[srcOffset + 2] - z;

                for (var n = 3; n < this.config.vertexSize; n++) {
                    vertices[dstOffset + n] = vertices[srcOffset + n];
                }

                dstOffset += this.config.vertexSize;
                srcOffset += srcStep;
            }
        };

        /**************************************************************************************************************/

        /**
         *    Generate normals for a tile
         */
        Tile.prototype.generateNormals = function () {
            var size = this.config.tesselation;
            var vertexSize = this.config.vertexSize;
            var lineSize = vertexSize * size;

            var vo = 0;
            for (var j = 0; j < size; j++) {
                var vp1 = j === size - 1 ? 0 : lineSize;
                var vm1 = j === 0 ? 0 : -lineSize;
                for (var i = 0; i < size; i++) {
                    var up1 = i === size - 1 ? 0 : vertexSize;
                    var um1 = i === 0 ? 0 : -vertexSize;
                    var u = [
                        this.vertices[vo + up1] - this.vertices[vo + um1],
                        this.vertices[vo + up1 + 1] - this.vertices[vo + um1 + 1],
                        this.vertices[vo + up1 + 2] - this.vertices[vo + um1 + 2]
                    ];
                    var v = [
                        this.vertices[vo + vp1] - this.vertices[vo + vm1],
                        this.vertices[vo + vp1 + 1] - this.vertices[vo + vm1 + 1],
                        this.vertices[vo + vp1 + 2] - this.vertices[vo + vm1 + 2]
                    ];

                    var normal = vec3.cross(u, v, []);
                    vec3.normalize(normal);
                    this.vertices[vo + 3] = normal[0];
                    this.vertices[vo + 4] = normal[1];
                    this.vertices[vo + 5] = normal[2];

                    vo += vertexSize;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         *    Generate the tile
         */
        Tile.prototype.generate = function (tilePool, image, elevations) {
            // Generate the vertices
            this.vertices = this.generateVertices(elevations);

            // Compute the bounding box
            var size = this.config.tesselation;
            var vertexSize = this.config.vertexSize;
            this.bbox.compute(this.vertices, vertexSize * size * size, vertexSize);
            this.radius = this.bbox.getRadius();

            // Compute normals if needed
            if (this.config.normals) {
                this.generateNormals();
            }
            // Compute skirt from vertices
            if (this.config.skirt) {
                // Compute local earth center, used to generate skirts
                var localEarthCenter = [0.0, 0.0, 0.0];
                mat4.multiplyVec3(this.inverseMatrix, localEarthCenter);

                // Skirts
                var dstOffset = vertexSize * (size * size); // TOP
                this.buildSkirtVertices(localEarthCenter, 0, vertexSize, dstOffset);
                dstOffset += vertexSize * size; // BOTTOM
                this.buildSkirtVertices(localEarthCenter, vertexSize * (size * (size - 1)), vertexSize, dstOffset);
                dstOffset += vertexSize * size; // LEFT
                this.buildSkirtVertices(localEarthCenter, 0, vertexSize * size, dstOffset);
                dstOffset += vertexSize * size; // RIGHT
                this.buildSkirtVertices(localEarthCenter, vertexSize * (size - 1), vertexSize * size, dstOffset);

                // These skirts are only used by children tile
                dstOffset += vertexSize * size; // CENTER
                this.buildSkirtVertices(localEarthCenter, vertexSize * ( size * (size - 1) / 2 ), vertexSize, dstOffset);
                dstOffset += vertexSize * size; // MIDDLE
                this.buildSkirtVertices(localEarthCenter, vertexSize * ( (size - 1) / 2 ), vertexSize * size, dstOffset);
            }

            // Avoid double creation of vertex buffer for level0Tiles generation
            if (this.vertexBuffer !== null && this.parent === null) {
                tilePool.disposeGLBuffer(this.vertexBuffer);
            }
            this.vertexBuffer = tilePool.createGLBuffer(this.vertices);

            // Create texture
            if (image) {
                this.texture = tilePool.createGLTexture(image);
                this.imageSize = this.config.imageSize;
            }

            this.state = Tile.State.LOADED;
        };

        /**************************************************************************************************************/

        return Tile;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/ImageRequest',[], function () {

    /**
     *    @constructor
     *    ImageRequest constructor
     */
    var ImageRequest = function (options) {
        this.successCallback = options.successCallback;
        this.failCallback = options.failCallback;
        this.abortCallback = options.abortCallback;
        this.image = null;
    };

    /**************************************************************************************************************/

    /**
     *    Send image request
     */
    ImageRequest.prototype.send = function (url, crossOrigin) {
        this.image = new Image();
        this.image.crossOrigin = crossOrigin;
        this.image.dataType = "byte";

        var self = this;
        this.image.onload = function () {
            var isComplete = self.image.naturalWidth !== 0 && self.image.complete;
            if (isComplete) {
                self.successCallback(self);
            }
        };
        this.image.onerror = this.failCallback.bind(this);
        this.image.src = url;
    };

    /**************************************************************************************************************/

    /**
     *    Abort image request
     */
    ImageRequest.prototype.abort = function () {
        if (this.abortCallback) {
            this.abortCallback(this);
        }
        this.image.src = '';
    };

    /**************************************************************************************************************/

    return ImageRequest;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/RendererTileData',[],function() {

/**************************************************************************************************************/
 /**
  @name RendererTileData
  @class
	  RendererTileData constructor
    Contains a list of renderables for the tiles
  @param manager
  @constructor
  */
var RendererTileData = function(manager)
{
	this.manager = manager;
	this.renderables = [];
};

/**************************************************************************************************************/

/**
 * Initialize a child tile
 * @function initChild
 * @memberof RendererTileData.prototype
 * @param childTile
 * @param i
 * @param j
 */
RendererTileData.prototype.initChild = function(childTile,i,j)
{
	var childData;
	for ( var n = 0; n < this.renderables.length; n++ )
	{
		if ( this.renderables[n].initChild )
		{
			var r = this.renderables[n].initChild(i,j,childTile);
			if (r)
			{
				if (!childData) {
					childData = childTile.extension.renderer = new RendererTileData(this.manager);
				}
				childData.renderables.push( r );
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Traverse the renderer data
 * @function traverse
 * @memberof RendererTileData.prototype
 * @param {Tile} tile Tile
 * @param isLeaf
 */
RendererTileData.prototype.traverse = function(tile,isLeaf)
{
	for ( var i = 0; i < this.renderables.length; i++ )
	{
		var renderable = this.renderables[i];
		var bucket = renderable.bucket;
		if ( bucket.layer.isVisible() && bucket.layer.opacity > 0 )
		{
			if ( renderable.traverse )
			{
				renderable.traverse( this.manager, tile, isLeaf  );
			}
			else
			{
				if ( renderable.hasChildren && !isLeaf ) {
					continue;
				}

				this.manager.renderables.push( renderable );
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Get a renderable from the tile, given the bucket
 * @function getRenderable
 * @memberof RendererTileData.prototype
 * @param {Bucket} bucket Bucket
 * @return Renderable
 */
RendererTileData.prototype.getRenderable = function(bucket)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		if ( bucket === this.renderables[i].bucket )
		{
			return this.renderables[i];
		}
	}
	return null;
};

/**************************************************************************************************************/

/**
 * Dispose renderable data from tile
 * @function dispose
 * @memberof RendererTileData.prototype
 * @param renderContext
 * @param tilePool
 */
RendererTileData.prototype.dispose = function(renderContext,tilePool)
{
	for ( var i=0; i < this.renderables.length; i++ )
	{
		this.renderables[i].dispose(renderContext,tilePool);
	}
	this.renderables.length = 0;
};

/**************************************************************************************************************/

return RendererTileData;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/RasterOverlayRenderer',['./Program','../Tiling/Tile','../Utils/ImageRequest','./RendererTileData'], function(Program, Tile, ImageRequest, RendererTileData) {

/**************************************************************************************************************/

 /**
	 @name RasterOverlayRenderer
	 @class
	   RasterOverlayRenderer constructor
	 @param {AbstractGlobe} globe AbstractGLobe
	 @constructor
	 */

var RasterOverlayRenderer = function(globe)
{
	this.vertexShader = "attribute vec3 vertex;\n";
	this.vertexShader+= "attribute vec2 tcoord;\n";
	this.vertexShader+= "uniform mat4 modelViewMatrix;\n";
	this.vertexShader+= "uniform mat4 projectionMatrix;\n";
	this.vertexShader+= "uniform vec4 textureTransform; \n";
	this.vertexShader+= "varying vec2 texCoord;\n";
	this.vertexShader+= "void main(void) \n";
	this.vertexShader+= "{\n";
	this.vertexShader+= "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
	this.vertexShader+= "	texCoord = tcoord * textureTransform.xy + textureTransform.zw;\n";
	this.vertexShader+= "}\n";

	this.fragmentShader = "precision lowp float;\n";
	this.fragmentShader+= "varying vec2 texCoord;\n";
	this.fragmentShader+= "uniform sampler2D overlayTexture;\n";
	this.fragmentShader+= "uniform float opacity; \n";
	this.fragmentShader+= "void main(void)\n";
	this.fragmentShader+= "{\n";
	this.fragmentShader+= "	gl_FragColor.rgba = texture2D(overlayTexture, texCoord.xy); \n";
	this.fragmentShader+= "	gl_FragColor.a *= opacity; \n";
	this.fragmentShader+= "}\n";

	this.rendererManager = globe.vectorRendererManager;
	this.tileManager = globe.tileManager;


	this.programs = [];
	this.program = this.createProgram( {
		vertexCode: this.vertexShader,
		fragmentCode: this.fragmentShader,
		updateUniforms: null
	});

	this.buckets = [];
	this.imageRequests = [];
	this.frameNumber = 0;


	var self = this;
	for ( var i = 0; i < 4; i++ ) {
		var imageRequest = new ImageRequest({
			successCallback: function(){
				if ( this.renderable )
				{
					if ( this.renderable.bucket.layer.handleImage ) {
						this.renderable.bucket.layer.handleImage(this);
					}

					this.renderable.ownTexture = self.tileManager.tilePool.createGLTexture(this.image);
					this.renderable.texture = this.renderable.ownTexture;
					this.renderable.uvScale = 1.0;
					this.renderable.uTrans = 0.0;
					this.renderable.vTrans = 0.0;
					this.renderable.updateChildrenTexture();
					this.renderable.onRequestFinished(true);
					this.renderable = null;
					self.tileManager.renderContext.requestFrame();
				}
			},
			failCallback: function(){
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(true);
					this.renderable = null;
				}
			},
			abortCallback: function(){
				//console.log("Raster overlay request abort.");
				if ( this.renderable )
				{
					this.renderable.onRequestFinished(false);
					this.renderable = null;
				}
			}
		});

		this.imageRequests.push( imageRequest );
	}
};

/**************************************************************************************************************/

 /**
  @name RasterOverlayRenderable
  @class
    Create a renderable for the overlay.
    There is one renderable per overlay and per tile.
  @param {Bucket} bucket Bucket
  @constructor
  */
var RasterOverlayRenderable = function( bucket )
{
	this.bucket = bucket;
	this.ownTexture = null;
	this.texture = null;
	this.request = null;
	this.requestFinished = false;
	this.tile = null;
	this.uvScale = 1.0;
	this.uTrans = 0.0;
	this.vTrans = 0.0;
};

/**************************************************************************************************************/

/**
 * Called when a request is started
 * @function onRequestStarted
 * @memberof RasterOverlayRenderable.prototype
 * @param {String}request Request
 * @fires Context#startLoad
 */
RasterOverlayRenderable.prototype.onRequestStarted = function(request)
{
	this.request = request;
	this.requestFinished = false;
	var layer = this.bucket.layer;
	if ( layer._numRequests === 0 )
	{
		layer.globe.publishEvent('startLoad',layer);
	}
	layer._numRequests++;
};

/**************************************************************************************************************/

/**
 * Called when a request is finished
 * @function onRequestFinished
 * @memberof RasterOverlayRenderable.prototype
 * @param completed
 * @fires Context#endLoad
 */
RasterOverlayRenderable.prototype.onRequestFinished = function(completed)
{
	this.request = null;
	this.requestFinished = completed;
	var layer = this.bucket.layer;
	layer._numRequests--;
	if ( layer.globe && layer._numRequests === 0 )
	{
		layer.globe.publishEvent('endLoad',layer);
	}
};

/**************************************************************************************************************/

/**
 * Initialize a child renderable
 * @function initChild
 * @memberof RasterOverlayRenderable.prototype
 * @param i
 * @param j
 * @param childTile
 */
RasterOverlayRenderable.prototype.initChild = function(i,j,childTile)
{
	// Request finished and no texture  : no init needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return null;*/

	var renderable = this.bucket.createRenderable();
	renderable.tile = childTile;
	if ( this.texture )
	{
		renderable.texture = this.texture;
		renderable.uvScale = this.uvScale;
		renderable.uTrans = this.uTrans;
		renderable.vTrans = this.vTrans;
	}

	return renderable;
};

/**************************************************************************************************************/

/**
 * Generate child renderable
 * @function generateChild
 * @memberof RasterOverlayRenderable.prototype
 * @param {Tile} tile Tile
 */
RasterOverlayRenderable.prototype.generateChild = function( tile )
{
	// Request finished and no texture  : no generate needed for children
/*	// TODO : does not work because sometimes level 0 cannot be loaded
	if (this.requestFinished && !this.ownTexture)
		return;*/

	var r = this.bucket.renderer;
	r.addOverlayToTile( tile, this.bucket, this );
};

/**************************************************************************************************************/

/**
 * Update the children texture
 * @function updateChildrenTexture
 * @memberof RasterOverlayRenderable.prototype
 */
 RasterOverlayRenderable.prototype.updateChildrenTexture = function()
{
	if ( this.tile.children )
	{
		for ( var i = 0; i < 4; i++ )
		{
			var rd = this.tile.children[i].extension.renderer;
			if ( rd )
			{
				var cr = rd.getRenderable(this.bucket);
				if ( cr && !cr.ownTexture )
				{
					cr.updateTextureFromParent( this );
					cr.updateChildrenTexture();
				}
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Update texture from its parent
 * @function updateTextureFromParent
 * @memberof RasterOverlayRenderable.prototype
 * @param parent
 */
RasterOverlayRenderable.prototype.updateTextureFromParent = function( parent )
{
	if ( this.tile.state === Tile.State.LOADED )
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale * 0.5;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;

		this.uTrans += (this.tile.parentIndex & 1) ? this.uvScale : 0;
		this.vTrans += (this.tile.parentIndex & 2) ? this.uvScale : 0;
	}
	else
	{
		this.texture = parent.texture;
		this.uvScale = parent.uvScale;
		this.uTrans = parent.uTrans;
		this.vTrans = parent.vTrans;
	}
};

/**************************************************************************************************************/

/**
 * Traverse renderable : add it to renderables list if there is a texture
	 Request the texture
 * @function traverse
 * @memberof RasterOverlayRenderable.prototype
 * @param manager
 * @param {Tile} tile Tile
 * @param {Boolean} isLeaf
 */
 RasterOverlayRenderable.prototype.traverse = function( manager, tile, isLeaf  )
{
	if ( isLeaf && this.texture )
	{
		manager.renderables.push( this );
	}

	if (!this.requestFinished && this.tile.state === Tile.State.LOADED)
	{
		this.bucket.renderer.requestOverlayTextureForTile( this);
	}
};

/**************************************************************************************************************/

/**
 * Dispose the renderable
 * @function dispose
 * @memberof RasterOverlayRenderable.prototype
 * @param renderContext
 * @param tilePool
 */
RasterOverlayRenderable.prototype.dispose = function(renderContext,tilePool)
{
	if ( this.ownTexture )
	{
		tilePool.disposeGLTexture(this.ownTexture);
		this.ownTexture = null;
	}
};


/**************************************************************************************************************/

 /**
  @name Bucket
  @class
    Bucket constructor for RasterOverlay
  @param layer
  @constructor
  */
var Bucket = function(layer)
{
	this.layer = layer;
	this.renderer = null;
	// TODO : hack
	this.style = layer;
};

/**************************************************************************************************************/

/**
 * Create a renderable for this bucket
 * @function createRenderable
 * @memberof Bucket.prototype
 * @return {RasterOverlayRenderable} Renderable
 */
Bucket.prototype.createRenderable = function()
{
	return new RasterOverlayRenderable(this);
};

/**************************************************************************************************************/

/**
 * Add an overlay into the renderer.
 * The overlay is added to all loaded tiles.
 * @function addOverlay
 * @memberof RasterOverlayRenderer.prototype
 * @param overlay
 */
RasterOverlayRenderer.prototype.addOverlay = function( overlay )
{
	// Initialize num requests to 0
	overlay._numRequests = 0;

	var bucket = new Bucket(overlay);
	bucket.renderer = this;
	bucket.id = this.rendererManager.bucketId++;
	this.buckets.push( bucket );

	overlay._bucket = bucket;

	for ( var i = 0; i < this.tileManager.level0Tiles.length; i++ )
	{
		var tile = this.tileManager.level0Tiles[i];
		if ( tile.state === Tile.State.LOADED )
		{
			this.addOverlayToTile( tile, bucket );
		}
	}
};

/**************************************************************************************************************/

/**
 * Remove an overlay
 * The overlay is removed from all loaded tiles.
 * @function removeOverlay
 * @memberof RasterOverlayRenderer.prototype
 * @param overlay
 */
RasterOverlayRenderer.prototype.removeOverlay = function( overlay )
{
	var index = this.buckets.indexOf( overlay._bucket );
	this.buckets.splice(index,1);

	var rc = this.tileManager.renderContext;
	var tp = this.tileManager.tilePool;
	this.tileManager.visitTiles( function(tile)
			{
				var rs = tile.extension.renderer;
				var renderable = rs ?  rs.getRenderable( overlay._bucket ) : null;
				if ( renderable )
				{
					// Remove the renderable
					var index = rs.renderables.indexOf(renderable);
					rs.renderables.splice(index,1);

					// Dispose its data
					renderable.dispose(rc,tp);

					// Remove tile data if not needed anymore
					if ( rs.renderables.length === 0 ) {
						delete tile.extension.renderer;
					}
				}
			}
	);
};

/**************************************************************************************************************/

/**
 * Add an overlay into a tile.
 * Create tile data if needed, and create the renderable for the overlay.
 * @function addOverlayToTile
 * @memberof RasterOverlayRenderer.prototype
 * @param tile
 * @param bucket
 * @param parentRenderable
 */
RasterOverlayRenderer.prototype.addOverlayToTile = function( tile, bucket, parentRenderable )
{
	if (!this.overlayIntersects( tile.geoBound, bucket.layer )) {
		return;
	}

	if ( !tile.extension.renderer ) {
		tile.extension.renderer = new RendererTileData(this.rendererManager);
	}

	var renderable = bucket.createRenderable();
	renderable.tile = tile;
	tile.extension.renderer.renderables.push( renderable );

	if ( parentRenderable && parentRenderable.texture )
	{
		renderable.updateTextureFromParent( parentRenderable );
	}

	if ( tile.children )
	{
		// Add the overlay to loaded children
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state === Tile.State.LOADED )
			{
				this.addOverlayToTile( tile.children[i], bucket, renderable );
			}
		}
	}

};

/**************************************************************************************************************/

/**
 * Create an interpolated for polygon clipping
 */
var _createInterpolatedVertex = function( t, p1, p2 )
{
	return [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]) ];
};

/**************************************************************************************************************/

/**
 * Clip polygon to a side (used by bound-overlay intersection)
 * @function clipPolygonToSide
 * @memberof RasterOverlayRenderer.prototype
 * @param coord
 * @param sign
 * @param value
 * @param polygon
 */
RasterOverlayRenderer.prototype.clipPolygonToSide = function( coord, sign, value, polygon )
{
	var clippedPolygon = [];
	var t,newPoint;
	// iterate through vertices
	for ( var i = 0; i < polygon.length; i++ )
	{
		var p1 = polygon[i];
		var p2 = polygon[ (i+1) % polygon.length ];
		var val1 = p1[coord];
		var val2 = p2[coord];

		// test containement
		var firstInside = (val1 - value) * sign >= 0.0;
		var secondInside = (val2 - value) * sign >= 0.0;

		// output vertices for inside polygon
		if ( !firstInside && secondInside )
		{
			t = (value - val1) / (val2- val1);
			newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && secondInside )
		{
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && !secondInside )
		{
			t = (value - val1) / (val2- val1);
			newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
		}
	}

	return clippedPolygon;
};

/**************************************************************************************************************/

/**
 * Check the intersection between a geo bound and an overlay
 * @function overlayIntersects
 * @memberof RasterOverlayRenderer.prototype
 * @param bound
 * @param overlay
 * @return {Boolean} Is intersects ?
 */
RasterOverlayRenderer.prototype.overlayIntersects = function( bound, overlay )
{
	if ( overlay.coordinates )
	{
		var c;
		c = this.clipPolygonToSide( 0, 1, bound.west, overlay.coordinates );
		c = this.clipPolygonToSide( 0, -1, bound.east, c );
		c = this.clipPolygonToSide( 1, 1, bound.south, c );
		c = this.clipPolygonToSide( 1, -1, bound.north, c );
		return c.length > 0;
	}
	else if ( overlay.geoBound )
	{
		return overlay.geoBound.intersects( bound );
	}

	// No geobound or coordinates : always return true
	return true;
};

/**************************************************************************************************************/

/**
 * Generate Raster overlay data on the tile.
 * The method is called by TileManager when a new tile has been generated.
 * @function generateLevelZero
 * @memberof RasterOverlayRenderer.prototype
 * @param {Tile} tile Tile
 */
RasterOverlayRenderer.prototype.generateLevelZero = function( tile )
{
	// Traverse all overlays
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		this.addOverlayToTile(tile,this.buckets[i]);
	}
};

/**************************************************************************************************************/

/**
 * Request the overlay texture for a tile
 * @function requestOverlayTextureForTile
 * @memberof RasterOverlayRenderer.prototype
 * @param renderable
 */
RasterOverlayRenderer.prototype.requestOverlayTextureForTile = function( renderable )
{
	if ( !renderable.request )
	{
		var imageRequest;
		for ( var i = 0; i < this.imageRequests.length; i++ )
		{
			if ( !this.imageRequests[i].renderable  )
			{
				imageRequest = this.imageRequests[i];
				break;
			}
		}

		if ( imageRequest )
		{
			renderable.onRequestStarted(imageRequest);
			imageRequest.renderable = renderable;
			imageRequest.frameNumber = this.frameNumber;
			imageRequest.send(renderable.bucket.layer.getUrl(renderable.tile), renderable.bucket.layer.crossOrigin);
		}
	}
	else
	{
		renderable.request.frameNumber = this.frameNumber;
	}
};

/**************************************************************************************************************/

/**
 * Create program from customShader object
 * @function createProgram
 * @memberof RasterOverlayRenderer.prototype
 * @param customShader
 * @return {Program} Program
 */
RasterOverlayRenderer.prototype.createProgram = function(customShader)
{
	var program = new Program(this.tileManager.renderContext);
	program.createFromSource(this.vertexShader, customShader.fragmentCode);

    // Add program
    program.id = this.programs.length;
    this.programs.push({
    	fragmentCode: customShader.fragmentCode,
    	program: program
	});
	return program;
};

/**************************************************************************************************************/

/**
 * Get program if known by renderer, create otherwise
 * @function getProgram
 * @memberof RasterOverlayRenderer.prototype
 * @param customShader
 * @return {Program} Program
 */
RasterOverlayRenderer.prototype.getProgram = function(customShader) {

	var program;

    for(var id=0; id<this.programs.length; id++)
    {
        if( this.programs[id].fragmentCode === customShader.fragmentCode )
        {
        	program = this.programs[id].program;
        }
    }

    if ( !program )
    {
    	program = this.createProgram(customShader);
    }
    return program;
};

/**************************************************************************************************************/

/**
 *	Render the raster overlays for the given tiles
 * @function render
 * @memberof RasterOverlayRenderer.prototype
 * @param renderables
 * @param {Integer} start Start index
 * @param {Integer} end End index
 */
RasterOverlayRenderer.prototype.render = function( renderables, start, end )
{
	var rc = this.tileManager.renderContext;
 	var gl = rc.gl;

	// Update gl states
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );

	var modelViewMatrix = mat4.create();

	var currentTile = null;
	var currentIB = null;
	var currentProgram = null;

	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var bucket = renderable.bucket;
		var layer = bucket.layer;

		var updateUniforms;
		var program;
		if ( layer.customShader )
		{
			program = this.getProgram(layer.customShader);
			updateUniforms = layer.customShader.updateUniforms;
		}
		else
		{
			program = this.getProgram({
				vertexCode: this.vertexShader,
				fragmentCode: this.fragmentShader,
				updateUniforms: null
			});
		}

		// Apply program if changed
		if ( program !== currentProgram )
		{
			currentProgram = program;
			program.apply();

			gl.uniformMatrix4fv(program.uniforms.projectionMatrix, false, rc.projectionMatrix);
			gl.uniform1i(program.uniforms.overlayTexture, 0);

			// Bind tcoord buffer
			gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
			gl.vertexAttribPointer(program.attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
		}

		if (updateUniforms) {
			updateUniforms(gl, program);
		}

		// Bind the vertex buffer
		gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tile.vertexBuffer);
		gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 4*renderable.tile.config.vertexSize, 0);

		// Bind the index buffer only if different (index buffer is shared between tiles)
		var indexBuffer = ( renderable.tile.state === Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(renderable.tile.parentIndex);
		if ( currentIB !== indexBuffer )
		{
			gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer );
			currentIB = indexBuffer;
		}

		// Bind the tile tile matrix
		mat4.multiply( rc.viewMatrix, renderable.tile.matrix, modelViewMatrix );
		gl.uniformMatrix4fv(program.uniforms.modelViewMatrix, false, modelViewMatrix);

		gl.uniform1f(program.uniforms.opacity, layer.opacity );
		gl.uniform4f(program.uniforms.textureTransform, renderable.uvScale, renderable.uvScale, renderable.uTrans, renderable.vTrans );

		gl.activeTexture(gl.TEXTURE0);
		gl.bindTexture(gl.TEXTURE_2D, renderable.texture );

		// Finally draw the tiles
		gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
	}

	// reset gl states
	gl.disable(gl.BLEND);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc( gl.LESS );
};

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 * @function canApply
 * @memberof RasterOverlayRenderer.prototype
 * @param type
 * @param style
 * @return {Boolean} Can apply ?
 */
RasterOverlayRenderer.prototype.canApply = function(type,style)
{
	return false;
};

/**************************************************************************************************************/

return RasterOverlayRenderer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Cache',[],function () {

    /**
     *    Cache storing <AbstractRasterLayer> tile requests in browser's local storage
     *    Due to performance reasons, it's recommended to use it only for tiles of level 0
     *    @param options
     *        <ul>
     *            <li>layer: Layer which will contain the given cache(required)</li>
     *            <li>cacheLevel: the maximum level of tiles to be cached</li>
     *        </ul>
     */
    var Cache = function (options) {

        this.layer = options.layer;

        this.cacheLevel = options.hasOwnProperty('cacheLevel') ? options.cacheLevel : 1;

        if (!localStorage.getItem(this.layer.name)) {
            // Create cache space in local storage named after layer
            localStorage.setItem(this.layer.name, JSON.stringify({}));
        }

        this._cacheMap = JSON.parse(localStorage.getItem(this.layer.name));

        this.imgCanvas = document.createElement("canvas");
        // Make sure canvas is as big as layer requests
        this.imgCanvas.width = options.tilePixelSize || 256;
        this.imgCanvas.height = options.tilePixelSize || 256;

        this.imgContext = this.imgCanvas.getContext("2d");
    };


    /**************************************************************************************************************/

    /**
     *    Get tile request from cache for the given tile
     *    @returns The image(TODO: handle elevations) corresponding to the given tile, null if doesn't exist in cache
     */
    Cache.prototype.getFromCache = function (tile) {
        var cachedTileRequest = null;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            var tileInfo = this._cacheMap[tileId];
            if (tileInfo) {
                // Update access info
                tileInfo.lastAccess = Date.now();

                var image = new Image();
                image.src = tileInfo.dataUrl;
                image.dataType = "byte";
                cachedTileRequest = {
                    image: image,
                    elevations: tileInfo.elevations
                };
            }
        }
        return cachedTileRequest;
    };

    /**************************************************************************************************************/

    /**
     *    Internal method to generate data url from HTML image object
     */
    Cache.prototype._createDataURL = function (image) {
        // Draw image into canvas element
        this.imgContext.drawImage(image, 0, 0, image.width, image.height);

        // Save image as a data URL
        return this.imgCanvas.toDataURL("image/png");
    };

    /**************************************************************************************************************/

    /**
     *    Store tile request in cache
     */
    Cache.prototype.storeInCache = function (tileRequest) {
        var tile = tileRequest.tile;
        if (this.cacheLevel >= tile.level) {
            var tileId = this.layer.getUrl(tile);
            this._cacheMap[tileId] = {
                dataUrl: this._createDataURL(tileRequest.image),
                elevations: tileRequest.elevations,
                lastAccess: Date.now()
            };
            console.log("Stored for " + tileRequest.image.src);

            // Update local storage with new cache
            localStorage.setItem(this.layer.name, JSON.stringify(this._cacheMap));
        }
    };

    return Cache;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/AbstractRasterLayer',['../Utils/Utils', './AbstractLayer', '../Renderer/RasterOverlayRenderer', '../Utils/Cache'],
    function (Utils, AbstractLayer, RasterOverlayRenderer, Cache) {

        /**
         * AbstractRasterLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractRasterLayer.configuration
         * @property {int} tilePixelSize - the image size of a tile in pixels
         * @property tiling - Tiling
         * @property {int} numberOfLevels - number of levels in the pyramidal tiles
         * @property [geoBound=null] - geography boundary
         * @property [coordinates=null]
         * @property {int} [zIndex=0]
         * @property {string} [crossOrigin="anonymous"]
         * @property {string} baseUrl
         * @property cache
         */

        /**
         * @name AbstractRasterLayer
         * @class
         *     Base class for raster layer
         * @augments AbstractLayer
         * @param {LAYER} type - the type of the layer
         * @param {AbstractRasterLayer.configuration} options -Configuration properties for the AbstractRasterLayer.
         * @constructor
         */
        var AbstractRasterLayer = function (type, options) {
            AbstractLayer.prototype.constructor.call(this, type, options);

            // Base properties
            this.tilePixelSize = options.tilePixelSize;
            this.tiling = options.tiling;
            this.numberOfLevels = options.numberOfLevels;
            this.geoBound = options.geoBound || null;
            this.coordinates = options.coordinates || null;
            this.zIndex = options.zIndex || 0;
            this.crossOrigin = options.crossOrigin || 'anonymous';
            this.baseUrlRaw = options.baseUrl;

            // Get capabilities url (without proxy)
            this.getCapabilitiesRaw = this.baseUrlRaw + "&request=GetCapabilities";
            // Get map url (without proxy)
            this.getMapRaw = this.baseUrlRaw;

            // Init cache if defined
            if (options.cache) {
                options.cache.layer = this;
                this.cache = new Cache(options.cache);
            }

            // Internal
            this._overlay = true;
            this._ready = true; // Ready is use by TileManager

            this.baseUrl = this.proxify(this.baseUrlRaw);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, AbstractRasterLayer);

        /**************************************************************************************************************/

        /**
         * Add parameter to
         * @function addParameterTo
         * @memberOf AbstractRasterLayer#
         * @param {String} url - parameter url
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         * @return {String} url updated
         */
        AbstractRasterLayer.prototype.addParameterTo = function (url,name,value) {
            var separator = "&";
            if ((typeof url !== "string") || (url.indexOf('?', 0) === -1)) {
              separator = "?";
            }
            return url + separator + name + "=" + value;
        };

        /**************************************************************************************************************/

        /**
         * Add parameter to getCapabilities url
         * @function addGetCapabilitiesParameter
         * @memberOf AbstractRasterLayer#
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         */
        AbstractRasterLayer.prototype.addGetCapabilitiesParameter = function (name,value) {
            this.getCapabilitiesRaw = this.addParameterTo(this.getCapabilitiesRaw,name,value);
        };

        /**************************************************************************************************************/

        /**
         * Get getCapabilities url
         * @function getGetCapabilitiesUrl
         * @memberOf AbstractRasterLayer#
         * @return {String} url
         */
        AbstractRasterLayer.prototype.getGetCapabilitiesUrl = function () {
            this.getCapabilities = this.proxify(this.getCapabilitiesRaw);
            return this.getCapabilities;
        };

        /**
         * Add parameter to getMap url
         * @function addGetMapParameter
         * @memberOf AbstractRasterLayer#
         * @param {String} name - parameter name
         * @param {String} value - parameter value
         */
        AbstractRasterLayer.prototype.addGetMapParameter = function (name,value) {
          this.getMapRaw = this.addParameterTo(this.getMapRaw,name,value);
        };

        /**************************************************************************************************************/

        /**
         * Get getMap url
         * @function getGetMapUrl
         * @memberOf AbstractRasterLayer#
         * @return {String} url
         */
        AbstractRasterLayer.prototype.getGetMapUrl = function () {
            this.getMap = this.proxify(this.getMapRaw);
            return this.getMap;
        };

        /**************************************************************************************************************/
        /**
         * Attach the raster layer to the planet
         * @function _attach
         * @memberOf AbstractRasterLayer#
         * @param {Globe} g - globe
         * @private
         */
        AbstractRasterLayer.prototype._attach = function (g) {
            if (!this._overlay) {
                // Override id of background layer because of unicity of background not overlayed layer
                this.id = 0;
            }

            AbstractLayer.prototype._attach.call(this, g);
            if (this._overlay) {
                // Create the renderer if needed
                if (!g.rasterOverlayRenderer) {
                    var renderer = new RasterOverlayRenderer(g);
                    g.vectorRendererManager.renderers.push(renderer);
                    g.rasterOverlayRenderer = renderer;
                }
                g.rasterOverlayRenderer.addOverlay(this);
            }
        };

        /**************************************************************************************************************/

        /**
         * Detach the raster layer from the planet
         * @function _detach
         * @memberOf AbstractRasterLayer
         * @private
         */
        AbstractRasterLayer.prototype._detach = function () {
            // Remove raster from overlay renderer if needed
            if (this._overlay && this.globe.rasterOverlayRenderer) {
                this.globe.rasterOverlayRenderer.removeOverlay(this);
            }

            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        return AbstractRasterLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/GeoBound',['../Utils/Constants'], function (Constants) {

    /**************************************************************************************************************/

    /**
     @name GeoBound
     @class
         Geo Bound
     @param {float} w West
     @param {float} s South
     @param {float} e East
     @param {float} n North
     @constructor
     */
    var GeoBound = function (w, s, e, n) {
        this.south = s;
        this.west = w;
        this.north = n;
        this.east = e;
    };

    /**
     Get geo center
     @function getCenter
     @memberOf GeoBound.prototype
     @return {float[]} Geo center as array of 2 float
     */
    GeoBound.prototype.getCenter = function () {
        return [(this.east + this.west) * 0.5, (this.south + this.north) * 0.5, 0.0];
    };


    /**
     Get North
     @function getNorth
     @memberOf GeoBound.prototype
     @return {float} North
     */
    GeoBound.prototype.getNorth = function () {
        return this.north;
    };

    /**
     Set North
     @function setNorth
     @memberOf GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setNorth = function (val) {
        this.north = val;
    };

    /**
     Get South
     @function getSouth
     @memberOf GeoBound.prototype
     @return {float} South
     */
    GeoBound.prototype.getSouth = function () {
        return this.south;
    };

    /**
     Set South
     @function setSouth
     @memberOf GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setSouth = function (val) {
        this.south = val;
    };

    /**
     Get West
     @function getWest
     @memberOf GeoBound.prototype
     @return {float} West
     */
    GeoBound.prototype.getWest = function () {
        return this.west;
    };

    /**
     Set West
     @function setWest
     @memberOf GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setWest = function (val) {
        this.west = val;
    };

    /**
     Get East
     @function getEast
     @memberOf GeoBound.prototype
     @return {float} East
     */
    GeoBound.prototype.getEast = function () {
        return this.east;
    };

    /**
     Set East
     @function setEast
     @memberOf GeoBound.prototype
     @param {float} val
     */
    GeoBound.prototype.setEast = function (val) {
        this.east = val;
    };

    /**
     Compute the geo bound from coordinates
     @function computeFromCoordinates
     @memberOf GeoBound.prototype
     @param {float[][]} coordinates Coordinates as bi-dimensionnal array of float
     */
    GeoBound.prototype.computeFromCoordinates = function (coordinates) {
        this.west = coordinates[0][0];
        this.east = coordinates[0][0];
        this.south = coordinates[0][1];
        this.north = coordinates[0][1];

        for (var i = 1; i < coordinates.length; i++) {
            this.west = Math.min(this.west, coordinates[i][0]);
            this.east = Math.max(this.east, coordinates[i][0]);
            this.south = Math.min(this.south, coordinates[i][1]);
            this.north = Math.max(this.north, coordinates[i][1]);
        }
    };

    function transformCoordinates (coordinates, crsID, globeCrs) {
        var len = coordinates.length,
            convertedCoord = new Array(len); // boost in Safari
        for (var i=0; i<len; ++i) {
            convertedCoord[i] = coordinates[i].slice(0);
        }

        convertedCoord[0][0] = globeCrs.convert(coordinates[0][0], crsID, globeCrs.getGeoideName());
        convertedCoord[0][1] = globeCrs.convert(coordinates[0][1], crsID, globeCrs.getGeoideName());
        for (var j = 1; j < coordinates.length; j++) {
            convertedCoord[j][0] = globeCrs.convert(coordinates[j][0], crsID, globeCrs.getGeoideName());
            convertedCoord[j][1] = globeCrs.convert(coordinates[j][1], crsID, globeCrs.getGeoideName());
        }
        return convertedCoord;
    }

    GeoBound.prototype.computeFromCoordinatesInCrsTo = function (coordinates, crsID, globeCrs) {
        var coords;
        if(crsID === globeCrs.getGeoideName()) {
            coords = coordinates;
        } else {
            coords = transformCoordinates(coordinates, crsID, globeCrs);
        }
        this.computeFromCoordinates(coords);
        return coords;
    };

    /**
     Check if a point is inside the given bound
     @function isPointInside
     @memberOf GeoBound.prototype
     @param {Array} point The point
     @return {Boolean} return the test
     */
    GeoBound.prototype.isPointInside = function (point) {
        return point[0] >= this.west && point[0] <= this.east && point[1] >= this.south && point[1] <= this.north;
    };

    /**
     Intersects this geo bound with another one
     @function intersects
     @memberOf GeoBound.prototype
     @param {GeoBound} geoBound Geo bound
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersects = function (geoBound) {
        if (this.west >= geoBound.east || this.east <= geoBound.west) {
            return false;
        }

        return !(this.south >= geoBound.north || this.north <= geoBound.south);
    };

    /**
     Intersects this geo bound with GeoJSON geometry
     @function intersectsGeometry
     @memberOf GeoBound.prototype
     @param {JSON} geometry GeoJSON geometry
     @return {Boolean} Intersects ?
     */
    GeoBound.prototype.intersectsGeometry = function (geometry) {
        var isIntersected = false;
        var i, j;
        var geoBound = new GeoBound();
        var coords = geometry.coordinates;
        switch (geometry.type) {
            case Constants.GEOMETRY.LineString:
                geoBound.computeFromCoordinates(coords);
                isIntersected |= this.intersects(geoBound);
                break;
            case Constants.GEOMETRY.Polygon:
                // Don't take care about holes
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    geoBound.computeFromCoordinates(coords[i]);
                    isIntersected |= this.intersects(geoBound);
                }
                break;
            case Constants.GEOMETRY.MultiLineString:
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    geoBound.computeFromCoordinates(coords[i]);
                    isIntersected |= this.intersects(geoBound);
                }
                break;
            case Constants.GEOMETRY.MultiPolygon:
                for (i = 0; i < coords.length && !isIntersected; i++) {
                    for (j = 0; j < coords[i].length && !isIntersected; j++) {
                        geoBound.computeFromCoordinates(coords[i][j]);
                        isIntersected |= this.intersects(geoBound);
                    }
                }
                break;
        }
        return isIntersected;
    };

    /**************************************************************************************************************/

    return GeoBound;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/GeoTiling',['../Utils/Utils', '../Utils/Constants',
        './Tile', '../Renderer/GeoBound', './HEALPixBase', '../Renderer/glMatrix'],
    function (Utils, Constants,
              Tile, GeoBound, HEALPixBase) {

        /** @constructor
         Tile constructor
         */
        var GeoTile = function (geoBound, level, x, y) {
            // Call ancestor constructor
            Tile.prototype.constructor.call(this);
            this.bound = this.geoBound = geoBound;
            this.level = level;
            this.x = x;
            this.y = y;
        };

        /**************************************************************************************************************/

        /** inherits from Tile */
        GeoTile.prototype = new Tile();

        /**************************************************************************************************************/

        /** @export
         Get elevation at a geo position
         */
        GeoTile.prototype.getElevation = function (lon, lat) {
            // Get the lon/lat in coordinates between [0,1] in the tile
            var u = (lon - this.geoBound.getWest()) / (this.geoBound.getEast() - this.geoBound.getWest());
            var v = (lat - this.geoBound.getNorth()) / (this.geoBound.getSouth() - this.geoBound.getNorth());

            // Quick fix when lat is on the border of the tile
            var childIndex = (v >= 1 ? 1 : Math.floor(2 * v) ) * 2 + Math.floor(2 * u);
            if (this.children && this.children[childIndex].state === Tile.State.LOADED) {
                return this.children[childIndex].getElevation(lon, lat);
            }

            var tess = this.config.tesselation;
            var i = Math.floor(u * tess);
            var j = Math.floor(v * tess);

            var vo = this.config.vertexSize * (j * tess + i);
            var vertex = [this.vertices[vo], this.vertices[vo + 1], this.vertices[vo + 2]];
            mat4.multiplyVec3(this.matrix, vertex);

            var geo = this.config.coordinateSystem.getWorldFrom3D(vertex);
            return geo[2];
        };

        /**************************************************************************************************************/

        /**
         Create the children
         */
        GeoTile.prototype.createChildren = function () {
            // Create the children
            var lonCenter = ( this.geoBound.getEast() + this.geoBound.getWest() ) * 0.5;
            var latCenter = ( this.geoBound.getNorth() + this.geoBound.getSouth() ) * 0.5;

            var level = this.level + 1;

            var tile00 = new GeoTile(new GeoBound(this.geoBound.getWest(), latCenter, lonCenter, this.geoBound.getNorth()), level, 2 * this.x, 2 * this.y);
            var tile10 = new GeoTile(new GeoBound(lonCenter, latCenter, this.geoBound.getEast(), this.geoBound.getNorth()), level, 2 * this.x + 1, 2 * this.y);
            var tile01 = new GeoTile(new GeoBound(this.geoBound.getWest(), this.geoBound.getSouth(), lonCenter, latCenter), level, 2 * this.x, 2 * this.y + 1);
            var tile11 = new GeoTile(new GeoBound(lonCenter, this.geoBound.getSouth(), this.geoBound.getEast(), latCenter), level, 2 * this.x + 1, 2 * this.y + 1);

            tile00.initFromParent(this, 0, 0);
            tile10.initFromParent(this, 1, 0);
            tile01.initFromParent(this, 0, 1);
            tile11.initFromParent(this, 1, 1);

            this.children = [tile00, tile10, tile01, tile11];
        };

        /**************************************************************************************************************/

        /**
         Convert coordinates in longitude,latitude to coordinate in "tile space"
         Tile space means coordinates are between [0,tesselation-1] if inside the tile
         Used by renderers algorithm to clamp coordinates on the tile
         */
        GeoTile.prototype.lonlat2tile = function (coordinates) {
            var ul = this.geoBound.getEast() - this.geoBound.getWest();
            var vl = this.geoBound.getSouth() - this.geoBound.getNorth();
            var factor = this.config.tesselation - 1;
            var tileCoords = [];
            for (var i = 0; i < coordinates.length; i++) {
                var u = factor * (coordinates[i][0] - this.geoBound.getWest()) / ul;
                var v = factor * (coordinates[i][1] - this.geoBound.getNorth()) / vl;
                tileCoords.push([u, v]);
            }
            return tileCoords;
        };

        /**************************************************************************************************************/

        /**
         Generate vertices for tile
         */
        GeoTile.prototype.generateVertices = function (elevations) {
            // Compute tile matrix
            this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
            var invMatrix = mat4.create();
            mat4.inverse(this.matrix, invMatrix);
            this.inverseMatrix = invMatrix;

            // Build the vertices
            var vertexSize = this.config.vertexSize;
            var size = this.config.tesselation;
            var vertices = new Float32Array(vertexSize * size * (size + 6));
            var lonStep = (this.geoBound.getEast() - this.geoBound.getWest()) / (size - 1);
            var latStep = (this.geoBound.getSouth() - this.geoBound.getNorth()) / (size - 1);
            var radius = this.config.coordinateSystem.getGeoide().getRadius();
            var scale = this.config.coordinateSystem.getGeoide().getHeightScale();
            var offset = 0;

            // Optimized build for sphere coordinates : uncomment if needed
            var lat = this.geoBound.getNorth() /* * Math.PI / 180.0*/;
            // latStep = latStep * Math.PI / 180.0;
            // lonStep = lonStep * Math.PI / 180.0;
            var pos3d = [0.0, 0.0, 0.0];
            for (var j = 0; j < size; j++) {
                //var cosLat = Math.cos( lat );
                //var sinLat = Math.sin( lat );

                var lon = this.geoBound.getWest() /* * Math.PI / 180.0*/;

                for (var i = 0; i < size; i++) {
                    // var height = elevations ? scale * elevations[ offset ] : 0.0;
                    // var x = (radius + height) * Math.cos( lon ) * cosLat;
                    // var y = (radius + height) * Math.sin( lon ) * cosLat;
                    // var z = (radius + height) * sinLat;

                    var height = elevations ? elevations[offset] : 0.0;
                    this.config.coordinateSystem.get3DFromWorld([lon, lat, height], pos3d);
                    var x = pos3d[0];
                    var y = pos3d[1];
                    var z = pos3d[2];
                    var vi = offset * vertexSize;
                    vertices[vi] = invMatrix[0] * x + invMatrix[4] * y + invMatrix[8] * z + invMatrix[12];
                    vertices[vi + 1] = invMatrix[1] * x + invMatrix[5] * y + invMatrix[9] * z + invMatrix[13];
                    vertices[vi + 2] = invMatrix[2] * x + invMatrix[6] * y + invMatrix[10] * z + invMatrix[14];

                    offset++;
                    lon += lonStep;
                }

                lat += latStep;
            }

            return vertices;
        };


        /**************************************************************************************************************/

        /** @constructor
         GeoTiling constructor
         */
        var GeoTiling = function (nx, ny) {
            this.level0NumTilesX = nx;
            this.level0NumTilesY = ny;
        };

        /**************************************************************************************************************/

        /**
         Generate the tiles for level zero
         */
        GeoTiling.prototype.generateLevelZeroTiles = function (config) {
            config.skirt = !config.coordinateSystem.isFlat();
            config.cullSign = 1;
            config.srs = 'EPSG:4326';

            var level0Tiles = [];


            var latStep = (config.coordinateSystem.getGeoBound().getNorth() - config.coordinateSystem.getGeoBound().getSouth()) / this.level0NumTilesY;
            var lonStep = (config.coordinateSystem.getGeoBound().getEast() - config.coordinateSystem.getGeoBound().getWest()) / this.level0NumTilesX;

            // Manage (just for latitude) a partial GeoTiling cover (not only 360 * 180)
            this.latStart = config.coordinateSystem.getGeoBound().getSouth();
            this.latDelta = config.coordinateSystem.getGeoBound().getNorth()-config.coordinateSystem.getGeoBound().getSouth();

            for (var j = 0; j < this.level0NumTilesY; j++) {
                for (var i = 0; i < this.level0NumTilesX; i++) {
                    var geoBound = new GeoBound(
                                        config.coordinateSystem.getGeoBound().getWest() + i * lonStep,
                                        config.coordinateSystem.getGeoBound().getNorth() - (j + 1) * latStep,
                                        config.coordinateSystem.getGeoBound().getWest() + (i + 1) * lonStep,
                                        config.coordinateSystem.getGeoBound().getNorth() - j * latStep
                                    );
                    var tile = new GeoTile(geoBound, 0, i, j);
                    tile.config = config;
                    level0Tiles.push(tile);
                }
            }

            return level0Tiles;
        };


        /**
         * Compute the bbox of a feature
         */
        var _getBBox = function (geometry) {

            // Get the coordinates
            var coords;
            var checkDateLine = true;
            switch (geometry.type) {
                case Constants.GEOMETRY.Point:
                    coords = geometry.coordinates;
                    return [coords[0], coords[1], coords[0], coords[1]];
                case Constants.GEOMETRY.MultiPoint:
                    coords = geometry.coordinates;
                    checkDateLine = false;
                    break;
                case Constants.GEOMETRY.Polygon:
                    coords = geometry.coordinates[0];
                    break;
                case Constants.GEOMETRY.MultiPolygon:
                    coords = geometry.coordinates[0][0];
                    break;
                case Constants.GEOMETRY.LineString:
                    coords = geometry.coordinates;
                    break;
                case Constants.GEOMETRY.MultiLineString:
                    coords = geometry.coordinates[0];
                    break;
            }

            if (!coords || coords.length === 0) {
                return;
            }

            var minX = coords[0][0];
            var minY = coords[0][1];
            var maxX = coords[0][0];
            var maxY = coords[0][1];

            var numOuterRings = (geometry.type === Constants.GEOMETRY.MultiPolygon || geometry.type === Constants.GEOMETRY.MultiLineString ? geometry.coordinates.length : 1);
            for (var j = 0; j < numOuterRings; j++) {
                switch (geometry.type) {
                    case Constants.GEOMETRY.MultiPolygon:
                        coords = geometry.coordinates[j][0];
                        break;
                    case Constants.GEOMETRY.MultiLineString:
                        coords = geometry.coordinates[j];
                        break;
                }

                for (var i = 0; i < coords.length; i++) {
                    minX = Math.min(minX, coords[i][0]);
                    minY = Math.min(minY, coords[i][1]);
                    maxX = Math.max(maxX, coords[i][0]);
                    maxY = Math.max(maxY, coords[i][1]);

                    // Check if the coordinates cross dateline
                    if (checkDateLine && i > 0 && Math.abs(coords[i - 1][0] - coords[i][0]) > 180) {
                        minX = -180;
                        maxX = 180;
                    }
                }
            }

            return [minX, minY, maxX, maxY];
        };

        /**************************************************************************************************************/

        /**
         Locate a level zero tile
         */

        GeoTiling.prototype._lon2LevelZeroIndex = function (lon) {
            return Math.min(this.level0NumTilesX - 1, Math.floor((lon + 180) * this.level0NumTilesX / 360));
        };

        /**************************************************************************************************************/

        /**
         Locate a level zero tile
         */
        GeoTiling.prototype._lat2LevelZeroIndex = function (lat) {
            // Take into account a partial bbox for GeoTiling
            var topLat = this.latStart + this.latDelta;
            return Math.min(this.level0NumTilesY - 1, Math.floor((topLat - lat) * this.level0NumTilesY / this.latDelta));
        };
        /**************************************************************************************************************/

        /**
         Locate a level zero tile
         */
        GeoTiling.prototype.lonlat2LevelZeroIndex = function (lon, lat) {
            return this._lat2LevelZeroIndex(lat) * this.level0NumTilesX + this._lon2LevelZeroIndex(lon);
        };


        /**************************************************************************************************************/

        /**
         Get the overlapped tile by the given geometry
         */
        GeoTiling.prototype.getOverlappedLevelZeroTiles = function (geometry) {
            var tileIndices = [];

            var bbox = _getBBox(geometry);
            if (bbox) {
                var i1 = this._lon2LevelZeroIndex(bbox[0]);
                var j1 = this._lat2LevelZeroIndex(bbox[3]);
                var i2 = this._lon2LevelZeroIndex(bbox[2]);
                var j2 = this._lat2LevelZeroIndex(bbox[1]);


                for (var j = j1; j <= j2; j++) {
                    for (var i = i1; i <= i2; i++) {
                        tileIndices.push(j * this.level0NumTilesX + i);
                    }
                }
            }

            return tileIndices;
        };

        /**************************************************************************************************************/

        /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
        GeoTiling.prototype.findInsideTile = function (lon, lat, tiles) {
            //var coordinateSystem = mizar.getCrs();
            //var geo = coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, coordinateSystem.getGeoideName);
            //lon = geo[0];
            //lat = geo[1];

            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
                if (index === tile.pixelIndex) {
                    return tile;
                }
            }
            return null;
        };


        /**************************************************************************************************************/

        return GeoTiling;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMSLayer',['../Utils/Utils', './AbstractRasterLayer', '../Utils/Constants', '../Tiling/GeoTiling'],
    function (Utils, AbstractRasterLayer, Constants, GeoTiling) {


        /**
         * Configuration parameters to query a Web Map Service (WMS)
         * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.wms_configuration
         * @property {int} [tilePixelSize = 256] - tile in pixels
         * @property {int} [numberOfLevels = 21] - number of levels
         * @property {string} [version = "1.1.1"] - WMS version
         * @property {string} [transparent]
         * @property {string} [time] - Time dimension
         * @property {string} [format = "image/jpeg"] - output image format
         * @property {string} layers - names of the layer
         * @property {string} [styles] - Styled Layers Descriptor for each layer
         */

        /**
         * @name WMSLayer
         * @class
         *    Creates a layer for imagery data using WMS (Web Map Service) protocol
         *    based on a GeoTiling(4, 2) with a pixelSize = 256 by default.<br/>
         *    WMS provides a standard interface for requesting a geospatial map image.
         *    The standard guarantees that these images can all be overlaid on one another.
         *    <br/><br/>
         *    Example of a WMS request<br/>
         *    <code>
         *        http://example.com/wms?request=GetMap&service=WMS&version=1.1.1&layers=MyLayer
         *        &styles=population&srs=EPSG:4326&bbox=-145.15104058007,21.731919794922,-57.154894212888,58.961058642578&
         *        &width=780&height=330&format=image/png
         *    </code>
         *
         * @augments AbstractRasterLayer
         * @param {AbstractRasterLayer.wms_configuration} options - WMS Configuration
         * @constructor
         * @memberOf module:Layer
         * @see {@link http://www.opengeospatial.org/standards/wms WMS} standard
         */
        var WMSLayer = function (options) {
            options.tilePixelSize = options.tilePixelSize || 256;
            options.tiling = new GeoTiling(4, 2);
            options.numberOfLevels = options.numberOfLevels || 21;

            AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.WMS, options);

            this.addGetCapabilitiesParameter("service","WMS");
            this.addGetCapabilitiesParameter("version",options.hasOwnProperty('version') ? options.version : '1.1.1');

            // Build the base GetMap URL
            this.addGetMapParameter("service","wms");
            this.addGetMapParameter("version",options.hasOwnProperty('version') ? options.version : '1.1.1');
            this.addGetMapParameter("request","getMap");
            this.addGetMapParameter("layers",options.layers);
            this.addGetMapParameter("styles",options.hasOwnProperty('styles') ? options.styles : "");
            this.addGetMapParameter("format",options.hasOwnProperty('format') ? options.format : 'image/jpeg');
            if (options.hasOwnProperty('transparent')) {
                this.addGetMapParameter("transparent",options.transparent);
            }
            this.addGetMapParameter("width",this.tilePixelSize);
            this.addGetMapParameter("&height",this.tilePixelSize);
            if (options.hasOwnProperty('time')) {
                this.addGetMapParameter("time=",options.time);
            }

            this.getMapBaseUrl = this.getGetMapUrl();
            //this.loadGetCapabilities(this.manageCapabilities,this.options);
            this.layer = options.layers;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractRasterLayer, WMSLayer);

        /**************************************************************************************************************/

        WMSLayer.prototype.manageCapabilities = function (json,options) {
          // Check if we have a layer list in options
          /*var listLayerNames = [];
          if (options) {
            if (options.layers) {
              // Just a name
              if (typeof options.layers === 'string') {
                listLayerNames [options.layers];
              } else {
                listLayerNames = options.layers;
              }
            }
          }

          jsRoot = json.WMT_MS_Capabilities;
          jsCapability = jsRoot.Capability;
          jsLayers = jsCapability.Layer.Layer;
          var needToLoad;
          for (i=0;i<layers.length;i++) {
            name = layers[i].Name._text;
            title = layers[i].Title._text;
            console.log("Layer "+ name +" : "+ title);
            // For each layer found, search if we have to load it
            needToLoad = false;
            if (listLayerNames.length === 0) {
              // If no layer list provided, load all !
              needToLoad = true;
            } else {
            }
          }*/
        }

        /**
         * Returns the url for the given tile
         * @function getUrl
         * @memberOf WMSLayer#
         * @param {Tile} tile Tile
         * @return {String} Url
         */
        WMSLayer.prototype.getUrl = function (tile) {
            // Just add the bounding box to the GetMap URL
            var bound = tile.bound;
            var bbox = bound.west + "," + bound.south + "," + bound.east + "," + bound.north;

            var url = this.getMapRaw;
            url = this.addParameterTo(url,"srs",tile.config.srs);
            url = this.addParameterTo(url,"bbox",bbox);

            return this.proxify(url);
        };

        /**
         * @function getBaseURl
         * @memberOf WMSLayer#
         */
        WMSLayer.prototype.getBaseURl = function() {
            return this.getMapBaseUrl;
        };

        /**************************************************************************************************************/

        return WMSLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMTSLayer',['../Utils/Utils', './AbstractRasterLayer', '../Utils/Constants'],
    function (Utils, AbstractRasterLayer, Constants) {
        /**
         * Configuration parameters to query a Web Map Tile Service (WMTS)
         * @typedef {AbstractRasterLayer} AbstractRasterLayer.wmts_configuration
         * @property {string} [version = "1.0.0"] WMTS version
         * @property {string} layer - basic unit of geographic information that may be requested as a map from a server
         * @property {string} matrixSet - The name of pyramidal images
         * @property {int} startLevel - Start level of the index
         * @property {string} [style] - Styled Layers Descriptor
         */
        /**
         * @name WMTSLayer
         * @class
         *    Creates a layer for imagery data using WMTS protocol.
         *    <br/>
         *    WMTS protocol provides tiles with a resolution of <i>tilePixelSize</i><br/>
         *    based on a GeoTiling(4, 2)<br/>
         *    <img src="../doc/images/wmts_tile.png"/><br/>
         *    <br/
         *    Example of a WMTS request:
         *    <code>
         *            http://example.com/wmts?LAYER=MyLayer1,MyLayer2&
         *            EXCEPTIONS=text/xml&FORMAT=image/jpeg&SERVICE=WMTS&
         *            VERSION=1.0.0&REQUEST=GetTile&STYLE=normal&
         *            TILEMATRIXSET=PM&TILEMATRIX=18&TILEROW=90241&TILECOL=132877&
         *    </code>
         *    <br/><br/>
         *    The parameters of a WMTS server are the following:
         *    <ul>
         *        <li><b>TILEMATRIXSET</b>: The name of pyramidal images</li>
         *        <li><b>TILEMATRIX</b>: The name of the matrix that contains the tile</li>
         *        <li><b>TILEROW</b>: The line number from the top left corner from the tile</li>
         *        <li><b>TILECOL</b>: The column number from the top left corner from the tile</li>
         *    </ul>
         *    <img src="../doc/images/wmts_pixel.png"/>
         *
         * @augments AbstractRasterLayer
         * @param {AbstractRasterLayer.configuration} options - WMTS configuration
         * @property {int} [tilePixelSize = 256] - tile in pixels
         * @property {int} [numberOfLevels = 21] - number of levels
         * @property {string} [version = "1.0.0"] - WMS version
         * @property {string} [transparent]
         * @property {string} [time] - Time dimension
         * @property {string} [format = "image/png"] - output image format
         * @constructor
         * @memberOf module:Layer
         * @see {@link http://www.opengeospatial.org/standards/wmts WMTS} standard
         * @see {@link http://www.opengeospatial.org/standards/sld SLD} standard
         */
        var WMTSLayer = function (options) {
            AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.WMTS, options);

            this.startLevel = options.startLevel || 1;

            // Build the base GetTile URL
            var url = this.baseUrl;
            if (url.indexOf('?', 0) === -1) {
                url += '?service=wmts';
            }
            else {
                url += '&service=wmts';
            }
            url += "&version=";
            url += options.version || '1.0.0';
            url += "&request=GetTile";
            url += "&layer=" + options.layer;
            url += "&tilematrixset=" + options.matrixSet;
            if (options.style) {
                url += "&style=" + options.style;
            }
            url += "&format=";
            this.format = options.hasOwnProperty('format') ? options.format : 'image/png';
            url += this.format;
            if (options.time) {
                url += "&time=" + options.time;
            }

            this.getTileBaseUrl = this._proxifyUrl(url);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractRasterLayer, WMTSLayer);

        /**************************************************************************************************************/

        /**
         * Returns an url for the given tile
         * @function getUrl
         * @memberOf WMTSLayer#
         * @param {Tile} tile Tile
         * @return {String} Url
         */
        WMTSLayer.prototype.getUrl = function (tile) {
            var url = this.getTileBaseUrl;
            url += "&tilematrix=";
            url += tile.level + this.startLevel;
            url += "&tilecol=" + tile.x;
            url += "&tilerow=" + tile.y;

            return url;
        };

        /**
         * @function getBaseURl
         * @memberOf WMTSLayer#
         */
        WMTSLayer.prototype.getBaseURl = function() {
            return this.getTileBaseUrl;
        };

        /**************************************************************************************************************/

        return WMTSLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WCSElevationLayer',['../Utils/Utils', './AbstractRasterLayer', '../Utils/Constants','../Tiling/GeoTiling'],
    function (Utils, AbstractRasterLayer, Constants, GeoTiling) {

        /**
         * WCSElevation configuration
         * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.wcsElevation_configuration
         * @property {int} [tilePixelSize = 33]
         * @property {int} [numberOfLevels = 21]
         * @property {string} baseUrl - the base Url to access the WCS server
         * @property {string} coverage - the name of the coverage to use (WCS parameter)
         * @property {string} crs - the coordinate reference system to use (WCS parameter)
         * @property {string} [outputCRS=crs] for 2.0
         * @property {string} version -  2.0.x or 1.0.x is supported
         * @property {float} [scale=1] - elevation scale value
         * @property {float} [scaleData=1] - elevation scale value to apply to have the true altitude
         * @property {string} [format='image/x-aaigrid']
         * @property {float} [minElevation=0]
         */

        /**
         * @name WCSElevationLayer
         * @class
         *    Create a layer for elevation data using WCS protocol  based on a GeoTiling(4, 2)
         *    with a pixelSize = 33 by default. The only supported format is right now image/x-aaigrid. It is an ASCII
         *    format that is easily parsed in Javascript.
         * @augments AbstractRasterLayer
         * @param {AbstractLayer.wcsElevation_configuration} options - WCSElevation Configuration
         * @constructor
         * @memberOf module:Layer
         */
        var WCSElevationLayer = function (options) {
            options.tilePixelSize = options.tilePixelSize || 33;
            options.tiling = new GeoTiling(4, 2);
            options.numberOfLevels = options.numberOfLevels || 21;
            AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.WMSElevation, options);

            this.version = options.version || '2.0.0';
            this.format = options.format || 'image/x-aaigrid';
            this.minElevation = options.minElevation || 0;
            this.scale = options.scale || 1;
            this.scaleData = options.scaleData || 1;

            // Build the base GetMap URL
            var url = this.baseUrl;
            if (url.indexOf('?', 0) === -1) {
                url += '?service=wcs';
            }
            else {
                url += '&service=wcs';
            }
            url += "&version=" + this.version;
            url += "&request=GetCoverage";

            switch (this.version.substring(0, 3)) {
                case '2.0':
                    this.crs = options.outputCRS || options.crs || 'http://www.opengis.net/def/crs/EPSG/0/4326';
                    url += '&outputCRS=' + this.crs;
                    url += "&size=x(" + this.tilePixelSize + ")";
                    url += "&size=y(" + this.tilePixelSize + ")";
                    url += "&coverageid=" + options.coverage;
                    break;
                case '1.0':
                    url += "&width=" + this.tilePixelSize;
                    url += "&height=" + this.tilePixelSize;
                    url += '&crs=' + (options.crs || 'EPSG:4326');
                    url += "&coverage=" + options.coverage;
                    break;
            }
            url += '&format=' + this.format;

            this.getCoverageBaseUrl = this._proxifyUrl(url);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractRasterLayer, WCSElevationLayer);

        /**************************************************************************************************************/

        /**
         * Parse a elevation response
         * @function parseElevations
         * @memberOf WCSElevationLayer#
         * @param {String} text Response as text
         */
        WCSElevationLayer.prototype.parseElevations = function (text) {
            if (text === null) {
                return this._returnZeroElevations();
            }
            switch (this.format) {
                case "image/x-aaigrid":
                    return this._parseAAIGrid(text);
                default:
                    console.log("Format '" + this.format + "' could not be parsed.");
                    return this._returnZeroElevations();
            }
        };

        /**
         * Fallback elevations when no data was returned
         * @function _returnZeroElevations
         * @memberOf WCSElevationLayer#
         * @returns {float[]} Array of float
         * @private
         */
        WCSElevationLayer.prototype._returnZeroElevations = function () {
            var elevations = [];
            for (var i = 0; i < this.tilePixelSize * this.tilePixelSize; ++i) {
                elevations.push(0);
            }
            return elevations;
        };

        /**
         * Parse a elevation response from AAIGrid
         * @function _parseAAIGrid
         * @memberOf WCSElevationLayer#
         * @param {String} text Response as text
         * @private
         */
        WCSElevationLayer.prototype._parseAAIGrid = function (text) {
            var elevations = [];
            var i;
            var lines = text.trim().split('\n');

            var dataLinesStart = 0;
            for (i = 0; i < lines.length; ++i) {
                if (lines[i].substring(0, 1) === " ") {
                    dataLinesStart = i;
                    break;
                }
            }

            for (i = dataLinesStart; i < lines.length; i++) {
                var elts = lines[i].trim().split(/\s+/);
                for (var n = 0; n < elts.length; n++) {
                    var elevation = parseInt(elts[n], 10);
                    if (elevation < this.minElevation) {
                        elevation = this.minElevation;
                    }
                    elevations.push(elevation * this.scale * this.scaleData);
                }
            }

            return elevations;
        };

        /**
         * @function getBaseURl
         * @memberOf WCSElevationLayer#
         */
        WCSElevationLayer.prototype.getBaseURl = function() {
            return this.getCoverageBaseUrl;
        };

        /**
         * Get an url for the given tile
         * @function getUrl
         * @memberOf WCSElevationLayer#
         * @param {Tile} tile Tile
         * @return {String} Url
         */
        WCSElevationLayer.prototype.getUrl = function (tile) {
            var geoBound = tile.geoBound;
            var url = this.getCoverageBaseUrl;

            if (this.version.substring(0, 3) === '2.0') {
                url += '&subset=x,' + this.crs + '(' + geoBound.west + ',' + geoBound.east + ')';
                url += '&subset=y,' + this.crs + '(' + geoBound.south + ',' + geoBound.north + ')';
            }
            else if (this.version.substring(0, 3) === '1.0') {
                url += "&bbox=";
                url += geoBound.west;
                url += ",";
                url += geoBound.south;
                url += ",";
                url += geoBound.east;
                url += ",";
                url += geoBound.north;
            }

            return url;
        };

        /**************************************************************************************************************/

        return WCSElevationLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/VectorLayer',['../Utils/Utils', './AbstractLayer', '../Utils/Constants', '../Renderer/FeatureStyle'],
    function (Utils, AbstractLayer, Constants, FeatureStyle) {
        /**
         * Vector layer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.vector_configuration
         * @property {string} url - the url of json data to load when attaching to globe
         * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
         * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
         * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
         */
        /**
         * @name VectorLayer
         * @class
         *    Create a layer to display vector data in GeoJSON format.
         * @augments AbstractLayer
         * @param {AbstractLayer.vector_configuration} options - Vector configuration
         * @constructor
         * @memberOf module:Layer
         */
        var VectorLayer = function (options) {
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.Vector, options);

            if (options && options.url) {
                this.url = this.proxify(options.url);
            } else {
                this.url = null;
            }

            if (options && options.callback) {
                this.callback = options.callback;
            } else {
                this.callback = null;
            }

            this.minLevel = options && options.hasOwnProperty('minLevel') ? options.minLevel : 0.0;
            this.maxLevel = options && options.hasOwnProperty('maxLevel') ? options.maxLevel : 15.0;

            this.features = [];
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, VectorLayer);

        /**************************************************************************************************************/

        /**
         * Attach the vector layer to the globe
         * @function _attach
         * @memberof VectorLayer#
         * @param {AbstractGlobe} g globe
         * @private
         */
        VectorLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);

            // Add the feature to renderers
            for (var i = 0; i < this.features.length; i++) {
                this._addFeatureToRenderers(this.features[i]);
            }
        };

        /**************************************************************************************************************/

        /**
         * Detach the vector layer from the globe
         * @function _detach
         * @memberof VectorLayer#
         * @private
         */
        VectorLayer.prototype._detach = function () {
            // Remove feature from renderers
            for (var i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }

            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        /**
         * Adds a feature collection, in GeoJSON format
         * @function addFeatureCollection
         * @memberof VectorLayer#
         * @param {GeoJSON} featureCollection Feature Collection
         */
        VectorLayer.prototype.addFeatureCollection = function (featureCollection) {
            // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
            var features = featureCollection.features;
            if (features) {
                for (var i = 0; i < features.length; i++) {
                    this.addFeature(features[i]);
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Removes a feature collection, in GeoJSON format
         * @function removeFeatureCollection
         * @memberof VectorLayer#
         * @param {GeoJSON} featureCollection Feature Collection
         */
        VectorLayer.prototype.removeFeatureCollection = function (featureCollection) {
            // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
            var features = featureCollection.features;
            if (features) {
                for (var i = 0; i < features.length; i++) {
                    this.removeFeature(features[i]);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Add a feature to renderers
         * @function _addFeatureToRenderers
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        VectorLayer.prototype._addFeatureToRenderers = function (feature) {
            var geometry = feature.geometry;

            // Manage style, if undefined try with properties, otherwise use defaultStyle
            var style = this.style;
            var props = feature.properties;
            if (props && props.style) {
                style = props.style;
            }

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                for (var i = 0; i < geoms.length; i++) {
                    this.globe.vectorRendererManager.addGeometry(this, geoms[i], style);
                }
            }
            else {
                // Add geometry to renderers
                this.globe.vectorRendererManager.addGeometry(this, geometry, style);
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove a feature from renderers
         * @function _removeFeatureFromRenderers
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        VectorLayer.prototype._removeFeatureFromRenderers = function (feature) {
            var geometry = feature.geometry;

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                var res = false;
                if (this.globe && this.globe.vectorRendererManager) {
                    for (var i = 0; i < geoms.length; i++) {
                        res = this.globe.vectorRendererManager.removeGeometry(geoms[i], this);
                    }
                }
                return res;
            }
            else {
                if (this.globe && this.globe.vectorRendererManager) {
                    return this.globe.vectorRendererManager.removeGeometry(geometry, this);
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Add a feature to the layer
         * @function addFeature
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         */
        VectorLayer.prototype.addFeature = function (feature) {
            // Check feature geometry : only add valid feature
            var geometry = feature.geometry;
            if (!geometry || !geometry.type) {
                return;
            }
            this.features.push(feature);

            // Add features to renderer if layer is attached to planet
            if (this.globe) {
                this._addFeatureToRenderers(feature);
                if (this.isVisible()) {
                    this.globe.renderContext.requestFrame();
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Add a feature to the layer
         * @function addFeature
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         */
        VectorLayer.prototype.removeFeature = function (feature) {
            var index = this.features.indexOf(feature);
            this.features.splice(index, 1);
            if (this.globe) {
                this._removeFeatureFromRenderers(feature);
                if (this.isVisible()) {
                    this.globe.renderContext.requestFrame();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove a feature from the layer
         * @function removeFeature
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         */
        VectorLayer.prototype.removeAllFeatures = function () {
            // Remove feature from renderers
            if (this.globe) {
                for (var i = 0; i < this.features.length; i++) {
                    this._removeFeatureFromRenderers(this.features[i]);
                }
            }
            this.features.length = 0;

            // Refresh rendering if needed
            if (this.globe && this.isVisible()) {
                this.globe.renderContext.requestFrame();
            }
        };

        /**************************************************************************************************************/
        /**
         * Remove all feature from the layer
         * @function removeAllFeatures
         * @memberof VectorLayer#
         */
        VectorLayer.prototype.modifyFeatureStyle = function (feature, style) {
            if (this._removeFeatureFromRenderers(feature)) {
                feature.properties.style = style;
                this._addFeatureToRenderers(feature);
            }
        };

        /**************************************************************************************************************/

        /**
         * Modify feature style
         * @function modifyFeatureStyle
         * @memberof VectorLayer#
         * @param {GeoJSON} feature Feature
         * @param {FeatureStyle} style Feature style
         */
        VectorLayer.prototype.modifyStyle = function (style) {
            var i;
            for (i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }

            this.style = style;

            for (i = 0; i < this.features.length; i++) {
                this._addFeatureToRenderers(this.features[i]);
            }
        };

        /**************************************************************************************************************/

        /**
         * Get the vector layer style
         * @function getStyle
         * @memberof VectorLayer#
         * @return {FeatureStyle}  Feature style
         */
        VectorLayer.prototype.getStyle = function () {
            return this.style;
        };

        /**
         * Set the vector layer style
         * @function setStyle
         * @memberof VectorLayer#
         * @param {FeatureStyle} arg Feature style
         */
        VectorLayer.prototype.setStyle = function (arg) {
            this.style = arg;
        };

        return VectorLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * A layer is an information that can be superimposed on another information.
 * <img src="../doc/images/gis_layers.gif">
 * It exists different natures of layer,
 * which are listed as below :
 * <ul>
 *     <li>{@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.</li>
 *     <li>{@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.</li>
 *     <li>{@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky</li>
 *     <li>{@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe</li>
 *     <li>{@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain</li>
 *     <li>{@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue</li>
 *     <li>{@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits</li>
 *     <li>{@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG</li>
 *     <li>{@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index</li>
 *     <li>{@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service</li>
 *     <li>{@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server</li>
 *     <li>{@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet</li>
 *     <li>{@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector</li>
 *     <li>{@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation</li>
 *     <li>{@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server</li>
 *     <li>{@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server</li>
 * </ul>
 * <br/>
 * In addition to the classes, a {@link module:Layer.LayerFactory factory} is available to help for creating layer.
 * Once the layer is created, the client can handle it by the use of its {@link Layer interface}.
 * @implements {Layer}
 * @module Layer
 */
define('Layer/AtmosphereLayer',['../Utils/Utils', './AbstractLayer', '../Utils/Constants','../Renderer/Program'], function (Utils, AbstractLayer, Constants, Program) {

    /**
     * Atmosphere layer configuration
     * @typedef {AbstractLayer.configuration} AbstractLayer.atmosphere_configuration
     * @property {float} [kr=0.0025] the rayleigh parameter
     * @property {float} [km=0.0015] the mie parameter
     * @property {float} [sunBrightness=15] The Sun brightness
     * @property {float} [exposure=2.0] the exposure, use for basic high dynamic range
     * @property {float[]} [wavelength=[0.650, 0.570, 0.475]] the RGB color of the sun
     * @property {float[]} [lightDir=[1, 0, 0]] The location of the light in (x,y,z)     
     */
    
    /**
     * @name AtmosphereLayer
     * @class
     * Creates an atmosphere on the planet.
     * @augments AbstractLayer
     * @param {AbstractLayer.atmosphere_configuration} options - Atmosphere configuration.
     * @constructor
     * @memberOf module:Layer
     */
    var AtmosphereLayer = function (options) {
        AbstractLayer.prototype.constructor.call(this, Constants.LAYER.Atmosphere, options);
        if (!this.name) {
            this.name = "Atmosphere";
        }
        this.kr = (options && options.kr) || 0.0025;
        this.km = (options && options.km) || 0.0015;
        this.sunBrightness = (options && options.sunBrightness) || 15.0;
        this.exposure = (options && options.exposure) || 2.0;
        this.wavelength = (options && options.wavelength) || [0.650, 0.570, 0.475];
        this.lightDir = (options && options.lightDir) || [1, 0, 0];

        // internal properties
        this._skyProgram = null;
        this._groundProgram = null;
        this._originalProgram = null;
        this._isValid = false;

        // For rendering
        this.zIndex = -1;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractLayer, AtmosphereLayer);

    /**************************************************************************************************************/

    /**
     * Attaches the atmosphere layer to the planet.
     * @function _attach
     * @memberOf AtmosphereLayer#
     * @param {Planet} g Planet
     * @private
     */
    AtmosphereLayer.prototype._attach = function (g) {
        this.globe = g;
        this._innerRadius = this.globe.getCoordinateSystem().getGeoide().getRadius();
        this._outerRadius = this._innerRadius * 1.005;
        var renderContext = g.renderContext;

        // Setup program, uniform now that we have the render context

        this._skyFromSpaceProgram = new Program(renderContext);
        this._skyFromSpaceProgram.loadFromFile("SkyFromSpaceVert.glsl", "SkyFrag.glsl");
        this._skyFromAtmosphereProgram = new Program(renderContext);
        this._skyFromAtmosphereProgram.loadFromFile("SkyFromAtmosphereVert.glsl", "SkyFrag.glsl");

        this._groundFromSpaceProgram = new Program(renderContext);
        this._groundFromSpaceProgram.loadFromFile("GroundFromSpaceVert.glsl", "GroundFrag.glsl");

        this._groundFromAtmosphereProgram = new Program(renderContext);
        this._groundFromAtmosphereProgram.loadFromFile("GroundFromAtmosphereVert.glsl", "GroundFrag.glsl");

        // Check if the atmosphre is valid : all programs must be OK
        this._isValid = (this._skyFromSpaceProgram.glProgram !== null) &&
                        (this._skyFromAtmosphereProgram.glProgram !== null) &&
                        (this._groundFromSpaceProgram.glProgram !== null) &&
                        (this._groundFromAtmosphereProgram.glProgram !== null);

        if (!this._isValid) {
            return;
        }
        this._skyFromSpaceProgram.apply();
        this._initUniforms(this._skyFromSpaceProgram.uniforms);
        this._skyFromAtmosphereProgram.apply();
        this._initUniforms(this._skyFromAtmosphereProgram.uniforms);
        this._groundFromSpaceProgram.apply();
        this._initUniforms(this._groundFromSpaceProgram.uniforms);
        this._groundFromAtmosphereProgram.apply();
        this._initUniforms(this._groundFromAtmosphereProgram.uniforms);

        // Create the sphere
        var vertices = [];
        var indices = [];

        var nbEl = 72;
        var nbAz = 144;

        // Create the vertices
        var el;
        var az;
        for (el = -nbEl; el <= nbEl; el++) {
            var elevation = el * (Math.PI * 0.5) / nbEl;
            for (az = -nbAz; az <= nbAz; az++) {
                var azimuth = az * Math.PI / nbAz;

                var x = this._outerRadius * Math.cos(azimuth) * Math.cos(elevation);
                var y = this._outerRadius * Math.sin(azimuth) * Math.cos(elevation);
                var z = this._outerRadius * Math.sin(elevation);

                vertices.push(x);
                vertices.push(y);
                vertices.push(z);
            }
        }

        // build the sphere triangles
        for (el = 0; el < 2 * nbEl; el++) {
            for (az = 0; az < 2 * nbAz; az++) {
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az + 1);

                indices.push((el + 1) * (2 * nbAz + 1) + az + 1);
                indices.push(el * (2 * nbAz + 1) + az);
                indices.push((el + 1) * (2 * nbAz + 1) + az);
            }
        }

        var gl = renderContext.gl;
        this._vertexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);

        this._indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        this._numIndices = indices.length;

        this._originalProgram = g.tileManager.program;

        g.preRenderers.push(this);
        g.tileManager.addPostRenderer(this);
    };

    /**************************************************************************************************************/

    /**
     * Initializes uniforms.
     * @function _initUniforms
     * @memberOf AtmosphereLayer#
     * @param uniforms
     * @private
     */
    AtmosphereLayer.prototype._initUniforms = function (uniforms) {
        var gl = this.globe.renderContext.gl;

        var g = -0.95;		// The Mie phase asymmetry factor
        var scale = 1.0 / ( this._outerRadius - this._innerRadius );
        var rayleighScaleDepth = 0.25;
        //var mieScaleDepth = 0.1;

        vec3.normalize(this.lightDir);

        gl.uniform1f(uniforms.fKrESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKmESun, this.kr * this.sunBrightness);
        gl.uniform1f(uniforms.fKr4PI, this.kr * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fKm4PI, this.km * 4.0 * Math.PI);
        gl.uniform1f(uniforms.fExposure, this.exposure);

        var wavelength = [Math.pow(this.wavelength[0], 4.0), Math.pow(this.wavelength[1], 4.0), Math.pow(this.wavelength[2], 4.0)];
        gl.uniform3f(uniforms.v3InvWavelength, 1.0 / wavelength[0], 1.0 / wavelength[1], 1.0 / wavelength[2]);

        gl.uniform3f(uniforms.v3LightPos, this.lightDir[0], this.lightDir[1], this.lightDir[2]);
        gl.uniform1f(uniforms.fInnerRadius, this._innerRadius);
        gl.uniform1f(uniforms.fInnerRadius2, this._innerRadius * this._innerRadius);
        gl.uniform1f(uniforms.fOuterRadius, this._outerRadius);
        gl.uniform1f(uniforms.fOuterRadius2, this._outerRadius * this._outerRadius);
        gl.uniform1f(uniforms.fScale, scale);
        gl.uniform1f(uniforms.fScaleDepth, rayleighScaleDepth);
        gl.uniform1f(uniforms.fScaleOverScaleDepth, scale / rayleighScaleDepth);
        gl.uniform1f(uniforms.g, g);
        gl.uniform1f(uniforms.g2, g * g);
    };

    /**************************************************************************************************************/

    /**
     * Pre-rendesr the atmoshpere.
     * @function preRender
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.preRender = function () {
        if (!this._isValid) {
            return;
        }
        var tileManager = this.globe.tileManager;
        if (!this.isVisible()) {
            tileManager.program = this._originalProgram;
            return;
        }

        var rc = this.globe.renderContext;
        var gl = rc.gl;
        var x,y,z;

        // Compute the eye position from the view matrix : the eye position is equals to [0,0,0] * inv(viewMatrix)
        // Optimized to avoid to compute the view matrix inverse
        var vm = rc.viewMatrix;
        x = vm[12];
        y = vm[13];
        z = vm[14];
        var eyePos = [-( vm[0] * x + vm[1] * y + vm[2] * z ),
            -( vm[4] * x + vm[5] * y + vm[6] * z ),
            -( vm[8] * x + vm[9] * y + vm[10] * z )];
        var eyeHeight = vec3.length(eyePos);

        this._skyProgram = eyeHeight < this._outerRadius ? this._skyFromAtmosphereProgram : this._skyFromSpaceProgram;
        this._groundProgram = eyeHeight < this._outerRadius ? this._groundFromAtmosphereProgram : this._groundFromSpaceProgram;

        this._skyProgram.apply();

        gl.uniform3f(this._skyProgram.uniforms.v3CameraPos, eyePos[0], eyePos[1], eyePos[2]);
        gl.uniform1f(this._skyProgram.uniforms.fCameraHeight2, eyeHeight * eyeHeight);
        gl.uniform1f(this._skyProgram.uniforms.fCameraHeight, eyeHeight);

        this._groundProgram.apply();

        var earthCenter = [0.0, 0.0, 0.0];
        mat4.multiplyVec3(rc.viewMatrix, earthCenter);
        gl.uniform3f(this._groundProgram.uniforms.earthCenter, earthCenter[0], earthCenter[1], earthCenter[2]);

        vec3.normalize(this.lightDir);
        x = this.lightDir[0];
        y = this.lightDir[1];
        z = this.lightDir[2];
        var mat = rc.viewMatrix;
        var lightDirUpdated = [];
        lightDirUpdated[0] = mat[0] * x + mat[4] * y + mat[8] * z;
        lightDirUpdated[1] = mat[1] * x + mat[5] * y + mat[9] * z;
        lightDirUpdated[2] = mat[2] * x + mat[6] * y + mat[10] * z;
        gl.uniform3f(this._groundProgram.uniforms.lightDir, lightDirUpdated[0], lightDirUpdated[1], lightDirUpdated[2]);

        gl.uniform3f(this._groundProgram.uniforms.v3CameraPos, eyePos[0], eyePos[1], eyePos[2]);
        gl.uniform1f(this._groundProgram.uniforms.fCameraHeight2, eyeHeight * eyeHeight);
        gl.uniform1f(this._groundProgram.uniforms.fCameraHeight, eyeHeight);

        tileManager.program = this._groundProgram;

//	rc.minFar = 2.0;
    };

    /**************************************************************************************************************/

    /**
     * Renders the atmosphere.
     * @function render
     * @memberof AtmosphereLayer#
     */
    AtmosphereLayer.prototype.render = function () {
        if (!this._isValid || !this.isVisible() || !this.globe) {
            return;
        }
        var rc = this.globe.renderContext;
        var gl = rc.gl;

        gl.enable(gl.CULL_FACE);

		this._skyProgram.apply();

        gl.uniformMatrix4fv(this._skyProgram.uniforms.projectionMatrix, false, rc.projectionMatrix);
        gl.uniformMatrix4fv(this._skyProgram.uniforms.viewMatrix, false, rc.viewMatrix);

        gl.bindBuffer(gl.ARRAY_BUFFER, this._vertexBuffer);
        gl.vertexAttribPointer(this._skyProgram.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this._indexBuffer);
        gl.drawElements(gl.TRIANGLES, this._numIndices, gl.UNSIGNED_SHORT, 0);

        gl.disable(gl.CULL_FACE);
    };

    /**************************************************************************************************************/

    return AtmosphereLayer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/MercatorTiling',['./Tile', '../Renderer/GeoBound', './GeoTiling'], function (Tile, GeoBound, GeoTiling) {
      var lon2merc = function (lon) {
          return lon * 20037508.34 / 180;
      };

      var lat2merc = function (lat) {
          var y = Math.log(Math.tan((90 + lat) * Math.PI / 360)) / (Math.PI / 180);
          return y * 20037508.34 / 180;
      };

      var tile2long = function (x, z) {
          return ( x / Math.pow(2, z) * 360 - 180 );
      };

      var tile2lat = function (y, z) {
          var n = Math.PI - 2 * Math.PI * y / Math.pow(2, z);
          return ( 180 / Math.PI * Math.atan(0.5 * (Math.exp(n) - Math.exp(-n))));
      };


      /**************************************************************************************************************/


      /** @constructor
       Tile constructor
       */
      var MercatorTile = function (level, x, y) {
          // Call ancestor constructor
          Tile.prototype.constructor.call(this);

          this.level = level;
          this.x = x;
          this.y = y;

          this.geoBound = new GeoBound(tile2long(x, level), tile2lat(y + 1, level), tile2long(x + 1, level), tile2lat(y, level));
          this.bound = new GeoBound(lon2merc(this.geoBound.west), lat2merc(this.geoBound.south), lon2merc(this.geoBound.east), lat2merc(this.geoBound.north));
      };

      /**************************************************************************************************************/

      /** Inhertis from tile */
      MercatorTile.prototype = new Tile;

      /**************************************************************************************************************/

      /** @export
       Get elevation at a geo position
       */
      MercatorTile.prototype.getElevation = function (lon, lat) {
          // TODO
          return 0.0;
      };

      /**************************************************************************************************************/

      /**
       Create the children
       */
      MercatorTile.prototype.createChildren = function () {
          // Create the children
          var tile00 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y);
          var tile10 = new MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y);
          var tile01 = new MercatorTile(this.level + 1, 2 * this.x, 2 * this.y + 1);
          var tile11 = new MercatorTile(this.level + 1, 2 * this.x + 1, 2 * this.y + 1);

          tile00.initFromParent(this, 0, 0);
          tile10.initFromParent(this, 1, 0);
          tile01.initFromParent(this, 0, 1);
          tile11.initFromParent(this, 1, 1);

          this.children = [tile00, tile10, tile01, tile11];
      };

      /**************************************************************************************************************/

      /**
       Convert coordinates in longitude,latitude to coordinate in "tile space"
       Tile space means coordinates are between [0,tesselation-1] if inside the tile
       Used by renderers algorithm to clamp coordinates on the tile
       */
      MercatorTile.prototype.lonlat2tile = function (coordinates) {
          var tpl = Math.pow(2, this.level);
          var factor = this.config.tesselation - 1;

          var tileCoords = [];
          for (var i = 0; i < coordinates.length; i++) {
              var x = ( coordinates[i][0] + 180.0) / 360.0;
              var sinLat = Math.sin(coordinates[i][1] * Math.PI / 180.0);
              var y = 0.5 - Math.log((1 + sinLat) / (1 - sinLat)) / (4.0 * Math.PI);

              tileCoords.push([factor * (x * tpl - this.x), factor * (y * tpl - this.y)]);
          }

          return tileCoords;
      };

      /**************************************************************************************************************/

      /**
       Generate vertices for tile
       */
      MercatorTile.prototype.generateVertices = function (elevations) {
          // Compute tile matrix
          this.matrix = this.config.coordinateSystem.getLHVTransform(this.geoBound.getCenter());
          var invMatrix = mat4.create();
          mat4.inverse(this.matrix, invMatrix);
          this.inverseMatrix = invMatrix;

          // Build the vertices
          var size = this.config.tesselation;
          var vertices = new Float32Array(3 * size * (size + 6));
          var step = 1.0 / (size - 1);
          var radius = this.config.coordinateSystem.geoide.radius;
          var scale = this.config.coordinateSystem.geoide.heightScale;
          var offset = 0;

          var twoPowLevel = Math.pow(2, this.level);
		  var pos3d = [0.0, 0.0, 0.0];
          var v = this.y;
          for (var j = 0; j < size; j++) {
              var n = Math.PI * (1.0 - 2.0 * v / twoPowLevel);
              var lat = Math.atan(0.5 * (Math.exp(n) - Math.exp(-n)));
			  lat = lat * 180 / Math.PI;

              var cosLat = Math.cos(lat);
              var sinLat = Math.sin(lat);

              var u = this.x;

              for (var i = 0; i < size; i++) {
                  var lon = 180 * ( 2.0 * u / twoPowLevel - 1.0 );
                  var height = elevations ? scale * elevations[offset] : 0.0;

				  this.config.coordinateSystem.fromGeoTo3D([lon, lat, height], pos3d);
				  var x = pos3d[0];
				  var y = pos3d[1];
				  var z = pos3d[2];

                  var vertexOffset = offset * 3;
                  vertices[vertexOffset] = invMatrix[0] * x + invMatrix[4] * y + invMatrix[8] * z + invMatrix[12];
                  vertices[vertexOffset + 1] = invMatrix[1] * x + invMatrix[5] * y + invMatrix[9] * z + invMatrix[13];
                  vertices[vertexOffset + 2] = invMatrix[2] * x + invMatrix[6] * y + invMatrix[10] * z + invMatrix[14];

                  offset++;
                  u += step;
              }

              v += step;
          }

          return vertices;
      };


      /**************************************************************************************************************/

      /**
       Override buildSkirtVertices for mercator.
       Use skirt to "fill" the pole
       */
      MercatorTile.prototype.buildSkirtVertices = function (center, srcOffset, srcStep, dstOffset) {
          var size = this.config.tesselation;
          var vertexSize = this.config.vertexSize;
          var numTilesY = Math.pow(2, this.level);

          // Check if the tile is at the north (isTop) or south (isBottom) pole
          var isTop = this.y === 0 && dstOffset === vertexSize * (size * size);
          var isBottom = this.y === numTilesY - 1 && dstOffset === vertexSize * ((size + 1) * size);

          if (isTop || isBottom) {
              var vertices = this.vertices;

              var pt = this.config.coordinateSystem.fromGeoTo3D(isTop ? [0.0, 90.0, 0.0] : [0.0, -90.0, 0.0]);
              mat4.multiplyVec3(this.inverseMatrix, pt);

              for (var i = 0; i < size; i++) {
                  vertices[dstOffset] = pt[0];
                  vertices[dstOffset + 1] = pt[1];
                  vertices[dstOffset + 2] = pt[2];

                  for (var n = 3; n < vertexSize; n++) {
                      vertices[dstOffset + n] = vertices[srcOffset + n];
                  }

                  dstOffset += vertexSize;
              }

              // Recompute the bbox to have correct culling
              //this.bbox.compute(this.vertices,dstOffset + vertexSize*size,vertexSize);
              //this.radius = this.bbox.getRadius();
          }
          else {
              Tile.prototype.buildSkirtVertices.call(this, center, srcOffset, srcStep, dstOffset);
          }
      };

    /**************************************************************************************************************/

    /**
     MercatorTiling constructor
     @constructor
     */
    var MercatorTiling = function (startLevel) {
        this.startLevel = startLevel;
        this.level0NumTilesX = Math.pow(2, this.startLevel);
    };

    /** inherits from geotiling */
    MercatorTiling.prototype = new GeoTiling;

    /**************************************************************************************************************/

    /**
     Generate the tiles for level zero
     */
    MercatorTiling.prototype.generateLevelZeroTiles = function (config) {
        config.skirt = !config.coordinateSystem.isFlat();
        config.cullSign = 1;
        config.srs = 'EPSG:3857';
        config.project = function (coord) {
            return [lon2merc(coord[0]), lat2merc(coord[1])];
        };

        var level0Tiles = [];

        var level0NumTilesX = Math.pow(2, this.startLevel);
        var level0NumTilesY = Math.pow(2, this.startLevel);

        for (var j = 0; j < level0NumTilesY; j++) {
            for (var i = 0; i < level0NumTilesX; i++) {
                var tile = new MercatorTile(this.startLevel, i, j);
                tile.config = config;
                level0Tiles.push(tile);
            }
        }

        return level0Tiles;
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lon2LevelZeroIndex = function (lon) {
        var x = (lon + 180) / 360;
        return Math.min(this.level0NumTilesX - 1, Math.floor(x * this.level0NumTilesX));
    };

    /**************************************************************************************************************/

    /**
     Locate a level zero tile
     */
    MercatorTiling.prototype._lat2LevelZeroIndex = function (lat) {
        var sinLatitude = Math.sin(lat * Math.PI / 180);
        var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);
        return Math.min(this.level0NumTilesX - 1, Math.floor(y * this.level0NumTilesX));
    };


    /**************************************************************************************************************/

    return MercatorTiling;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/BingLayer',['../Utils/Utils', './AbstractRasterLayer', '../Utils/Constants','../Tiling/MercatorTiling'], function (Utils, AbstractRasterLayer, Constants, MercatorTiling) {

    /**************************************************************************************************************/
    var BingTileSystem = (function () {
        var EarthRadius = 6378137;
        var MinLatitude = -85.05112878;
        var MaxLatitude = 85.05112878;
        var MinLongitude = -180;
        var MaxLongitude = 180;

        /**
         * Clips a number to the specified minimum and maximum values.
         * @param n - The number to clip.
         * @param minValue - Minimum allowable value.
         * @param maxValue - Maximum allowable value.
         * @returns {number} The clipped value.
         * @private
         * @constructor
         */
        function Clip(n, minValue, maxValue) {
            return Math.min(Math.max(n, minValue), maxValue);
        }

        /**
         * Determines the map width and height (in pixels) at a specified level of detail.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number} The map width and height in pixels.
         * @constructor
         * @private
         */
        function MapSize(levelOfDetail) {
            return 256 << levelOfDetail;
        }

        /**
         * Determines the ground resolution (in meters per pixel) at a specified
         * latitude and level of detail.
         * @param latitude - Latitude (in degrees) at which to measure the ground resolution
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {number}
         * @constructor
         */
        function GroundResolution(latitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            return Math.cos(latitude * Math.PI / 180.0) * 2.0 * Math.PI * EarthRadius / MapSize(levelOfDetail);
        }

        /**
         * Determines the map scale at a specified latitude, level of detail, and screen resolution.
         * @param latitude - Latitude (in degrees) at which to measure the map scale.
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @param screenDpi - Resolution of the screen, in dots per inch.
         * @returns {number} The map scale, expressed as the denominator N of the ratio 1 : N.
         * @constructor
         * @private
         */
        function MapScale(latitude, levelOfDetail, screenDpi) {
            return GroundResolution(latitude, levelOfDetail) * screenDpi / 0.0254;
        }

        /**
         * Converts a point from latitude/longitude WGS-84 coordinates (in degrees)
         * into pixel XY coordinates at a specified level of detail.
         * @param latitude - Latitude of the point, in degrees
         * @param longitude - Longitude of the point, in degrees
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the X coordinate in pixels, Output parameter receiving the Y coordinate in pixels]
         * @constructor
         */
        function LatLongToPixelXY(latitude, longitude, levelOfDetail) {
            latitude = Clip(latitude, MinLatitude, MaxLatitude);
            longitude = Clip(longitude, MinLongitude, MaxLongitude);

            var x = (longitude + 180) / 360;
            var sinLatitude = Math.sin(latitude * Math.PI / 180);
            var y = 0.5 - Math.log((1 + sinLatitude) / (1 - sinLatitude)) / (4 * Math.PI);

            var mapSize = MapSize(levelOfDetail);
            var pixelX = Clip(x * mapSize + 0.5, 0, mapSize - 1);
            var pixelY = Clip(y * mapSize + 0.5, 0, mapSize - 1);

            return [Math.floor(pixelX), Math.floor(pixelY)];
        }

        /**
         * Converts a pixel from pixel XY coordinates at a specified level of detail
         * into latitude/longitude WGS-84 coordinates (in degrees).
         * @param pixelX - X coordinate of the point, in pixels
         * @param pixelY - Y coordinates of the point, in pixels
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {float[]} [Output parameter receiving the latitude in degrees, Output parameter receiving the longitude in degrees]
         * @constructor
         */
        function PixelXYToLatLong(pixelX, pixelY, levelOfDetail) {
            var mapSize = MapSize(levelOfDetail);
            var x = (Clip(pixelX, 0, mapSize - 1) / mapSize) - 0.5;
            var y = 0.5 - (Clip(pixelY, 0, mapSize - 1) / mapSize);

            var latitude = 90 - 360 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI;
            var longitude = 360 * x;

            return [latitude, longitude];
        }

        /**
         * Converts pixel XY coordinates into tile XY coordinates of the tile containing the specified pixel.
         * @param pixelXY [Pixel X coordinate, Pixel Y coordinate]
         * @returns {float[]} [Output parameter receiving the tile X coordinate, Output parameter receiving the tile Y coordinate]
         * @constructor
         */
        function PixelXYToTileXY(pixelXY) {
            return [pixelXY[0] / 256, pixelXY[1] / 256];
        }

        /**
         * Converts tile XY coordinates into pixel XY coordinates of the upper-left pixel of the specified tile.
         * @param tileXY [Tile X coordinate, Tile Y coordinate.]
         * @returns {float[]} [Output parameter receiving the pixel X coordinate,  Output parameter receiving the pixel Y coordinate]
         * @constructor
         */
        function TileXYToPixelXY(tileXY) {
            return [tileXY[0] * 256, tileXY[1] * 256];
        }

        /**
         * Converts tile XY coordinates into a QuadKey at a specified level of detail.
         * @param tileX - Tile X coordinate
         * @param tileY - Tile Y coordinate
         * @param levelOfDetail - Level of detail, from 1 (lowest detail) to 23 (highest detail)
         * @returns {string} A string containing the QuadKey
         * @constructor
         * @private
         */
        function TileXYToQuadKey(tileX, tileY, levelOfDetail) {
            var quadKey = "";
            for (var i = levelOfDetail; i > 0; i--) {
                var digit = '0';
                var mask = 1 << (i - 1);
                if ((tileX & mask) !== 0) {
                    digit++;
                }
                if ((tileY & mask) !== 0) {
                    digit++;
                    digit++;
                }
                quadKey += digit;
            }
            return quadKey;
        }

        /**
         * Converts a QuadKey into tile XY coordinates.
         * @param quadKey - QuadKey of the tile
         * @constructor
         */
        function QuadKeyToTileXY(quadKey) {
            var tileX = 0, tileY = 0;
            var levelOfDetail = quadKey.length();
            for (var i = levelOfDetail; i > 0; i--) {
                var mask = 1 << (i - 1);
                switch (quadKey[levelOfDetail - i]) {
                    case '0':
                        break;

                    case '1':
                        tileX |= mask;
                        break;

                    case '2':
                        tileY |= mask;
                        break;

                    case '3':
                        tileX |= mask;
                        tileY |= mask;
                        break;

                    default:
                        throw new ArgumentException("Invalid QuadKey digit sequence.");
                }
            }
        }

        return {
            tileXYToQuadKey: TileXYToQuadKey,
            latLongToPixelXY: LatLongToPixelXY
        };
    })();

    /**************************************************************************************************************/

    /**
     * Bing layer configuration
     * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.bing_configuration
     * @property {int} [baseLevel=2]
     * @property {onreadyCallback} [onready] - CallBack function.
     * @property {String} imageSet the image set to use, can be Aerial, Road
     * @property {String} key the bing key to use
     */

    /**
     * Callback when the layer is ready.
     * @callback onreadyCallback
     * @param {BingLayer} Bing layer
     */

    /**
     * @name BingLayer
     * @class
     *     Bing Maps is a web mapping service provided as a part of Microsoft's Bing suite of search engines and powered
     * by the Bing Maps for Enterprise framework.
     * @augments AbstractRasterLayer
     * @param {AbstractRasterLayer.bing_configuration} options -Bing Layer configuration
     * @see {@link https://en.wikipedia.org/wiki/Bing_Maps}
     * @memberOf module:Layer
     */
    var BingLayer = function (options) {
        // Call ancestor
        AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.Bing, options);

        this.tilePixelSize = 256;
        this.tiling = new MercatorTiling(options.baseLevel || 2);
        this.numberOfLevels = 18;
        this.baseUrl = "";
        this.baseUrlSubDomains = [];
        this._ready = false;

        var self = this;

        // Need to provide a global callback for JSONP
        window._bingTileProviderCallback = function (result) {

            self.baseUrl = this.proxify(result.resourceSets[0].resources[0].imageUrl);
            self.baseUrlSubDomains = this.proxify(result.resourceSets[0].resources[0].imageUrlSubdomains);
            self._ready = true;

            // Call callback if set
            if (options.onready && options.onready instanceof Function) {
                options.onready(self);
            }

            // Request a frame
            if (self.globe) {
                self.globe.renderContext.requestFrame();
            }
        };

        // JSONP Call : needed because of cross-site origin policy
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = this.proxify("http://dev.virtualearth.net/REST/V1/Imagery/Metadata/" + options.imageSet + "?jsonp=_bingTileProviderCallback&key=" + options.key);
        script.id = "_bingTileProviderCallback";
        document.getElementsByTagName("head")[0].appendChild(script);
    };

    Utils.inherits(AbstractRasterLayer, BingLayer);

    /**************************************************************************************************************/

    /**
     * Returns an url for the given tile.
     * @function getUrl
     * @memberOf BingLayer#
     * @param {Tile} tile Tile
     * @returns {string} Url
     */
    BingLayer.prototype.getUrl = function (tile) {
        var url = this.baseUrl.replace("{quadkey}", BingTileSystem.tileXYToQuadKey(tile.x, tile.y, tile.level));
        return url.replace("{subdomain}", this.baseUrlSubDomains[Math.floor(Math.random() * this.baseUrlSubDomains.length)]);
    };

    /**************************************************************************************************************/

    return BingLayer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/GroundOverlayRenderer',['./Program','../Tiling/Tile'], function(Program,Tile) {

//*************************************************************************

/**
	@name GroundOverlayRenderer
	@class
	 GroundOverlayRenderer constructor
	@param {TileManager} tileManager Tile manager
	@constructor
	*/
var GroundOverlayRenderer = function(tileManager)
{
	this.renderContext = tileManager.renderContext;
	this.tileManager = tileManager;

	var vertexShader = "attribute vec3 vertex;\n";
	vertexShader    += "attribute vec2 tcoord;\n";
	vertexShader    += "uniform mat4 modelViewMatrix;\n";
	vertexShader    += "uniform mat4 projectionMatrix;\n";
	vertexShader    += "uniform vec4 extent; \n";
	vertexShader    += "varying vec2 texCoord;\n";
	vertexShader    += "void main(void) \n";
	vertexShader    += "{\n";
	vertexShader    += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
	vertexShader    += "	texCoord.x = tcoord.x * (extent[1] - extent[0]) + extent[0];\n";
	vertexShader    += "	texCoord.y = tcoord.y * (extent[3] - extent[2]) + extent[2];\n";
	vertexShader    += "}\n";

	var fragmentShader = "#ifdef GL_ES\n";
	fragmentShader    += "precision highp float;\n";
	fragmentShader    += "#endif\n";
	fragmentShader    += "\n";
	fragmentShader    += "varying vec2 texCoord;\n";
	fragmentShader    += "uniform sampler2D overlayTexture;\n";
	fragmentShader    += "uniform mat3 transform;\n";
	fragmentShader    += "uniform float opacity; \n";
	fragmentShader    += "\n";
	fragmentShader    += "void main(void)\n";
	fragmentShader    += "{\n";
	fragmentShader    += "	vec3 tc = transform * vec3(texCoord,1.0); \n";
	fragmentShader    += "	tc.xy /= tc.z; \n";
	fragmentShader    += "	gl_FragColor.rgba = texture2D(overlayTexture, tc.xy); \n";
	fragmentShader    += "	gl_FragColor.a = (tc.x >= 0.0 && tc.x <= 1.0 && tc.y >= 0.0 && tc.y <= 1.0) ? opacity * gl_FragColor.a  : 0.0; \n";
	fragmentShader    += "}\n";

  this.program = new Program(this.renderContext);
	this.program.createFromSource( vertexShader, fragmentShader );

	this.groundOverlays = [];
};

//*************************************************************************

/*
	Render the ground overlays above the tiles in parameter
 */
GroundOverlayRenderer.prototype.render = function( tiles )
{
 	var gl = this.renderContext.gl;

	// Setup program
    this.program.apply();

	var attributes = this.program.attributes;

	gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, this.renderContext.projectionMatrix);
	gl.uniform1i(this.program.uniforms.overlayTexture, 0);
	gl.enable(gl.BLEND);
	gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA );
	gl.depthFunc( gl.LEQUAL );
	gl.depthMask(false);

	var modelViewMatrix = mat4.create();

	var currentIB = null;

	for ( var j=0; j < this.groundOverlays.length; j++ )
	{
		var go = this.groundOverlays[j];

		// Image is not loaded, nothing to be done
		if ( !go.image.complete )
		{
			continue;
		}

		if ( !go.texture )
		{
			go.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(go.image,go.flipY);
		}

		var initialized = false;

		for ( var i = 0; i < tiles.length; i++ )
		{
			var tile = tiles[i];
			if ( go.geoBound.intersects( tile.geoBound ) )
			{
				if (!initialized)
				{
					gl.uniformMatrix3fv(this.program.uniforms.transform, false, go.inverseTransform );
					gl.uniform1f(this.program.uniforms.opacity, go.opacity );

					gl.activeTexture(gl.TEXTURE0);
					gl.bindTexture(gl.TEXTURE_2D, go.texture);

					gl.bindBuffer(gl.ARRAY_BUFFER, this.tileManager.tcoordBuffer);
					gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);

					initialized = true;
				}

				var extent = (tile.state === Tile.State.LOADED) ? tile.bound : tile.parent.bound;

				gl.uniform4f(this.program.uniforms.extent, extent.west, extent.east, extent.north, extent.south );
				mat4.multiply( this.renderContext.viewMatrix, tile.matrix, modelViewMatrix );
				gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, modelViewMatrix);

				// Bind the vertex buffer
				gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
				gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0);

				// Bind the index buffer only if different (index buffer is shared between tiles)
				var indexBuffer = ( tile.state === Tile.State.LOADED ) ? this.tileManager.tileIndexBuffer.getSolid() : this.tileManager.tileIndexBuffer.getSubSolid(tile.parentIndex);
				if ( currentIB !== indexBuffer )
				{
					gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
					currentIB = indexBuffer;
				}

				// Finally draw the tiles
				gl.drawElements(gl.TRIANGLES, indexBuffer.numIndices, gl.UNSIGNED_SHORT, 0);
			}
		}
	}

	gl.disable(gl.BLEND);
	gl.depthMask(true);
};

//*************************************************************************

return GroundOverlayRenderer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/GroundOverlayLayer',['../Utils/Utils', './AbstractLayer', '../Utils/Constants', '../Renderer/GeoBound', '../Renderer/GroundOverlayRenderer'],
    function (Utils, AbstractLayer, Constants, GeoBound, GroundOverlayRenderer) {

        /**
         * GroundOverlay Layer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.groundOverlay_configuration
         * @param {float[]} quad  - An array of 4 points to define the area on the terrain to drape the image
         * @param {Object|String} image - the image to drape on the terrain, can be an Image element or a string (url of the image)
         * @param {boolean} [flipY=true] - flip or not the image          
         */
        
        /**
         * @name GroundOverlayLayer
         * @class
         * This layer draws an image overlay draped onto the terrain
         * @augments AbstractLayer
         * @param {AbstractLayer.groundOverlay_configuration} options - Ground overlay configuration
         * @constructor
         * @memberOf module:Layer
         */
        var GroundOverlayLayer = function (options) {
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.GroundOverlay, options);

            this.quad = options.quad;
            if (typeof options.flipY === 'undefined') {
                this.flipY = true;
            }
            else {
                this.flipY = options.flipY;
            }

            // Compute the geo bound of the ground overlay
            this.geoBound = new GeoBound();
            this.geoBound.computeFromCoordinates(this.quad);

            if (typeof options.image === "string") {
                this.image = new Image();
                this.image.crossOrigin = '';
                this.image.src = options.image;
            }
            else if (options.image instanceof HTMLImageElement) {
                this.image = options.image;
            }
            this.globe = null;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, GroundOverlayLayer);

        /**************************************************************************************************************/

        /**
         * Attaches layer to the globe.
         * @function _attach
         * @memberof GroundOverlayLayer#
         * @param {AbstractGlobe} planet - Globe to attach
         * @private
         */
        GroundOverlayLayer.prototype._attach = function (planet) {
            // Add layer to ground overlay renderer, create one if needed
            var renderer = planet.groundOverlayRenderer;
            if (!renderer) {
                renderer = new GroundOverlayRenderer(planet.tileManager);
                planet.tileManager.addPostRenderer(renderer);
                planet.groundOverlayRenderer = renderer;
            }
            renderer.groundOverlays.push(this);

            this.globe = planet;

            this.computeTransform();
        };

        //*************************************************************************

        /**
         * Detaches layer from the globe.
         * @function _detach
         * @memberof GroundOverlayLayer#
         * @param {AbstractGlobe} globe - globe to detach
         * @private
         */
        GroundOverlayLayer.prototype._detach = function (planet) {
            // Remove layer from the planet renderer for ground overlay
            var prevRenderer = this.globe.groundOverlayRenderer;
            if (prevRenderer) {
                var index = prevRenderer.groundOverlays.indexOf(this);
                if (index !== -1) {
                    prevRenderer.groundOverlays.splice(index, 1);

                    if (prevRenderer.groundOverlays.length === 0) {
                        this.globe.tileManager.removePostRenderer(prevRenderer);
                        this.globe.groundOverlayRenderer = null;
                    }
                }
            }
        };

        //*************************************************************************


        /**
         * Computes the inverse transform from unit square to geo position
         * Code taken from QTransform
         * @function computeInverse
         * @memberOf GroundOverlayLayer#
         */
        GroundOverlayLayer.prototype.computeInverse = function () {
            var det = this.transform[0] * (this.transform[8] * this.transform[4] - this.transform[5] * this.transform[7]) -
                this.transform[3] * (this.transform[8] * this.transform[1] - this.transform[7]) * this.transform[3] +
                this.transform[6] * ( this.transform[5] * this.transform[1] - this.transform[4] * this.transform[2]);

            var h11, h12, h13,
                h21, h22, h23,
                h31, h32, h33;
            h11 = this.transform[4] * this.transform[8] - this.transform[5] * this.transform[7];
            h21 = this.transform[5] * this.transform[6] - this.transform[3] * this.transform[8];
            h31 = this.transform[3] * this.transform[7] - this.transform[4] * this.transform[6];
            h12 = this.transform[2] * this.transform[7] - this.transform[1] * this.transform[8];
            h22 = this.transform[0] * this.transform[8] - this.transform[2] * this.transform[6];
            h32 = this.transform[1] * this.transform[6] - this.transform[0] * this.transform[7];
            h13 = this.transform[1] * this.transform[5] - this.transform[2] * this.transform[4];
            h23 = this.transform[2] * this.transform[3] - this.transform[0] * this.transform[5];
            h33 = this.transform[0] * this.transform[4] - this.transform[1] * this.transform[3];

            this.inverseTransform = [h11 / det, h12 / det, h13 / det,
                h21 / det, h22 / det, h23 / det,
                h31 / det, h32 / det, h33 / det];
        };

        //*************************************************************************

        /**
         * Computes the transform from geo position to unit square
         * Code taken from QTransform
         * @function computeTransform
         * @memberOf GroundOverlayLayer#
         */
        GroundOverlayLayer.prototype.computeTransform = function () {
            var q1 = this.quad[0];
            var q2 = this.quad[1];
            var q3 = this.quad[2];
            var q4 = this.quad[3];

            var tileConfig = this.globe.tileManager.tileConfig;
            if (tileConfig.srs !== 'EPSG:4326') {
                q1 = tileConfig.project(q1);
                q2 = tileConfig.project(q2);
                q3 = tileConfig.project(q3);
                q4 = tileConfig.project(q4);
            }

            var dx0 = q1[0];
            var dx1 = q2[0];
            var dx2 = q3[0];
            var dx3 = q4[0];

            var dy0 = q1[1];
            var dy1 = q2[1];
            var dy2 = q3[1];
            var dy3 = q4[1];

            var ax = dx0 - dx1 + dx2 - dx3;
            var ay = dy0 - dy1 + dy2 - dy3;

            if (!ax && !ay) { //afine transform
                this.transform = [dx1 - dx0, dy1 - dy0, 0,
                    dx2 - dx1, dy2 - dy1, 0,
                    dx0, dy0, 1];
            }
            else {
                var ax1 = dx1 - dx2;
                var ax2 = dx3 - dx2;
                var ay1 = dy1 - dy2;
                var ay2 = dy3 - dy2;

                /*determinants */
                var gtop = ax * ay2 - ax2 * ay;
                var htop = ax1 * ay - ax * ay1;
                var bottom = ax1 * ay2 - ax2 * ay1;

                var a, b, c, d, e, f, g, h;
                /*i is always 1*/

                if (!bottom) {
                    return;
                }

                g = gtop / bottom;
                h = htop / bottom;

                a = dx1 - dx0 + g * dx1;
                b = dx3 - dx0 + h * dx3;
                c = dx0;
                d = dy1 - dy0 + g * dy1;
                e = dy3 - dy0 + h * dy3;
                f = dy0;

                this.transform = [a, d, g,
                    b, e, h,
                    c, f, 1.0];
            }

            this.computeInverse();
        };

        //*************************************************************************

        return GroundOverlayLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/OSMLayer',['../Utils/Utils', './AbstractRasterLayer', '../Utils/Constants', '../Tiling/MercatorTiling'],
    function (Utils, AbstractRasterLayer, Constants, MercatorTiling) {

        /**************************************************************************************************************/

        /**
         * Open Street Map configuration
         * @typedef {AbstractRasterLayer.configuration} AbstractRasterLayer.osm_configuration
         * @property {int} [tilePixelSize=256]
         * @property {int} [baseLevel=2]
         * @property {int} [numberOfLevels=21]
         */
        /**
         * @name OSMLayer
         * @class
         *    A layer to display data coming from OpenStreetMap server. OpenStreetMap (OSM) is a collaborative project to
         * create a free editable map of the world
         * @augments AbstractRasterLayer
         * @param {AbstractRasterLayer.osm_configuration} options - OSM Configuration
         * @memberOf module:Layer
         */
        var OSMLayer = function (options) {
            options.tilePixelSize = options.tilePixelSize || 256;
            options.tiling = new MercatorTiling(options.baseLevel || 2);
            options.numberOfLevels = options.numberOfLevels || 21;
            AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.OSM, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractRasterLayer, OSMLayer);

        /**************************************************************************************************************/

        /**
         * Returns an url for the given tile.
         * @function getUrl
         * @memberof OSMLayer#
         * @param {Tile} tile Tile
         * @return {String} Url
         */
        OSMLayer.prototype.getUrl = function (tile) {
            return this.baseUrl + '/' + tile.level + '/' + tile.x + '/' + tile.y + '.png';
        };


        /**************************************************************************************************************/

        return OSMLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/TileWireframeLayer',['../Utils/Utils', './AbstractLayer', '../Utils/Constants', '../Renderer/Program', '../Tiling/Tile'],
    function (Utils, AbstractLayer, Constants, Program, Tile) {

        /**
         * TileWireFrameLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.tileWireFrame_configuration
         * @property [outline=false]
         */

        /**
         * @name TileWireframeLayer
         * @class
         *    This layer draws an TileWireframe  layer
         * @augments AbstractLayer
         * @param {AbstractLayer.tileWireFrame_configuration} options - TileWireFrame configuration
         * @memberOf module:Layer
         * @constructor
         */
        var TileWireframeLayer = function (options) {
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.TileWireframe, options);
            this.outline = (options && options.outline) ? options.outline : false;
            this.globe = null;
            this.program = null;
            this.indexBuffer = null;
            this.subIndexBuffer = [null, null, null, null];
            this.zIndex = -1;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, TileWireframeLayer);

        /**************************************************************************************************************/

        /**
         * Build the index buffer
         * @function buildIndexBuffer
         * @memberof TileWireframeLayer#
         */
        TileWireframeLayer.prototype.buildIndexBuffer = function () {
            var gl = this.globe.renderContext.gl;
            var size = this.globe.tileManager.tileConfig.tesselation;
            var indices = [];
            var i, j, ii, n, k;
            var step = this.outline ? size - 1 : 1;
            var ib;

            // Build horizontal lines
            for (j = 0; j < size; j += step) {
                for (i = 0; i < size - 1; i++) {
                    indices.push(j * size + i);
                    indices.push(j * size + i + 1);
                }
            }

            // Build vertical lines
            for (j = 0; j < size; j += step) {
                for (i = 0; i < size - 1; i++) {
                    indices.push(i * size + j);
                    indices.push((i + 1) * size + j);
                }
            }


            ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);

            ib.numIndices = indices.length;
            this.indexBuffer = ib;

            var halfTesselation = (size - 1) / 2;
            step = this.outline ? halfTesselation : 1;
            for (ii = 0; ii < 4; ii++) {
                i = ii % 2;
                j = Math.floor(ii / 2);

                // Build the sub grid for 'inside' tile
                indices = [];
                for (n = halfTesselation * j; n < halfTesselation * (j + 1) + 1; n += step) {
                    for (k = halfTesselation * i; k < halfTesselation * (i + 1); k++) {
                        indices.push(n * size + k);
                        indices.push(n * size + k + 1);
                    }
                }
                for (n = halfTesselation * i; n < halfTesselation * (i + 1) + 1; n += step) {
                    for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
                        indices.push(k * size + n);
                        indices.push((k + 1) * size + n);
                    }
                }

                ib = gl.createBuffer();
                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
                gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
                ib.numIndices = indices.length;
                this.subIndexBuffer[ii] = ib;
            }
        };

        /**************************************************************************************************************/
        /**
         * Attaches the layer to the planet
         * @function _attach
         * @memberof TileWireframeLayer#
         * @param {AbstractGlobe} g globe
         * @private
         */
        TileWireframeLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);

            if (this.isVisible()) {
                this.globe.tileManager.addPostRenderer(this);
            }

            if (!this.program) {
                var vertexShader = "attribute vec3 vertex;\n";
                vertexShader += "uniform mat4 modelViewMatrix;\n";
                vertexShader += "uniform mat4 projectionMatrix;\n";
                vertexShader += "void main(void) \n";
                vertexShader += "{\n";
                vertexShader += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
                vertexShader += "}\n";

                var fragmentShader = "precision highp float; \n";
                fragmentShader += "uniform vec3 color; \n";
                fragmentShader += "uniform float alpha; \n";
                fragmentShader += "void main(void)\n";
                fragmentShader += "{\n";
                fragmentShader += "	gl_FragColor = vec4(color,alpha);\n";
                fragmentShader += "}\n";

                this.program = new Program(this.globe.renderContext);
                this.program.createFromSource(vertexShader, fragmentShader);

                this.buildIndexBuffer();
            }
        };

        /**************************************************************************************************************/

        /**
         * Detaches the layer from the planet
         * @function _detach
         * @memberof TileWireframeLayer#
         * @private
         */
        TileWireframeLayer.prototype._detach = function () {
            this.globe.tileManager.removePostRenderer(this);
            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        /**
         * Renders the tiles outline
         * @function render
         * @memberof TileWireframeLayer#
         * @param {Array} tiles Array of Tile
         */
        TileWireframeLayer.prototype.render = function (tiles) {
            var rc = this.globe.renderContext;
            var gl = rc.gl;

            gl.enable(gl.BLEND);

            // Setup program
            this.program.apply();
            gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, rc.projectionMatrix);

            var vertexAttribute = this.program.attributes.vertex;
            var currentIB = null;

            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];

                var isLoaded = ( tile.state === Tile.State.LOADED );
                var isLevelZero = ( tile.parentIndex === -1 );

                // Update uniforms for modelview matrix
                mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
                gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, rc.modelViewMatrix);
                gl.uniform3f(this.program.uniforms.color, this.color[0], this.color[1], this.color[2]);
                gl.uniform1f(this.program.uniforms.alpha, this.getOpacity());

                // Bind the vertex buffer
                gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                gl.vertexAttribPointer(vertexAttribute, 3, gl.FLOAT, false, 4 * tile.config.vertexSize, 0);

                var indexBuffer = ( isLoaded || isLevelZero ) ? this.indexBuffer : this.subIndexBuffer[tile.parentIndex];
                // Bind the index buffer only if different (index buffer is shared between tiles)
                if (currentIB !== indexBuffer) {
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                    currentIB = indexBuffer;
                }

                // Draw the tiles in wireframe mode
                var numIndices = currentIB.numIndices;
                gl.drawElements(gl.LINES, numIndices, gl.UNSIGNED_SHORT, 0);
            }

            gl.disable(gl.BLEND);
        };

        /**************************************************************************************************************/

        /**
         * Get/Set visibility of the layer
         * @function setVisible
         * @memberof TileWireframeLayer#
         * @param {boolean} arg Visiblity
         */
        TileWireframeLayer.prototype.setVisible = function (arg) {
            AbstractLayer.prototype.setVisible.call(this, arg);

            if (typeof arg === "boolean") {
                if (this.isVisible()) {
                    this.globe.tileManager.addPostRenderer(this);
                }
                else {
                    this.globe.tileManager.removePostRenderer(this);
                }
            }

            return this.isVisible();
        };

        return TileWireframeLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/Ray',['./glMatrix'], function() {

/**************************************************************************************************************/

  /**
	 @name Ray
	 @class
	   Ray constructor
	 @param origin
	 @param dir
	 @constructor
	 */
var Ray = function(orig,dir)
{
	this.orig = orig;
	this.dir = dir;
};

/**************************************************************************************************************/

 /**
  * Create a ray from a pixel
  * @function createFromPixel
  * @memberof Ray
  * @param renderContext
  * @param x
  * @param y
  * @return {Ray} Ray
  */
Ray.createFromPixel = function( renderContext, x, y )
{
	// reverse y because (0,0) is top left but opengl's normalized
	// device coordinate (-1,-1) is bottom left
	var nx = ((x / renderContext.canvas.width) * 2.0) - 1.0;
	var ny = -(((y / renderContext.canvas.height) * 2.0) - 1.0);

	var tmpMat = mat4.create();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, tmpMat);
	mat4.inverse(tmpMat);
	// Transform pos to world using inverse viewProjection matrix
	var pos3D = mat4.multiplyVec4(tmpMat, [ nx, ny, -1, 1]);
	pos3D[0] /= pos3D[3];
	pos3D[1] /= pos3D[3];
	pos3D[2] /= pos3D[3];

//	console.log('Old EP ' + renderContext.eyePosition );
	var inverseViewMatrix = mat4.create();
	mat4.inverse( renderContext.viewMatrix, inverseViewMatrix );
	vec3.set( [ 0.0, 0.0, 0.0 ], renderContext.eyePosition );
	mat4.multiplyVec3( inverseViewMatrix, renderContext.eyePosition );
//	console.log('New EP ' + renderContext.eyePosition );


	var orig = vec3.create( renderContext.eyePosition );
	var dir = vec3.subtract( pos3D, renderContext.eyePosition, vec3.create() );
	vec3.normalize(dir);

	return new Ray(orig,dir);
};

/**************************************************************************************************************/

 /**
  * Create a ray from an event
  * @function createFromEvent
  * @memberof Ray
  * @param renderContext
  * @param event
  * @return {Ray} Ray
  */
Ray.createFromEvent = function( renderContext, event )
{
	var pos = renderContext.getXYRelativeToCanvas(event);
	return Ray.createFromPixel( pos[0], pos[1] );
};

/**************************************************************************************************************/

/**
 * Intersection object returned
 * @function Intersection
 * @memberof Ray
 * @param t
 */
Ray.Intersection = function( t )
{
	this.t = t;
	this.geometry = null;
};

/**************************************************************************************************************/

 /**
  * Compute a point on the ray given its t parameter
  * @function computePoint
  * @memberof Ray.prototype
  * @param t
  * @return Point
  */
Ray.prototype.computePoint = function( t )
{
	var pt = vec3.create();
	vec3.scale( this.dir, t, pt );
	vec3.add( pt, this.orig );
	return pt;
};

/**************************************************************************************************************/

 /**
  *	Compute intersection between a plan and ray
  * @function planeIntersect
  * @memberof Ray.prototype
  * @param pt
  * @param normal
  * @return The nearest intersection, < 0 if no intersection
  */
Ray.prototype.planeIntersect = function( pt, normal )
{
    // Assuming vectors are all normalized
    var denom = vec3.dot(normal, this.dir);
	var epsilon = 1e-6;
    if (Math.abs(denom) > epsilon) {
        var p0l0 = vec3.create();
        vec3.subtract(pt, this.orig, p0l0);
        var t = vec3.dot(p0l0, normal) / denom;
        return t;
    }
    return -1;
};

/**************************************************************************************************************/

 /**
  * Compute intersection between a sphere and ray
  * @function sphereIntersect
  * @memberof Ray.prototype
  * @param center
  * @param radius
  * @return the nearest intersection, < 0 if no intersection
  */
Ray.prototype.sphereIntersect = function( center, radius )
{
    // cf. http://wiki.cgsociety.org/index.php/Ray_Sphere_Intersection

    var rs = vec3.subtract( this.orig, center, vec3.create() );
    // rayDirection is normalized so a = 1
    // var a = vec3.dot(rayDirection, rayDirection);
    var b = 2.0 * vec3.dot(this.dir, rs);
    var c = vec3.dot(rs, rs) - radius*radius;

    // as a == 1, discriminant = b^2 - (4*c)
    // var discr = (b*b) - (4*a*c);
    var discr = (b*b) - (4*c);
    if (discr < 0) {
        return -1;
		}

    // t0 = (-b - sqrt(discr)) / 2a, t1 = (-b + sqrt(discr)) / 2a, a == 1
    discr = Math.sqrt(discr);
    var tNear = (-b - discr) / 2;
    var tFar  = (-b + discr) / 2;
    if (tNear > tFar) // Swap t values
    {
        var tmp = tNear;
        tNear = tFar;
        tFar = tmp;
    }

    if (tFar < 0) {
			// Hit is beyond ray origin
	    return -1;
		}

    return tNear < 0 ? tFar : tNear;
};

var EPS = 1e-6;

/**************************************************************************************************************/

 /**
  * Ray triangle intersection optimized
  * @function triangleIntersectOptimized
  * @memberof Ray.prototype
  * @param verts
  * @param i0
  * @param i1
  * @param i2
  * @return the nearest intersection, null if no intersection

  */
Ray.prototype.triangleIntersectOptimized = function( verts, i0, i1, i2 )
{
	var e1x = verts[i1] - verts[i0];
	var e1y = verts[i1+1] - verts[i0+1];
	var e1z = verts[i1+2] - verts[i0+2];

	var e2x = verts[i2] - verts[i0];
	var e2y = verts[i2+1] - verts[i0+1];
	var e2z = verts[i2+2] - verts[i0+2];

    var px = this.dir[1] * e2z - this.dir[2] * e2y;
	var py = this.dir[2] * e2x - this.dir[0] * e2z;
    var pz = this.dir[0] * e2y - this.dir[1] * e2x;

	var det = e1x * px + e1y * py + e1z * pz;

	if ( det > -EPS && det < EPS ) {
		return null;
	}

	var inv_det = 1.0 / det;

	var tx =  this.orig[0] - verts[i0];
	var ty = this.orig[1] - verts[i0+1];
	var tz = this.orig[2] - verts[i0+2];

	var u = (tx * px + ty * py + tz * pz) * inv_det;
	if ( u < 0.0 ||u > 1.0 ) {
		return null;
	}

    var qx = ty * e1z - tz * e1y;
	var qy = tz * e1x - tx * e1z;
    var qz = tx * e1y - ty * e1x;

	var v = (this.dir[0] * qx + this.dir[1] * qy + this.dir[2]  * qz) * inv_det;
	if ( v < 0.0 || u+v > 1.0 ) {
		return null;
	}

	var t = (e2x * qx + e2y * qy + e2z * qz) * inv_det;
	if ( t >= 0 ) {
		return new Ray.Intersection(t);
	} else {
		return null;
	}
};

/**************************************************************************************************************/

/**
 * @function nodeIntersect
 * @memberof Ray.prototype
 * @param node
 * @param intersects
 * @return Intersects
 */
Ray.prototype.nodeIntersect = function (node, intersects) {
		var i;
		intersects = intersects || [];

		for (i = 0; i < node.children.length; i++) {
				node.children[i].intersectWith(this, intersects);
		}

		for (i = 0; i < node.geometries.length; i++) {
				this.geometryIntersect(node.geometries[i], intersects);
		}

		intersects.sort(function (a, b) {
				return a.t - b.t;
		});
		return intersects;
};

/**
 * @function lodNodeIntersect
 * @memberof Ray.prototype
 * @param node
 * @param intersects
 * @return Intersects
 */
Ray.prototype.lodNodeIntersect = function (node, intersects) {
		var i;
		intersects = intersects || [];

		if (this.sphereIntersect(node.center, node.radius) >= 0) {
				if (node.children.length > 0 && node.childToLoad === 0) {
						for (i = 0; i < node.children.length; i++) {
								this.lodNodeIntersect(node.children[i], intersects);
						}
				}
				else {
						for (i = 0; i < node.geometries.length; i++) {
								this.geometryIntersect(node.geometries[i], intersects);
						}
				}
		}

		return intersects;
};

/**
 * @function geometryIntersect
 * @memberof Ray.prototype
 * @param geometry
 * @param intersects
 * @return Intersects
 */
Ray.prototype.geometryIntersect = function (geometry, intersects) {
		var indices = geometry.mesh.indices;
		for (var i = 0; i < indices.length; i += 3) {
				var intersect = this.triangleIntersectOptimized(geometry.mesh.vertices, geometry.mesh.numElements * indices[i],
						geometry.mesh.numElements * indices[i + 1], geometry.mesh.numElements * indices[i + 2]);

				if (intersect) {
						intersect.geometry = geometry;
						intersects.push(intersect);
				}
		}
};

return Ray;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Mesh',[],function () {

    /**************************************************************************************************************/

    /** @constructor
     Mesh constructor
     */
    var Mesh = function (renderContext) {
        this.renderContext = renderContext;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.indexBuffer = null;
        this.colorBuffer = null;
        this.numVertices = 0;
        this.mode = renderContext.gl.TRIANGLES;
    };

    /**************************************************************************************************************/

    /*
     Mesh setVertices method
     */
    Mesh.prototype.setVertices = function (vertices) {
        var gl = this.renderContext.gl;
        if (this.vertexBuffer === null) {
            this.vertexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        this.numVertices = vertices.length;
    };

    /**************************************************************************************************************/

    /*
     Mesh setTexCoords method
     */
    Mesh.prototype.setTexCoords = function (tcoords) {
        var gl = this.renderContext.gl;
        if (this.tcoordBuffer === null) {
            this.tcoordBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(tcoords), gl.STATIC_DRAW);
    };

    /**************************************************************************************************************/

    /*
     Mesh setColors method
     */
    Mesh.prototype.setColors = function (colors) {
        var gl = this.renderContext.gl;
        if (this.colorBuffer === null) {
            this.colorBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors), gl.STATIC_DRAW);
    };

    /**************************************************************************************************************/

    /*
     Mesh setIndices method
     */
    Mesh.prototype.setIndices = function (indices) {
        var gl = this.renderContext.gl;
        if (this.indexBuffer === null) {
            this.indexBuffer = gl.createBuffer();
        }
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
        this.numIndices = indices.length;
    };

    /**************************************************************************************************************/

    /*
     Convert to wireframe (for debug purposes)
     */
    Mesh.prototype.setIndicesToWireframe = function (indices) {
        this.mode = this.renderContext.gl.LINES;

        // Convert indices
        var wireframeIndices = [];
        wireframeIndices.length = 2 * indices.length;

        for (var i = 0; i < indices.length; i += 3) {
            wireframeIndices[2 * i] = indices[i];
            wireframeIndices[2 * i + 1] = indices[i + 1];

            wireframeIndices[2 * i + 2] = indices[i + 1];
            wireframeIndices[2 * i + 3] = indices[i + 2];

            wireframeIndices[2 * i + 4] = indices[i + 2];
            wireframeIndices[2 * i + 5] = indices[i];
        }

        this.setIndices(wireframeIndices);
    };

    /**************************************************************************************************************/

    /*
     Mesh render method
     */
    Mesh.prototype.render = function (attributes) {
        var gl = this.renderContext.gl;

        // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
        gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
        gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 0, 0);
        if (attributes.hasOwnProperty('tcoord')) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
            gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);
        }
        if (attributes.hasOwnProperty('color')) {
            gl.bindBuffer(gl.ARRAY_BUFFER, this.colorBuffer);
            gl.vertexAttribPointer(attributes.color, 4, gl.FLOAT, false, 0, 0);
        }
        if (this.indexBuffer) {
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(this.mode, this.numIndices, gl.UNSIGNED_SHORT, 0);
        }
        else {
            gl.drawArrays(this.mode, 0, this.numVertices / 3);
        }
    };

    /**************************************************************************************************************/

    /*
     Mesh dispose method
     */
    Mesh.prototype.dispose = function () {
        var gl = this.renderContext.gl;
        if (this.indexBuffer) {
            gl.deleteBuffer(this.indexBuffer);
        }
        if (this.vertexBuffer) {
            gl.deleteBuffer(this.vertexBuffer);
        }
        if (this.tcoordBuffer) {
            gl.deleteBuffer(this.tcoordBuffer);
        }
        if (this.colorBuffer) {
            gl.deleteBuffer(this.colorBuffer);
        }

        this.indexBuffer = null;
        this.vertexBuffer = null;
        this.tcoordBuffer = null;
        this.colorBuffer = null;
    };

    /**************************************************************************************************************/

    return Mesh;

});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Crs/AstroCoordTransform',[],function () {

    /**************************************************************************************************************/

    /** The Constant twoPi. */
    var twoPi = 2.0 * Math.PI;

    /** The Constant fourPi. */
    var fourPi = 4.0 * Math.PI;

    /** The Constant degToRad. */
    var degToRad = 180.0 / Math.PI;

    /** The Constant psi. */
    var psi = [
        [0.57595865315, 4.92619181360, 0.00000000000, 0.00000000000, 0.11129056012, 4.70053728340],
        [0.57477043300, 4.93682924650, 0.00000000000, 0.00000000000, 0.11142137093, 4.71279419371]
    ];

    /** The Constant stheta. */
    var stheta = [
        [0.88781538514, -0.88781538514, 0.39788119938, -0.39788119938, 0.86766174755, -0.86766174755],
        [0.88998808748, -0.88998808748, 0.39777715593, -0.39777715593, 0.86766622025, -0.86766622025]
    ];

    /** The Constant ctheta. */
    var ctheta = [
        [0.46019978478, 0.46019978478, 0.91743694670, 0.91743694670, 0.49715499774, 0.49715499774],
        [0.45598377618, 0.45598377618, 0.91748206207, 0.91748206207, 0.49714719172, 0.49714719172]
    ];

    /** The Constant phi. */
    var phi = [
        [4.92619181360, 0.57595865315, 0.00000000000, 0.00000000000, 4.70053728340, 0.11129056012],
        [4.93682924650, 0.57477043300, 0.00000000000, 0.00000000000, 4.71279419371, 0.11142137093]
    ];

    var AstroCoordTransform = {

        /**Transforms an angular position in radians in a given coordinate system to a position
         in an other coordinate system, also in radians. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transform: function (pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] - phi[J2000][trType];
            b = pos[1];
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b);

            a = Math.atan2(ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb, cb * Math.cos(a));
            ao = (a + psi[J2000][trType] + fourPi) % twoPi;

            return [ao, bo]; // phi, theta
        },

        /**Transforms an angular position in degrees in a given coordinate system to a position
         in an other coordinate systems, also in degrees. RA-Dec position are intended in
         Equinox J2000

         @param {float[]} pos Angular position [phi, theta]
         @param trType Transform type
         */
        transformInDeg: function (pos, trType) {
            var ao, bo, a, b, sb, cb, cbsa;
            var J2000 = 1;
            //by setting J2000 = 0, RA-Dec are intended in Equinox 1950.

            a = pos[0] / degToRad - phi[J2000][trType];
            b = pos[1] / degToRad;
            sb = Math.sin(b);
            cb = Math.cos(b);
            cbsa = cb * Math.sin(a);
            b = -stheta[J2000][trType] * cbsa + ctheta[J2000][trType] * sb;
            b = Math.max(-1.0, Math.min(b, 1.0));
            bo = Math.asin(b) * degToRad;

            a = Math.atan2(ctheta[J2000][trType] * cbsa + stheta[J2000][trType] * sb, cb * Math.cos(a));
            ao = ((a + psi[J2000][trType] + fourPi) % twoPi) * degToRad;

            return [ao, bo];
        }
    };

    /**
     *    Transform type enumerations
     */
    AstroCoordTransform.Type =
    {
        EQ2GAL: 0,		//RA-Dec (2000) -> Galactic
        GAL2EQ: 1,		//Galactic      -> RA-Dec
        EQ2ECL: 2,		//RA-Dec        -> Ecliptic
        ECL2EQ: 3,		//Ecliptic      -> RA-Dec
        ECL2GAL: 4,		//Ecliptic      -> Galactic
        GAL2ECL: 5 		//Galactic      -> Ecliptic
    };

    /**************************************************************************************************************/

    return AstroCoordTransform;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Geoide',[], function () {

    /**
     * Geoide configuration
     * @typedef {Object} AbstractCrs.geoide_configuration
     * @property {float} radius - internal radius in vector length
     * @property {float} realPlanetRadius - real planet radius in meter
     */

    /**
     * @name Geoide
     * @class
     * Geodetic datum is a set of parameters that define the position of the origin, the scale, and the orientation of a
     * coordinate system in relationship with the planet.
     * @param {AbstractCrs.geoide_configuration} options - Options for Geoide
     * @constructor
     * @throws {ReferenceError} Will throw an error when options.realPlanetRadius or options.radius are not defined
     * @memberOf module:Crs
     * @todo add flattening parameter
     */
    var Geoide = function (options) {
        this.radius = options && options.hasOwnProperty('radius') ? options.radius : null;
        this.realPlanetRadius = options && options.hasOwnProperty('realPlanetRadius') ? options.realPlanetRadius : null;
        if (this.radius === null || this.realPlanetRadius === null) {
            throw new ReferenceError("Radius and realPlanetRadius must be set to define a geoide", "Geoide.js");
        }
        this.heightScale = 1.0 / this.realPlanetRadius;
    };


    /**
     * Get real planet radius in meter
     * @function getRealPlanetRadius
     * @memberOf Geoide#
     * @return {float} Real planet radius
     */
    Geoide.prototype.getRealPlanetRadius = function () {
        return this.realPlanetRadius;
    };

    /**
     * Get radius in vector length
     * @function getRadius
     * @memberOf Geoide#
     * @return {float} Radius
     */
    Geoide.prototype.getRadius = function () {
        return this.radius;
    };

    /**
     * Get height scale = 1/realPlanetRadius
     * @function getHeightScale
     * @memberOf Geoide#
     * @return {float} Height scale
     */
    Geoide.prototype.getHeightScale = function () {
        return this.heightScale;
    };
    /**************************************************************************************************************/

    return Geoide;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define(
    'Crs/AbstractCrs',['../Utils/Numeric', './Geoide', '../Utils/Constants','./AstroCoordTransform','../Renderer/glMatrix'],
    function (Numeric, Geoide, Constants, AstroCoordTransform) {

        /**
         * Abstract coordinate reference system configuration
         * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
         * @property {CRS} geoideName - name of the coordinate reference system
         * @property {CONTEXT} type - Type of the CRS
         * @property {GeoBound} geoBound - Geographical bounding box
         */

        /**
         * @name AbstractCrs
         * @class
         * Creates an coordinate reference system for a globe and data.
         *
         * A coordinate reference system is a coordinate system that is related to an object
         * by a {@link Geoide geodetic datum}.
         *
         * A coordinate system is a set of mathematical rules for specifying how coordinates are to be assigned to points
         * @param {AbstractCrs.configuration} options - Options for the coordinate reference system.
         * @throws {ReferenceError} Will throw when option.geoideName, options.geoBound and options.type are not defined
         * @constructor
         * @implements {Crs}
         */
        var AbstractCrs = function (options) {
            this.flat = false;
            this.geoide = null;
            this.type = null;
            this.geoBound = null;

            // If geoideName is specified, use it
            if (options && options.geoideName && options.type && options.geoBound) {
                this.geoide = new Geoide(options);
                this.geoideName = options.geoideName;
                this.type = options.type;
                this.geoBound = options.geoBound;
            } else {
                throw new ReferenceError("The geoide's parameters, the geoBound and the type of context must be defined",AbstractCrs.js);
            }
        };

        /**
         * @function isFlat
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.isFlat = function() {
            return this.flat;
        };

        /**
         * @function getVerticalAt3D
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getVerticalAt3D = function (pos, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            if (this.isFlat()) {
                dest[0] = 0.0;
                dest[1] = 0.0;
                dest[2] = 1.0;
            } else {
                vec3.normalize(pos, dest);
            }
            return dest;
        };

        /**
         * @function fromGeoTo3D
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.fromGeoTo3D = function (geo, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            if ((!geo) || (geo.length < 2)) {
                console.log("Erreur !");
                dest[0] = 0;
                dest[1] = 0;
                dest[2] = 0;
                return dest;
            }
            var longInRad = Numeric.toRadian(geo[0]);
            var latInRad = Numeric.toRadian(geo[1]);
            var cosLat = Math.cos(latInRad);

            // Take height into account
            var height = geo.length > 2 ? this.geoide.getHeightScale() * geo[2] : 0;
            var radius = this.geoide.getRadius() + height;

            dest[0] = radius * Math.cos(longInRad) * cosLat;
            dest[1] = radius * Math.sin(longInRad) * cosLat;
            dest[2] = radius * Math.sin(latInRad);

            return dest;
        };


        /**
         * @function from3DToGeo
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.from3DToGeo = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var r = Math.sqrt(position3d[0] * position3d[0] +
                position3d[1] * position3d[1] +
                position3d[2] * position3d[2]);
            var lon = Math.atan2(position3d[1] / r, position3d[0] / r);
            var lat = Math.asin(position3d[2] / r);

            dest[0] = Numeric.toDegree(lon);
            dest[1] = Numeric.toDegree(lat);
            dest[2] = this.geoide.getRealPlanetRadius() * (r - this.geoide.getRadius());
            return dest;
        };

        /**
         * @function getLocalTransform
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getLocalTransform = function (geo, dest) {
            if (!dest) {
                dest = mat4.create();
            }

            var longitude = geo[0] * Math.PI / 180.0;
            var latitude = geo[1] * Math.PI / 180.0;

            var up = [Math.cos(longitude) * Math.cos(latitude), Math.sin(longitude) * Math.cos(latitude), Math.sin(latitude)];
            var east = [-Math.sin(longitude), Math.cos(longitude), 0];
            var north = vec3.create();
            vec3.cross(up, east, north);

            dest[0] = east[0];
            dest[1] = east[1];
            dest[2] = east[2];
            dest[3] = 0.0;

            dest[4] = north[0];
            dest[5] = north[1];
            dest[6] = north[2];
            dest[7] = 0.0;

            dest[8] = up[0];
            dest[9] = up[1];
            dest[10] = up[2];
            dest[11] = 0.0;

            dest[12] = 0.0;
            dest[13] = 0.0;
            dest[14] = 0.0;
            dest[15] = 1.0;

            return dest;
        };

        /**
         * @function getLHVTransform
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getLHVTransform = function (geo, dest) {
            if (!dest) {
                dest = mat4.create();
            }

            var longitude = geo[0] * Math.PI / 180.0;
            var latitude = geo[1] * Math.PI / 180.0;

            var up = [Math.cos(longitude) * Math.cos(latitude), Math.sin(longitude) * Math.cos(latitude), Math.sin(latitude)];
            var east = [-Math.sin(longitude), Math.cos(longitude), 0];
            var north = vec3.create();
            vec3.cross(up, east, north);

            var pt = this.get3DFromWorld(geo);

            dest[0] = east[0];
            dest[1] = east[1];
            dest[2] = east[2];
            dest[3] = 0.0;

            dest[4] = north[0];
            dest[5] = north[1];
            dest[6] = north[2];
            dest[7] = 0.0;

            dest[8] = up[0];
            dest[9] = up[1];
            dest[10] = up[2];
            dest[11] = 0.0;

            dest[12] = pt[0];
            dest[13] = pt[1];
            dest[14] = pt[2];
            dest[15] = 1.0;

            return dest;
        };

        /**
         * @function getSideVector
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getSideVector = function (matrix, v) {
            v[0] = matrix[0];
            v[1] = matrix[1];
            v[2] = matrix[2];
            return v;
        };

        /**
         * @function getFrontVector
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getFrontVector = function (matrix, v) {
            v[0] = matrix[4];
            v[1] = matrix[5];
            v[2] = matrix[6];

            return v;
        };

        /**
         * @function getUpVector
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getUpVector = function (matrix, v) {
            v[0] = matrix[8];
            v[1] = matrix[9];
            v[2] = matrix[10];

            return v;
        };


        /**
         * @function formatCoordinates
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype.formatCoordinates = function (geo) {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function getGeoide
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getGeoide = function () {
            return this.geoide;
        };

        /**
         * @function getGeoideName
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getGeoideName = function () {
            return this.geoideName;
        };

        /**
         * @function getType
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getType = function () {
            return this.type;
        };

        /**
         * @function getElevation
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getElevation = function (globe, geoPos) {
            return globe.getElevation(geoPos.coordinates[0],geoPos.coordinates[1]);
        };

        /**
         * @function getWorldFrom3D
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getWorldFrom3D = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            var geoPos = this.from3DToGeo(position3d);
            this._setupPosAfterTrans(geoPos);
            dest[0] = geoPos[0];
            dest[1] = geoPos[1];
            dest[2] = geoPos.length > 2 ? geoPos[2] : this.geoide.getRealPlanetRadius();
            return dest;
        };

        /**
         * @function get3DFromWorld
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.get3DFromWorld = function (posWorld, dest) {
            if (!dest) {
                dest = vec3.create();
            }
            var pos = posWorld.slice(0);
            this._setupPosBeforeTrans(pos);
            this.fromGeoTo3D(pos, dest);
            return dest;
        };

        /**
         * @function get3DFromWorldInCrs
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.get3DFromWorldInCrs = function (posWorld, posCrsID, dest) {
            if (!dest) {
                dest = vec3.create();
            }
            var posWorldInCurrentCrs = this.convert(posWorld, posCrsID, this.getGeoideName());
            this.get3DFromWorld(posWorldInCurrentCrs, dest);
            return dest;
        };

        /**
         * @function getSexagesimalFromDeg
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getSexagesimalFromDeg = function (degPos, dest) {
            dest = dest || [];

            var deg = degPos[0];
            // RA
            if (deg < 0) {
                deg += 360;
            }

            dest[0] = this.fromDegreesToHMS(deg);
            dest[1] = this.fromDegreesToDMS(degPos[1]);

            return dest;
        };

        /**
         * @function getDecimalDegFromSexagesimal
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getDecimalDegFromSexagesimal = function (sexagesimalPos, dest) {

            dest = dest || [];

            // we use string because : parseFloat("-0") returns 0..
            function sign(stringDegree) {
                return ((stringDegree[0] === "-") ? -1 : 1);
            }

            var longitude = sexagesimalPos[0].split(" ");
            // long
            var deg = parseFloat(longitude[0]);
            var min = parseFloat(longitude[1]);
            var sec = parseFloat(longitude[2]);

            dest[0] = (deg + min / 60 + sec / 3600) * 15.0;

            var latitude = sexagesimalPos[1].split(" ");
            // lat
            deg = parseFloat(latitude[0]);
            min = parseFloat(latitude[1]);
            sec = parseFloat(latitude[2]);

            dest[1] = sign(latitude[0]) * (Math.abs(deg) + min / 60 + sec / 3600);

            return dest;

        };

        /**
         * @function convert
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.convert = function (geo, from, to) {
            // No conversion needed
            if (from === to) {
                return geo;
            }

            var convertedGeo = null;
            var convertType = null;
            switch (from + "2" + to) {
                case Constants.CRS.Galactic+"2"+Constants.CRS.Equatorial :
                    convertType = AstroCoordTransform.Type.GAL2EQ;
                    convertedGeo = AstroCoordTransform.transformInDeg(geo, convertType);
                    break;
                case Constants.CRS.Equatorial+"2"+Constants.CRS.Galactic :
                    convertType = AstroCoordTransform.Type.EQ2GAL;
                    convertedGeo = AstroCoordTransform.transformInDeg(geo, convertType);
                    if (convertedGeo[0] < 0) {
                        // TODO : Check if convertedGeo can be negative
                        console.warn("EQ2GAL transformation returned negative value");
                        convertedGeo[0] += 360;
                    }
                    break;
                case Constants.CRS.Mars_2000+"2"+Constants.CRS.Mars_2000_old :
                case Constants.CRS.Mars_2000_old+"2"+Constants.CRS.Mars_2000 :
                    convertedGeo = geo;
                    break;
                case Constants.CRS.Moon_2000+"2"+Constants.CRS.Moon_2000_old :
                case Constants.CRS.Moon_2000_old+"2"+Constants.CRS.Moon_2000 :
                    convertedGeo = geo;
                    break;
                default:
                    throw new RangeError("Conversion "+from+" to "+to+" is not implemented", "AbstractCrs.js");
            }

            return convertedGeo;
        };

        /**
         * Adds a zero before the number < 10
         * @function _pad2Digits
         * @param number number to format
         * @returns {String}
         * @private
         */
        AbstractCrs.prototype._pad2Digits = function(number) {
            return (number < 10) ? ("0" + number) : number;
        };

        /**
         * @function fromDegreesToHMS
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.fromDegreesToHMS = function (degree) {
            var localDegree = degree / 15;

            var absLon = Math.abs(localDegree);
            var hours = Math.floor(absLon);
            var decimal = (absLon - hours) * 60;
            var min = Math.floor(decimal);
            var sec = (decimal - min) * 60;

            return this._pad2Digits(hours) + "h " + this._pad2Digits(min) + "m " + this._pad2Digits(Numeric.roundNumber(sec, 2)) + "s";
        };

        /**
         * @function fromDegreesToDMS
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.fromDegreesToDMS = function (degree) {
            function stringSign(val) {
                return (val >= 0 ? "+" : "-");
            }

            var absLat = Math.abs(degree);
            var deg = Math.floor(absLat);
            var decimal = (absLat - deg) * 60;
            var min = Math.floor(decimal);
            var sec = (decimal - min) * 60;

            return stringSign(degree) + this._pad2Digits(deg) + String.fromCharCode(176) + " " + this._pad2Digits(min) + "' " + this._pad2Digits(Numeric.roundNumber(sec, 2)) + "\"";

        };

        /**
         * @function _setupPosBeforeTrans
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype._setupPosBeforeTrans = function(posWorld) {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function _setupPosAfterTrans
         * @memberOf AbstractCrs#
         * @bastract
         */
        AbstractCrs.prototype._setupPosAfterTrans = function(posWorld) {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function getGeoBound
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.getGeoBound = function() {
            return this.geoBound;
        };

        /**
         * @function getName
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype.getName = function () {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function getDescription
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype.getDescription = function () {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function getLongitudeLabel
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype.getLongitudeLabel = function () {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function getLatitudeLabel
         * @memberOf AbstractCrs#
         * @abstract
         */
        AbstractCrs.prototype.getLatitudeLabel = function () {
            throw new SyntaxError("Not implemented");
        };

        /**
         * @function isProjected
         * @memberOf AbstractCrs#
         * @return {boolean} True when the Crs is projected in 2D otherwise false.
         */
        AbstractCrs.prototype.isProjected = function () {
            return false;
        };

        /**
         * @function destroy
         * @memberOf AbstractCrs#
         */
        AbstractCrs.prototype.destroy = function() {
            this.flat = null;
            this.geoide = null;
            this.type = null;
            this.geoBound = null;
            this.projected = null;
        };


        /**************************************************************************************************************/
        return AbstractCrs;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/WGS84Crs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Utils/Numeric'],
    function (AbstractCrs, GeoBound, Utils, Constants, Numeric) {

        const DESCRIPTION = "WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which " +
            "the geographic longitude increases to the east. The geographic latitude is measured in degrees north or south " +
            "of the Earth equator. In Mizar, the latitudes are projected on a sphere";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "Long";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "Lat";

        /**
         * @name WGS84Crs
         * @class
         * WGS84 coordinate Reference System is a coordinate system using the Earth geoide in which the
         * geographic longitude increases to the east. The geographic latitude is measured in degrees north or south
         * of the Earth equator.
         * <br/>
         * <img src="../doc/images/earth.jpg" width="200px"/>
         * <br/>
         * WGS84Crs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = EPSG:4326</li>
         *     <li>radius = 1</li>
         *     <li>realPlanetRadius = 6378137 meters</li>
         *     <li>type = Planet</li>
         *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
         * </ul>         
         * @augments AbstractCrs
         * @param options - No option to give.
         * @constructor
         * @memberOf module:Crs
         */
        var WGS84Crs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.WGS84,
                radius: 1.0,
                realPlanetRadius: 6378137,
                type: Constants.CONTEXT.Planet,
                geoBound: new GeoBound(-180, -90, 180, 90)
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, WGS84Crs);

        /**************************************************************************************************************/

        /**
         * Formats the coordinates (longitude, latitude) as (x.xxx&deg, y.yyy&deg).
         * @function formatCoordinates
         * @memberOf WGS84Crs#
         * @param {float[]} geo the spatial position in degree
         * @return {string[]} the formatted chain
         */
        WGS84Crs.prototype.formatCoordinates = function (geo) {
            var astro = [];
            var longitude = Numeric.roundNumber(geo[0], 3);
            var latitude = Numeric.roundNumber(geo[1], 3);
            astro[0] = this.getLatitudeLabel()+" = ";
            astro[0] += (latitude >= 0 ) ? latitude+" N" : -1.0*latitude+" S";
            astro[1] = this.getLongitudeLabel()+" = ";
            astro[1] += (longitude >= 0 ) ? longitude+" E" : -1.0*longitude+" W";
            return astro;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf WGS84Crs#
         */
        WGS84Crs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf WGS84Crs#
         */
        WGS84Crs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * @function _setupPosAfterTrans
         * @memberOf WGS84Crs#
         * Do nothing
         * @param posWorld
         * @private
         */
        WGS84Crs.prototype._setupPosAfterTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * Do nothing
         * @function _setupPosBeforeTrans
         * @memberOf WGS84Crs#
         * @param posWorld
         * @private
         */
        WGS84Crs.prototype._setupPosBeforeTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * @function getName
         * @memberOf WGS84Crs#
         */
        WGS84Crs.prototype.getName = function () {
            return Constants.CRS.WGS84;
        };

        return WGS84Crs;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Mars2000Crs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Utils/Numeric'],
    function (AbstractCrs, GeoBound, Utils, Constants, Numeric) {

        /**
         * @constant
         * @type {string}
         */
        const DESCRIPTION = "Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in " +
            "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
            "north or south of the Mars equator.";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "Long";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "Lat";

        /**
         * @name Mars2000Crs
         * @class
         * Mars 2000 coordinate Reference System is a coordinate system using the Mars sphere and in which the
         * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
         * of the Mars equator.
         * <br/>
         * Mars2000Crs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = IAU2000:49901</li>
         *     <li>radius = 1.0</li>
         *     <li>realPlanetRadius = 3396190</li>
         *     <li>type = Planet</li>
         *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
         * </ul>
         * @augments AbstractCrs
         * @param options - No option to give.
         * @constructor
         * @memberOf module:Crs
         */
        var Mars2000Crs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.Mars_2000,
                radius: 1.0,
                realPlanetRadius: 3396190,
                type: Constants.CONTEXT.Planet,
                geoBound: new GeoBound(-180, -90, 180, 90)                
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, Mars2000Crs);

        /**************************************************************************************************************/

        /**
         * Formats coordinates as (x.xxx N, y.yyy E).
         * @function formatCoordinates
         * @memberOf Mars2000Crs
         * @param {float[]} geo the spatial position in degree
         * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
         */
        Mars2000Crs.prototype.formatCoordinates = function (geo) {
            var astro = [];
            var longitude = Numeric.roundNumber(geo[0], 3);
            var latitude = Numeric.roundNumber(geo[1], 3);
            astro[0] = this.getLatitudeLabel()+" = ";
            astro[0] += (latitude >= 0 ) ? latitude+" N" : -1.0*latitude+" S";
            astro[1] = this.getLongitudeLabel()+" = ";
            astro[1] += (longitude >= 0 ) ? longitude+" E" : -1.0*longitude+" W";
            return astro;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf Mars2000Crs#
         */
        Mars2000Crs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf Mars2000Crs#
         */
        Mars2000Crs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * Do nothing
         * @function _setupPosAfterTrans
         * @memberOf Mars2000Crs
         * @private
         */
        Mars2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * Do nothing
         * @function _setupPosBeforeTrans
         * @memberOf Mars2000Crs
         * @private
         */
        Mars2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * @function getName
         * @memberOf Mars2000Crs#
         */
        Mars2000Crs.prototype.getName = function () {
            return Constants.CRS.Mars_2000;
        };

        /**
         * @function getDescription
         * @memberOf Mars2000Crs#
         */
        Mars2000Crs.prototype.getDescription = function () {
            return DESCRIPTION;
        };

        return Mars2000Crs;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/Moon2000Crs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Utils/Numeric'],
    function (AbstractCrs, GeoBound, Utils, Constants, Numeric) {

        /**
         * @constant
         * @type {string}
         */
        const DESCRIPTION = "Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in " +
            "which the planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees " +
            "north or south of the Moon equator.";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "Long";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "Lat";

        /**
         * @name Moon2000Crs
         * @class
         * Moon 2000 coordinate Reference System is a coordinate system using the Moon sphere and in which the
         * planetocentric longitude increases to the east. The planetocentric latitude is measured in degrees north or south
         * of the Moon equator.
         * <br/>
         * Moon2000Crs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = IAU2000:30101</li>
         *     <li>radius = 1.0</li>
         *     <li>realPlanetRadius = 1737400</li>
         *     <li>type = Planet</li>
         *     <li>geoBound = new GeoBound(-180, -90, 180, 90)</li>
         * </ul>
         * @augments AbstractCrs
         * @param options - No option to give.
         * @constructor
         * @memberOf module:Crs
         */
        var Moon2000Crs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.Moon_2000,
                radius: 1.0,
                realPlanetRadius: 1737400,
                type: Constants.CONTEXT.Planet,
                geoBound: new GeoBound(-180, -90, 180, 90)
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, Moon2000Crs);

        /**************************************************************************************************************/

        /**
         * Formats coordinates as (x.xxx N, y.yyy E).
         * @function formatCoordinates
         * @memberOf Moon2000Crs
         * @param {float[]} geo the spatial position in degree
         * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
         */
        Moon2000Crs.prototype.formatCoordinates = function (geo) {
            var astro = [];
            var longitude = Numeric.roundNumber(geo[0], 3);
            var latitude = Numeric.roundNumber(geo[1], 3);
            astro[0] = this.getLatitudeLabel()+" = ";
            astro[0] += (latitude >= 0 ) ? latitude+" N" : -1.0*latitude+" S";
            astro[1] = this.getLongitudeLabel()+" = ";
            astro[1] += (longitude >= 0 ) ? longitude+" E" : -1.0*longitude+" W";
            return astro;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf Moon2000Crs#
         */
        Moon2000Crs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf Moon2000Crs#
         */
        Moon2000Crs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * Do nothing
         * @function _setupPosAfterTrans
         * @memberOf Moon2000Crs
         * @private
         */
        Moon2000Crs.prototype._setupPosAfterTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * Do nothing
         * @function _setupPosBeforeTrans
         * @memberOf Moon2000Crs
         * @private
         */
        Moon2000Crs.prototype._setupPosBeforeTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * @function getName
         * @memberOf Moon2000Crs#
         */
        Moon2000Crs.prototype.getName = function () {
            return Constants.CRS.Moon_2000;
        };

        /**
         * @function getDescription
         * @memberOf Moon2000Crs#
         */
        Moon2000Crs.prototype.getDescription = function () {
            return DESCRIPTION;
        };

        return Moon2000Crs;

    });
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * A coordinate reference system is a coordinate system that is related to an object
 * by a {@link module:Crs.Geoide geodetic datum}.
 * Mizar currently supports the following coordinates reference systems :
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/equatorial.png" width="200px"/></td>
 *         <td>{@link module:Crs.EquatorialCrs EquatorialCrs}</td>
 *         <td>Provides an equatorial coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/galactic.png" width="200px"/></td>
 *         <td>{@link module:Crs.GalacticCrs GalacticCrs}</td>
 *         <td>Provides a galactic coordinate reference system</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.Mars2000Crs Mars2000Crs}</td>
 *         <td>Provides a coordinate reference system base on the Mars geoide</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/earth.jpg" width="200px"/></td>
 *         <td>{@link module:Crs.WGS84Crs WGS84Crs}</td>
 *         <td>Provides a coordinate reference system base on the Earth geoide</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Crs.ProjectedCrs ProjectedCrs}</td>
 *         <td>Provides a projected coordinate reference system on a map</td>
 *     </tr>
 * </table>
 * <br/>
 * In addition to the classes, a {@link module:Crs.CoordinateSystemFactory factory} is available to help for creating
 * coordinate reference system. Once the coordinate reference system is created, the client can handle it by the use of its
 * {@link Crs interface}.
 *
 * @module Crs
 * @implements {Crs}
 */
define('Crs/EquatorialCrs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractCrs, GeoBound, Utils, Constants) {

        /**
         * @constant
         * @type {string}
         */
        const DESCRIPTION = "System in which a celestial object's position on the celestial " +
            "sphere is described in terms of its declination and right ascension, measured with respect to the celestial " +
            "equator. Declination and right ascension correspond directly to geographic latitude and longitude as " +
            "projected outward onto the celestial sphere. Declination is measured in degrees north or south of the " +
            "celestial equator but right ascension  is measured in hours, minutes, and seconds eastward along the " +
            "celestial equator from the point of the vernal equinox. Because the celestial equator moves among the fixed " +
            "stars with the precession of the Earth's poles, an object's declination and right ascension change " +
            "gradually over time, and coordinates in the equatorial system must be specified for particular years. By " +
            "Default J2000 is used";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "&alpha;";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "&delta;";

        /**
         * @name EquatorialCrs
         * @class
         * System in which a celestial object's position on the celestial
         * sphere is described in terms of its declination and right ascension, measured with respect to the celestial equator.
         * Declination and right ascension correspond directly to geographic latitude and longitude as projected outward onto
         * the celestial sphere. Declination is measured in degrees north or south of the celestial equator but right ascension
         * is measured in hours, minutes, and seconds eastward along the celestial equator from the point of the vernal equinox.
         * Because the celestial equator moves among the fixed stars with the precession of the Earth's poles, an object's
         * declination and right ascension change gradually over time, and coordinates in the equatorial system must be
         * specified for particular years.
         * <br/>
         * <i>source : equatorial coordinate system. Dictionary.com. The American Heritage® Science Dictionary.
         * Houghton Mifflin Company. http://www.dictionary.com/browse/equatorial-coordinate-system (accessed: March 5, 2017).</i>
         * <br/>
         * <img src="../doc/images/equatorial.png"/>
         * <br/>
         * EquatorialCrs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = Equatorial</li>
         *     <li>radius = 10.0</li>
         *     <li>realPlanetRadius = 1.0</li>
         *     <li>type = Sky</li>
         *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
         * </ul>
         * @augments AbstractCrs
         * @param {Object} options - No option to give
         * @constructor
         * @see {@link https://en.wikipedia.org/wiki/Equatorial_coordinate_system Wikipedia}
         * @memberOf module:Crs
         */
        var EquatorialCrs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.Equatorial,
                radius: 10.0,
                realPlanetRadius: 1.0,
                type: Constants.CONTEXT.Sky,
                geoBound: new GeoBound(0, -90, 360, 90)
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, EquatorialCrs);

        /**************************************************************************************************************/

        /**
         * @function transformVec
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.transformVec = function (vec) {
            var transformMatrix = this.computeTransformMatrix();
            var res = [];
            mat4.multiplyVec3(transformMatrix, vec, res);
            return res;
        };


        /**
         * @function computeTransformMatrix
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.computeTransformMatrix = function () {
            var transformMatrix = [];

            var galNorth = this.convert([0, 90], Constants.CRS.Galactic, Constants.CRS.Equatorial);
            var gal3DNorth = this.fromGeoTo3D(galNorth);

            var galCenter = this.convert([0, 0], Constants.CRS.Galactic, Constants.CRS.Equatorial);
            var gal3DCenter = this.fromGeoTo3D(galCenter);

            var galEast = this.convert([90, 0], Constants.CRS.Galactic, Constants.CRS.Equatorial);
            var gal3DEast = this.fromGeoTo3D(galEast);

            transformMatrix[0] = gal3DCenter[0];
            transformMatrix[1] = gal3DCenter[1];
            transformMatrix[2] = gal3DCenter[2];
            transformMatrix[3] = 0.0;
            transformMatrix[4] = gal3DEast[0];
            transformMatrix[5] = gal3DEast[1];
            transformMatrix[6] = gal3DEast[2];
            transformMatrix[7] = 0.0;
            transformMatrix[8] = gal3DNorth[0];
            transformMatrix[9] = gal3DNorth[1];
            transformMatrix[10] = gal3DNorth[2];
            transformMatrix[11] = 0.0;
            transformMatrix[12] = 0.0;
            transformMatrix[13] = 0.0;
            transformMatrix[14] = 0.0;
            transformMatrix[15] = 1.0;

            return transformMatrix;
        };

        /**
         * @function formatCoordinates
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.formatCoordinates = function (geo) {
            var sexa =  this.getSexagesimalFromDeg(geo);
            var dest = [];
            dest[0] = this.getLongitudeLabel()+" = "+sexa[0];
            dest[1] = this.getLatitudeLabel()+" = "+sexa[1];
            return dest;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * @function _setupPosAfterTrans
         * @memberOf EquatorialCrs#
         * @private
         */
        EquatorialCrs.prototype._setupPosAfterTrans = function (posWorld) {
            if (posWorld[0] < 0) {
                posWorld[0] += 360.0;
            }
        };

        /**
         * @function _setupPosBeforeTrans
         * @memberOf EquatorialCrs#
         * @private
         */
        EquatorialCrs.prototype._setupPosBeforeTrans = function (posWorld) {
            if (posWorld[0] > 180) {
                posWorld[0] -= 360.0;
            }
        };

        /**
         * @function getName
         * @memberOf EquatorialCrs#
         */
        EquatorialCrs.prototype.getName = function () {
            return Constants.CRS.Equatorial;
        };

        /**
         * @function getDescription
         * @memberOf EquatorialCrs#
         * @abstract
         */
        EquatorialCrs.prototype.getDescription = function () {
            return DESCRIPTION;
        };


        /**************************************************************************************************************/

        return EquatorialCrs;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/GalacticCrs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Utils/Numeric'],
    function (AbstractCrs, GeoBound, Utils, Constants, Numeric) {

        /**
         * @constant
         * @type {string}
         */
        const DESCRIPTION = "System in which a celestial object's position on the celestial sphere is described in " +
            "relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured along the " +
            "galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way. The " +
            "galactic equator, also called the galactic circle, is inclined at an angle of approximately 62° to the " +
            "celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in " +
            "the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line " +
            "through the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic " +
            "latitude is measured in degrees north or south of the galactic equator toward the galactic poles.";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "l";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "b";

        /**
         * @name GalacticCrs
         * @class
         * System in which a celestial object's position on the celestial
         * sphere is described in relation to the structure of the Milky Way galaxy. An object's galactic longitude is measured
         * along the galactic equator, a great circle on the celestial sphere that follows the band of the Milky Way.
         * The galactic equator, also called the galactic circle, is inclined at an angle of approximately 62° to the
         * celestial equator; distances are measured along it beginning at a point in the constellation Sagittarius lying in
         * the direction of the Milky Way's nucleus. The galactic poles are the two points where a perpendicular line through
         * the middle of the plane of the galactic equator intersect the celestial sphere. An object's galactic latitude is
         * measured in degrees north or south of the galactic equator toward the galactic poles.
         * <br/>
         * <i>source : galactic coordinate system. Dictionary.com. The American Heritage® Science Dictionary.
         * Houghton Mifflin Company. http://www.dictionary.com/browse/galactic-coordinate-system (accessed: March 5, 2017).</i>
         * <br/>
         * <img src="../doc/images/galactic.png"/>
         * <br/>
         * GalacticCrs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = Galactic</li>
         *     <li>radius = 10.0</li>
         *     <li>realPlanetRadius = 1.0</li>
         *     <li>type = Sky</li>
         *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
         * </ul>
         * @augments AbstractCrs
         * @param options - no option to give.
         * @constructor
         * @see {@link https://en.wikipedia.org/wiki/Galactic_coordinate_system Wikipedia}
         * @memberOf module:Crs
         */
        var GalacticCrs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.Galactic,
                radius: 10.0,
                realPlanetRadius: 1.0,
                type: Constants.CONTEXT.Sky,
                geoBound: new GeoBound(0, -90, 360, 90)
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, GalacticCrs);

        /**************************************************************************************************************/

        /**
         * @function formatCoordinates
         * @memberOf GalacticCrs#
         */
        GalacticCrs.prototype.formatCoordinates = function (geo) {
            var astro = [];
            astro[0] = this.getLongitudeLabel()+" = "+Numeric.roundNumber(geo[0], 3);
            astro[0] += "&deg;";
            astro[1] = this.getLatitudeLabel()+" = "+Numeric.roundNumber(geo[1], 3);
            astro[1] += "&deg;";
            return astro;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf GalacticCrs#
         */
        GalacticCrs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf GalacticCrs#
         */
        GalacticCrs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * @function _setupPosAfterTrans
         * @memberOf GalacticCrs#
         * @private
         */
        GalacticCrs.prototype._setupPosAfterTrans = function (posWorld) {
            if (posWorld[0] < 0) {
                posWorld[0] += 360.0;
            }
            [posWorld[0], posWorld[1]] = this.convert(posWorld, Constants.CRS.Equatorial, Constants.CRS.Galactic);
        };

        /**
         * @function _setupPosBeforeTrans
         * @memberOf GalacticCrs#
         * @rpivate
         */
        GalacticCrs.prototype._setupPosBeforeTrans = function (posWorld) {
            [posWorld[0], posWorld[1]] = this.convert(posWorld, Constants.CRS.Galactic, Constants.CRS.Equatorial);
            if (posWorld[0] > 180) {
                posWorld[0] -= 360.0;
            }
        };

        /**
         * @function getName
         * @memberOf GalacticCrs#
         */
        GalacticCrs.prototype.getName = function () {
            return Constants.CRS.Galactic;
        };

        /**
         * @function getName
         * @memberOf GalacticCrs#
         */
        GalacticCrs.prototype.getDescription = function () {
            return DESCRIPTION;
        };

        return GalacticCrs;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/AbstractProjection',['../Renderer/GeoBound'],
    function (GeoBound) {

        /**
         * Base projection configuration
         * @typedef {Object} AbstractProjection.configuration
         * @property {PROJECTION} projectionName - Name of the projection
         */

        /**
         * @name AbstractProjection
         * @class
         *   Abstract class for projections.
         * A map projection is one of many methods used to represent the 3-dimensional surface of the earth or other round body
         * on a 2-dimensional plane in cartography. The creation of a map projection involves two steps :
         * <ul>
         *     <li>selection of a model for the shape of the body (choosing between a sphere or ellipsoid),</li>
         *     <li>transform planetographic coordinates to plane coordinates.</li>
         * </ul>
         * @param {float[]} projectionCenter - the projection center as (longitude, latitude)
         * @param {float[]} geoBound - Geo boundary as [minLongitude, minLatitude, maxLongitude, maxLatitude]
         * @param {AbstractProjection.configuration} options - Not used currently
         * @constructor
         * @implements {Projection}
         */
        var AbstractProjection = function (projectionCenter, geoBound, options) {
            this.geoBound = new GeoBound(geoBound[0], geoBound[1], geoBound[2], geoBound[3]);
            this.projectionCenter = projectionCenter;
            this.options = options || {};
        };

        /**
         * @function getProjectionCenter
         * @memberOf AbstractProjection#
         */
        AbstractProjection.prototype.getProjectionCenter = function() {
            return this.projectionCenter;
        };

        /**
         * @function getGeoBound
         * @memberOf AbstractProjection#
         */
        AbstractProjection.prototype.getGeoBound = function() {
            return this.geoBound;
        };

        /**
         * @function unProject
         * @memberOf AbstractProjection#
         * @abstract
         */
        AbstractProjection.prototype.unProject = function (position3d, dest) {
            throw new SyntaxError("unProject not implemented", "AbstractProjection.js");
        };

        /**
         * @function project
         * @memberOf AbstractProjection#
         * @abstract
         */
        AbstractProjection.prototype.project = function (geoPos, dest) {
            throw new SyntaxError("project not implemented", "AbstractProjection.js");
        };

        /**
         * @function getName
         * @memberOf AbstractProjection#
         * @abstract
         */
        AbstractProjection.prototype.getName = function () {
            throw new SyntaxError("getName not implemented", "AbstractProjection.js");
        };

        /**************************************************************************************************************/

        return AbstractProjection;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of projection, which is used to represent a planet on a 2D map.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/aitoff.png" width="200px"/></td>
 *         <td>{@link module:Projection.AitoffProjection AitoffProjection}</td>
 *         <td>Provides a AITOFF projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/august.png" width="200px"/></td>
 *         <td>{@link module:Projection.AugustProjection AugustProjection}</td>
 *         <td>Provides an august projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/azimuth.png" width="200px"/></td>
 *         <td>{@link module:Projection.AzimuthProjection AzimuthProjection}</td>
 *         <td>Provides an azimuth projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mercator.png" width="200px"/></td>
 *         <td>{@link module:Projection.MercatorProjection MercatorProjection}</td>
 *         <td>Provides a mercator projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/mollweide.png" width="200px"/></td>
 *         <td>{@link module:Projection.MollweideProjection MollweideProjection}</td>
 *         <td>Provides a mollweide projection</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/platecarré.png" width="200px"/></td>
 *         <td>{@link module:Projection.PlateProjection PlateProjection}</td>
 *         <td>Provides a plate carrée projection</td>
 *     </tr>
 * </table>
 *
 * The projection is automatically instantiated by the {@link module:Crs.ProjectedCrs ProjectedCrs} class.
 * @module Projection
 * @implements {Projection}
 */
define('Projection/AitoffProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {
        /**
         * @name AitoffProjection
         * @class
         *    The Aitoff coordinate system is a coordinate reference system. It is composed of :
         * <ul>
         *  <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
         *  <li>a projection : the Aitoff projection.</li>
         * </ul>
         *
         * The Aitoff projection is a modified azimuthal map projection first proposed by David A. Aitoff in 1889.
         * Based on the equatorial form of the azimuthal equidistant projection, Aitoff halved longitudes from the central
         * meridian, projected by the azimuthal equidistant, and then stretched the result horizontally into a 2:1 ellipse.
         * <img src="../doc/images/aitoff.png" width="200px"/>
         *
         *
         * @see {@link https://en.wikipedia.org/wiki/Aitoff_projection}
         * @augments AbstractProjection
         * @param {AbstractProjection.configuration} [options] - Aitoff projection configuration.
         * @constructor
         * @memberOf module:Projection
         */
        var AitoffProjection = function (options) {
            AbstractProjection.prototype.constructor.call(this, [0, 0], [-180, -90, 180, 90], options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, AitoffProjection);

        /**************************************************************************************************************/

        /**
         *    Inverse sampling function(sinc)
         */
        var _sinci = function (x) {
            return x ? x / Math.sin(x) : 1;
        };


        /**
         * @function unProject
         * @memberOf AitoffProjection#
         */
        AitoffProjection.prototype.unProject = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var epsilon = 0.005;
            var deltaLambda;
            var deltaPhi;
            // Abort if [x, y] is not within an ellipse centered at [0, 0] with
            // semi-major axis pi and semi-minor axis pi/2.
            if (position3d[0] * position3d[0] + 4 * position3d[1] * position3d[1] > Math.PI * Math.PI + epsilon) {
                return;
            }

            var lambda = position3d[0],
                phi = position3d[1],
                i = 25;

            do {
                var sinLambda = Math.sin(lambda),
                    sinLambda_2 = Math.sin(lambda / 2),
                    cosLambda_2 = Math.cos(lambda / 2),
                    sinPhi = Math.sin(phi),
                    cosPhi = Math.cos(phi),
                    sin_2phi = Math.sin(2 * phi),
                    sin2phi = sinPhi * sinPhi,
                    cos2phi = cosPhi * cosPhi,
                    sin2lambda_2 = sinLambda_2 * sinLambda_2,
                    F,
                    C = 1 - cos2phi * cosLambda_2 * cosLambda_2,
                    E = C ? Math.acos(cosPhi * cosLambda_2) * Math.sqrt(F = 1 / C) : F = 0,
                    fx = 2 * E * cosPhi * sinLambda_2 - position3d[0],
                    fy = E * sinPhi - position3d[1],
                    deltaXLambda = F * (cos2phi * sin2lambda_2 + E * cosPhi * cosLambda_2 * sin2phi),
                    deltaXPhi = F * (0.5 * sinLambda * sin_2phi - E * 2 * sinPhi * sinLambda_2),
                    deltaYLambda = F * 0.25 * (sin_2phi * sinLambda_2 - E * sinPhi * cos2phi * sinLambda),
                    deltaYPhi = F * (sin2phi * cosLambda_2 + E * sin2lambda_2 * cosPhi),
                    denominator = deltaXPhi * deltaYLambda - deltaYPhi * deltaXLambda;
                if (!denominator) {
                    break;
                }
                deltaLambda = (fy * deltaXPhi - fx * deltaYPhi) / denominator;
                deltaPhi = (fx * deltaYLambda - fy * deltaXLambda) / denominator;
                lambda -= deltaLambda;
                phi -= deltaPhi;
            } while ((Math.abs(deltaLambda) > epsilon || Math.abs(deltaPhi) > epsilon) && --i > 0);

            dest[0] = lambda * 180 / Math.PI;
            dest[1] = phi * 180 / Math.PI;
            dest[2] = position3d[2];
            return dest;
        };

        /**
         * @function project
         * @memberOf AitoffProjection#
         */
        AitoffProjection.prototype.project = function (geoPos, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var lambda = geoPos[0] * Math.PI / 180; // longitude
            var phi = geoPos[1] * Math.PI / 180;  // latitude

            var cosPhi = Math.cos(phi);
            var sinciAlpha = _sinci(Math.acos(cosPhi * Math.cos(lambda /= 2)));

            dest[0] = 2 * cosPhi * Math.sin(lambda) * sinciAlpha;
            dest[1] = Math.sin(phi) * sinciAlpha;
            dest[2] = this.getDefaultZ();
            //dest[2] = geoPos[2];

            // Triple winkel: mode
            // TODO: inverse
            // dest[0] = (dest[0] + lambda / Math.PI/2) / 2;
            // dest[1] = (dest[1] + phi) / 2;

            return dest;
        };

        /**
         * @function getName
         * @memberOf AitoffProjection#
         */
        AitoffProjection.prototype.getName = function() {
            return Constants.PROJECTION.Aitoff;
        };

        /**************************************************************************************************************/

        return AitoffProjection;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/AugustProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {
        /**
         * @name AugustProjection
         * @class
         *    The August coordinate system is a coordinate reference system. It is composed of :
         * <ul>
         * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
         * <li>a projection : the August projection.</li>
         * </ul>
         * <img src="../doc/images/august.png" width="200px">
         * @augments AbstractProjection
         * @param {AbstractProjection.configuration} [options] - August projection configuration.
         * @constructor
         * @memberOf module:Projection
         */
        var AugustProjection = function (options) {
            AbstractProjection.prototype.constructor.call(this, [0,0], [-180, -90, 180, 90], options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, AugustProjection);

        /**************************************************************************************************************/

        /**
         * @function unProject
         * @memberOf AugustProjection#
         * @throws "must be implemented"
         */
        AugustProjection.prototype.unProject = function (position3d, dest) {
            throw new SyntaxError("must be implemented");
        };

        /**
         * @function project
         * @memberOf AugustProjection#
         */
        AugustProjection.prototype.project = function (geoPos, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var lambda = geoPos[0] * Math.PI / 180; // longitude
            var phi = geoPos[1] * Math.PI / 180; // latitude

            var tanPhi = Math.tan(phi / 2),
                k = Math.sqrt(1 - tanPhi * tanPhi),
                c = 1 + k * Math.cos(lambda /= 2),
                x = Math.sin(lambda) * k / c,
                y = tanPhi / c,
                x2 = x * x,
                y2 = y * y;

            dest[0] = 4 / 3 * x * (3 + x2 - 3 * y2);
            dest[1] = 4 / 3 * y * (3 + 3 * x2 - y2);
            dest[2] = this.getDefaultZ();
            //dest[2] = geoPos[2];
            return dest;
        };

        /**
         * @function getName
         * @memberOf AugustProjection#
         */
        AugustProjection.prototype.getName = function() {
            return Constants.PROJECTION.August;
        };

        /**************************************************************************************************************/

        return AugustProjection;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/MercatorProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {

        /**
         * Mercator projection configuration
         * @typedef {AbstractProjection.configuration} AbstractProjection.mercator_configuration
         * @property {float} [lambda0 = 0.0] - the longitude of an arbitrary central meridian usually(but not always) Greenwich, in degrees
         * (default value is 0)
         */

        /**
         * @name MercatorProjection
         * @class
         *    The Mercator coordinate system is a coordinate reference system. It is composed of :
         * <ul>
         * <li>a reference frame : the reference geoide, which is set as parameter of the options object,</li>
         * <li>a projection : the Mercator projection.</li>
         * </ul>
         * The Mercator projection is a cylindrical map projection presented by the Flemish geographer and cartographer
         * Gerardus Mercator in 1569. It became the standard map projection for nautical purposes because of its ability to
         * represent lines of constant course<br/>
         * <img src="../doc/images/mercator.png" width="200px"/>
         * @augments AbstractProjection
         * @param {AbstractProjection.mercator_configuration} [options] - Mercator projection configuration.
         * @see {@link https://en.wikipedia.org/wiki/Mercator_projection}
         * @constructor
         * @memberOf module:Projection
         */
        var MercatorProjection = function (options) {
            AbstractProjection.prototype.constructor.call(this, [0,0], [-180, -80, 180, 84], options);
            this.lambda0 = options && options.lambda0 ? options.lambda0 : 0.0; // Greenwich (i.e., zero)
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, MercatorProjection);

        /**************************************************************************************************************/

        /**
         *  Hyperbolic sine
         */
        var _sinh = function (x) {
            var expY = Math.exp(x);
            return (expY - 1 / expY) / 2;
        };

        /**
         * @function unProject
         * @memberOf MercatorProjection#
         */
        MercatorProjection.prototype.unProject = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            dest[0] = this.lambda0 + position3d[0] * 180 / Math.PI;
            dest[1] = Math.atan(_sinh(position3d[1])) * 180 / Math.PI;
            dest[2] = position3d[2];

            if (Math.abs(dest[1]) > 85.05)
                return null;

            return dest;
        };

        /**
         * @function project
         * @memberOf MercatorProjection#
         */
        MercatorProjection.prototype.project = function (geoPos, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            // Clamp latitude values, since mercator converges to infinity at poles
            if (geoPos[1] > 85.05) {
                geoPos[1] = 85.05;
            }
            if (geoPos[1] < -85.05) {
                geoPos[1] = -85.05;
            }

            var longInRad = geoPos[0] * Math.PI / 180; // longitude
            var latInRad = geoPos[1] * Math.PI / 180;  // latitude

            var x = longInRad - (this.lambda0 * Math.PI / 180);
            var y = Math.log(Math.tan(latInRad) + 1 / Math.cos(latInRad));

            dest[0] = x;
            dest[1] = y;
            dest[2] = this.getDefaultZ();
            //dest[2] = geoPos[2];
            return dest;
        };

        /**
         * @function getName
         * @memberOf MercatorProjection#
         */
        MercatorProjection.prototype.getName = function() {
            return Constants.PROJECTION.Mercator;
        };

        /**************************************************************************************************************/

        return MercatorProjection;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/


define('Projection/MollweideProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {
      /**
       * @name MollweideProjection
       * @class
       *    The Mollweide coordinate system is a coordinate reference system. It is composed of :
       * <ul>
       * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
       * <li>a projection : the Mollweide projection.</li>
       * </ul>
       * The Mollweide projection is an equal-area, pseudocylindrical map projection generally used for global maps of
       * the world or night sky.<br/>
       * <img src="../doc/images/mollweide.png" width="200px"/>
       * @augments AbstractProjection
       * @param {AbstractProjection.configuration} [options] - No options.
       * @constructor
       * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
       * @memberOf module:Projection
       */
       var MollweideProjection = function (options) {
          AbstractProjection.prototype.constructor.call(this, [0,0], [-180, -90, 180, 90], options);
      };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, MollweideProjection);

        /**************************************************************************************************************/

        /**
         *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
         *  @see https://en.wikipedia.org/wiki/Mollweide_projection
         */
        function _findTheta(lat) {
            // Avoid divide by zero
            if (Math.abs(lat) === Math.PI / 2) {
                return lat;
            }

            var epsilon = 0.001;
            var thetaN = lat;  // n
            var thetaN1;       // n+1

            do
            {
                var twoThetaN = 2 * thetaN;
                thetaN = thetaN1;
                if (!thetaN) {
                    thetaN = lat;
                }
                thetaN1 = twoThetaN / 2 - (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) / (2 + 2 * Math.cos(twoThetaN));
            } while (Math.abs(thetaN1 - thetaN) >= epsilon);

            return thetaN1;
        }

        /**
         * @function unProject
         * @memberOf MollweideProjection#
         */
        MollweideProjection.prototype.unProject = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var auxTheta = Math.asin(position3d[1] / Math.sqrt(2));
            var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
            var lambda = (Math.PI * position3d[0]) / ( 2 * Math.sqrt(2) * Math.cos(auxTheta));

            dest[0] = lambda * 180 / Math.PI;
            dest[1] = phi * 180 / Math.PI;
            dest[2] = position3d[2];
            return dest;
        };

        /**
         * @function project
         * @memberOf MollweideProjection#
         */
        MollweideProjection.prototype.project = function (geoPos, dest) {
            if (!dest) {
                dest = new Array(3);
            }

            var lambda = geoPos[0] * Math.PI / 180; // longitude
            var theta0 = geoPos[1] * Math.PI / 180;  // latitude
            var auxTheta = _findTheta(theta0);

            // Transfrom to Mollweide coordinate system
            var mollX = 2 * Math.sqrt(2) / Math.PI * lambda * Math.cos(auxTheta);
            var mollY = Math.sqrt(2) * Math.sin(auxTheta);

            dest[0] = mollX;
            dest[1] = mollY;
            dest[2] = this.getDefaultZ();
            //dest[2] = geoPos[2];
            return dest;
        };

        /**
         * @function getName
         * @memberOf MollweideProjection#
         */
        MollweideProjection.prototype.getName = function() {
            return Constants.PROJECTION.Mollweide;
        };

        /**************************************************************************************************************/

        return MollweideProjection;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Projection/PlateProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {
        /**
         * @name PlateProjection
         * @class
         *    The Plate coordinate system is a coordinate reference system. It is composed of :
         * <ul>
         * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
         * <li>a projection : the Plate carrée projection.</li>
         * </ul>
         * <img src="../doc/images/platecarré.png" width="200px"/>
         * @augments AbstractProjection
         * @param {AbstractProjection.configuration} [options] - No options.
         * @constructor
         * @see {@link https://en.wikipedia.org/wiki/Mollweide_projection}
         * @memberOf module:Projection
         */
        var PlateProjection = function (options) {
            AbstractProjection.prototype.constructor.call(this, [0,0], [-180, -90, 180, 90], options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, PlateProjection);

        /**************************************************************************************************************/

        /**
         * @function unProject
         * @memberOf PlateProjection#
         */
        PlateProjection.prototype.unProject = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            dest[0] = position3d[0] * 180 / Math.PI;
            dest[1] = position3d[1] * 180 / Math.PI;
            dest[2] = position3d[2];

            return dest;
        };

        /**
         * @function project
         * @memberOf PlateProjection#
         */
        PlateProjection.prototype.project = function (geoPos, dest) {

            if (!dest) {
                dest = new Array(3);
            }
            dest[0] = geoPos[0] * Math.PI / 180;
            dest[1] = geoPos[1] * Math.PI / 180;
            dest[2] = geoPos[2];
            return dest;
        };

        /**
         * @function getName
         * @memberOf PlateProjection#
         */
        PlateProjection.prototype.getName = function() {
            return Constants.PROJECTION.Plate;
        };

        /**************************************************************************************************************/

        return PlateProjection;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/


define('Projection/AzimuthProjection',['./AbstractProjection', '../Utils/Utils', '../Utils/Constants', '../Renderer/glMatrix'],
    function (AbstractProjection, Utils, Constants) {

        /**
         * Azimuthal projection configuration
         * @typedef {AbstractProjection.configuration} AbstractProjection.azimuth_configuration
         * @property {string} [pole = "north"] - Projection center. It can be "north" or "south"
         */

        /**
         * @name AzimuthProjection
         * @class
         *    The Azimuth coordinate system is a coordinate reference system. It is composed of :
         * <ul>
         * <li>a reference frame : the reference geoid, which is set as parameter of the options object,</li>
         * <li>a projection : the Azimuth projection.</li>
         * </ul>
         * <img src="../doc/images/azimuth.png" width="200px"/>
         *
         * @see {@link https://en.wikipedia.org/wiki/Azimuthal_equidistant_projection}
         * @augments AbstractProjection
         * @param {AbstractProjection.azimuth_configuration} [options] - Azimuthal projection configuration.
         * @constructor
         * @memberOf module:Projection
         */
        var AzimuthProjection = function (options) {
            this.pole = (options && options.pole) || "north";
            var geoBound;
            var projectionCenter;
            if (this.pole === "south") {
                geoBound = [-180, -90, 180, 0];
                projectionCenter = [0, -90];
            } else {
                geoBound = [-180, 0, 180, 90];
                projectionCenter = [0, 90];
                this.pole = "north";
            }
            AbstractProjection.prototype.constructor.call(this, projectionCenter, geoBound, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProjection, AzimuthProjection);

        /**************************************************************************************************************/

        /**
         * @function unProject
         * @memberOf AzimuthProjection#
         */
        AzimuthProjection.prototype.unProject = function (position3d, dest) {
            var p = Math.sqrt(position3d[0] * position3d[0] + position3d[1] * position3d[1]);
            var o = Math.atan2(position3d[0], -position3d[1]);

            p = p * 180 / Math.PI;
            o = o * 180 / Math.PI;

            o *= this.pole === "south" ? -1 : 1;

            if (p > 90)
                return null;

            if (!dest) {
                dest = new Array(3);
            }
            dest[0] = o;
            dest[1] = this.pole === "south" ? p - 90 : 90 - p;
            dest[2] = position3d[2];
            return dest;
        };

        /**
         * @function project
         * @memberOf AzimuthProjection#
         */
        AzimuthProjection.prototype.project = function (geoPos, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            var p = this.pole === "south" ? 90 + geoPos[1] : 90 - geoPos[1];
            p = p * Math.PI / 180;

            var o = geoPos[0] * Math.PI / 180;
            o *= this.pole === "south" ? -1 : 1;
            dest[0] = p * Math.sin(o);
            dest[1] = -p * Math.cos(o);
            dest[2] = geoPos[2];

            return dest;
        };

        /**
         * @function getName
         * @memberOf AzimuthProjection#
         */
        AzimuthProjection.prototype.getName = function() {
            return Constants.PROJECTION.Azimuth;
        };

        /**************************************************************************************************************/

        return AzimuthProjection;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ProjectionFactory
 * @class
 * Factory to create a projection
 * @memberOf module:Projection
 */
define('Projection/ProjectionFactory',["../Utils/Constants",
        "./AitoffProjection", "./AugustProjection",
        "./MercatorProjection", "./MollweideProjection",
        "./PlateProjection", "./AzimuthProjection"],
    function (Constants,
              AitoffProjection, AugustProjection,
              MercatorProjection, MollweideProjection,
              PlateProjection, AzimuthProjection) {

        /**
         * Creates a projection based on the name of the projection and its options.
         * @param {PROJECTION} projectionName - Name of the projection
         * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options for the projection
         * @returns {Projection} projection
         * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
         * @private
         */
        function _createProjection(projectionName, options) {
            var cs;
            switch (projectionName) {
                case Constants.PROJECTION.Aitoff :
                    cs = new AitoffProjection(options);
                    break;
                case Constants.PROJECTION.August :
                    cs = new AugustProjection(options);
                    break;
                case Constants.PROJECTION.Azimuth :
                    cs = new AzimuthProjection(options);
                    break;
                case Constants.PROJECTION.Mercator :
                    cs = new MercatorProjection(options);
                    break;
                case Constants.PROJECTION.Mollweide :
                    cs = new MollweideProjection(options);
                    break;
                case Constants.PROJECTION.Plate :
                    cs = new PlateProjection(cs, options);
                    break;
                default :
                    throw new RangeError("Unable to create the projection " + options.projectionName,"ProjectionFactory.js");
            }
            return cs;
        }

        return {
            /**
             * Create a projection
             * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - Options.
             * @return {Projection}
             * @throws {ReferenceError} Will throw when options.projectionName is not defined
             * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
             * @alias module:Projection.ProjectionFactory.create
             */
            create : function (options) {
                var cs;

                if (options && options.projectionName) {
                    cs =_createProjection(options.projectionName, options);
                } else {
                    throw new ReferenceError("Unable to get options.projectionName","ProjectionFactory.js");
                }

                return cs;
            }

        }});




/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/ProjectedCrs',['./AbstractCrs', '../Utils/Utils', '../Projection/ProjectionFactory','../Renderer/glMatrix'],
    function (AbstractCrs, Utils, ProjectionFactory) {

        /**
         * ProjectedCrs configuration
         * @typedef {AbstractCrs.geoide_configuration} AbstractCrs.configuration
         * @property {CRS} geoideName - name of the coordinate reference system
         * @property {CONTEXT} type - Type of the CRS
         * @property {GeoBound} geoBound - Geographical bounding box
         */

        /**
         * @name ProjectedCrs
         * @class
         * A coordinate reference system projected on a 2D map.
         * @augments AbstractCrs
         * @param {Crs} cs - coordinate reference system
         * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} options - projection configuration
         * @constructor
         * @memberOf module:Crs
         * @throws {ReferenceError} Will throw when options.projectionName is not defined
         * @throws {RangeError} Will throw when options.projectionName is not part of {@link PROJECTION}
         */
        var ProjectedCrs = function (cs, options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: cs.getGeoideName(),
                radius: cs.getGeoide().getRadius(),
                realPlanetRadius: cs.getGeoide().getRealPlanetRadius(),
                type: cs.getType(),
                geoBound: cs.getGeoBound()
            });
            this.cs = cs;
            this.projection = ProjectionFactory.create(options);
            this.geoBound.setWest(this.projection.getGeoBound().getWest());
            this.geoBound.setSouth(this.projection.getGeoBound().getSouth());
            this.geoBound.setEast(this.projection.getGeoBound().getEast());
            this.geoBound.setNorth(this.projection.getGeoBound().getNorth());
            this.flat = true;
        };
        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, ProjectedCrs);

        /**************************************************************************************************************/

        /**
         * Formats the coordinates
         * @function formatCoordinates
         * @memberOf ProjectedCrs
         * @param geo the spatial position in degrees
         * @return {string[]} the format coordinates of the geoide given in parameter
         */
        ProjectedCrs.prototype.formatCoordinates = function (geo) {
            return this.cs.formatCoordinates(geo);
        };

        /**
         * @function getLongitudeLabel
         * @memberOf ProjectedCrs#
         */
        ProjectedCrs.prototype.getLongitudeLabel = function () {
            return this.cs.getLongitudeLabel();
        };

        /**
         * @function getLatitudeLabel
         * @memberOf ProjectedCrs#
         */
        ProjectedCrs.prototype.getLatitudeLabel = function () {
            return this.cs.getLatitudeLabel();
        };

        /**
         * Returns the physical position in degrees.
         * @function getWorldFrom3D
         * @memberOf ProjectedCrs
         * @param position3d the position in 3D
         * @param {float[]} dest the physical position
         * @return {float[]} the physical position
         */
        ProjectedCrs.prototype.getWorldFrom3D = function (position3d, dest) {
            if (!dest) {
                dest = new Array(3);
            }
            this.projection.unProject(position3d, dest);
            this.cs._setupPosAfterTrans(dest);
            dest[2] = dest[2] / this.geoide.getHeightScale();
            return dest;
        };

        /**
         * Returns the 3D position from physical position
         * @param posWorld physical position
         * @param {float[]}dest the 3D position
         * @return {float[]} the 3D position
         */
        ProjectedCrs.prototype.get3DFromWorld = function (posWorld, dest) {
            if (!dest) {
                dest = vec3.create();
            }
            var pos = posWorld.slice(0);
            this.cs._setupPosBeforeTrans(pos);
            this.projection.project(pos, dest);
            dest[2] = dest[2] ? dest[2] * this.geoide.getHeightScale() : 0.0;
            return dest;
        };


        /**
         * Returns the local transformation
         * @function getLocalTransform
         * @memberOf ProjectedCrs#
         * @param {Array} geo
         * @param {Array} dest
         * @return {Array} dest Matrix as 16 values
         */
        ProjectedCrs.prototype.getLocalTransform = function (geo, dest) {
            if (!dest) {
                dest = mat4.create();
            }
            mat4.identity(dest);
            return dest;
        };

        /**************************************************************************************************************/

        /**
         * Returns the LHV transformation
         * @function getLHVTransform
         * @memberOf ProjectedCrs
         * @param {Array} geo
         * @param {Array} dest
         * @return {Array} dest Matrix as 16 values
         */
        ProjectedCrs.prototype.getLHVTransform = function (geo, dest) {
            if (!dest) {
                dest = mat4.create();
            }
            var pt = this.projection.project(geo);
            mat4.identity(dest);
            dest[12] = pt[0];
            dest[13] = pt[1];
            dest[14] = pt[2] ? pt[2] * this.geoide.getHeightScale() : 0.0;
            dest[15] = 1.0;
            return dest;
        };

        /**
         * Returns the projection.
         * @function getProjection
         * @memberOf ProjectedCrs
         * @returns {AbstractProjection} the used projection
         */
        ProjectedCrs.prototype.getProjection = function() {
             return this.projection;
        };

        /**
         * @function getName
         * @memberOf ProjectedCrs#
         */
        ProjectedCrs.prototype.getName = function () {
            return this.cs.getName();
        };

        /**
         * @function getDescription
         * @memberOf ProjectedCrs#
         */
        ProjectedCrs.prototype.getDescription = function () {
            return this.cs.getDescription();
        };

        /**
         * @function isProjected
         * @memberOf ProjectedCrs#
         * @return {boolean} True.
         */
        ProjectedCrs.prototype.isProjected = function () {
            return true;
        };

        return ProjectedCrs;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Crs/HorizontalLocalCrs',['./AbstractCrs', '../Renderer/GeoBound', '../Utils/Utils', '../Utils/Constants', '../Utils/Numeric'],
    function (AbstractCrs, GeoBound, Utils, Constants, Numeric) {

        /**
         * @constant
         * @type {string}
         */
        const DESCRIPTION = "System in which an local object's position is described in the observer's local horizon." +
            "It is expressed in terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90° " +
            "(nadir) to 90° (zenith) but azimuth is measured in degrees eastward along the horizon from the North";

        /**
         * @constant
         * @type {string}
         */
        const LONGITUDE_LABEL = "Az";

        /**
         * @constant
         * @type {string}
         */
        const LATITUDE_LABEL = "Alt";


        /**
         * @name HorizontalLocalCrs
         * @class
         * System in which an local object's position is described in the observer's local horizon. It is expressed in
         * terms of altitude (or elevation) angle and azimuth. The elevation is measured for -90° (nadir) to 90° (zenith)
         * but azimuth is measured in degrees eastward along the horizon from the North.
         * <br/>
         * HorizontalLocalCrs is initialized with the following parameters :
         * <ul>
         *     <li>geoideName = HorizontalLocalCrs</li>
         *     <li>radius = 1.0</li>
         *     <li>realPlanetRadius = 1</li>
         *     <li>type = Planet</li>
         *     <li>geoBound = new GeoBound(0, -90, 360, 90)</li>
         * </ul>
         * @augments AbstractCrs
         * @param options - No option to give.
         * @constructor
         * @memberOf module:Crs
         */
        var HorizontalLocalCrs = function (options) {
            AbstractCrs.prototype.constructor.call(this, {
                geoideName: Constants.CRS.HorizontalLocal,
                radius: 1.0,
                realPlanetRadius: 1,
                type: Constants.CONTEXT.Ground,
                geoBound: new GeoBound(0, -90, 360, 90)
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractCrs, HorizontalLocalCrs);

        /**************************************************************************************************************/

        /**
         * Formats coordinates as (x.xxx N, y.yyy E).
         * @function formatCoordinates
         * @memberOf HorizontalLocalCrs
         * @param {float[]} geo the spatial position in degree
         * @return {string[]} the coordinates as xx.xxx S/N xx.xxx E/W
         */
        HorizontalLocalCrs.prototype.formatCoordinates = function (geo) {
            var astro = [];
            var azimuth = Numeric.roundNumber(geo[0], 3);
            var altitude = Numeric.roundNumber(geo[1], 3);
            if(azimuth > 0 && azimuth <= 180) {
                azimuth = 360 - azimuth;
            } else {
                azimuth = -1*azimuth;
            }
            astro[0] = this.getLongitudeLabel()+" = "+azimuth;
            astro[0] += "&deg;";
            astro[1] = this.getLatitudeLabel()+" = "+altitude;
            astro[1] +="&deg;";
            return astro;
        };

        /**
         * @function getLongitudeLabel
         * @memberOf HorizontalLocalCrs#
         */
        HorizontalLocalCrs.prototype.getLongitudeLabel = function () {
            return LONGITUDE_LABEL;
        };

        /**
         * @function getLatitudeLabel
         * @memberOf HorizontalLocalCrs#
         */
        HorizontalLocalCrs.prototype.getLatitudeLabel = function () {
            return LATITUDE_LABEL;
        };

        /**
         * Do nothing
         * @function _setupPosAfterTrans
         * @memberOf HorizontalLocalCrs
         * @private
         */
        HorizontalLocalCrs.prototype._setupPosAfterTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * Do nothing
         * @function _setupPosBeforeTrans
         * @memberOf HorizontalLocalCrs
         * @private
         */
        HorizontalLocalCrs.prototype._setupPosBeforeTrans = function(posWorld) {
            //Do Nothing
        };

        /**
         * @function getName
         * @memberOf HorizontalLocalCrs#
         */
        HorizontalLocalCrs.prototype.getName = function () {
            return Constants.CRS.HorizontalLocal;
        };

        /**
         * @function getDescription
         * @memberOf HorizontalLocalCrs#
         */
        HorizontalLocalCrs.prototype.getDescription = function () {
            return DESCRIPTION;
        };

        return HorizontalLocalCrs;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name CoordinateSystemFactory
 * @class
 * Factory to create a coordinate reference system
 * @memberOf module:Crs
 */
define('Crs/CoordinateSystemFactory',["../Utils/Constants", "./WGS84Crs", "./Mars2000Crs", "./Moon2000Crs","./EquatorialCrs",
        "./GalacticCrs", "./ProjectedCrs", "./HorizontalLocalCrs"],
    function (Constants, WGS84Crs, Mars2000Crs, Moon2000Crs,
              EquatorialCrs, GalacticCrs, ProjectedCrs, HorizontalLocalCrs) {

        /**
         * Creates a coordinate reference system based on its geoide name and its options.
         * @param {CRS} geoideName
         * @param {AbstractCrs.crsFactory} options - options to create a coordinate reference system
         * @returns {Crs} the created coordinate reference system
         * @throws {RangeError} Will throw an error when options.geoideName  is not part of {@link CRS}
         * @private
         */
        function _createCrs(geoideName, options) {
            var cs;
            switch (geoideName) {
                case Constants.CRS.Equatorial :
                    cs = new EquatorialCrs(options);
                    break;
                case Constants.CRS.Galactic :
                    cs = new GalacticCrs(options);
                    break;
                // For Earth
                case Constants.CRS.WGS84 :
                    cs = new WGS84Crs(options);
                    break;
                // For Mars
                case Constants.CRS.Mars_2000_old:
                case Constants.CRS.Mars_2000 :
                    cs = new Mars2000Crs(options);
                    break;
                // For Moon
                case Constants.CRS.Moon_2000_old:
                case Constants.CRS.Moon_2000 :
                    cs = new Moon2000Crs(options);
                    break;
                // For Ground
                case Constants.CRS.HorizontalLocal:
                    cs = new HorizontalLocalCrs(options);
                    break;
                // Unknown geoide name
                default :
                    throw new RangeError("Datum " + options.geoideName + " not implemented","CoordinateSystemFactory.js");
            }
            return cs;
        }


        return {
            /**
             * Data model to create a coordinate reference system through the factory
             * @typedef {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} AbstractCrs.crsFactory
             * @property {CRS} options.geoideName - name of the geoide
             */
            /**
             * Factory for CRS.
             * @param {AbstractCrs.crsFactory} options - Options to create a coordinate reference system
             * @return {Crs} Object to handle CRS
             * @alias module:Crs.CoordinateSystemFactory.create
             * @throws {ReferenceError} Will throw an error when options.geoideName is not defined
             * @throws {RangeError} Will throw an error when options.geoideName  is not part of {@link CRS}
             * @throws {RangeError} Will throw an error when options.projectionName is not part of {@link PROJECTION}
             */
            create: function (options) {
                var cs;
                if (options && options.geoideName) {
                    cs =_createCrs(options.geoideName, options);
                } else {
                    throw new ReferenceError("geoideName not defined in " + JSON.stringify(options), "CoordinateSystemFactory.js");
                }

                if (options && options.projectionName) {
                    cs = new ProjectedCrs(cs, options);
                }
                return cs;
            }
        }
    });



/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/CoordinateGridLayer',['./AbstractLayer', '../Utils/Utils', '../Renderer/Ray', '../Renderer/Program', '../Tiling/Mesh', '../Crs/AstroCoordTransform', '../Renderer/FeatureStyle', '../Utils/Constants', '../Crs/CoordinateSystemFactory'],
    function (AbstractLayer, Utils, Ray, Program, Mesh, AstroCoordTransform, FeatureStyle, Constants, CoordinateSystemFactory) {
        /**
         *    GL Textures pool
         *    @constructor
         */
        var TexturePool = function (pgl) {
            // TODO : changement gl en pgl pour éviter doublon
            var gl = pgl;
            var glTextures = [];

            /**
             Create a non power of two texture from an image
             */
            var createNewGLTexture = function (image) {
                var tex = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, tex);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                return tex;
            };


            /**
             Reuse a GL texture
             */
            var reuseGLTexture = function (image) {
                var glTexture = glTextures.pop();
                gl.bindTexture(gl.TEXTURE_2D, glTexture);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                return glTexture;
            };

            /**
             Create a GL texture
             */
            this.createGLTexture = function (image) {
                if (glTextures.length > 0) {
                    return reuseGLTexture(image);
                }
                else {
                    return createNewGLTexture(image);
                }
            };


            /**
             Dispose a GL texture
             */
            this.disposeGLTexture = function (texture) {
                glTextures.push(texture);
            };

            this.disposeAll = function () {
                for (var i = 0; i < glTextures.length; i++) {
                    gl.deleteTexture(glTextures[i]);
                }
                glTextures.length = 0;
            };


        };

        /**************************************************************************************************************/

        /**
         * CoordinateGridLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.coordinateGrid_configuration
         * @property {float} [longitudeSample=15] - Longitude sampling in decimal degree
         * @property {float} [latitudeSample=10] - Latitude sampling in decimal degree
         * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - The coordinate system of the grid
         * @property {String} [longFormat="Deg"] Representation of longitude axe(HMS, DMS, Deg)
         * @property {String} [latFormat="Deg"] Representation of latitude axe(HMS, DMS, Deg)
         * @property {Integer} [tesselation=2] Tesselation order (only for latitude bands currently)
         
         * 
         */
        /**
         * @name CoordinateGridLayer
         * @class
         *    A layer for coordinate grid
         * @augments AbstractLayer
         * @param {AbstractLayer.coordinateGrid_configuration} options - coordinate grid layer configuration
         * @constructor
         * @memberOf module:Layer
         */
        var CoordinateGridLayer = function (options) {
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.CoordinateGrid, options);
            this.globe = null;

            // Equatorial coordinates label renderables
            this.labels = {};

            // WebGL textures
            this.texturePool = null;

            this.longitudeSample = options.longitudeSample || 15; // *24 = 360
            this.latitudeSample = options.latitudeSample || 10; // *18 = 180

            // Canvas for generation of equatorial coordinate labels
            this.canvas2d = document.createElement("canvas");
            this.canvas2d.width = 100;
            this.canvas2d.height = 20;

            // Grid buffers
            this.vertexBuffer = null;
            this.indexBuffer = null;

            this.gridCrs = CoordinateSystemFactory.create(options.coordinateSystem);

            this.longFormat = options.longFormat ? options.longFormat : "Deg";
            this.latFormat = options.latFormat ? options.latFormat : "Deg";

            // Keep trace on geoBound
            this.geoBound = {};
            this.tesselation = options.tesselation || 2;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, CoordinateGridLayer);

        /**************************************************************************************************************/

        /**
         * Generates an image data from text.
         * @function generateImageData
         * @memberOf CoordinateGridLayer#
         * @param {String} text Text generated in canvas
         * @return {Object} Context of 2D canvas
         */
        CoordinateGridLayer.prototype.generateImageData = function (text) {
            var ctx = this.canvas2d.getContext("2d");
            ctx.clearRect(0, 0, this.canvas2d.width, this.canvas2d.height);
            ctx.fillStyle = FeatureStyle.fromColorToString(this.color);
            ctx.font = '18px sans-serif';
            ctx.textBaseline = 'top';
            ctx.textAlign = 'center';
            var x = this.canvas2d.width / 2;

            ctx.fillText(text, x, 0);

            return ctx.getImageData(0, 0, this.canvas2d.width, this.canvas2d.height);
        };

        /**************************************************************************************************************/

        /**
         * Attaches the layer to the globe.
         * @function _attach
         * @memberOf CoordinateGridLayer#
         * @param {Planet} g Planet
         * @private
         */
        CoordinateGridLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);

            if (this.isVisible()) {
                this.globe.tileManager.addPostRenderer(this);
            }

            if (!this.gridProgram) {
                /*  var vertexShader = "\
                 attribute vec3 vertex;\n\
                 uniform mat4 viewProjectionMatrix;\n\
                 void main(void) \n\
                 {\n\
                 gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n\
                 }\n\
                 ";*/
                var vertexShader = "attribute vec3 vertex;\n";
                vertexShader += "uniform mat4 viewProjectionMatrix;\n";
                vertexShader += "void main(void) \n";
                vertexShader += "{\n";
                vertexShader += "gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
                vertexShader += "}\n";

                /*                var fragmentShader = "\
                 precision highp float; \n\
                 uniform float alpha; \n\
                 uniform vec3 color; \n\
                 void main(void)\n\
                 {\n\
                 gl_FragColor = vec4(color,alpha);\n\
                 }\n\
                 ";*/

                var fragmentShader = "precision highp float; \n";
                fragmentShader += "uniform float alpha; \n";
                fragmentShader += "uniform vec3 color; \n";
                fragmentShader += "void main(void)\n";
                fragmentShader += "{\n";
                fragmentShader += "gl_FragColor = vec4(color,alpha);\n";
                fragmentShader += "}\n";

                /*                var vertexLabelShader = "\
                 attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n\
                 uniform mat4 viewProjectionMatrix; \n\
                 uniform vec3 poiPosition; // world position \n\
                 uniform vec2 poiScale; // x,y scale \n\
                 \n\
                 varying vec2 texCoord; \n\
                 \n\
                 void main(void)  \n\
                 { \n\
                 // Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n\
                 texCoord = vertex.xy + vec2(0.5); \n\
                 // Invert y \n\
                 texCoord.y = 1.0 - texCoord.y; \n\
                 \n\
                 // Compute poi position in clip coordinate \n\
                 gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n\
                 gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n\
                 } \n\
                 ";*/

                var vertexLabelShader = "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
                vertexLabelShader += "uniform mat4 viewProjectionMatrix; \n";
                vertexLabelShader += "uniform vec3 poiPosition; // world position \n";
                vertexLabelShader += "uniform vec2 poiScale; // x,y scale \n";
                vertexLabelShader += "\n";
                vertexLabelShader += "varying vec2 texCoord; \n";
                vertexLabelShader += "\n";
                vertexLabelShader += "void main(void)  \n";
                vertexLabelShader += "{ \n";
                vertexLabelShader += "// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
                vertexLabelShader += "texCoord = vertex.xy + vec2(0.5); \n";
                vertexLabelShader += "// Invert y \n";
                vertexLabelShader += "texCoord.y = 1.0 - texCoord.y; \n";
                vertexLabelShader += "\n";
                vertexLabelShader += "// Compute poi position in clip coordinate \n";
                vertexLabelShader += "gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
                vertexLabelShader += "gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
                vertexLabelShader += "} \n";


                /*    var fragmentLabelShader = "\
                 #ifdef GL_ES \n\
                 precision highp float; \n\
                 #endif \n\
                 \n\
                 varying vec2 texCoord; \n\
                 uniform sampler2D texture; \n\
                 uniform float alpha; \n\
                 \n\
                 void main(void) \n\
                 { \n\
                 vec4 textureColor = texture2D(texture, texCoord); \n\
                 gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n\
                 } \n\
                 ";*/
                var fragmentLabelShader = "#ifdef GL_ES \n";
                fragmentLabelShader += "precision highp float; \n";
                fragmentLabelShader += "#endif \n";
                fragmentLabelShader += "\n";
                fragmentLabelShader += "varying vec2 texCoord; \n";
                fragmentLabelShader += "uniform sampler2D texture; \n";
                fragmentLabelShader += "uniform float alpha; \n";
                fragmentLabelShader += "\n";
                fragmentLabelShader += "void main(void) \n";
                fragmentLabelShader += "{ \n";
                fragmentLabelShader += "	vec4 textureColor = texture2D(texture, texCoord); \n";
                fragmentLabelShader += "	gl_FragColor = vec4(textureColor.rgb, textureColor.a * alpha); \n";
                fragmentLabelShader += "} \n";

                this.gridProgram = new Program(this.globe.renderContext);
                this.labelProgram = new Program(this.globe.renderContext);
                this.gridProgram.createFromSource(vertexShader, fragmentShader);
                this.labelProgram.createFromSource(vertexLabelShader, fragmentLabelShader);
            }

            // Texture used to show the equatorial coordinates
            this.labelMesh = new Mesh(this.globe.renderContext);
            var vertices = [-0.5, -0.5, 0.0,
                -0.5, 0.5, 0.0,
                0.5, 0.5, 0.0,
                0.5, -0.5, 0.0];
            var indices = [0, 3, 1, 1, 3, 2];
            this.labelMesh.setVertices(vertices);
            this.labelMesh.setIndices(indices);

            // Init grid buffers
            var gl = this.globe.renderContext.gl;
            this.vertexBuffer = gl.createBuffer();
            this.indexBuffer = gl.createBuffer();

            // Init texture pool
            if (!this.texturePool) {
                this.texturePool = new TexturePool(gl);
            }
        };

        /**************************************************************************************************************/

        /**
         * Detaches the layer from the globe.
         * @function _detach
         * @memberOf CoordinateGridLayer#
         * @private
         */
        CoordinateGridLayer.prototype._detach = function () {
            var gl = this.globe.renderContext.gl;
            gl.deleteBuffer(this.vertexBuffer);
            gl.deleteBuffer(this.indexBuffer);

            this.texturePool.disposeAll();
            for (var i in this.labels) {
                if(this.labels.hasOwnProperty(i)) {
                    delete this.labels[i];
                }
            }

            this.globe.tileManager.removePostRenderer(this);
            AbstractLayer.prototype._detach.call(this);

        };

        /**************************************************************************************************************/

        /**
         * Clamps the geoBound to longitude/latitude samples.
         * @function clampGeoBound
         * @memberOf CoordinateGridLayer#
         * @param {GeoBound} geoBound Bbox
         * @return {GeoBound} Bbox clamped
         */
        CoordinateGridLayer.prototype.clampGeoBound = function (geoBound) {
            geoBound.west = Math.floor(geoBound.west / this.longitudeSample) * this.longitudeSample;
            geoBound.east = Math.ceil(geoBound.east / this.longitudeSample) * this.longitudeSample;
            geoBound.north = Math.ceil(geoBound.north / this.latitudeSample) * this.latitudeSample;
            geoBound.south = Math.floor(geoBound.south / this.latitudeSample) * this.latitudeSample;
            return geoBound;
        };

        /**
         * Renders the grid.
         * @function render
         * @memberOf CoordinateGridLayer#
         * @param {Array} tiles Tiles
         */
        CoordinateGridLayer.prototype.render = function (tiles) {
            var renderContext = this.globe.renderContext;
            var gl = renderContext.gl;

            gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Compute current geoBound
            //TODO a modifier
            var geoBound;
            // Transform geoBound computed in default coordinate system to coordinate system of current grid if different
            var self = this;
            geoBound = this.globe.getViewportGeoBound(function (coordinate) {
                //return coordinate;
                return self.globe.getCoordinateSystem().convert(coordinate, Constants.CRS.Equatorial, self.gridCrs.getGeoideName());
            });

            // Clamp geoBound angles to longitude/latitude samples
            geoBound = this.clampGeoBound(geoBound);

            // Regenerate grid & labels only if geoBound has changed
            if (this.geoBound.west !== geoBound.west || this.geoBound.east !== geoBound.east || this.geoBound.north !== geoBound.north || this.geoBound.south !== geoBound.south) {
                this.geoBound = geoBound;
                this.computeSamples();
                this.generateGridBuffers();
                this.generateLabels();
            }
            else {
                this.updateLabels();
            }

            /*** Render grid ***/
            this.gridProgram.apply();
            mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
            gl.uniformMatrix4fv(this.gridProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
            gl.uniform1f(this.gridProgram.uniforms.alpha, this.opacity);
            gl.uniform3f(this.gridProgram.uniforms.color, this.color[0], this.color[1], this.color[2]);

            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.vertexAttribPointer(this.gridProgram.attributes.vertex, this.vertexBuffer.itemSize, gl.FLOAT, false, 0, 0);

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.drawElements(gl.LINES, this.indexBuffer.numItems, gl.UNSIGNED_SHORT, 0);

            /*** Render labels ***/
            this.labelProgram.apply();

            mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
            gl.uniformMatrix4fv(this.labelProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
            gl.uniform1i(this.labelProgram.uniforms.texture, 0);

            var pixelSizeVector = renderContext.computePixelSizeVector();
            for (var n in this.labels) {
                if(this.labels.hasOwnProperty(n)) {
                    var label = this.labels[n];
                    // Bind point texture
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, label.texture);

                    // 2.0 * because normalized device coordinates goes from -1 to 1
                    var scale = [2.0 * label.textureWidth / renderContext.canvas.width,
                        2.0 * label.textureHeight / renderContext.canvas.height];

                    gl.uniform2fv(this.labelProgram.uniforms.poiScale, scale);
                    // gl.uniform2fv(this.labelProgram.uniforms["tst"], [ 0.5 / (label.textureWidth), 0.5 / (label.textureHeight)  ]);

                    // Poi culling
                    var worldPoi = label.pos3d;
                    var poiVec = label.vertical;
                    scale = label.textureHeight * ( pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3] );

                    var x = poiVec[0] * scale + worldPoi[0];
                    var y = poiVec[1] * scale + worldPoi[1];
                    var z = poiVec[2] * scale + worldPoi[2];

                    gl.uniform3f(this.labelProgram.uniforms.poiPosition, x, y, z);
                    gl.uniform1f(this.labelProgram.uniforms.alpha, 1.0);

                    this.labelMesh.render(this.labelProgram.attributes);
                    label.needed = false;
                }
            }
            gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
        };

        /**************************************************************************************************************/

        /**
         * Get/Set visibility of the layer.
         * @function setVisible
         * @memberOf CoordinateGridLayer#
         * @param {boolean} arg Visibility or not
         */
        CoordinateGridLayer.prototype.setVisible = function (arg) {
            AbstractLayer.prototype.setVisible.call(this, arg);
            if (typeof arg === "boolean") {
                if (this.isVisible()) {
                    this.globe.tileManager.addPostRenderer(this);
                }
                else {
                    this.globe.tileManager.removePostRenderer(this);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Computes samples depending on geoBound.
         * @function computeSamples
         * @memberOf CoordinateGridLayer#
         */
        CoordinateGridLayer.prototype.computeSamples = function () {
            var dlong = this.geoBound.east - this.geoBound.west;
            var dlat = this.geoBound.north - this.geoBound.south;

            // if under-sampled and not divergent
            while (dlong / this.longitudeSample < 3.0 && this.longitudeSample > 1.0) {
                this.longitudeSample /= 2;
                this.latitudeSample /= 2;
            }

            // if over-sampled and not exceed the initial value
            while (dlong / this.longitudeSample > 7.0 && this.longitudeSample < 15.0) {
                this.longitudeSample *= 2;
                this.latitudeSample *= 2;
            }
        };

        /**************************************************************************************************************/

        /**
         * Generates buffers object of the grid.
         * @function generateGridBuffers
         * @memberOf CoordinateGridLayer#
         */
        CoordinateGridLayer.prototype.generateGridBuffers = function () {
            var phiStart, phiStop;
            var latNumber, phi, i;
            // Difference is larger than hemisphere
            if ((this.geoBound.east - this.geoBound.west) > 180.0) {
                // pole in the viewport
                phiStart = 0;
                phiStop = 360;
            }
            else {
                phiStart = this.geoBound.west;
                phiStop = this.geoBound.east;
            }

            // TODO adaptative generation of theta value
            // for (var theta = geoBound.south; theta <= geoBound.north; theta+=latStep) {

            var vertexPositionData = [];
            var latitudeBands = 180.0 / this.latitudeSample;

            for (latNumber = 0; latNumber <= latitudeBands; latNumber++) {
                var theta = latNumber * Math.PI / latitudeBands;
                var sinTheta = Math.sin(theta);
                var cosTheta = Math.cos(theta);

                for (phi = phiStart; phi <= phiStop; phi += this.longitudeSample) {
                    // Tesselation
                    var step = this.longitudeSample / this.tesselation;
                    for (i = 0; i < this.tesselation; i++) {
                        var radPhi = (phi + i * step) * Math.PI / 180;

                        var sinPhi = Math.sin(radPhi);
                        var cosPhi = Math.cos(radPhi);

                        // z is the up vector
                        var x = cosPhi * sinTheta * this.globe.getCoordinateSystem().getGeoide().getRadius();
                        var y = sinPhi * sinTheta * this.globe.getCoordinateSystem().getGeoide().getRadius();
                        var z = cosTheta * this.globe.getCoordinateSystem().getGeoide().getRadius();

                        //TODO a modifier
                        if (this.gridCrs.getGeoideName() !== Constants.CRS.Equatorial) {
                            var geo = this.globe.getCoordinateSystem().from3DToGeo([x, y, z]);
                            geo = this.globe.getCoordinateSystem().convert(geo, this.gridCrs.getGeoideName(), Constants.CRS.Equatorial);
                            var eq = this.globe.getCoordinateSystem().fromGeoTo3D(geo);
                            vertexPositionData.push(eq[0], eq[1], eq[2]);
                        } else {
                            vertexPositionData.push(x, y, z);
                        }
                    }

                }
            }

            var gl = this.globe.renderContext.gl;
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexPositionData), gl.STATIC_DRAW);
            this.vertexBuffer.itemSize = 3;
            this.vertexBuffer.numItems = vertexPositionData.length / 3;


            var indexData = [];
            var longitudeBands = (phiStop - phiStart) / this.longitudeSample + 1;

            // Tesselation
            longitudeBands *= this.tesselation;

            for (latNumber = 0; latNumber < latitudeBands; latNumber++) {
                for (phi = phiStart, longNumber = 0; phi < phiStop; phi += this.longitudeSample, longNumber += this.tesselation) {
                    var first = (latNumber * (longitudeBands)) + longNumber % (longitudeBands - 1);
                    var second = first + longitudeBands;

                    // Horizontal lines
                    for (i = 0; i < this.tesselation; i++) {
                        indexData.push(first + i);
                        indexData.push(first + i + 1);
                    }

                    // Vertical lines
                    indexData.push(first + this.tesselation);
                    indexData.push(second + this.tesselation);

                    indexData.push(second);
                    indexData.push(first);
                }
            }

            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indexData), gl.STATIC_DRAW);
            this.indexBuffer.itemSize = 1;
            this.indexBuffer.numItems = indexData.length;
        };

        /**************************************************************************************************************/

        /**
         * Builds the angle representation.
         * @function buildAngle
         * @memberOf CoordinateGridLayer#
         * @param {String} format The building format("HMS", "DMS" or "Deg")
         * @param {float} angle The angle to build
         * @return {String} Label
         */
        CoordinateGridLayer.prototype.buildAngle = function (format, angle) {
            var label;
            switch (format) {
                case "Deg":
                    label = angle + "°";
                    break;
                case "HMS":
                    label = this.globe.getCoordinateSystem().fromDegreesToHMS(angle);
                    break;
                case "DMS":
                    label = this.globe.getCoordinateSystem().fromDegreesToDMS(angle);
                    break;
                default:
                    console.error(format + " : format not supported");
                    return null;
            }
            return label;
        };

        /**************************************************************************************************************/

        /**
         * Computes the geographic center of canvas in grid's coordinate system
         * @function computeGeoCenter
         * @memberOf CoordinateGridLayer#
         * @return {Array} Geocenter as array of float
         */
        CoordinateGridLayer.prototype.computeGeoCenter = function () {
            var ray = Ray.createFromPixel(this.globe.getRenderContext(), this.globe.getRenderContext().canvas.width / 2.0, this.globe.getRenderContext().canvas.height / 2.0);
            var center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.globe.getCoordinateSystem().getGeoide().getRadius()));
            var geoCenter = [];
            this.globe.getCoordinateSystem().from3DToGeo(center3d, geoCenter);

            // Convert geoCenter into grid's coordinate system
            geoCenter = this.globe.getCoordinateSystem().convert(geoCenter, Constants.CRS.Equatorial, this.gridCrs.getGeoideName());

            return geoCenter;
        };

        /**************************************************************************************************************/

        /**
         * Updates 3D position of a given label.
         * @function updateLabel
         * @memberOf CoordinateGridLayer#
         * @param {String} label The label id in labels object
         * @param {float[]} posGeo Updated geographic position of label
         */
        CoordinateGridLayer.prototype.updateLabel = function (label, posGeo) {
            posGeo = this.globe.getCoordinateSystem().convert(posGeo, this.gridCrs.getGeoideName(), Constants.CRS.Equatorial);
            var pos3d = this.globe.getCoordinateSystem().fromGeoTo3D(posGeo);
            var vertical = vec3.create();
            vec3.normalize(pos3d, vertical);

            this.labels[label].pos3d = pos3d;
            this.labels[label].vertical = vertical;
            this.labels[label].needed = true;
        };

        /**************************************************************************************************************/

        /**
         * Updates the position of all labels.
         * @function updateLabels
         * @memberOf CoordinateGridLayer.prototype
         */
        CoordinateGridLayer.prototype.updateLabels = function () {

            var geoCenter = this.computeGeoCenter();
            for (var x in this.labels) {
                if(this.labels.hasOwnProperty(x)) {
                    // Compute position of label
                    var posGeo;
                    if (this.labels[x].type === "lat") {
                        posGeo = [this.labels[x].angle, geoCenter[1]];
                    }
                    else if (this.labels[x].type === "long") {
                        posGeo = [geoCenter[0], this.labels[x].angle];
                    }
                    this.updateLabel(x, posGeo);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Generates labels of the grid.
         * @function generateLabels
         * @memberOf CoordinateGridLayer#
         */
        CoordinateGridLayer.prototype.generateLabels = function () {
            var phiStop, phiStart;
            var imageData, phi, x, posGeo, angle, theta;

            // Difference is larger than hemisphere
            if ((this.geoBound.east - this.geoBound.west) > 180.0) {
                // pole in the viewport => generate all longitude bands
                phiStart = 0;
                phiStop = 360;
            }
            else {
                phiStart = this.geoBound.west;
                phiStop = this.geoBound.east;
            }

            var geoCenter = this.computeGeoCenter();
            var label;
            for (phi = phiStart; phi < phiStop; phi += this.longitudeSample) {
                // convert to positive [0..360[
                angle = (phi < 0) ? phi + 360 : phi;

                label = this.buildAngle(this.longFormat, angle);

                if (!this.labels["lat_" + label]) {
                    this.labels["lat_" + label] = {
                        angle: phi,
                        type: "lat"
                    };
                    imageData = this.generateImageData(label);
                    this._buildTextureFromImage(this.labels["lat_" + label], imageData);
                }

                // Compute position of label
                posGeo = [phi, geoCenter[1]];
                this.updateLabel("lat_" + label, posGeo);
            }

            // TODO <!> Adaptative rendering isn't totally implemented for theta due to difficulty to compute extrem latitude using geoBound <!>
            thetaStart = Math.min(this.geoBound.north, this.geoBound.south);
            thetaStop = Math.max(this.geoBound.north, this.geoBound.south);

            for (theta = thetaStart; theta <= thetaStop; theta += this.latitudeSample) {
// 	for (var theta = -90; theta < 90; theta+=this.latitudeSample) {

                label = this.buildAngle(this.latFormat, theta);

                if (!this.labels["long_" + label]) {
                    this.labels["long_" + label] = {
                        angle: theta,
                        type: "long"
                    };
                    imageData = this.generateImageData(label);
                    this._buildTextureFromImage(this.labels["long_" + label], imageData);
                }

                // Compute position of label
                posGeo = [geoCenter[0], theta];
                this.updateLabel("long_" + label, posGeo);
            }

            // Dispose texture if not needed
            for (x in this.labels) {
                if (!this.labels[x].needed) {
                    this.texturePool.disposeGLTexture(this.labels[x].texture);
                    delete this.labels[x];
                }
            }

        };

        /**************************************************************************************************************/

        /*
         * Builds a texture from an image and store in a renderable
         * @function _buildTextureFromImage
         * @memberOf CoordinateGridLayer#
         * @param {boolean} renderable Is renderable ?
         * @param {Object} image Image object
         */
        CoordinateGridLayer.prototype._buildTextureFromImage = function (renderable, image) {
            renderable.texture = this.texturePool.createGLTexture(image);
            renderable.textureWidth = image.width;
            renderable.textureHeight = image.height;
        };

        /**************************************************************************************************************/

        return CoordinateGridLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/HEALPixTiling',['./Tile', './HEALPixBase', '../Renderer/GeoBound', '../Utils/Numeric', '../Utils/Constants'],
    function (Tile, HEALPixBase, GeoBound, Numeric, Constants) {
        /**
         Tile constructor

         Quadrilateral which composes one tile of HEALPix sphere

         nside : 2^order
         order : log2(nside);
         pix : pixel index number
         face : face number = [0..11]
         @constructor
         */
        var HEALPixTile = function (order, pix, face) {
            // Call ancestor constructor
            Tile.prototype.constructor.call(this);

            this.order = order;
            this.nside = Math.pow(2, this.order);
            this.pixelIndex = pix;
            this.face = face;

            // Compute texture transform
            /*	var width = 1728/64;
             var height = 1856/64;
             this.texTransform = [64/1728, 64/1856, ((this.pixelIndex % width))/width, ((Math.floor(this.pixelIndex/width))/height)];*/

            this.geoBound = null;
        };

        /**************************************************************************************************************/

        /** inherits from Tile */
        HEALPixTile.prototype = new Tile;

        /**************************************************************************************************************/

        /**
         Create the children
         */
        HEALPixTile.prototype.createChildren = function () {
            // Create the children

            var child00 = new HEALPixTile(this.order + 1, this.pixelIndex * 4, this.face);
            var child10 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 2, this.face);
            var child01 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 1, this.face);
            var child11 = new HEALPixTile(this.order + 1, this.pixelIndex * 4 + 3, this.face);

            child00.initFromParent(this, 0, 0);
            child10.initFromParent(this, 1, 0);
            child01.initFromParent(this, 0, 1);
            child11.initFromParent(this, 1, 1);

            this.children = [child00, child10, child01, child11];

        };

        /**************************************************************************************************************/

        /**
         Compute the local matrix for the tile
         */
        HEALPixTile.prototype.computeLocalMatrix = function (vertices) {
            var matrix = mat4.create();

            var east = vec3.create();
            var north = vec3.create();
            var up = vec3.create();

            var mx = 0;
            var my = 0;
            var mz = 0;
            for (var i = 0; i < vertices.length; i++) {
                mx += vertices[i][0];
                my += vertices[i][1];
                mz += vertices[i][2];
            }
            var barycenter = vec3.create([mx / vertices.length, my / vertices.length, mz / vertices.length]);

            vec3.set(barycenter, up);
            vec3.normalize(up);

            vec3.subtract(vertices[0], vertices[3], north);

            vec3.cross(up, north, east);
            vec3.normalize(east);
            vec3.cross(up, east, north);
            vec3.normalize(north);

            matrix[0] = east[0];
            matrix[1] = east[1];
            matrix[2] = east[2];
            matrix[3] = 0.0;

            matrix[4] = north[0];
            matrix[5] = north[1];
            matrix[6] = north[2];
            matrix[7] = 0.0;

            matrix[8] = up[0];
            matrix[9] = up[1];
            matrix[10] = up[2];
            matrix[11] = 0.0;

            matrix[12] = barycenter[0];
            matrix[13] = barycenter[1];
            matrix[14] = barycenter[2];
            matrix[15] = 1.0;

            return matrix;
        };

        /**************************************************************************************************************/

        /**
         Generate vertices for tile
         */
        HEALPixTile.prototype.generateVertices = function () {
            // Build the vertices
            var size = this.config.tesselation;
            var worldSpaceVertices = [];
            var step = 1.0 / (size - 1);

            // xyf calculation
            var pix = this.pixelIndex & (this.nside * this.nside - 1);
            var ix = HEALPixBase.compress_bits(pix);
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            var coordinateSystem = this.config.coordinateSystem;
            // Compute array of worldspace coordinates
            for (var u = 0; u < size; u++) {
                for (var v = 0; v < size; v++) {

                    var vertice = HEALPixBase.fxyf((ix + u * step) / this.nside, (iy + v * step) / this.nside, this.face);

                    // Take sphere radius into account
                    vertice[0] *= coordinateSystem.getGeoide().getRadius();
                    vertice[1] *= coordinateSystem.getGeoide().getRadius();
                    vertice[2] *= coordinateSystem.getGeoide().getRadius();
                    //TODO a modifier
                    if (coordinateSystem.getGeoideName() !== Constants.CRS.Equatorial) {
                        var geo = coordinateSystem.getWorldFrom3D(vertice);
                        var eq = coordinateSystem.convert(geo, coordinateSystem.getGeoideName(), Constants.CRS.Equatorial);
                        worldSpaceVertices[u * size + v] = coordinateSystem.get3DFromWorld(eq);
                    }
                    else {
                        worldSpaceVertices[u * size + v] = vertice;
                    }
                }
            }

            // Compute geoBound using corners of tile
            this.geoBound = new GeoBound();

            var corners = [];
            corners.push(coordinateSystem.getWorldFrom3D(worldSpaceVertices[0]));
            corners.push(coordinateSystem.getWorldFrom3D(worldSpaceVertices[size - 1]));
            corners.push(coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * (size - 1)]));
            corners.push(coordinateSystem.getWorldFrom3D(worldSpaceVertices[size * size - 1]));

            this.geoBound.computeFromCoordinates(corners);

            // Compute tile matrix
            this.matrix = this.computeLocalMatrix(worldSpaceVertices);
            var invMatrix = mat4.create();
            mat4.inverse(this.matrix, invMatrix);
            this.inverseMatrix = invMatrix;

            // Compute tile matrix
            /*var center = HEALPixBase.fxyf((ix+0.5)/this.nside, (iy+0.5)/this.nside, face);
             var geoCenter = coordinateSystem.getWorldFrom3D(center);
             this.matrix = coordinateSystem.getLHVTransform( geoCenter );
             var invMatrix = mat4.create();
             mat4.inverse( this.matrix, invMatrix );
             this.inverseMatrix = invMatrix;*/

            // Build the vertices
            var vertices = new Float32Array(3 * size * size);

            // Vertex coordinates in local space
            var vertexOffset = 0;
            for (var i = 0; i < worldSpaceVertices.length; i++) {
                vertices[vertexOffset] = invMatrix[0] * worldSpaceVertices[i][0] + invMatrix[4] * worldSpaceVertices[i][1] + invMatrix[8] * worldSpaceVertices[i][2] + invMatrix[12];
                vertices[vertexOffset + 1] = invMatrix[1] * worldSpaceVertices[i][0] + invMatrix[5] * worldSpaceVertices[i][1] + invMatrix[9] * worldSpaceVertices[i][2] + invMatrix[13];
                vertices[vertexOffset + 2] = invMatrix[2] * worldSpaceVertices[i][0] + invMatrix[6] * worldSpaceVertices[i][1] + invMatrix[10] * worldSpaceVertices[i][2] + invMatrix[14];
                vertexOffset += 3;
            }

            return vertices;
        };


        /**************************************************************************************************************/

        /**
         *    HEALPixTiling constructor
         *    @name HEALPixTiling
         *
         *    @param order Starting tiling order
         *    @param options Options
         *        <ul>
         *            <li>coordSystem: Coordinate system of the given tiling</li>
         *        </ul>
         *    @constructor
         */
        var HEALPixTiling = function (order, options) {
            this.order = order;
            this.nside = Math.pow(2, this.order);
            this.coordinateSystem = options.coordinateSystem;
            // TODO undefined coord system
        };

        /**************************************************************************************************************/

        /**
         Generate the tiles for level zero
         */
        HEALPixTiling.prototype.generateLevelZeroTiles = function (config, tilePool) {
            config.skirt = false;
            config.cullSign = -1;
            config.tesselation = 5;
            // TODO : change name to avoid ambiguity
            config.coordinateSystem = this.coordinateSystem;
            this.coordinateSystem = config.coordinateSystem;
            var level0Tiles = [];

            var qpf = Math.pow(this.nside, 2); // quad per face
            var nFaces = 12;
            var nQuads = nFaces * qpf;

            for (var i = 0; i < nQuads; i++) {
                var face = Math.floor(i / qpf);
                var tile = new HEALPixTile(this.order, i, face);
                tile.config = config;
                level0Tiles.push(tile);
            }

            return level0Tiles;
        };

// Get all the coordinates of a geometry
        var _getGeometryCoordinates = function (geometry) {
            var coords, n;
            switch (geometry.type) {
                case Constants.GEOMETRY.Point:
                    coords = [];
                    coords.push(geometry.coordinates);
                    break;
                case Constants.GEOMETRY.MultiPoint:
                case Constants.GEOMETRY.LineString:
                    coords = geometry.coordinates;
                    break;
                case Constants.GEOMETRY.MultiLineString:
                    coords = [];
                    for (n = 0; n < geometry.coordinates.length; n++) {
                        coords = coords.concat(geometry.coordinates[n]);
                    }
                    break;
                case Constants.GEOMETRY.Polygon:
                    coords = geometry.coordinates[0];
                    break;
                case Constants.GEOMETRY.MultiPolygon:
                    coords = [];
                    for (n = 0; n < geometry.coordinates.length; n++) {
                        coords = coords.concat(geometry.coordinates[n][0]);
                    }
                    break;
                case Constants.GEOMETRY.GeometryCollection:
                    coords = [];
                    for (n = 0; n < geometry.geometries.length; n++) {
                        coords = coords.concat(_getGeometryCoordinates(geometry.geometries[n]));
                    }
                    break;
            }
            return coords;
        };

        /**************************************************************************************************************/

        /**
         Get the level zero tiles that overlaps the given geometry
         */
        HEALPixTiling.prototype.getOverlappedLevelZeroTiles = function (geometry) {
            var tileIndices = [];

            var coords = _getGeometryCoordinates(geometry);
            if (!coords) {
                console.log("Invalid geometry type or not supported.");
                return tileIndices;
            }

            var indexMap = {};
            for (var i = 0; i < coords.length; i++) {
                var index = this.lonlat2LevelZeroIndex(coords[i][0], coords[i][1]);
                if (!indexMap[index]) {
                    indexMap[index] = true;
                    tileIndices.push(index);
                }
            }

            return tileIndices;
        };

        /**************************************************************************************************************/

        /**
         Locate a level zero tile
         */
        HEALPixTiling.prototype.lonlat2LevelZeroIndex = function (lon, lat) {
            //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
            //lon = geo[0];
            //lat = geo[1];
            return HEALPixBase.lonLat2pix(this.order, lon, lat);
        };

        /**************************************************************************************************************/

        /**
         Return tile of given longitude/latitude from tiles array if exists, null otherwise
         */
        HEALPixTiling.prototype.findInsideTile = function (lon, lat, tiles) {
            //var geo = this.coordinateSystem.convert([lon, lat], Constants.CRS.Equatorial, this.coordinateSystem.getGeoideName());
            //lon = geo[0];
            //lat = geo[1];
            for (var i = 0; i < tiles.length; i++) {
                var tile = tiles[i];
                var index = HEALPixBase.lonLat2pix(tile.order, lon, lat);
                if (index === tile.pixelIndex) {
                    return tile;
                }
            }
            return null;
        };

        /**************************************************************************************************************/


        /**************************************************************************************************************/

        return HEALPixTiling;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/HipsMetadata',["jquery", "../Utils/Constants"], function ($, Constants) {

    /**
     * @namespace
     * GENERAL_WAVELENGTH
     * @property {String} Radio - Radio
     * @property {String} Millimeter - Millimeter
     * @property {String} Infrared - Infrared
     * @property {String} Optical - Optical
     * @property {String} UV - UV
     * @property {String} EUV - EUV
     * @property {String} X-ray - X-ray
     * @property {String} Gamma-ray - Gamma-ray
     */
    var GENERAL_WAVELENGTH = {
        "Radio": "Radio",
        "Millimeter": "Millimeter",
        "Infrared": "Infrared",
        "Optical": "Optical",
        "UV": "UV",
        "EUV": "EUV",
        "X-ray": "X-ray",
        "Gamma-ray": "Gamma-ray"
    };

    /**
     * @namespace
     * HIPS_FRAME
     * @property {String} equatorial - equatorial
     * @property {String} galactic - galactic
     * @property {String} ecliptic - ecliptic
     */
    var HIPS_FRAME = {
        "equatorial": Constants.CRS.Equatorial,
        "galactic": Constants.CRS.Galactic,
        "ecliptic": "ecliptic"
    };

    /**
     * @namespace
     * HIPS_TILE_FORMAT
     * @property {String} jpeg - jpeg
     * @property {String} png - png
     * @property {String} fits - fits
     * @property {String} tsv - tsv
     */
    var HIPS_TILE_FORMAT = {
        "jpeg": "jpeg",
        "png": "png",
        "fits": "fits",
        "tsv": "tsv"
    };

    /**
     * @namespace
     * SAMPLING
     * @property {String} none - none
     * @property {String} nearest - nearest
     * @property {String} bilinear - bilinear
     */
    var SAMPLING = {
        "none": "non",
        "nearest": "nearest",
        "bilinear": "bilinear"
    };

    /**
     * @namespace
     * PIXEL_OVERLAY
     * @property {String} add - add
     * @property {String} mean - mean
     * @property {String} first - first
     * @property {String} border_fading - border_fading
     * @property {String} custom - custom
     */
    var PIXEL_OVERLAY = {
        "add": "add",
        "mean": "mean",
        "first": "first",
        "border_fading": "border_fading",
        "custom": "custom"
    };

    /**
     * @namespace
     * SKY_VAL
     * @property {String} none - none
     * @property {String} hips_estimation - hips_estimation
     * @property {String} fits_keyword - fits_keyword
     */
    var SKY_VAL = {
        "none": "none",
        "hips_estimation": "hips_estimation",
        "fits_keyword": "fits_keyword"
    };

    /**
     * @namespace
     * DATA_PRODUCT_TYPE
     * @property {String} image - image
     * @property {String} cube - cube
     * @property {String} catalog - catalog
     * @property {String} meta - meta
     */
    var DATA_PRODUCT_TYPE = {
        "image": "image",
        "cube": "cube",
        "catalog": "catalog",
        "meta": "meta"
    };

    /**
     * @namespace
     * SUB_TYPE_DATA
     * @property {String} color - color
     * @property {String} live - live
     */
    var SUB_TYPE_DATA = {
        "color": "color",
        "live": "live"
    };

    /**
     * Hips data model
     * Mandatory, description, isMultiple, default value, distinctvalue, isArray
     * @namespace
     * HIPS_METADATA
     * @property {String} creator_did - Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J
     * @property {String} [publisher_id] - Unique ID of the HiPS publisher – Format: IVOID - Ex : ivo://CDS
     * @property {String} [obs_collection] - Short name of original data set – Format: one word – Ex : 2MASS
     * @property {String} obs_title - Data set title – Format: free text, one line – Ex : HST F110W observations
     * @property {String} [obs_description] - Data set description – Format: free text, longer free text description of the dataset
     * @property {String} [obs_ack] - Acknowledgment mention"
     * @property {String} [prov_progenitor] - Provenance of the original data – Format: free text
     * @property {String} [bib_reference] - Bibliographic reference
     * @property {String} [bib_reference_url] - URL to bibliographic reference
     * @property {String} [obs_copyright] - Copyright mention – Format: free text
     * @property {String} [obs_copyright_url] - URL to a copyright mention
     * @property {GENERAL_WAVELENGTH} [obs_regime] - General wavelength
     * @property {String} [data_ucd] - UCD describing data contents
     * @property {String} hips_version="1.4" - Number of HiPS version – Format: number
     * @property {String} [hips_builder] - Name and version of the tool used for building the HiPS – Format: free text
     * @property {String} [hips_publisher] - Institute or person who built the HiPS – Format: free text – Ex : CDS (T.Boch)
     * @property {String} [hips_creation_date] - HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {String} hips_release_date - Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ
     * @property {String} [hips_service_url] - HiPS access url – Format: URL
     * @property {String} hips_status - HiPS status
     * @property {String} [hips_estsize] - HiPS size estimation – Format: positive integer – Unit : KB
     * @property {HIPS_FRAME} hips_frame - Coordinate frame reference
     * @property {int} hips_order - Deepest HiPS order – Format: positive integer
     * @property {int} [hips_tile_width=512] - Tiles width in pixels – Format: positive integer
     * @property {HIPS_TILE_FORMAT} hips_tile_format - List of available tile formats
     * @property {String} [hips_pixel_cut] - Suggested pixel display cut range (physical values) – Format: min max
     * @property {String} [hips_data_range] - Pixel data range taken into account during the HiPS generation (physical values) – Format: min max – Ex : -18.5 510.5
     * @property {SAMPLING} [hips_sampling] - Sampling applied for the HiPS generation
     * @property {PIXEL_OVERLAY} [hips_overlay] - Pixel composition method applied on the image overlay region during HiPS generation
     * @property {SKY_VAL} [hips_skyval] - Sky background subtraction method applied during HiPS generation
     * @property {String} [hips_pixel_bitpix] - Fits tile BITPIX code
     * @property {String} [data_pixel_bitpix] - Original data BITPIX code
     * @property {DATA_PRODUCT_TYPE} dataproduct_type - Type of data
     * @property {SUB_TYPE_DATA} [dataproduct_subtype] - Subtype of data
     * @property {String} [hips_progenitor_url] - URL to an associated progenitor HiPS
     * @property {int} [hips_cat_nrows] -  Number of rows of the HiPS catalog
     * @property {int} [hips_cube_depth] - Number of frames of the HiPS cube
     * @property {int} [hips_cube_firstframe=0] - Initial first index frame to display for a HiPS cube
     * @property {float} [data_cube_crpix3] - Coef for computing physical channel value
     * @property {float} [data_cube_crval3] - Coef for computing physical channel value
     * @property {float} [data_cube_cdelt3] - Coef for computing physical channel value
     * @property {String} [data_cube_bunit3] - Third axis unit
     * @property {float} [hips_initial_ra] - Default RA display position (ICRS frame) – Unit : degrees
     * @property {float} [hips_initial_dec] - Default DEC display position (ICRS frame) – Unit : degrees
     * @property {float} [hips_initial_fov] - Default display size – Unit : degrees
     * @property {float} [hips_pixel_scale] - HiPS pixel angular resolution at the highest order – Unit : degrees
     * @property {float} [s_pixel_scale] - Best pixel angular resolution of the original images – Unit : degrees
     * @property {float} [t_min] - Start time of the observations - Representation: MJD
     * @property {float} [t_max] - Stop time of the observations - Representation: MJD
     * @property {float} [em_min] - Start in spectral coordinates – Unit: meters
     * @property {float} [em_max] - Stop in spectral coordinates – Unit: meters
     * @property {String} [client_category] - / separated keywords suggesting a display hierarchy to the client – Ex : Image/InfraRed
     * @property {String} [client_sort_key] - Sort key suggesting a display order to the client inside a client_category – Sort : alphanumeric
     * @property {String} [addendum_did] - In case of “live” HiPS, creator_did of the added HiPS
     * @property {float} [moc_sky_fraction] - Fraction of the sky covers by the MOC associated to the HiPS – Format: real between 0 and 1
     */
    var HipsVersion_1_4 = {
        creator_did: ["R", "Unique ID of the HiPS - Format: IVOID - Ex : ivo://CDS/P/2MASS/J", false, null, null, false],
        publisher_id: [null, "Unique ID of the HiPS publisher – Format: IVOID - Ex : ivo://CDS", false, null, null, false],
        obs_collection: [null, "Short name of original data set – Format: one word – Ex : 2MASS", false, null, null, false],
        obs_title: ["R", "Data set title – Format: free text, one line – Ex : HST F110W observations", false, null, null, false],
        obs_description: ["S", "Data set description – Format: free text, longer free text description of the dataset", false, null, null, false],
        obs_ack: [null, "Acknowledgment mention", false, null, null, false],
        prov_progenitor: ["S", "Provenance of the original data – Format: free text", true, null, null, false],
        bib_reference: [null, "Bibliographic reference", true, null, null, false],
        bib_reference_url: [null, "URL to bibliographic reference", true, null, null, false],
        obs_copyright: [null, "Copyright mention – Format: free text", false, null, null, false],
        obs_copyright_url: [null, "URL to a copyright mention", false, null, null, false],
        obs_regime: ["S", "General wavelength – Format: word", true, null, GENERAL_WAVELENGTH, false],
        data_ucd: [null, "UCD describing data contents", true, null, null, false],
        hips_version: ["R", "Number of HiPS version – Format: number", false, "1.4", null, false],
        hips_builder: [null, "Name and version of the tool used for building the HiPS – Format: free text", false, null, null, false],
        hips_publisher: [null, "Institute or person who built the HiPS – Format: free text – Ex : CDS (T.Boch)", false, null, null, false],
        hips_creation_date: ["S", "HiPS first creation date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ", false, null, null, false],
        hips_release_date: ["R", "Last HiPS update date - Format: ISO 8601 => YYYY-mm-ddTHH:MMZ", false, null, null, false],
        hips_service_url: [null, "HiPS access url – Format: URL", false, null, null, false],
        hips_status: ["R", "HiPS status", false, "public master clonableOnce", null, true],
        hips_estsize: [null, "HiPS size estimation – Format: positive integer – Unit : KB", false, null, null, false],
        hips_frame: ["R", "Coordinate frame reference", false, null, HIPS_FRAME, false],
        hips_order: ["R", "Deepest HiPS order – Format: positive integer", false, null, null, false],
        hips_tile_width: [null, "Tiles width in pixels – Format: positive integer", false, 512, null, false],
        hips_tile_format: ["R", "List of available tile formats. The first one is the default suggested to the client", false, null, HIPS_TILE_FORMAT, true],
        hips_pixel_cut: [null, "Suggested pixel display cut range (physical values) – Format: min max", null, null, null, true],
        hips_data_range: [null, "Pixel data range taken into account during the HiPS generation (physical values) – Format: min max – Ex : -18.5 510.5", false, null, null, true],
        hips_sampling: [null, "Sampling applied for the HiPS generation", false, null, SAMPLING, false],
        hips_overlay: [null, "Pixel composition method applied on the image overlay region during HiPS generation", false, null, PIXEL_OVERLAY, false],
        hips_skyval: [null, "Sky background subtraction method applied during HiPS generation", false, null, SKY_VAL, false],
        hips_pixel_bitpix: [null, "Fits tile BITPIX code", false, null, null, false],
        data_pixel_bitpix: [null, "Original data BITPIX code", false, null, null],
        dataproduct_type: ["R", "Type of data", false, null, DATA_PRODUCT_TYPE, false],
        dataproduct_subtype: ["RD", "Subtype of data", false, null, SUB_TYPE_DATA, false],
        hips_progenitor_url: [null, "URL to an associated progenitor HiPS", false, null, null, false],
        hips_cat_nrows: ["S", "Number of rows of the HiPS catalog", false, null, null, false],
        hips_cube_depth: ["RD", "Number of frames of the HiPS cube", false, null, null, false],
        hips_cube_firstframe: [null, "Initial first index frame to display for a HiPS cube", false, 0, null, false],
        data_cube_crpix3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
        data_cube_crval3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
        data_cube_cdelt3: [null, "Coef for computing physical channel value (see FITS doc)", false, null, null, false],
        data_cube_bunit3: [null, "Third axis unit (see FITS doc)", false, null, null, false],
        hips_initial_ra: ["S", "Default RA display position (ICRS frame) – Unit : degrees", false, null, null, false],
        hips_initial_dec: ["S", "Default DEC display position (ICRS frame) – Unit : degrees", false, null, null, false],
        hips_initial_fov: ["S", "Default display size – Unit : degrees", false, null, null, false],
        hips_pixel_scale: [null, "HiPS pixel angular resolution at the highest order – Unit : degrees", false, null, null, false],
        s_pixel_scale: [null, "Best pixel angular resolution of the original images – Unit : degrees", false, null, null, false],
        t_min: ["S", "Start time of the observations - Representation: MJD", false, null, null, false],
        t_max: ["S", "Stop time of the observations - Representation: MJD", false, null, null, false],
        em_min: ["S", "Start in spectral coordinates – Unit: meters", false, null, null, false],
        em_max: ["S", "Stop in spectral coordinates – Unit: meters", false, null, null, false],
        client_category: [null, "/ separated keywords suggesting a display hierarchy to the client – Ex : Image/InfraRed", false, null, null, false],
        client_sort_key: [null, "Sort key suggesting a display order to the client inside a client_category – Sort : alphanumeric", false, null, null, false],
        addendum_did: [null, "In case of “live” HiPS, creator_did of the added HiPS", true, null, null, false],
        moc_sky_fraction: [null, "Fraction of the sky covers by the MOC associated to the HiPS – Format: real between 0 and 1", false, null, null, false]
    };

    /**
     * Checks if the required attribute is stored in hipsMetadata.<br>
     * when the attribute is not stored, then store this information in requiredKeywordNotFound.
     * @param {HIPS_METADATA} hipsMetadata
     * @param {string} mandatory - "R" is a required parameter
     * @param {string} key - attribute to check
     * @param {string} description Key's description
     * @param requiredKeywordNotFound - Array or required information not found
     * @private
     */
    function _checkRequiredParameters(hipsMetadata, mandatory, key, description, requiredKeywordNotFound) {
        if (mandatory === "R" && !hipsMetadata.hasOwnProperty(key)) {
            //Fix for version=1.2
            if (key === "creator_did" && hipsMetadata['hips_version'] === "1.2") {
                hipsMetadata['creator_did'] = hipsMetadata['publisher_did'];
            } else {
                requiredKeywordNotFound.push(key + " (" + description + ") is not present. ");
            }
        }
    }

    /**
     *
     * @param {boolean} valueArray - is an Array
     * @param {string} key - attribute
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _transformAStringToArray(valueArray, key, hipsMetadata) {
        if (valueArray && hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = hipsMetadata[key].split(/\s+/);
        }
    }

    /**
     * Checks a value is among an enumerated list
     * @param {string} key - key to test
     * @param {string} description - key's description
     * @param distinctValue - enumeration
     * @param hipsMetadata - hipsMetadata
     * @param valueNotRight - Wrong value
     * @private
     */
    function _checkValueAmongEnumeratedList(key, valueArray, description, distinctValue, hipsMetadata, valueNotRight) {
        if (distinctValue !== null && hipsMetadata.hasOwnProperty(key)) {
            if (valueArray) {
                for (var val in hipsMetadata[key]) {
                    if (hipsMetadata[key].hasOwnProperty(val)) {
                        var format = hipsMetadata[key][val];
                        if (!distinctValue.hasOwnProperty(format)) {
                            valueNotRight.push("The value \"" + hipsMetadata[key] + "\" of " + key + " (" + description + ") is not correct. ");
                            break;
                        }
                    }
                }
            } else {
                if (!distinctValue.hasOwnProperty(hipsMetadata[key])) {
                    valueNotRight.push("The value \"" + hipsMetadata[key] + "\" of " + key + " (" + description + ") is not correct. ");
                }
            }
        }
    }

    /**
     * fills hipsMetadata with the default value when the key is not present
     * @param {string} key - key
     * @param {string} defaultValue - default value
     * @param {HIPS_METADATA} hipsMetadata
     * @private
     */
    function _fillWithDefaultValue(key, defaultValue, hipsMetadata) {
        if (defaultValue !== null && !hipsMetadata.hasOwnProperty(key)) {
            hipsMetadata[key] = defaultValue;
        }
    }

    /**
     * Validates and fixes metadata
     * @param {HIPS_METADATA} hipsMetadata
     * @throws RangeError - "unvalid hips metadata"
     */
    function _validateAndFixHips(hipsMetadata) {
        var requiredKeywordNotFound = [];
        var valueNotRight = [];
        var values, mandatory, description, isMutiple, defaultValue, distinctValue, valueArray;
        for (var key in HipsVersion_1_4) {
            if (HipsVersion_1_4.hasOwnProperty(key)) {
                values = HipsVersion_1_4[key];
                mandatory = values[0];
                description = values[1];
                defaultValue = values[3];
                distinctValue = values[4];
                valueArray = values[5];

                // checking the required parameter is here
                _checkRequiredParameters.call(this, hipsMetadata, key, description, requiredKeywordNotFound);

                // Transforms a key's value into an array when it is necessary and store the result in hipsMetadata
                _transformAStringToArray.call(this, valueArray, key, hipsMetadata);

                // checking the value of the parameter among a list of values
                //_checkValueAmongEnumeratedList.call(this, key, valueArray, description, distinctValue, hipsMetadata, valueNotRight);

                // checking the key is here when a default value exists
                _fillWithDefaultValue.call(this, key, defaultValue, hipsMetadata);

            }
        }
        if (requiredKeywordNotFound.length > 0 || valueNotRight.length > 0) {
            throw new RangeError("unvalid hips metadata : \n" + requiredKeywordNotFound.toString() + "\n" + valueNotRight.toString(),"HipsMetadata.js");
        }

    }

    /**
     * Loads Hips properties
     * @param baseUrl
     * @throws ReferenceError - Unable to load the Hips
     * @return {*}
     */
    function _loadHipsProperties(baseUrl) {
        var url = baseUrl + "/properties";
        var properties = $.ajax({
            type: "GET",
            url: baseUrl + "/properties",
            async: false
        }).responseText;
        if (typeof properties === 'undefined') {
            throw new ReferenceError("Unable to load the Hips at " + baseUrl,"HipsMetadata.js");
        }
        var hipsProperties = _parseProperties.call(this, properties);
        _validateAndFixHips.call(this, hipsProperties);
        return hipsProperties;
    }

    /**
     * Parses properties
     * @param propertiestext
     * @return {{}}
     */
    function _parseProperties(propertiestext) {
        var propertyMap = {};
        var lines = propertiestext.split(/\r?\n/);
        var currentLine = '';
        $.each(lines, function (i, value) {
            //check if it is a comment line
            if (!/^\s*(\#|\!|$)/.test(value)) // line is whitespace or first non-whitespace character is '#' or '!'
            {
                value = value.replace(/^\s*/, ''); // remove space at start of line
                currentLine += value;
                if (/(\\\\)*\\$/.test(currentLine)) // line ends with an odd number of '\' (backslash)
                {
                    //line ends with continuation character, remember it and don't process further
                    currentLine = currentLine.replace(/\\$/, '');
                }
                else {
                    /^\s*((?:[^\s:=\\]|\\.)+)\s*[:=\s]\s*(.*)$/.test(currentLine); // sub-matches pick out key and value
                    var nkey = RegExp.$1;
                    var nvalue = RegExp.$2;
                    if (propertyMap.hasOwnProperty(nkey)) {
                        propertyMap[nkey] = (propertyMap[nkey].isPrototypeOf(Array)) ? propertyMap[nkey].push(nvalue) : [propertyMap[nkey], nvalue];
                    } else {
                        propertyMap[nkey] = nvalue;
                    }

                    currentLine = '';
                }
            }
        });
        return propertyMap;
    }

    /**
     * @name HipsMetadata
     * @class
     * Hips data model
     * @param baseUrl
     * @constructor
     */
    var HipsMetadata = function (baseUrl) {
        if (typeof (baseUrl) === "string") {
            this.baseUrl = baseUrl;
            this.hipsMetadata = _loadHipsProperties.call(this, baseUrl);
        } else {
            this.hipsMetadata = baseUrl;
        }
    };

    /**
     * Supported {@link GENERAL_WAVELENGTH wavelength}
     * @name GeneralWavelength
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.GeneralWavelength = GENERAL_WAVELENGTH;

    /**
     * Supported {@link HIPS_FRAME Hips frame}
     * @name HipsFrame
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.HipsFrame = HIPS_FRAME;

    /**
     * Supported {@link HIPS_TILE_FORMAT Hips tile format}
     * @name HipsTileFormat
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.HipsTileFormat = HIPS_TILE_FORMAT;

    /**
     * Supported {@link SAMPLING Sampling}
     * @name Sampling
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.Sampling = SAMPLING;

    /**
     * Supported {@link PIXEL_OVERLAY pixel overlay}
     * @name PixelOverlay
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.PixelOverlay = PIXEL_OVERLAY;

    /**
     * Supported {@link SKY_VAL SkyVal}
     * @name SkyVal
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.SkyVal = SKY_VAL;

    /**
     * Supported {@link DATA_PRODUCT_TYPE DataProductType}
     * @name DataProductType
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.DataProductType = DATA_PRODUCT_TYPE;

    /**
     * Supported {@link SUB_TYPE_DATA SubTypeData}
     * @name SubTypeData
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.SubTypeData = SUB_TYPE_DATA;

    /**
     * Returns the Hips metadata.
     * @function getHipsMetadata
     * @returns {HIPS_METADATA}
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.getHipsMetadata = function () {
        return this.hipsMetadata;
    };

    /**
     * Returns base URL
     * @function getBaseUrl
     * @returns {string} the URL of the Hips
     * @memberOf HipsMetadata#
     */
    HipsMetadata.prototype.getBaseUrl = function () {
        return this.baseUrl;
    };

    return HipsMetadata;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/AbstractHipsLayer',["./AbstractRasterLayer", "../Utils/Utils", "../Utils/Constants", "../Tiling/HEALPixTiling", "../Crs/CoordinateSystemFactory", "./HipsMetadata"],
    function (AbstractRasterLayer, Utils, Constants, HEALPixTiling, CoordinateSystemFactory, HipsMetadata) {

        /**
         * AbstractHipsLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractHipsLayer.configuration
         * @property {Crs} [coordinateSystem = CoordinateSystemFactory.create({geoideName: Constants.MappingCrsHips2Mizar[this.hipsMetadata.hips_frame]})] - Coordinate reference system
         * @property {int} [tilePixelSize = hipsMetadata['hips_tile_width'] - Tiles width in pixels
         * @property {int} [baseLevel = 2] - min HiPS order
         * @property {HEALPixTiling} [tiling = new HEALPixTiling(options.baseLevel, {coordinateSystem: options.coordinateSystem})] - Tiling
         * @property {int} [numberOfLevels = hipsMetadata['hips_order']] - Deepest order min
         * @property {string} [name = hipsMetadata['obs_title']] - Data set title
         * @property {string} [attribution = <a href=\"" + this.hipsMetadata['obs_copyright_url'] + "\" target=\"_blank\">" + this.hipsMetadata['obs_copyright'] + "</a>"] - URL to a copyright mention
         * @property {string} [ack = hipsMetadata['obs_ack']] - Acknowledgment mention
         * @property {string} [icon = ""] - icon used as metadata representation on the map
         * @property {string} [description = hipsMetadata['obs_description']] - Data set description
         * @property {boolean} [visible = false] visibility by default on the map
         * @property {Object} properties - other metadata
         * @property {float} [properties.initialRa = undefined] - Initial RA
         * @property {float} [properties.initialDec = undefined] - Initial DEC
         * @property {float} [properties.initialFov = undefined] - Initial field of view
         * @property {float} [properties.mocCoverage = undefined] - Sky fraction coverage
         * @property {boolean} [pickable = false] - Pickable layer
         * @property {Array} [availableServices = {}] - List of services related to the layer
         * @property {Array} [format = hipsMetadata['hips_tile_format']] - List of available tile formats
         * @property {string} [baseUrl =  hipsMetadata['hips_service_url']] - Endpoint service
         * @property {string} [category = Image] - Default category
         * @property {boolean} background - Tell if the layer is set as background
         */

        /**
         * @name AbstractHipsLayer
         * @class
         * Abstract class for HIPS
         * @augments AbstractRasterLayer
         * @param {HipsMetadata} hipsMetadata
         * @param {AbstractHipsLayer.configuration} options - AbstractHipsLayer configuration
         * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
         * @throws ReferenceError - Some required parameters are missing
         * @constructor
         */
        var AbstractHipsLayer = function (hipsMetadata, options) {
            _checkAndSetDefaultOptions.call(this, options);
            this.hipsMetadata = _createMetadata.call(this, hipsMetadata, this.proxify(options.baseUrl));
            _overloadHipsMetataByConfiguration.call(this, options, this.hipsMetadata);

            options.tiling = new HEALPixTiling(options.baseLevel || 2, {coordinateSystem: options.coordinateSystem});
            options.icon = options.hasOwnProperty('icon') ? options.icon : (options.mizarBaseUrl ? options.mizarBaseUrl + "css/images/star.png" : "");
            options.visible = options.hasOwnProperty('visible') ? options.visible : false;
            options.properties = options.hasOwnProperty('properties') ? options.properties : {};
            options.pickable = options.hasOwnProperty('pickable') ? options.pickable : false;
            options.services = options.hasOwnProperty('services') ? options.services : [];

            options.category = options.hasOwnProperty('category') ? options.category : "Image";//this.hipsMetadata.client_category;

            options.availableServices = {};
            if ( this.hipsMetadata.hasOwnProperty("moc_access_url")) {
                options.availableServices.Moc = {
                    serviceURL:  this.hipsMetadata.moc_access_url,
                    skyFraction:  this.hipsMetadata.moc_sky_fraction
                };
            }

            //Hack : set Galactic layer as background because only background owns two grids (equetorial and galactic)
            if (options.coordinateSystem.getGeoideName() === Constants.CRS.Galactic) {
                options.background = true;
            }

            AbstractRasterLayer.prototype.constructor.call(this, Constants.LAYER.Hips, options);

            // TODO : attention au cas où background:true est spécifié directement dans la description du layer
            // dans ce cas, on n'a plus de besoin de passer par setBackgroundLayer. C'est backgroundLayer qui met
            //_overlay à false. _overlay est utilisé dans AbstractRaster
            // De plus, la grille galactique ne peut être utilisée qu'en mode background. Lorsque l'on utilise
            // l'annuaire HIPS, on détecte les couches qui possèdent le CRS galactique et on leur ajoute le
            // background:true
            this._overlay = (!options.background); // a ne pas mettre sinon on ne charge Allsky.jpg
            //AllSky.jpg est téléchargé mais n'est pas affiché
            // La couche IRIS (en mode galactique) ne fonctionne plus. Elle est affichée 1 seconde puis plus aucune image

            //TODO : le fichier allsky
        };

        /**
         * Check options.
         * @param options
         * @throws ReferenceError - Some required parameters are missing
         * @private
         */
        function _checkAndSetDefaultOptions(options) {
            if (!options) {
                throw new ReferenceError("Some required parameters are missing", "AbstractHipsLayer.js");
            } else {
                options.category = options.category || "Image";
                options.pickable = options.pickable || false;
            }
        }

        /**
         * Creates metadata.
         * @param hipsMetadata
         * @param baseUrl
         * @returns {*}
         * @private
         */
        function _createMetadata(hipsMetadata, baseUrl) {
            var metadata = hipsMetadata;
            if (typeof metadata === 'undefined') {
                var hipsProperties = new HipsMetadata(baseUrl);
                metadata = hipsProperties.getHipsMetadata();
            }
            return metadata;
        }

        /**
         *
         * @param options
         * @param hipsMetadata
         * @private
         */
        function _overloadHipsMetataByConfiguration(options, hipsMetadata) {
            options.coordinateSystem = options.hasOwnProperty('coordinateSystem') ? CoordinateSystemFactory.create(options.coordinateSystem) : CoordinateSystemFactory.create({geoideName: Constants.MappingCrsHips2Mizar[hipsMetadata.hips_frame]});
            options.tilePixelSize = options.hasOwnProperty('tilePixelSize') ? options.tilePixelSize : hipsMetadata['hips_tile_width'];
            options.baseLevel = options.hasOwnProperty('baseLevel') ? options.baseLevel : (hipsMetadata.hasOwnProperty('hips_order_min') ? hipsMetadata.hips_order_min : 2);
            options.numberOfLevels = options.hasOwnProperty('numberOfLevels') ? options.numberOfLevels : hipsMetadata['hips_order'];
            options.name = options.hasOwnProperty('name') ? options.name : hipsMetadata['obs_title'];
            options.attribution = options.hasOwnProperty('attribution') ? options.attribution : "<a href=\"" + hipsMetadata['obs_copyright_url'] + "\" target=\"_blank\">" + hipsMetadata['obs_copyright'] + "</a>";
            options.copyrightUrl = options.hasOwnProperty('copyrightUrl') ? options.copyrightUrl : hipsMetadata['obs_copyright_url'];
            options.ack = options.hasOwnProperty('ack') ? options.ack : hipsMetadata['obs_ack'];
            options.description = options.hasOwnProperty('description') ? options.description : hipsMetadata['obs_description'];
            options.format = options.hasOwnProperty('format') ? options.format : hipsMetadata['hips_tile_format'];
            options.baseUrl = options.hasOwnProperty('baseUrl') ? options.baseUrl : hipsMetadata['hips_service_url'];
            options.properties = options.hasOwnProperty('properties') ? options.properties : {};
            if(hipsMetadata.hasOwnProperty("obs_initial_ra")) {
                options.properties.initialRa = parseFloat(hipsMetadata.obs_initial_ra);
            }
            if(hipsMetadata.hasOwnProperty("obs_initial_dec")) {
                options.properties.initialDec = parseFloat(hipsMetadata.obs_initial_dec);
            }
            if(hipsMetadata.hasOwnProperty("obs_initial_fov")) {
                options.properties.initialFov = parseFloat(hipsMetadata.obs_initial_fov);
            }
            if(hipsMetadata.hasOwnProperty("moc_sky_fraction")) {
                options.properties.moc_sky_fraction = parseFloat(hipsMetadata.moc_sky_fraction);
            }
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractRasterLayer, AbstractHipsLayer);

        /**************************************************************************************************************/

        /**
         * Returns the Metadata related to Hips protocol.
         * @return {Object}
         * @memberOf AbstractHipsLayer#
         */
        AbstractHipsLayer.prototype.getHipsMetadata = function () {
            return this.hipsMetadata;
        };

        return AbstractHipsLayer;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Renderer/ColorMap',["../Utils/Numeric"], function (Numeric) {

    /**************************************************************************************************************/
    var transferFonctions = {
        "linear": [],
        "asin": [],
        "sqrt": [],
        "sqr": [],
        "log": []
    };

    var computeTransferFunctions = function () {

        for (var x in transferFonctions) {
            if (transferFonctions.hasOwnProperty(x)) {
                var min = Number.MAX_VALUE;
                var max = Number.MIN_VALUE;
                var v;
                var val = [];
                for (var i = 0; i < 256; i++) {
                    v = i;
                    switch (x) {
                        case "linear":
                            val[i] = v;
                            break;
                        case "asin":
                            val[i] = Math.log(v + Math.sqrt(Math.pow(v, 2) + 1.0));
                            break;
                        case "log":
                            val[i] = Math.log(v / 10.0 + 1);
                            break;
                        case "sqrt":
                            val[i] = Math.sqrt(v / 10.0);
                            break;
                        case "sqr":
                            val[i] = v * v;
                            break;
                        default:
                            break;
                    }

                    if (val[i] < min) {
                        min = val[i];
                    }
                    if (val[i] > max) {
                        max = val[i];
                    }
                }

                // Normalize between [0..256]
                for (i = 0; i < 256; i++) {
                    v = 256 * ((val[i] - min) / (max - min));

                    // Clamp
                    if (v > 256.0) {
                        v = 256.0;
                    } else {
                        if (v < 0.0) {
                            v = 0.0;
                        }
                    }

                    transferFonctions[x][i] = Math.floor(v);
                }
            }
        }
    };

    computeTransferFunctions();

// Contstant colormaps
    var colormaps = {
        // composantes de la table 'Fire' (ImageJ)
        "fire": {
            red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 4, 7,
                10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46, 49, 52, 55, 58, 61, 64, 67, 70, 73, 76, 79,
                82, 85, 88, 91, 94, 98, 101, 104, 107, 110, 113, 116, 119, 122, 125, 128, 131, 134, 137,
                140, 143, 146, 148, 150, 152, 154, 156, 158, 160, 162, 163, 164, 166, 167, 168, 170, 171,
                173, 174, 175, 177, 178, 179, 181, 182, 184, 185, 186, 188, 189, 190, 192, 193, 195, 196,
                198, 199, 201, 202, 204, 205, 207, 208, 209, 210, 212, 213, 214, 215, 217, 218, 220, 221,
                223, 224, 226, 227, 229, 230, 231, 233, 234, 235, 237, 238, 240, 241, 243, 244, 246, 247,
                249, 250, 252, 252, 252, 253, 253, 253, 254, 254, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],

            green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 1, 3, 5, 7, 8, 10, 12, 14, 16, 19, 21, 24, 27, 29, 32, 35, 37, 40, 43, 46, 48,
                51, 54, 57, 59, 62, 65, 68, 70, 73, 76, 79, 81, 84, 87, 90, 92, 95, 98, 101, 103, 105, 107,
                109, 111, 113, 115, 117, 119, 121, 123, 125, 127, 129, 131, 133, 134, 136, 138, 140, 141,
                143, 145, 147, 148, 150, 152, 154, 155, 157, 159, 161, 162, 164, 166, 168, 169, 171, 173,
                175, 176, 178, 180, 182, 184, 186, 188, 190, 191, 193, 195, 197, 199, 201, 203, 205, 206,
                208, 210, 212, 213, 215, 217, 219, 220, 222, 224, 226, 228, 230, 232, 234, 235, 237, 239,
                241, 242, 244, 246, 248, 248, 249, 250, 251, 252, 253, 254, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255],

            blue: [0, 7, 15, 22, 30, 38, 45, 53, 61, 65, 69, 74, 78,
                82, 87, 91, 96, 100, 104, 108, 113, 117, 121, 125, 130, 134, 138, 143, 147, 151, 156, 160,
                165, 168, 171, 175, 178, 181, 185, 188, 192, 195, 199, 202, 206, 209, 213, 216, 220, 220,
                221, 222, 223, 224, 225, 226, 227, 224, 222, 220, 218, 216, 214, 212, 210, 206, 202, 199,
                195, 191, 188, 184, 181, 177, 173, 169, 166, 162, 158, 154, 151, 147, 143, 140, 136, 132,
                129, 125, 122, 118, 114, 111, 107, 103, 100, 96, 93, 89, 85, 82, 78, 74, 71, 67, 64, 60, 56,
                53, 49, 45, 42, 38, 35, 31, 27, 23, 20, 16, 12, 8, 5, 4, 3, 3, 2, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                4, 8, 13, 17, 21, 26, 30, 35, 42, 50, 58, 66, 74, 82, 90, 98, 105, 113, 121, 129, 136, 144,
                152, 160, 167, 175, 183, 191, 199, 207, 215, 223, 227, 231, 235, 239, 243, 247, 251, 255,
                255, 255, 255, 255, 255, 255, 255]
        },

        // composantes de la table EOSB (IDL color table 27)
        "eosb": {
            red: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 18, 27, 36, 45, 49, 57, 72, 81, 91, 100, 109, 118, 127,
                136, 131, 139, 163, 173, 182, 191, 200, 209, 218, 227, 213, 221, 255, 255, 255, 255, 255,
                255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255,
                255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255,
                255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229,
                229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255,
                255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 253, 251, 249, 247,
                245, 243, 241, 215, 214, 235, 234, 232, 230, 228, 226, 224, 222, 198, 196, 216, 215, 213,
                211, 209, 207, 205, 203, 181, 179, 197, 196, 194, 192, 190, 188, 186, 184, 164, 162, 178,
                176, 175, 173, 171, 169, 167, 165, 147, 145, 159, 157, 156, 154, 152, 150, 148, 146, 130,
                128, 140, 138, 137, 135, 133, 131, 129, 127, 113, 111, 121, 119, 117, 117],

            green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 15, 23, 31, 39, 47, 55, 57, 64, 79, 87, 95,
                103, 111, 119, 127, 135, 129, 136, 159, 167, 175, 183, 191, 199, 207, 215, 200, 207, 239,
                247, 255, 255, 255, 255, 255, 255, 229, 229, 255, 255, 255, 255, 255, 255, 255, 255, 229,
                229, 255, 255, 255, 255, 255, 255, 255, 255, 229, 229, 255, 250, 246, 242, 238, 233, 229,
                225, 198, 195, 212, 208, 204, 199, 195, 191, 187, 182, 160, 156, 169, 165, 161, 157, 153,
                148, 144, 140, 122, 118, 127, 125, 123, 121, 119, 116, 114, 112, 99, 97, 106, 104, 102,
                99, 97, 95, 93, 91, 80, 78, 84, 82, 80, 78, 76, 74, 72, 70, 61, 59, 63, 61, 59, 57, 55, 53, 50,
                48, 42, 40, 42, 40, 38, 36, 33, 31, 29, 27, 22, 21, 21, 19, 16, 14, 12, 13, 8, 6, 3, 1, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],

            blue: [116, 121, 127, 131, 136, 140, 144, 148, 153,
                157, 145, 149, 170, 174, 178, 182, 187, 191, 195, 199, 183, 187, 212, 216, 221, 225, 229,
                233, 238, 242, 221, 225, 255, 247, 239, 231, 223, 215, 207, 199, 172, 164, 175, 167, 159,
                151, 143, 135, 127, 119, 100, 93, 95, 87, 79, 71, 63, 55, 47, 39, 28, 21, 15, 7, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0]
        },

        // tableau des composantes pour Stern
        "stern": {
            red: [0, 18, 36, 54, 72, 90, 108, 127, 145, 163, 199, 217, 235,
                254, 249, 244, 239, 234, 229, 223, 218, 213, 208, 203, 197, 192, 187, 182, 177, 172,
                161, 156, 151, 146, 140, 135, 130, 125, 120, 115, 109, 104, 99, 94, 89, 83, 78, 73, 68,
                63, 52, 47, 42, 37, 32, 26, 21, 16, 11, 6, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 75, 76,
                77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 96, 97, 98, 99, 100,
                101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 117, 118,
                119, 120, 121, 122, 123, 124, 125, 126, 128, 129, 130, 131, 132, 133, 134, 135, 136,
                137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154,
                155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172,
                173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190,
                192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203, 204, 205, 206, 207, 208, 209,
                210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 224, 225, 226, 227,
                228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 245,
                246, 247, 248, 249, 250, 251, 252, 253, 254],

            green: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18,
                19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67,
                68, 69, 70, 71, 72, 73, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
                92, 93, 94, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
                112, 113, 114, 115, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 128, 129, 130,
                131, 132, 133, 134, 135, 136, 137, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
                149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 160, 161, 162, 163, 164, 165, 166,
                167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 181, 182, 183, 184,
                185, 186, 187, 188, 189, 190, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 203,
                204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
                239, 240, 241, 242, 243, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254],

            blue: [0, 1, 3, 5, 7, 9, 11, 13, 15, 17, 21, 23, 25, 27, 29, 31, 33,
                35, 37, 39, 41, 43, 45, 47, 49, 51, 53, 55, 57, 59, 63, 65, 67, 69, 71, 73, 75, 77, 79, 81,
                83, 85, 87, 89, 91, 93, 95, 97, 99, 101, 105, 107, 109, 111, 113, 115, 117, 119, 121,
                123, 127, 129, 131, 133, 135, 137, 139, 141, 143, 145, 149, 151, 153, 155, 157, 159,
                161, 163, 165, 167, 169, 171, 173, 175, 177, 179, 181, 183, 185, 187, 191, 193, 195,
                197, 199, 201, 203, 205, 207, 209, 211, 213, 215, 217, 219, 221, 223, 225, 227, 229,
                233, 235, 237, 239, 241, 243, 245, 247, 249, 251, 255, 251, 247, 243, 238, 234, 230,
                226, 221, 217, 209, 204, 200, 196, 192, 187, 183, 179, 175, 170, 166, 162, 158, 153,
                149, 145, 141, 136, 132, 128, 119, 115, 111, 107, 102, 98, 94, 90, 85, 81, 77, 73, 68,
                64, 60, 56, 51, 47, 43, 39, 30, 26, 22, 17, 13, 9, 5, 0, 3, 7, 15, 19, 22, 26, 30, 34, 38, 41,
                45, 49, 57, 60, 64, 68, 72, 76, 79, 83, 87, 91, 95, 98, 102, 106, 110, 114, 117, 121, 125,
                129, 137, 140, 144, 148, 152, 156, 159, 163, 167, 171, 175, 178, 182, 186, 190, 194,
                197, 201, 205, 209, 216, 220, 224, 228, 232, 235, 239, 243, 247, 251]
        },

        // composantes de la table rainbow (IDL color table 13)
        "rainbow": {
            red: [0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 45, 50, 54,
                58, 61, 64, 68, 69, 72, 74, 77, 79, 80, 82, 83, 85, 84, 86, 87, 88, 86, 87, 87, 87, 85, 84, 84,
                84, 83, 79, 78, 77, 76, 71, 70, 68, 66, 60, 58, 55, 53, 46, 43, 40, 36, 33, 25, 21, 16, 12, 4, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 21, 25, 29, 33, 42,
                46, 51, 55, 63, 67, 72, 76, 80, 89, 93, 97, 101, 110, 114, 119, 123, 131, 135, 140, 144, 153,
                157, 161, 165, 169, 178, 182, 187, 191, 199, 203, 208, 212, 221, 225, 229, 233, 242, 246,
                250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255],
            green: [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 16, 21, 25, 29, 38, 42, 46, 51, 55, 63, 67, 72, 76, 84, 89, 93, 97,
                106, 110, 114, 119, 127, 131, 135, 140, 144, 152, 157, 161, 165, 174, 178, 182, 187, 195,
                199, 203, 208, 216, 220, 225, 229, 233, 242, 246, 250, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 250, 242, 238, 233, 229, 221, 216, 212, 208, 199, 195, 191, 187, 178, 174, 170, 165,
                161, 153, 148, 144, 140, 131, 127, 123, 119, 110, 106, 102, 97, 89, 85, 80, 76, 72, 63, 59,
                55, 51, 42, 38, 34, 29, 21, 17, 12, 8, 0],
            blue: [0, 3, 7, 10, 14, 19, 23, 28, 32, 38, 43, 48, 53,
                59, 63, 68, 72, 77, 81, 86, 91, 95, 100, 104, 109, 113, 118, 122, 127, 132, 136, 141, 145,
                150, 154, 159, 163, 168, 173, 177, 182, 186, 191, 195, 200, 204, 209, 214, 218, 223, 227,
                232, 236, 241, 245, 250, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
                255, 255, 255, 255, 255, 255, 246, 242, 238, 233, 225, 220, 216, 212, 203, 199, 195, 191,
                187, 178, 174, 170, 165, 157, 152, 148, 144, 135, 131, 127, 123, 114, 110, 106, 102, 97,
                89, 84, 80, 76, 67, 63, 59, 55, 46, 42, 38, 34, 25, 21, 16, 12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        },

        // Simple grey levels
        "grey": {
            red: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
                92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
                112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
                131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
                149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166,
                167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
                185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
                204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
                239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
            green: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
                92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
                112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
                131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
                149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166,
                167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
                185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
                204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
                239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255],
            blue: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
                19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
                68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91,
                92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
                112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,
                131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,
                149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166,
                167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184,
                185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203,
                204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220,
                221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238,
                239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255]
        }
    };

    /**
     *    Create texture from array
     *    TODO : maybe move this function to renderContext ?
     *
     *    @param gl Context
     *    @param dataArray Array creating the texture
     *    @param format Content format(gl.LUMINANCE, gl.RGB...)
     *    @param dataType Type of data(gl.UNSIGNED_BYTE or gl.FLOAT)
     *    @param width Width of texture
     *    @param height Height of texture
     *
     *    @return GLTexture, or null caused by not supported format
     */
    function _textureFromPixelArray(gl, dataArray, format, dataType, width, height) {
        var dataTypedArray;
        if (dataType === gl.UNSIGNED_BYTE) {
            dataTypedArray = new Uint8Array(dataArray);
        } else {
            if (dataType === gl.FLOAT) {
                dataTypedArray = new Float32Array(dataArray);
            } else {
                return null;
            }
        }

        var texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, 0, format, dataType, dataTypedArray);

        // NPOT properties
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);

        return texture;
    }

    return {
        /**
         *    Create custom colormap with equidistant intervals
         *
         *    @param name Colormap name
         *    @param colors The array of colors defining the colormap(must have length at least >=2)
         */
        addCustomColormap: function (name, colors) {
            if (colors.length < 2) {
                console.error("Colors length must be >= 2");
                return null;
            }

            var colormapSize = 256;
            var colormap = {
                red: [],
                green: [],
                blue: []
            };

            var nbIntervals = colors.length - 1;
            for (var i = 0; i < nbIntervals; i++) {
                var c1 = colors[i];
                var c2 = colors[i + 1];

                var intervalLength = colormapSize / (colors.length - 1);
                var start = colormap.red.length;
                var end = Math.floor((i + 1) * intervalLength);
                for (var j = start; j < end; j++) {
                    colormap.red.push(Numeric.lerp(j / end, c1[0], c2[0]));
                    colormap.green.push(Numeric.lerp(j / end, c1[1], c2[1]));
                    colormap.blue.push(Numeric.lerp(j / end, c1[2], c2[2]));
                }
            }

            // Add to colormaps object
            colormaps[name] = colormap;
        },

        /**
         * Generate colormap
         */
        generateColormap: function (gl, transferFonction, colormap, inverse) {
            // var pas1 = 128./(tr1-tr0);
            // var pas2 = 128./(tr2-tr1);

            // Get transfer function
            var fctGap = transferFonctions[transferFonction];

            var cm = [];

            var Sr, Sg, Sb;
            Sr = colormaps[colormap].red;
            Sg = colormaps[colormap].green;
            Sb = colormaps[colormap].blue;
            var max = Sr.length - 1;
            for (var i = 0; i < 256; i++) {
                // int j= i<tr0 ? 0 :
                //       i<tr1 ? (int)Math.round((i-tr0)*pas1) :
                //       i<tr2 ? 128+(int)Math.round((i-tr1)*pas2) :
                //               max;

                var j = fctGap[i];

                // Clamp
                if (j > max) {
                    j = max;
                } else {
                    if (j < 0) {
                        j = 0;
                    }
                }
                if (inverse) {
                    j = max - j;
                }

                // Normalize between [0..1]
                cm[i * 3] = Sr[j] / 256.0;
                cm[i * 3 + 1] = Sg[j] / 256.0;
                cm[i * 3 + 2] = Sb[j] / 256.0;
            }

            // Create new texture
            return _textureFromPixelArray(gl, cm, gl.RGB, gl.FLOAT, cm.length / 3, 1);
        }

    };

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/DynamicImage',['./ColorMap'], function(ColorMap) {

/**************************************************************************************************************/

// TODO : Unify shader programs between TileManager, ConvexPolygonRenderer and ImageRenderer
//		* inverse Y coordinates(if needed)
//		* vTextureCoord name refactor
var defaultFragmentCode = "precision highp float; \n";
defaultFragmentCode +=    "varying vec2 vTextureCoord;\n";
defaultFragmentCode +=    "uniform sampler2D texture; \n";
defaultFragmentCode +=    "uniform sampler2D colormap; \n";
defaultFragmentCode +=    "uniform float min; \n";
defaultFragmentCode +=    "uniform float max; \n";
defaultFragmentCode +=    "uniform vec4 color; \n";
defaultFragmentCode +=    "void main(void)\n";
defaultFragmentCode +=    "{\n";
defaultFragmentCode +=    "	float i = texture2D(texture,vTextureCoord).r;\n";
defaultFragmentCode +=    "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
defaultFragmentCode +=    "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
defaultFragmentCode +=    "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b,color.a);\n";
defaultFragmentCode +=    "}\n";

var defaultCallback = function(gl, renderable, program)
{
	if ( !program ) {
		program = renderable.polygonProgram;
	}
	gl.uniform1f(program.uniforms.max, renderable.style.uniformValues.tmax );
	gl.uniform1f(program.uniforms.min, renderable.style.uniformValues.tmin );

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, renderable.style.uniformValues.colormapTex);
	gl.uniform1i(program.uniforms.colormap, 1);
};

/**************************************************************************************************************/

 /**
	 @name DynamicImage
	 @class
		DynamicImage constructor
	 @param renderContext
	 @param pixels
	 @param format
	 @param dataType
	 @param width
	 @param height
	 @param options
	 @constructor
	 */
var DynamicImage = function(renderContext, pixels, format, dataType, width, height, options)
{
	// Initialize fragment shader and uniformsCallback if needed
	defaultFragmentCode = (options && options.fragmentCode) ? options.fragmentCode : defaultFragmentCode;
	defaultCallback = (options && options.updateUniforms) ? options.updateUniforms : defaultCallback;

	this.fragmentCode = defaultFragmentCode;
	this.updateUniforms = defaultCallback;
	this.tmin = 0.0;
	this.tmax = 1.0;
	this.colormapTex = null;
	this.renderContext = renderContext;

	// Parameters for histogram generation
	this.pixels = pixels;
	this.transferFn = "raw";
	this.inverse = false;

	// Create texture
	var gl = renderContext.gl;
	var tex = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, tex);
    // TODO : Flip around X axis
    //gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
	gl.texImage2D(
		gl.TEXTURE_2D, 0,
		format, width, height, 0,
		format, dataType, pixels);


	if ( dataType === gl.FLOAT )
	{
		// Choose floating point texture filtering depending on extension support
		var float_linear_ext = gl.getExtension("OES_texture_float_linear");
		var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
	}
	else
	{
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	}

    // NPOT properties
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

	this.texture = tex;
	this.width = width;
	this.height = height;

	this.computeMinMax(pixels);
	renderContext.requestFrame();
};

/**************************************************************************************************************/

/**
 * Compute min/max of fits data
 * @function computeMinMax
 * @memberof DynamicImage.prototype
 * @param pixels Fits data
 */
DynamicImage.prototype.computeMinMax = function(pixels)
{
	var max = Number.MIN_VALUE;
	var min = Number.MAX_VALUE;
	for ( var i=1; i<pixels.length; i++ )
	{
		var val = pixels[i];
		if ( isNaN(val) ) {
			continue;
		}
		if ( max < val ) {
			max = val;
		}
		if ( min > val ) {
			min = val;
		}
	}
	this.min = min;
	this.max = max;
	this.tmax = max;
	this.tmin = min;
};

/**************************************************************************************************************/

/**
 * Update colormap of current image
 * @function updateColormap
 * @memberof DynamicImage.prototype
 * @param transferFn Transfer function("linear", "log", "sqrt", "pow2", "asin")
 * @param colormap Colormap("grey", "rainbow", "fire", "stern", "eosb")
 * @param inverse Boolean indicating if colormap is inversed
 */
DynamicImage.prototype.updateColormap = function(transferFn, colormap, inverse)
{
	var gl = this.renderContext.gl;
	if ( transferFn !== "raw" )
	{
		this.fragmentCode = defaultFragmentCode;
		this.updateUniforms = defaultCallback;
		// Dispose current texture
		if ( this.colormapTex ) {
	    	gl.deleteTexture( this.colormapTex );
		}

		this.colormapTex = ColorMap.generateColormap(gl, transferFn, colormap, inverse);
	}
	else
	{
		this.fragmentCode = null;
		this.updateUniforms = null;
	}
	this.transferFn = transferFn;
	this.inverse = inverse;
};

/**************************************************************************************************************/

/**
 * Dispose textures
 * @function dispose
 * @memberof DynamicImage.prototype
 */
DynamicImage.prototype.dispose = function()
{
	var gl = this.renderContext.gl;
	if ( this.colormapTex ) {
		gl.deleteTexture( this.colormapTex );
	}
	if ( this.texture ) {
		gl.deleteTexture( this.texture );
	}

	this.colormapTex = null;
	this.texture = null;
};

/**************************************************************************************************************/

return DynamicImage;

});

// Generated by CoffeeScript 1.4.0
(function() {
  var BinaryTable, CompressedImage, DataUnit, Decompress, FITS, File, HDU, Header, HeaderVerify, Image, ImageUtils, Module, Table, Tabular, moduleKeywords,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  if (this.astro == null) {
    this.astro = {};
  }

  FITS = {};

  FITS.version = '0.2.3';

  this.astro.FITS = FITS;

  moduleKeywords = ['included', 'extended'];

  Module = (function() {

    function Module() {}

    Module.include = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'include(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this.prototype[key] = value;
        }
      }
      if ((_ref = obj.included) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.extend = function(obj) {
      var key, value, _ref;
      if (!obj) {
        throw 'extend(obj) requires obj';
      }
      for (key in obj) {
        value = obj[key];
        if (__indexOf.call(moduleKeywords, key) < 0) {
          this[key] = value;
        }
      }
      if ((_ref = obj.extended) != null) {
        _ref.apply(this);
      }
      return this;
    };

    Module.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    Module.prototype.proxy = function(func) {
      var _this = this;
      return function() {
        return func.apply(_this, arguments);
      };
    };

    return Module;

  })();

  this.astro.FITS.Module = Module;

  DataUnit = (function(_super) {

    __extends(DataUnit, _super);

    function DataUnit(view, header) {
      this.view = view;
      this.begin = this.current = view.tell();
      this.length = void 0;
    }

    return DataUnit;

  })(Module);

  this.astro.FITS.DataUnit = DataUnit;

  HeaderVerify = {
    verifyOrder: function(keyword, order) {
      if (order !== this.cardIndex) {
        return console.warn("" + keyword + " should appear at index " + this.cardIndex + " in the FITS header");
      }
    },
    verifyBetween: function(keyword, value, lower, upper) {
      if (!(value >= lower && value <= upper)) {
        throw "The " + keyword + " value of " + value + " is not between " + lower + " and " + upper;
      }
    },
    verifyBoolean: function(value) {
      if (value === "T") {
        return true;
      } else {
        return false;
      }
    },
    Functions: {
      SIMPLE: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.primary = true;
        this.verifyOrder("SIMPLE", 0);
        return this.verifyBoolean(value);
      },
      XTENSION: function() {
        var args, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        value = arguments[0];
        this.extension = true;
        this.extensionType = value;
        this.verifyOrder("XTENSION", 0);
        return value;
      },
      BITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BITPIX";
        value = parseInt(arguments[0]);
        this.verifyOrder(key, 1);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      NAXIS: function() {
        var args, array, key, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "NAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        if (!array) {
          this.verifyOrder(key, 2);
          this.verifyBetween(key, value, 0, 999);
          if (this.isExtension()) {
            if ((_ref = this.extensionType) === "TABLE" || _ref === "BINTABLE") {
              required = 2;
              if (value !== required) {
                throw "" + key + " must be " + required + " for TABLE and BINTABLE extensions";
              }
            }
          }
        }
        return value;
      },
      PCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "PCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"];
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE") {
            required = 0;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      GCOUNT: function() {
        var args, key, order, required, value, _ref;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "GCOUNT";
        value = parseInt(arguments[0]);
        order = 1 + 1 + 1 + this["NAXIS"] + 1;
        this.verifyOrder(key, order);
        if (this.isExtension()) {
          if ((_ref = this.extensionType) === "IMAGE" || _ref === "TABLE" || _ref === "BINTABLE") {
            required = 1;
            if (value !== required) {
              throw "" + key + " must be " + required + " for the " + this.extensionType + " extensions";
            }
          }
        }
        return value;
      },
      EXTEND: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTEND";
        value = arguments[0];
        if (!this.isPrimary()) {
          throw "" + key + " must only appear in the primary header";
        }
        return this.verifyBoolean(value);
      },
      BSCALE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BZERO: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      BLANK: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "BLANK";
        value = arguments[0];
        // if (!(this["BITPIX"] > 0)) {
        //   throw "" + key + " is not to be used for BITPIX = " + this['BITPIX'];
        // }
        return parseInt(value);
      },
      DATAMIN: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      DATAMAX: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return parseFloat(arguments[0]);
      },
      EXTVER: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTVER";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      EXTLEVEL: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "EXTLEVEL";
        value = arguments[0];
        value = parseInt(value);
        return value;
      },
      TFIELDS: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TFIELDS";
        value = arguments[0];
        value = parseInt(value);
        this.verifyBetween(key, value, 0, 999);
        return value;
      },
      TBCOL: function() {
        var args, index, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "TBCOL";
        value = arguments[0];
        index = arguments[2];
        this.verifyBetween(key, index, 0, this["TFIELDS"]);
        return value;
      },
      ZIMAGE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZIMAGE";
        value = arguments[0];
        return this.verifyBoolean(value);
      },
      ZCMPTYPE: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZCMPTYPE";
        value = arguments[0];
        if (value !== 'GZIP_1' && value !== 'RICE_1' && value !== 'PLIO_1' && value !== 'HCOMPRESS_1') {
          throw "" + key + " value " + value + " is not permitted";
        }
        if (value !== 'RICE_1' && value !== 'GZIP_1') {
          throw "Compress type " + value + " is not yet implement";
        }
        return value;
      },
      ZBITPIX: function() {
        var args, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZBITPIX";
        value = parseInt(arguments[0]);
        if (value !== 8 && value !== 16 && value !== 32 && value !== 64 && value !== (-32) && value !== (-64)) {
          throw "" + key + " value " + value + " is not permitted";
        }
        return value;
      },
      ZNAXIS: function() {
        var args, array, key, value;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZNAXIS";
        value = parseInt(arguments[0]);
        array = arguments[1];
        value = value;
        if (!array) {
          this.verifyBetween(key, value, 0, 999);
        }
        return value;
      },
      ZTILE: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZTILE";
        return parseInt(arguments[0]);
      },
      ZSIMPLE: function() {
        var args;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if (arguments[0] === "T") {
          return true;
        } else {
          return false;
        }
      },
      ZPCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZPCOUNT";
        return parseInt(arguments[0]);
      },
      ZGCOUNT: function() {
        var args, key;
        args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        key = "ZGCOUNT";
        return parseInt(arguments[0]);
      }
    }
  };

  this.astro.FITS.HeaderVerify = HeaderVerify;

  Header = (function(_super) {

    __extends(Header, _super);

    Header.keywordPattern = /^([A-Z0-9_-]+)\s*=\s*(.*)/;

    Header.nonStringPattern = /([^\/]*)\s*\/*(.*)/;

    Header.stringPattern = /'(.*)'\s*\/*(.*)/;

    Header.arrayPattern = /([A-Za-z]+)(\d+)/;

    Header.include(HeaderVerify);

    function Header() {
      this.init = __bind(this.init, this);

      var method, name, _ref;
      this.primary = false;
      this.extension = false;
      this.verifyCard = {};
      _ref = this.Functions;
      for (name in _ref) {
        method = _ref[name];
        this.verifyCard[name] = this.proxy(method);
      }
      this.cards = {};
      this.cardIndex = 0;
    }

    Header.prototype.get = function(key) {
      if (this.contains(key)) {
        return this.cards[key];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getIndex = function(key) {
      if (this.contains(key)) {
        return this.cards[key][0];
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComment = function(key) {
      if (this.contains(key)) {
        if (this.cards[key][2] != null) {
          return this.cards[key][2];
        } else {
          return console.warn("" + key + " does not contain a comment");
        }
      } else {
        return console.warn("Header does not contain the key " + key);
      }
    };

    Header.prototype.getComments = function() {
      if (this.contains('COMMENT')) {
        return this.cards['COMMENT'];
      } else {
        return console.warn("Header does not contain any COMMENT fields");
      }
    };

    Header.prototype.getHistory = function() {
      if (this.contains('HISTORY')) {
        return this.cards['HISTORY'];
      } else {
        return console.warn("Header does not contain any HISTORY fields");
      }
    };

    Header.prototype.set = function(key, value, comment) {
      this.cards[key] = comment ? [this.cardIndex, value, comment] : [this.cardIndex, value];
      return this.cardIndex += 1;
    };

    Header.prototype.setComment = function(comment) {
      if (!this.contains("COMMENT")) {
        this.cards["COMMENT"] = [];
        this.cardIndex += 1;
      }
      return this.cards["COMMENT"].push(comment);
    };

    Header.prototype.setHistory = function(history) {
      if (!this.contains("HISTORY")) {
        this.cards["HISTORY"] = [];
        this.cardIndex += 1;
      }
      return this.cards["HISTORY"].push(history);
    };

    Header.prototype.contains = function(keyword) {
      return this.cards.hasOwnProperty(keyword);
    };

    Header.prototype.readCard = function(line) {
      var array, comment, index, key, keyToVerify, match, value, _ref, _ref1, _ref2, _ref3, _ref4;
      match = line.match(Header.keywordPattern);
      if (match == null) {
        return;
      }
      _ref = match.slice(1), key = _ref[0], value = _ref[1];
      if (key === "COMMENT" || key === "HISTORY") {
        match[1] = value.trim();
      } else if (value[0] === "'") {
        match = value.match(Header.stringPattern);
        match[1] = match[1].trim();
      } else {
        match = value.match(Header.nonStringPattern);
        match[1] = (_ref1 = match[1][0]) === "T" || _ref1 === "F" ? match[1].trim() : parseFloat(match[1]);
      }
      match[2] = match[2].trim();
      _ref2 = match.slice(1), value = _ref2[0], comment = _ref2[1];
      keyToVerify = key;
      _ref3 = [false, void 0], array = _ref3[0], index = _ref3[1];
      match = key.match(Header.arrayPattern);
      if (match != null) {
        keyToVerify = match[1];
        _ref4 = [true, match[2]], array = _ref4[0], index = _ref4[1];
      }
      if (this.verifyCard.hasOwnProperty(keyToVerify)) {
        value = this.verifyCard[keyToVerify](value, array, index);
      }
      switch (key) {
        case "COMMENT":
          return this.setComment(value);
        case "HISTORY":
          return this.setHistory(value);
        default:
          this.set(key, value, comment);
          return this.__defineGetter__(key, function() {
            return this.cards[key][1];
          });
      }
    };

    Header.prototype.init = function(block) {
      var i, line, lineWidth, maxNumLines, numLines, _i, _ref, _results;
      lineWidth = 80;
      numLines = block.length / lineWidth;
      maxNumLines = 600;
      numLines = numLines < maxNumLines ? numLines : maxNumLines;
      _results = [];
      for (i = _i = 0, _ref = numLines - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        line = block.slice(i * lineWidth, (i + 1) * lineWidth);
        _results.push(this.readCard(line));
      }
      return _results;
    };

    Header.prototype.hasDataUnit = function() {
      if (this["NAXIS"] === 0) {
        return false;
      } else {
        return true;
      }
    };

    Header.prototype.isPrimary = function() {
      return this.primary;
    };

    Header.prototype.isExtension = function() {
      return this.extension;
    };

    return Header;

  })(Module);

  this.astro.FITS.Header = Header;

  ImageUtils = {
    initArray: function(arrayType) {
      return this.data = new arrayType(this.width * this.height);
    },
    getExtremes: function() {
      var index, max, min, value, _ref, _ref1;
      if ((this.min != null) && (this.max != null)) {
        return [this.min, this.max];
      }
      index = this.data.length;
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        _ref = [value, value], min = _ref[0], max = _ref[1];
        break;
      }
      while (index--) {
        value = this.data[index];
        if (isNaN(value)) {
          continue;
        }
        if (value < min) {
          min = value;
        }
        if (value > max) {
          max = value;
        }
      }
      _ref1 = [min, max], this.min = _ref1[0], this.max = _ref1[1];
      return [this.min, this.max];
    },
    getPixel: function(x, y) {
      return this.data[y * this.width + x];
    }
  };

  this.astro.FITS.ImageUtils = ImageUtils;

  Image = (function(_super) {

    __extends(Image, _super);

    Image.include(ImageUtils);

    function Image(view, header) {
      var bitpix, i, naxis, _i,
        _this = this;
      Image.__super__.constructor.apply(this, arguments);
      naxis = header["NAXIS"];
      bitpix = header["BITPIX"];
      this.naxis = [];
      for (i = _i = 1; 1 <= naxis ? _i <= naxis : _i >= naxis; i = 1 <= naxis ? ++_i : --_i) {
        this.naxis.push(header["NAXIS" + i]);
      }
      this.width = header["NAXIS1"];
      this.height = header["NAXIS2"] || 1;
      this.bzero = header["BZERO"] || 0;
      this.bscale = header["BSCALE"] || 1;
      this.rowByteSize = this.width * Math.abs(bitpix) / 8;
      this.totalRowsRead = 0;
      this.length = this.naxis.reduce(function(a, b) {
        return a * b;
      }) * Math.abs(bitpix) / 8;
      this.data = void 0;
      this.frame = 0;
      switch (bitpix) {
        case 8:
          if (this.bscale % 1 === 0) {
            this.arrayType = Uint8Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint8();
            };
          }
          break;
        case 16:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int16Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getInt16();
            };
          }
          break;
        case 32:
          if (this.bscale % 1 === 0) {
            this.arrayType = Int32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          } else {
            this.arrayType = Float32Array;
            this.accessor = function() {
              return _this.bzero + _this.bscale * _this.view.getUint32();
            };
          }
          break;
        case 64:
          this.arrayType = this.bscale % 1 === 0 ? Int32Array : Float32Array;
          console.warn("Unusual behaviour with 64 bit integers.");
          this.accessor = function() {
            var factor, highByte, lowByte, mod, value;
            highByte = Math.abs(_this.view.getInt32());
            lowByte = Math.abs(_this.view.getInt32());
            mod = highByte % 10;
            factor = mod ? -1 : 1;
            highByte -= mod;
            value = factor * ((highByte << 32) | lowByte);
            return _this.bzero + _this.bscale * value;
          };
          break;
        case -32:
          this.arrayType = Float32Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat32();
          };
          break;
        case -64:
          this.arrayType = Float64Array;
          this.accessor = function() {
            return _this.bzero + _this.bscale * _this.view.getFloat64();
          };
          break;
        default:
          throw "Invalid BITPIX.";
      }
    }

    Image.prototype.getRow = function() {
      var i, _i, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      for (i = _i = 0, _ref = this.width - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        this.data[this.width * this.rowsRead + i] = this.accessor();
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    Image.prototype.getFrame = function(frame) {
      var height;
      this.frame = frame != null ? frame : this.frame;
      if (this.data == null) {
        this.initArray(this.arrayType);
      }
      this.totalRowsRead = this.width * this.frame;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      this.frame += 1;
      return this.data;
    };

    Image.prototype.seek = function(frame) {
      if (frame == null) {
        frame = 0;
      }
      if (this.naxis.length === 2) {
        this.totalRowsRead = 0;
        return this.frame = 0;
      } else {
        this.totalRowsRead = this.height * frame;
        return this.frame = this.height / this.totalRowsRead - 1;
      }
    };

    Image.prototype.isDataCube = function() {
      if (this.naxis.length > 2) {
        return true;
      } else {
        return false;
      }
    };

    return Image;

  })(DataUnit);

  this.astro.FITS.Image = Image;

  Tabular = (function(_super) {

    __extends(Tabular, _super);

    Tabular.dataAccessors = {
      L: function(view) {
        if (view.getInt8() === 84) {
          return true;
        } else {
          return false;
        }
      },
      X: function(view) {
        throw "Data type not yet implemented";
      },
      B: function(view) {
        return view.getUint8();
      },
      I: function(view) {
        return view.getInt16();
      },
      J: function(view) {
        return view.getInt32();
      },
      K: function(view) {
        var factor, highByte, lowByte, mod, value;
        highByte = Math.abs(view.getInt32());
        lowByte = Math.abs(view.getInt32());
        mod = highByte % 10;
        factor = mod ? -1 : 1;
        highByte -= mod;
        value = factor * ((highByte << 32) | lowByte);
        console.warn("Something funky happens here when dealing with 64 bit integers.  Be wary!!!");
        return value;
      },
      A: function(view) {
        return view.getChar();
      },
      E: function(view) {
        return view.getFloat32();
      },
      D: function(view) {
        return view.getFloat64();
      },
      C: function(view) {
        return [view.getFloat32(), view.getFloat32()];
      },
      M: function(view) {
        return [view.getFloat64(), view.getFloat64()];
      }
    };

    function Tabular(view, header) {
      this.getRow = __bind(this.getRow, this);
      Tabular.__super__.constructor.apply(this, arguments);
      this.rowByteSize = header["NAXIS1"];
      this.rows = header["NAXIS2"];
      this.cols = header["TFIELDS"];
      this.length = this.tableLength = this.rowByteSize * this.rows;
      this.rowsRead = 0;
      this.columns = this.getColumnNames(header);
      this.accessors = [];
    }

    Tabular.prototype.getRow = function(row) {
      var accessor, index, _i, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = {};
      _ref = this.accessors;
      for (index = _i = 0, _len = _ref.length; _i < _len; index = ++_i) {
        accessor = _ref[index];
        row[this.columns[index]] = accessor();
      }
      this.rowsRead += 1;
      return row;
    };

    Tabular.prototype.getColumnNames = function(header) {
      var columnNames, i, key, _i, _ref;
      columnNames = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        key = "TTYPE" + i;
        if (!header.contains(key)) {
          return null;
        }
        columnNames.push(header[key]);
      }
      return columnNames;
    };

    return Tabular;

  })(DataUnit);

  this.astro.FITS.Tabular = Tabular;

  Table = (function(_super) {

    __extends(Table, _super);

    Table.formPattern = /([AIFED])(\d+)\.*(\d+)*/;

    Table.dataAccessors = {
      A: function(value) {
        return value.trim();
      },
      I: function(value) {
        return parseInt(value);
      },
      F: function(value) {
        return parseFloat(value);
      },
      E: function(value) {
        return parseFloat(value);
      },
      D: function(value) {
        return parseFloat(value);
      }
    };

    function Table(view, header) {
      this.getRow = __bind(this.getRow, this);

      var form, i, match, _fn, _i, _ref,
        _this = this;
      Table.__super__.constructor.apply(this, arguments);
      _fn = function() {
        var accessor, dataType, decimals, length, _ref1;
        _ref1 = match.slice(1), dataType = _ref1[0], length = _ref1[1], decimals = _ref1[2];
        accessor = function(value) {
          return Table.dataAccessors[dataType](value);
        };
        return _this.accessors.push(accessor);
      };
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        form = header["TFORM" + i];
        match = form.match(Table.formPattern);
        _fn();
      }
    }

    Table.prototype.getRow = function(row) {
      var i, index, line, value, _i, _j, _len, _ref;
      if (row == null) {
        row = null;
      }
      if (row != null) {
        this.rowsRead = row;
      }
      this.current = this.begin + this.rowsRead * this.rowByteSize;
      this.view.seek(this.current);
      line = "";
      for (i = _i = 1, _ref = this.rowByteSize; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        line += this.view.getChar();
      }
      line = line.trim().split(/\s+/);
      row = {};
      for (index = _j = 0, _len = line.length; _j < _len; index = ++_j) {
        value = line[index];
        row[this.columns[index]] = this.accessors[index](value);
      }
      this.rowsRead += 1;
      return row;
    };

    return Table;

  })(Tabular);

  this.astro.FITS.Table = Table;

  BinaryTable = (function(_super) {

    __extends(BinaryTable, _super);

    BinaryTable.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    BinaryTable.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    function BinaryTable(view, header) {
      var dataType, i, keyword, length, match, value, _i, _ref, _ref1,
        _this = this;
      BinaryTable.__super__.constructor.apply(this, arguments);
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        keyword = "TFORM" + i;
        value = header[keyword];
        match = value.match(BinaryTable.arrayDescriptorPattern);
        if (match != null) {
          (function() {
            var accessor, dataType;
            dataType = match[1];
            accessor = function() {
              var data, length, offset, _j;
              length = _this.view.getInt32();
              offset = _this.view.getInt32();
              _this.current = _this.view.tell();
              _this.view.seek(_this.begin + _this.tableLength + offset);
              data = [];
              for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                data.push(BinaryTable.dataAccessors[dataType](_this.view));
              }
              _this.view.seek(_this.current);
              return data;
            };
            return _this.accessors.push(accessor);
          })();
        } else {
          match = value.match(BinaryTable.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              var accessor;
              accessor = function() {
                var data;
                data = BinaryTable.dataAccessors[dataType](_this.view);
                return data;
              };
              return _this.accessors.push(accessor);
            })(dataType);
          } else {
            (function(dataType, length) {
              var accessor, numBytes;
              if (dataType === 'X') {
                numBytes = Math.log(length) / Math.log(2);
                accessor = function() {
                  var bit, bitarray, byte, byte2bits, data, _j, _k, _len;
                  byte2bits = function(byte) {
                    var bitarray;
                    bitarray = [];
                    i = 128;
                    while (i >= 1) {
                      bitarray.push((byte & i ? 1 : 0));
                      i /= 2;
                    }
                    return bitarray;
                  };
                  data = [];
                  for (i = _j = 1; 1 <= numBytes ? _j <= numBytes : _j >= numBytes; i = 1 <= numBytes ? ++_j : --_j) {
                    byte = _this.view.getUint8();
                    bitarray = byte2bits(byte);
                    for (_k = 0, _len = bitarray.length; _k < _len; _k++) {
                      bit = bitarray[_k];
                      data.push(bit);
                    }
                  }
                  return data.slice(0, +(length - 1) + 1 || 9e9);
                };
              } else if (dataType === 'A') {
                accessor = function() {
                  var data, _j;
                  data = '';
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data += BinaryTable.dataAccessors[dataType](_this.view);
                  }
                  return data.trim();
                };
              } else {
                accessor = function() {
                  var data, _j;
                  data = [];
                  for (i = _j = 1; 1 <= length ? _j <= length : _j >= length; i = 1 <= length ? ++_j : --_j) {
                    data.push(BinaryTable.dataAccessors[dataType](_this.view));
                  }
                  return data;
                };
              }
              return _this.accessors.push(accessor);
            })(dataType, length);
          }
        }
      }
    }

    return BinaryTable;

  })(Tabular);

  this.astro.FITS.BinaryTable = BinaryTable;

  Decompress = {
    Rice: function(array, arrayLen, blocksize, bytepix, pixels, nx) {
      var b, bbits, diff, fs, fsbits, fsmax, i, imax, k, lastpix, nbits, nonzeroCount, nzero, pointer, _ref, _ref1;
      bbits = 1 << fsbits;
      _ref = this.RiceSetup[bytepix](array), fsbits = _ref[0], fsmax = _ref[1], lastpix = _ref[2], pointer = _ref[3];
      nonzeroCount = new Uint8Array(256);
      nzero = 8;
      _ref1 = [128, 255], k = _ref1[0], i = _ref1[1];
      while (i >= 0) {
        while (i >= k) {
          nonzeroCount[i] = nzero;
          i -= 1;
        }
        k = k / 2;
        nzero -= 1;
      }
      nonzeroCount[0] = 0;
      b = array[pointer];
      pointer += 1;
      nbits = 8;
      i = 0;
      while (i < nx) {
        nbits -= fsbits;
        while (nbits < 0) {
          b = (b << 8) | array[pointer];
          pointer += 1;
          nbits += 8;
        }
        fs = (b >> nbits) - 1;
        b &= (1 << nbits) - 1;
        imax = i + blocksize;
        if (imax > nx) {
          imax = nx;
        }
        if (fs < 0) {
          while (i < imax) {
            array[i] = lastpix;
            i++;
          }
        } else if (fs === fsmax) {
          while (i < imax) {
            k = bbits - nbits;
            diff = b << k;
            k -= 8;
            while (k >= 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b << k;
              k -= 8;
            }
            if (nbits > 0) {
              b = array[pointer];
              pointer += 1;
              diff |= b >> (-k);
              b &= (1 << nbits) - 1;
            } else {
              b = 0;
            }
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            array[i] = diff + lastpix;
            lastpix = array[i];
            i++;
          }
        } else {
          while (i < imax) {
            while (b === 0) {
              nbits += 8;
              b = array[pointer];
              pointer += 1;
            }
            nzero = nbits - nonzeroCount[b];
            nbits -= nzero + 1;
            b ^= 1 << nbits;
            nbits -= fs;
            while (nbits < 0) {
              b = (b << 8) | array[pointer];
              pointer += 1;
              nbits += 8;
            }
            diff = (nzero << fs) | (b >> nbits);
            b &= (1 << nbits) - 1;
            if ((diff & 1) === 0) {
              diff = diff >> 1;
            } else {
              diff = ~(diff >> 1);
            }
            pixels[i] = diff + lastpix;
            lastpix = pixels[i];
            i++;
          }
        }
      }
      return pixels;
    },
    RiceSetup: {
      1: function(array) {
        var fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 3;
        fsmax = 6;
        lastpix = array[pointer];
        pointer += 1;
        return [fsbits, fsmax, lastpix, pointer];
      },
      2: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 4;
        fsmax = 14;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      },
      4: function(array) {
        var bytevalue, fsbits, fsmax, lastpix, pointer;
        pointer = 0;
        fsbits = 5;
        fsmax = 25;
        lastpix = 0;
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 24);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 16);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | (bytevalue << 8);
        bytevalue = array[pointer];
        pointer += 1;
        lastpix = lastpix | bytevalue;
        return [fsbits, fsmax, lastpix, pointer];
      }
    },
    gzip: function(array) {
      throw "Not yet implemented";
    },
    plio: function(array, length) {
      throw "Not yet implemented";
    },
    hcompress: function(array, length) {
      throw "Not yet implemented";
    }
  };

  this.astro.FITS.Decompress = Decompress;

  CompressedImage = (function(_super) {

    __extends(CompressedImage, _super);

    CompressedImage.dataTypePattern = /(\d*)([L|X|B|I|J|K|A|E|D|C|M])/;

    CompressedImage.arrayDescriptorPattern = /[0,1]*P([L|X|B|I|J|K|A|E|D|C|M])\((\d*)\)/;

    CompressedImage.include(ImageUtils);

    CompressedImage.extend(Decompress);

    CompressedImage.typedArray = {
      B: Uint8Array,
      I: Int16Array,
      J: Int32Array,
      E: Float32Array,
      D: Float64Array,
      1: Uint8Array,
      2: Uint8Array,
      4: Int16Array,
      8: Int32Array
    };

    function CompressedImage(view, header) {
      var i, key, value, ztile, _i, _ref;
      CompressedImage.__super__.constructor.apply(this, arguments);
      this.length += header["PCOUNT"];
      this.zcmptype = header["ZCMPTYPE"];
      this.zbitpix = header["ZBITPIX"];
      this.znaxis = header["ZNAXIS"];
      this.zblank = CompressedImage.setValue(header, "ZBLANK", void 0);
      this.blank = CompressedImage.setValue(header, "BLANK", void 0);
      this.ztile = [];
      for (i = _i = 1, _ref = this.znaxis; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        ztile = header.contains("ZTILE" + i) ? header["ZTILE" + i] : i === 1 ? header["ZNAXIS1"] : 1;
        this.ztile.push(ztile);
      }
      this.width = header["ZNAXIS1"];
      this.height = header["ZNAXIS2"] || 1;
      this.algorithmParameters = {};
      i = 1;
      while (true) {
        key = "ZNAME" + i;
        if (!header.contains(key)) {
          break;
        }
        value = "ZVAL" + i;
        this.algorithmParameters[header[key]] = header[value];
        i += 1;
      }
      if (this.zcmptype === 'RICE_1') {
        this.setRiceDefaults();
      }
      this.zmaskcmp = CompressedImage.setValue(header, "ZMASKCMP", void 0);
      this.zquantiz = CompressedImage.setValue(header, "ZQUANTIZ", "LINEAR_SCALING");
      this.bzero = CompressedImage.setValue(header, "BZERO", 0);
      this.bscale = CompressedImage.setValue(header, "BSCALE", 1);
      this.defineColumnAccessors(header);
      this.defineGetRow();
    }

    CompressedImage.prototype.defineColumnAccessors = function(header) {
      var accessor, dataType, i, length, match, ttype, value, _i, _ref, _ref1, _results,
        _this = this;
      this.columnNames = {};
      _results = [];
      for (i = _i = 1, _ref = this.cols; 1 <= _ref ? _i <= _ref : _i >= _ref; i = 1 <= _ref ? ++_i : --_i) {
        value = header["TFORM" + i];
        match = value.match(CompressedImage.arrayDescriptorPattern);
        ttype = header["TTYPE" + i].toUpperCase();
        this.columnNames[ttype] = i - 1;
        accessor = null;
        if (match != null) {
          dataType = match[1];
          switch (ttype) {
            case "COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, pixels;
                  data = _this._accessor(dataType);
                  if (data == null) {
                    return new Float32Array(_this.ztile[0]);
                  }
                  pixels = new CompressedImage.typedArray[_this.algorithmParameters["BYTEPIX"]](_this.ztile[0]);
                  CompressedImage.Rice(data, length, _this.algorithmParameters["BLOCKSIZE"], _this.algorithmParameters["BYTEPIX"], pixels, _this.ztile[0]);
                  return pixels;
                };
              })(dataType);
              break;
            case "UNCOMPRESSED_DATA":
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
              break;
            case "GZIP_COMPRESSED_DATA":
              (function(dataType) {
                return accessor = function() {
                  var data, index, item, _j, _len;
                  data = _this._accessor(dataType);
                  if (data != null) {
                    data = new Float32Array(_this.width);
                    for (index = _j = 0, _len = data.length; _j < _len; index = ++_j) {
                      item = data[index];
                      data[index] = NaN;
                    }
                    return data;
                  } else {
                    return null;
                  }
                };
              })(dataType);
              break;
            default:
              (function(dataType) {
                return accessor = _this._accessor(dataType);
              })(dataType);
          }
        } else {
          match = value.match(CompressedImage.dataTypePattern);
          _ref1 = match.slice(1), length = _ref1[0], dataType = _ref1[1];
          length = length != null ? parseInt(length) : 0;
          if (length === 0 || length === 1) {
            (function(dataType) {
              return accessor = function() {
                return CompressedImage.dataAccessors[dataType](_this.view);
              };
            })(dataType);
          } else {
            (function(length, dataType) {
              return accessor = function() {
                var data, _j, _ref2;
                data = new CompressedImage.typedArray[dataType](length);
                for (i = _j = 0, _ref2 = length - 1; 0 <= _ref2 ? _j <= _ref2 : _j >= _ref2; i = 0 <= _ref2 ? ++_j : --_j) {
                  data[i] = CompressedImage.dataAccessors[dataType](_this.view);
                }
                return data;
              };
            })(length, dataType);
          }
        }
        _results.push(this.accessors.push(accessor));
      }
      return _results;
    };

    CompressedImage.prototype.defineGetRow = function() {
      var hasBlanks;
      this.totalRowsRead = 0;
      hasBlanks = (this.zblank != null) || (this.blank != null) || this.columnNames.hasOwnProperty("ZBLANK");
      return this.getRow = hasBlanks ? this.getRowHasBlanks : this.getRowNoBlanks;
    };

    CompressedImage.prototype.setRiceDefaults = function() {
      if (!this.algorithmParameters.hasOwnProperty("BLOCKSIZE")) {
        this.algorithmParameters["BLOCKSIZE"] = 32;
      }
      if (!this.algorithmParameters.hasOwnProperty("BYTEPIX")) {
        return this.algorithmParameters["BYTEPIX"] = 4;
      }
    };

    CompressedImage.setValue = function(header, key, defaultValue) {
      if (header.contains(key)) {
        return header[key];
      } else {
        return defaultValue;
      }
    };

    CompressedImage.prototype.getRowHasBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = value === blank ? NaN : zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getRowNoBlanks = function() {
      var blank, data, index, location, scale, value, zero, _i, _len, _ref;
      _ref = this._getRow(), data = _ref[0], blank = _ref[1], scale = _ref[2], zero = _ref[3];
      for (index = _i = 0, _len = data.length; _i < _len; index = ++_i) {
        value = data[index];
        location = this.totalRowsRead * this.width + index;
        this.data[location] = zero + scale * value;
      }
      this.rowsRead += 1;
      return this.totalRowsRead += 1;
    };

    CompressedImage.prototype.getFrame = function() {
      var height;
      if (this.data == null) {
        this.initArray(Float32Array);
      }
      this.totalRowsRead = 0;
      this.rowsRead = 0;
      height = this.height;
      while (height--) {
        this.getRow();
      }
      return this.data;
    };

    CompressedImage.prototype._accessor = function(dataType) {
      var data, i, length, offset, _i, _ref, _ref1;
      _ref = [this.view.getInt32(), this.view.getInt32()], length = _ref[0], offset = _ref[1];
      if (length === 0) {
        return null;
      }
      data = new CompressedImage.typedArray[dataType](length);
      this.current = this.view.tell();
      this.view.seek(this.begin + this.tableLength + offset);
      for (i = _i = 0, _ref1 = length - 1; 0 <= _ref1 ? _i <= _ref1 : _i >= _ref1; i = 0 <= _ref1 ? ++_i : --_i) {
        data[i] = CompressedImage.dataAccessors[dataType](this.view);
      }
      this.view.seek(this.current);
      return data;
    };

    CompressedImage.prototype._getRow = function() {
      var accessor, blank, data, row, scale, zero, _i, _len, _ref;
      this.current = this.begin + this.totalRowsRead * this.rowByteSize;
      this.view.seek(this.current);
      row = [];
      _ref = this.accessors;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        accessor = _ref[_i];
        row.push(accessor());
      }
      data = row[this.columnNames["COMPRESSED_DATA"]] || row[this.columnNames["UNCOMPRESSED_DATA"]] || row[this.columnNames["GZIP_COMPRESSED_DATA"]];
      blank = row[this.columnNames["ZBLANK"]] || this.zblank;
      scale = row[this.columnNames["ZSCALE"]] || this.bscale;
      zero = row[this.columnNames["ZZERO"]] || this.bzero;
      return [data, blank, scale, zero];
    };

    CompressedImage.subtractiveDither1 = function() {
      throw "Not yet implemented";
    };

    CompressedImage.linearScaling = function() {
      throw "Not yet implemented";
    };

    return CompressedImage;

  })(Tabular);

  this.astro.FITS.CompressedImage = CompressedImage;

  HDU = (function() {

    function HDU(header, data) {
      this.header = header;
      this.data = data;
    }

    HDU.prototype.hasData = function() {
      if (this.data != null) {
        return true;
      } else {
        return false;
      }
    };

    HDU.prototype.getCard = function(key) {
      return this.header[key];
    };

    return HDU;

  })();

  this.astro.FITS.HDU = HDU;

  File = (function() {

    File.LINEWIDTH = 80;

    File.BLOCKLENGTH = 2880;

    File.getType = function(obj) {
      return Object.prototype.toString.call(obj).slice(8, -1).toLowerCase();
    };

    function File(buffer) {
      var name;
      name = File.getType(buffer);
      switch (name) {
        case 'arraybuffer':
          this.initFromBuffer(buffer);
          break;
        case 'object':
          this.initFromObject(buffer);
          break;
        default:
          throw 'fitsjs cannot initialize object';
      }
    }

    File.excessBytes = function(length) {
      return (File.BLOCKLENGTH - (length % File.BLOCKLENGTH)) % File.BLOCKLENGTH;
    };

    File.extendDataView = function(view) {
      var getFloat32, getFloat64, getInt16, getInt32, getInt8, getUint16, getUint32, getUint8;
      DataView.prototype.getString = function(length) {
        var c, i, value, _i, _ref;
        value = '';
        for (i = _i = 0, _ref = length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          c = this.getUint8();
          value += String.fromCharCode(c > 127 ? 65533 : c);
        }
        return value;
      };
      DataView.prototype.getChar = function() {
        return this.getString(1);
      };
      view.offset = 0;
      getInt8 = view.getInt8;
      getUint8 = view.getUint8;
      getInt16 = view.getInt16;
      getUint16 = view.getUint16;
      getInt32 = view.getInt32;
      getUint32 = view.getUint32;
      getFloat32 = view.getFloat32;
      getFloat64 = view.getFloat64;
      view.getInt8 = function() {
        var value;
        value = getInt8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getUint8 = function() {
        var value;
        value = getUint8.apply(this, [this.offset]);
        this.offset += 1;
        return value;
      };
      view.getInt16 = function() {
        var value;
        value = getInt16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getUint16 = function() {
        var value;
        value = getUint16.apply(this, [this.offset, false]);
        this.offset += 2;
        return value;
      };
      view.getInt32 = function() {
        var value;
        value = getInt32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getUint32 = function() {
        var value;
        value = getUint32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat32 = function() {
        var value;
        value = getFloat32.apply(this, [this.offset, false]);
        this.offset += 4;
        return value;
      };
      view.getFloat64 = function() {
        var value;
        value = getFloat64.apply(this, [this.offset, false]);
        this.offset += 8;
        return value;
      };
      view.seek = function(offset) {
        return this.offset = offset;
      };
      return view.tell = function() {
        return this.offset;
      };
    };

    File.prototype.initFromBuffer = function(buffer) {
      var data, hdu, header, _results;
      this.length = buffer.byteLength;
      this.view = new DataView(buffer);
      this.hdus = [];
      this.eof = false;
      File.extendDataView(this.view);
      _results = [];
      while (true) {
        header = this.readHeader();
        data = this.readData(header);
        hdu = new HDU(header, data);
        this.hdus.push(hdu);
        if (this.eof) {
          break;
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    };

    File.prototype.initFromObject = function(buffer) {
      this.length = buffer.length;
      this.view = null;
      this.hdus = buffer.hdus;
      return this.eof = true;
    };

    File.prototype.readHeader = function() {
      var beginOffset, block, done, end, endOffset, endPattern, header, i, line, match, start, whitespacePattern;
      whitespacePattern = /\s{80}/;
      endPattern = /^END\s/;
      beginOffset = this.view.tell();
      done = false;
      while (true) {
        if (done) {
          break;
        }
        block = this.view.getString(File.BLOCKLENGTH);
        i = 0;
        while (true) {
          start = File.BLOCKLENGTH - File.LINEWIDTH * (i + 1);
          end = File.BLOCKLENGTH - File.LINEWIDTH * i;
          line = block.slice(start, end);
          match = line.match(whitespacePattern);
          if (match) {
            i += 1;
            continue;
          }
          match = line.match(endPattern);
          if (match) {
            endOffset = this.view.tell();
            this.view.seek(beginOffset);
            block = this.view.getString(endOffset - beginOffset);
            header = new Header();
            header.init(block);
            done = true;
            this.checkEOF();
            return header;
          }
          break;
        }
      }
    };

    File.prototype.readData = function(header) {
      var data, excess;
      if (!header.hasDataUnit()) {
        return;
      }
      if (header.isPrimary()) {
        data = new Image(this.view, header);
      } else if (header.isExtension()) {
        if (header.extensionType === "BINTABLE") {
          if (header.contains("ZIMAGE")) {
            data = new CompressedImage(this.view, header);
          } else {
            data = new BinaryTable(this.view, header);
          }
        } else if (header.extensionType === "TABLE") {
          data = new Table(this.view, header);
        } else if (header.extensionType === "IMAGE") {
          data = new Image(this.view, header);
        }
      }
      excess = File.excessBytes(data.length);
      this.view.seek(this.view.tell() + data.length + excess);
      this.checkEOF();
      return data;
    };

    File.prototype.checkEOF = function() {
      if (this.view.offset >= this.length) {
        return this.eof = true;
      }
    };

    File.prototype.count = function() {
      return this.hdus.length;
    };

    File.prototype.getHDU = function(index) {
      var hdu, _i, _len, _ref;
      if (index == null) {
        index = void 0;
      }
      if ((index != null) && (this.hdus[index] != null)) {
        return this.hdus[index];
      }
      _ref = this.hdus;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        hdu = _ref[_i];
        if (hdu.hasData()) {
          return hdu;
        }
      }
    };

    File.prototype.getHeader = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).header;
    };

    File.prototype.getDataUnit = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data;
    };

    File.prototype.getData = function(index) {
      if (index == null) {
        index = void 0;
      }
      return this.getHDU(index).data.getFrame();
    };

    return File;

  })();

  this.astro.FITS.File = File;

}).call(this);

define("fits", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Layer/FitsLoader',["fits"], function () {

    /**
     *    Parse fits file
     *
     *    @param response XHR response containing fits
     *
     *    @return Parsed data
     */
    function parseFits(response) {
        var FITS = astro.FITS;
        // Initialize the FITS.File object using
        // the array buffer returned from the XHR
        var fits = new FITS.File(response);
        // Grab the first HDU with a data unit
        var hdu = fits.getHDU();
        var data = hdu.data;

        var uintPixels;
        var swapPixels = new Uint8Array(data.view.buffer, data.begin, data.length); // with gl.UNSIGNED_byte

        var bpe;
        if (data.arrayType) {
            bpe = data.arrayType.BYTES_PER_ELEMENT;
        } else {
            bpe = Math.abs(hdu.header.BITPIX) / 8;
        }
        for (var i = 0; i < swapPixels.length; i += bpe) {
            var temp;
            // Swap to little-endian
            for (var j = 0; j < bpe / 2; j++) {
                temp = swapPixels[i + j];
                swapPixels[i + j] = swapPixels[i + bpe - 1 - j];
                swapPixels[i + bpe - 1 - j] = temp;
            }
        }

        return fits;
    }

    var loadFits = function (url, successCallback, failCallback, onprogressCallback) {
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function (e) {
            if (xhr.readyState === 4) {
                if (xhr.status === 200) {
                    if (xhr.response) {
                        var fits = parseFits(xhr.response);
                        if (successCallback) {
                            successCallback(fits);
                        }
                    }
                }
                else {
                    console.log("Error while loading " + url);
                    if (failCallback) {
                        failCallback();
                    }
                }
            }
        };


        // Define default on progress function, otherwise
        // Firefox won't take Content-length header into account
        // so evt.lengthComputable will be always set to false..
        xhr.onprogress = function (evt) {
        };
        xhr.open("GET", url);
        xhr.responseType = 'arraybuffer';
        xhr.send();
        return xhr;
    };

    return {
        loadFits: loadFits,
        parseFits: parseFits
    };

});

(function() {'use strict';var p=void 0,v=!0,da=this;function fa(f,e){var c=f.split("."),a=da;!(c[0]in a)&&a.execScript&&a.execScript("var "+c[0]);for(var b;c.length&&(b=c.shift());)!c.length&&e!==p?a[b]=e:a=a[b]?a[b]:a[b]={}};var C="undefined"!==typeof Uint8Array&&"undefined"!==typeof Uint16Array&&"undefined"!==typeof Uint32Array&&"undefined"!==typeof DataView;function F(f,e){this.index="number"===typeof e?e:0;this.f=0;this.buffer=f instanceof(C?Uint8Array:Array)?f:new (C?Uint8Array:Array)(32768);if(2*this.buffer.length<=this.index)throw Error("invalid index");this.buffer.length<=this.index&&ga(this)}function ga(f){var e=f.buffer,c,a=e.length,b=new (C?Uint8Array:Array)(a<<1);if(C)b.set(e);else for(c=0;c<a;++c)b[c]=e[c];return f.buffer=b}
F.prototype.b=function(f,e,c){var a=this.buffer,b=this.index,g=this.f,l=a[b],m;c&&1<e&&(f=8<e?(H[f&255]<<24|H[f>>>8&255]<<16|H[f>>>16&255]<<8|H[f>>>24&255])>>32-e:H[f]>>8-e);if(8>e+g)l=l<<e|f,g+=e;else for(m=0;m<e;++m)l=l<<1|f>>e-m-1&1,8===++g&&(g=0,a[b++]=H[l],l=0,b===a.length&&(a=ga(this)));a[b]=l;this.buffer=a;this.f=g;this.index=b};F.prototype.finish=function(){var f=this.buffer,e=this.index,c;0<this.f&&(f[e]<<=8-this.f,f[e]=H[f[e]],e++);C?c=f.subarray(0,e):(f.length=e,c=f);return c};
var ia=new (C?Uint8Array:Array)(256),M;for(M=0;256>M;++M){for(var N=M,S=N,ja=7,N=N>>>1;N;N>>>=1)S<<=1,S|=N&1,--ja;ia[M]=(S<<ja&255)>>>0}var H=ia;function ka(f,e,c){var a,b="number"===typeof e?e:e=0,g="number"===typeof c?c:f.length;a=-1;for(b=g&7;b--;++e)a=a>>>8^T[(a^f[e])&255];for(b=g>>3;b--;e+=8)a=a>>>8^T[(a^f[e])&255],a=a>>>8^T[(a^f[e+1])&255],a=a>>>8^T[(a^f[e+2])&255],a=a>>>8^T[(a^f[e+3])&255],a=a>>>8^T[(a^f[e+4])&255],a=a>>>8^T[(a^f[e+5])&255],a=a>>>8^T[(a^f[e+6])&255],a=a>>>8^T[(a^f[e+7])&255];return(a^4294967295)>>>0}
var la=[0,1996959894,3993919788,2567524794,124634137,1886057615,3915621685,2657392035,249268274,2044508324,3772115230,2547177864,162941995,2125561021,3887607047,2428444049,498536548,1789927666,4089016648,2227061214,450548861,1843258603,4107580753,2211677639,325883990,1684777152,4251122042,2321926636,335633487,1661365465,4195302755,2366115317,997073096,1281953886,3579855332,2724688242,1006888145,1258607687,3524101629,2768942443,901097722,1119000684,3686517206,2898065728,853044451,1172266101,3705015759,
2882616665,651767980,1373503546,3369554304,3218104598,565507253,1454621731,3485111705,3099436303,671266974,1594198024,3322730930,2970347812,795835527,1483230225,3244367275,3060149565,1994146192,31158534,2563907772,4023717930,1907459465,112637215,2680153253,3904427059,2013776290,251722036,2517215374,3775830040,2137656763,141376813,2439277719,3865271297,1802195444,476864866,2238001368,4066508878,1812370925,453092731,2181625025,4111451223,1706088902,314042704,2344532202,4240017532,1658658271,366619977,
2362670323,4224994405,1303535960,984961486,2747007092,3569037538,1256170817,1037604311,2765210733,3554079995,1131014506,879679996,2909243462,3663771856,1141124467,855842277,2852801631,3708648649,1342533948,654459306,3188396048,3373015174,1466479909,544179635,3110523913,3462522015,1591671054,702138776,2966460450,3352799412,1504918807,783551873,3082640443,3233442989,3988292384,2596254646,62317068,1957810842,3939845945,2647816111,81470997,1943803523,3814918930,2489596804,225274430,2053790376,3826175755,
2466906013,167816743,2097651377,4027552580,2265490386,503444072,1762050814,4150417245,2154129355,426522225,1852507879,4275313526,2312317920,282753626,1742555852,4189708143,2394877945,397917763,1622183637,3604390888,2714866558,953729732,1340076626,3518719985,2797360999,1068828381,1219638859,3624741850,2936675148,906185462,1090812512,3747672003,2825379669,829329135,1181335161,3412177804,3160834842,628085408,1382605366,3423369109,3138078467,570562233,1426400815,3317316542,2998733608,733239954,1555261956,
3268935591,3050360625,752459403,1541320221,2607071920,3965973030,1969922972,40735498,2617837225,3943577151,1913087877,83908371,2512341634,3803740692,2075208622,213261112,2463272603,3855990285,2094854071,198958881,2262029012,4057260610,1759359992,534414190,2176718541,4139329115,1873836001,414664567,2282248934,4279200368,1711684554,285281116,2405801727,4167216745,1634467795,376229701,2685067896,3608007406,1308918612,956543938,2808555105,3495958263,1231636301,1047427035,2932959818,3654703836,1088359270,
936918E3,2847714899,3736837829,1202900863,817233897,3183342108,3401237130,1404277552,615818150,3134207493,3453421203,1423857449,601450431,3009837614,3294710456,1567103746,711928724,3020668471,3272380065,1510334235,755167117],T=C?new Uint32Array(la):la;function U(f){this.buffer=new (C?Uint16Array:Array)(2*f);this.length=0}U.prototype.getParent=function(f){return 2*((f-2)/4|0)};U.prototype.push=function(f,e){var c,a,b=this.buffer,g;c=this.length;b[this.length++]=e;for(b[this.length++]=f;0<c;)if(a=this.getParent(c),b[c]>b[a])g=b[c],b[c]=b[a],b[a]=g,g=b[c+1],b[c+1]=b[a+1],b[a+1]=g,c=a;else break;return this.length};
U.prototype.pop=function(){var f,e,c=this.buffer,a,b,g;e=c[0];f=c[1];this.length-=2;c[0]=c[this.length];c[1]=c[this.length+1];for(g=0;;){b=2*g+2;if(b>=this.length)break;b+2<this.length&&c[b+2]>c[b]&&(b+=2);if(c[b]>c[g])a=c[g],c[g]=c[b],c[b]=a,a=c[g+1],c[g+1]=c[b+1],c[b+1]=a;else break;g=b}return{index:f,value:e,length:this.length}};function ma(f,e){this.h=na;this.j=0;this.input=C&&f instanceof Array?new Uint8Array(f):f;this.c=0;e&&(e.lazy&&(this.j=e.lazy),"number"===typeof e.compressionType&&(this.h=e.compressionType),e.outputBuffer&&(this.a=C&&e.outputBuffer instanceof Array?new Uint8Array(e.outputBuffer):e.outputBuffer),"number"===typeof e.outputIndex&&(this.c=e.outputIndex));this.a||(this.a=new (C?Uint8Array:Array)(32768))}var na=2,V=[],$;
for($=0;288>$;$++)switch(v){case 143>=$:V.push([$+48,8]);break;case 255>=$:V.push([$-144+400,9]);break;case 279>=$:V.push([$-256+0,7]);break;case 287>=$:V.push([$-280+192,8]);break;default:throw"invalid literal: "+$;}
ma.prototype.g=function(){var f,e,c,a,b=this.input;switch(this.h){case 0:c=0;for(a=b.length;c<a;){e=C?b.subarray(c,c+65535):b.slice(c,c+65535);c+=e.length;var g=e,l=c===a,m=p,d=p,h=p,s=p,x=p,n=this.a,k=this.c;if(C){for(n=new Uint8Array(this.a.buffer);n.length<=k+g.length+5;)n=new Uint8Array(n.length<<1);n.set(this.a)}m=l?1:0;n[k++]=m|0;d=g.length;h=~d+65536&65535;n[k++]=d&255;n[k++]=d>>>8&255;n[k++]=h&255;n[k++]=h>>>8&255;if(C)n.set(g,k),k+=g.length,n=n.subarray(0,k);else{s=0;for(x=g.length;s<x;++s)n[k++]=
g[s];n.length=k}this.c=k;this.a=n}break;case 1:var q=new F(C?new Uint8Array(this.a.buffer):this.a,this.c);q.b(1,1,v);q.b(1,2,v);var u=oa(this,b),w,aa,z;w=0;for(aa=u.length;w<aa;w++)if(z=u[w],F.prototype.b.apply(q,V[z]),256<z)q.b(u[++w],u[++w],v),q.b(u[++w],5),q.b(u[++w],u[++w],v);else if(256===z)break;this.a=q.finish();this.c=this.a.length;break;case na:var B=new F(C?new Uint8Array(this.a.buffer):this.a,this.c),ra,L,O,P,Q,Ha=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],W,sa,X,ta,ba,ea=Array(19),
ua,R,ca,y,va;ra=na;B.b(1,1,v);B.b(ra,2,v);L=oa(this,b);W=pa(this.n,15);sa=qa(W);X=pa(this.m,7);ta=qa(X);for(O=286;257<O&&0===W[O-1];O--);for(P=30;1<P&&0===X[P-1];P--);var wa=O,xa=P,G=new (C?Uint32Array:Array)(wa+xa),r,I,t,Y,E=new (C?Uint32Array:Array)(316),D,A,J=new (C?Uint8Array:Array)(19);for(r=I=0;r<wa;r++)G[I++]=W[r];for(r=0;r<xa;r++)G[I++]=X[r];if(!C){r=0;for(Y=J.length;r<Y;++r)J[r]=0}r=D=0;for(Y=G.length;r<Y;r+=I){for(I=1;r+I<Y&&G[r+I]===G[r];++I);t=I;if(0===G[r])if(3>t)for(;0<t--;)E[D++]=0,
J[0]++;else for(;0<t;)A=138>t?t:138,A>t-3&&A<t&&(A=t-3),10>=A?(E[D++]=17,E[D++]=A-3,J[17]++):(E[D++]=18,E[D++]=A-11,J[18]++),t-=A;else if(E[D++]=G[r],J[G[r]]++,t--,3>t)for(;0<t--;)E[D++]=G[r],J[G[r]]++;else for(;0<t;)A=6>t?t:6,A>t-3&&A<t&&(A=t-3),E[D++]=16,E[D++]=A-3,J[16]++,t-=A}f=C?E.subarray(0,D):E.slice(0,D);ba=pa(J,7);for(y=0;19>y;y++)ea[y]=ba[Ha[y]];for(Q=19;4<Q&&0===ea[Q-1];Q--);ua=qa(ba);B.b(O-257,5,v);B.b(P-1,5,v);B.b(Q-4,4,v);for(y=0;y<Q;y++)B.b(ea[y],3,v);y=0;for(va=f.length;y<va;y++)if(R=
f[y],B.b(ua[R],ba[R],v),16<=R){y++;switch(R){case 16:ca=2;break;case 17:ca=3;break;case 18:ca=7;break;default:throw"invalid code: "+R;}B.b(f[y],ca,v)}var ya=[sa,W],za=[ta,X],K,Aa,Z,ha,Ba,Ca,Da,Ea;Ba=ya[0];Ca=ya[1];Da=za[0];Ea=za[1];K=0;for(Aa=L.length;K<Aa;++K)if(Z=L[K],B.b(Ba[Z],Ca[Z],v),256<Z)B.b(L[++K],L[++K],v),ha=L[++K],B.b(Da[ha],Ea[ha],v),B.b(L[++K],L[++K],v);else if(256===Z)break;this.a=B.finish();this.c=this.a.length;break;default:throw"invalid compression type";}return this.a};
function Fa(f,e){this.length=f;this.k=e}
var Ga=function(){function f(b){switch(v){case 3===b:return[257,b-3,0];case 4===b:return[258,b-4,0];case 5===b:return[259,b-5,0];case 6===b:return[260,b-6,0];case 7===b:return[261,b-7,0];case 8===b:return[262,b-8,0];case 9===b:return[263,b-9,0];case 10===b:return[264,b-10,0];case 12>=b:return[265,b-11,1];case 14>=b:return[266,b-13,1];case 16>=b:return[267,b-15,1];case 18>=b:return[268,b-17,1];case 22>=b:return[269,b-19,2];case 26>=b:return[270,b-23,2];case 30>=b:return[271,b-27,2];case 34>=b:return[272,
b-31,2];case 42>=b:return[273,b-35,3];case 50>=b:return[274,b-43,3];case 58>=b:return[275,b-51,3];case 66>=b:return[276,b-59,3];case 82>=b:return[277,b-67,4];case 98>=b:return[278,b-83,4];case 114>=b:return[279,b-99,4];case 130>=b:return[280,b-115,4];case 162>=b:return[281,b-131,5];case 194>=b:return[282,b-163,5];case 226>=b:return[283,b-195,5];case 257>=b:return[284,b-227,5];case 258===b:return[285,b-258,0];default:throw"invalid length: "+b;}}var e=[],c,a;for(c=3;258>=c;c++)a=f(c),e[c]=a[2]<<24|
a[1]<<16|a[0];return e}(),Ia=C?new Uint32Array(Ga):Ga;
function oa(f,e){function c(b,e){var a=b.k,c=[],g=0,f;f=Ia[b.length];c[g++]=f&65535;c[g++]=f>>16&255;c[g++]=f>>24;var d;switch(v){case 1===a:d=[0,a-1,0];break;case 2===a:d=[1,a-2,0];break;case 3===a:d=[2,a-3,0];break;case 4===a:d=[3,a-4,0];break;case 6>=a:d=[4,a-5,1];break;case 8>=a:d=[5,a-7,1];break;case 12>=a:d=[6,a-9,2];break;case 16>=a:d=[7,a-13,2];break;case 24>=a:d=[8,a-17,3];break;case 32>=a:d=[9,a-25,3];break;case 48>=a:d=[10,a-33,4];break;case 64>=a:d=[11,a-49,4];break;case 96>=a:d=[12,a-
65,5];break;case 128>=a:d=[13,a-97,5];break;case 192>=a:d=[14,a-129,6];break;case 256>=a:d=[15,a-193,6];break;case 384>=a:d=[16,a-257,7];break;case 512>=a:d=[17,a-385,7];break;case 768>=a:d=[18,a-513,8];break;case 1024>=a:d=[19,a-769,8];break;case 1536>=a:d=[20,a-1025,9];break;case 2048>=a:d=[21,a-1537,9];break;case 3072>=a:d=[22,a-2049,10];break;case 4096>=a:d=[23,a-3073,10];break;case 6144>=a:d=[24,a-4097,11];break;case 8192>=a:d=[25,a-6145,11];break;case 12288>=a:d=[26,a-8193,12];break;case 16384>=
a:d=[27,a-12289,12];break;case 24576>=a:d=[28,a-16385,13];break;case 32768>=a:d=[29,a-24577,13];break;default:throw"invalid distance";}f=d;c[g++]=f[0];c[g++]=f[1];c[g++]=f[2];var h,l;h=0;for(l=c.length;h<l;++h)n[k++]=c[h];u[c[0]]++;w[c[3]]++;q=b.length+e-1;x=null}var a,b,g,l,m,d={},h,s,x,n=C?new Uint16Array(2*e.length):[],k=0,q=0,u=new (C?Uint32Array:Array)(286),w=new (C?Uint32Array:Array)(30),aa=f.j,z;if(!C){for(g=0;285>=g;)u[g++]=0;for(g=0;29>=g;)w[g++]=0}u[256]=1;a=0;for(b=e.length;a<b;++a){g=
m=0;for(l=3;g<l&&a+g!==b;++g)m=m<<8|e[a+g];d[m]===p&&(d[m]=[]);h=d[m];if(!(0<q--)){for(;0<h.length&&32768<a-h[0];)h.shift();if(a+3>=b){x&&c(x,-1);g=0;for(l=b-a;g<l;++g)z=e[a+g],n[k++]=z,++u[z];break}0<h.length?(s=Ja(e,a,h),x?x.length<s.length?(z=e[a-1],n[k++]=z,++u[z],c(s,0)):c(x,-1):s.length<aa?x=s:c(s,0)):x?c(x,-1):(z=e[a],n[k++]=z,++u[z])}h.push(a)}n[k++]=256;u[256]++;f.n=u;f.m=w;return C?n.subarray(0,k):n}
function Ja(f,e,c){var a,b,g=0,l,m,d,h,s=f.length;m=0;h=c.length;a:for(;m<h;m++){a=c[h-m-1];l=3;if(3<g){for(d=g;3<d;d--)if(f[a+d-1]!==f[e+d-1])continue a;l=g}for(;258>l&&e+l<s&&f[a+l]===f[e+l];)++l;l>g&&(b=a,g=l);if(258===l)break}return new Fa(g,e-b)}
function pa(f,e){var c=f.length,a=new U(572),b=new (C?Uint8Array:Array)(c),g,l,m,d,h;if(!C)for(d=0;d<c;d++)b[d]=0;for(d=0;d<c;++d)0<f[d]&&a.push(d,f[d]);g=Array(a.length/2);l=new (C?Uint32Array:Array)(a.length/2);if(1===g.length)return b[a.pop().index]=1,b;d=0;for(h=a.length/2;d<h;++d)g[d]=a.pop(),l[d]=g[d].value;m=Ka(l,l.length,e);d=0;for(h=g.length;d<h;++d)b[g[d].index]=m[d];return b}
function Ka(f,e,c){function a(b){var c=d[b][h[b]];c===e?(a(b+1),a(b+1)):--l[c];++h[b]}var b=new (C?Uint16Array:Array)(c),g=new (C?Uint8Array:Array)(c),l=new (C?Uint8Array:Array)(e),m=Array(c),d=Array(c),h=Array(c),s=(1<<c)-e,x=1<<c-1,n,k,q,u,w;b[c-1]=e;for(k=0;k<c;++k)s<x?g[k]=0:(g[k]=1,s-=x),s<<=1,b[c-2-k]=(b[c-1-k]/2|0)+e;b[0]=g[0];m[0]=Array(b[0]);d[0]=Array(b[0]);for(k=1;k<c;++k)b[k]>2*b[k-1]+g[k]&&(b[k]=2*b[k-1]+g[k]),m[k]=Array(b[k]),d[k]=Array(b[k]);for(n=0;n<e;++n)l[n]=c;for(q=0;q<b[c-1];++q)m[c-
1][q]=f[q],d[c-1][q]=q;for(n=0;n<c;++n)h[n]=0;1===g[c-1]&&(--l[0],++h[c-1]);for(k=c-2;0<=k;--k){u=n=0;w=h[k+1];for(q=0;q<b[k];q++)u=m[k+1][w]+m[k+1][w+1],u>f[n]?(m[k][q]=u,d[k][q]=e,w+=2):(m[k][q]=f[n],d[k][q]=n,++n);h[k]=0;1===g[k]&&a(k)}return l}
function qa(f){var e=new (C?Uint16Array:Array)(f.length),c=[],a=[],b=0,g,l,m,d;g=0;for(l=f.length;g<l;g++)c[f[g]]=(c[f[g]]|0)+1;g=1;for(l=16;g<=l;g++)a[g]=b,b+=c[g]|0,b<<=1;g=0;for(l=f.length;g<l;g++){b=a[f[g]];a[f[g]]+=1;m=e[g]=0;for(d=f[g];m<d;m++)e[g]=e[g]<<1|b&1,b>>>=1}return e};function La(f,e){this.input=f;this.c=this.i=0;this.d={};e&&(e.flags&&(this.d=e.flags),"string"===typeof e.filename&&(this.filename=e.filename),"string"===typeof e.comment&&(this.l=e.comment),e.deflateOptions&&(this.e=e.deflateOptions));this.e||(this.e={})}
La.prototype.g=function(){var f,e,c,a,b,g,l,m,d=new (C?Uint8Array:Array)(32768),h=0,s=this.input,x=this.i,n=this.filename,k=this.l;d[h++]=31;d[h++]=139;d[h++]=8;f=0;this.d.fname&&(f|=Ma);this.d.fcomment&&(f|=Na);this.d.fhcrc&&(f|=Oa);d[h++]=f;e=(Date.now?Date.now():+new Date)/1E3|0;d[h++]=e&255;d[h++]=e>>>8&255;d[h++]=e>>>16&255;d[h++]=e>>>24&255;d[h++]=0;d[h++]=Pa;if(this.d.fname!==p){l=0;for(m=n.length;l<m;++l)g=n.charCodeAt(l),255<g&&(d[h++]=g>>>8&255),d[h++]=g&255;d[h++]=0}if(this.d.comment){l=
0;for(m=k.length;l<m;++l)g=k.charCodeAt(l),255<g&&(d[h++]=g>>>8&255),d[h++]=g&255;d[h++]=0}this.d.fhcrc&&(c=ka(d,0,h)&65535,d[h++]=c&255,d[h++]=c>>>8&255);this.e.outputBuffer=d;this.e.outputIndex=h;b=new ma(s,this.e);d=b.g();h=b.c;C&&(h+8>d.buffer.byteLength?(this.a=new Uint8Array(h+8),this.a.set(new Uint8Array(d.buffer)),d=this.a):d=new Uint8Array(d.buffer));a=ka(s,p,p);d[h++]=a&255;d[h++]=a>>>8&255;d[h++]=a>>>16&255;d[h++]=a>>>24&255;m=s.length;d[h++]=m&255;d[h++]=m>>>8&255;d[h++]=m>>>16&255;d[h++]=
m>>>24&255;this.i=x;C&&h<d.length&&(this.a=d=d.subarray(0,h));return d};var Pa=255,Oa=2,Ma=8,Na=16;fa("Zlib.Gzip",La);fa("Zlib.Gzip.prototype.compress",La.prototype.g);}).call(this);

define("gzip", function(){});

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

define('Layer/FitsRequest',['../Utils/ImageRequest'], function (ImageRequest) {

    /**************************************************************************************************************/

    /*
     *	Override send function to handle fits requests
     */
    ImageRequest.prototype.send = function (url, crossOrigin, noRequest) {


        var self = this;
        if (noRequest) {
            self.failCallback(self);
            return;
        }
        if (url.search("fits") > 0) {
            // Fits
            var xhr = new XMLHttpRequest();
            xhr.onreadystatechange = function (e) {
                if (xhr && xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        if (xhr.response) {
                            self.image = xhr.response;
                            if (self.successCallback) {
                                self.successCallback(self);
                            }
                        }
                    }
                    else {
                        if (xhr.status !== 0) {
                            // Fail
                            console.log("Error while loading " + url);
                            if (self.failCallback) {
                                self.failCallback(self);
                            }
                        }
                    }
                    xhr = null;
                }
            };

            xhr.onabort = function (e) {
                if (self.abortCallback) {
                    self.abortCallback(self);
                }
                self.xhr = null;
            };

            xhr.open("GET", url);
            xhr.responseType = 'arraybuffer';
            xhr.send();
            this.xhr = xhr;
        }
        else {
            this.image = new Image();
            this.image.aborted = false;
            this.image.crossOrigin = '';
            this.image.dataType = "byte";
            this.image.onload = function () {
                var isComplete = self.image.naturalWidth !== 0 && self.image.complete;
                if (isComplete && !this.aborted) {
                    self.successCallback(self);
                }
            };
            this.image.onerror = function () {
                if (self.failCallback && !this.aborted) {
                    self.failCallback(self);
                }
            };
            this.image.src = url;
        }
    };

    /**************************************************************************************************************/

    /*
     *	Override abort
     */
    ImageRequest.prototype.abort = function () {
        if (this.xhr) {
            this.xhr.abort();
        }
        else {
            if (this.abortCallback) {
                this.abortCallback(this);
            }
            this.image.aborted = true;
            this.image.src = '';
        }
    };

    /**************************************************************************************************************/

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/HipsFitsLayer',['../Utils/Constants', '../Utils/Utils', '../Utils/Constants', '../Tiling/HEALPixTiling', './AbstractHipsLayer', '../Renderer/DynamicImage', './FitsLoader', 'gzip', '../Utils/ImageRequest', './FitsRequest'],
    function (Contants, Utils, Constants, HEALPixTiling, AbstractHipsLayer, DynamicImage, FitsLoader, gZip, ImageRequest) {

        /**************************************************************************************************************/

        /**
         * HipsFits configuration
         * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.hipsFits_configuration
         * @property {Function} onready - Callback function
         */
        
        /**
         * @name HipsFitsLayer
         * @class
         * This layer draws an Hips Fits Image
         * @augments AbstractHipsLayer
         * @param {Object} hipsMetadata - HIPS Metadata
         * @param {AbstractHipsLayer.hipsFits_configuration} options - HipsFits configuration
         * @memberOf module:Layer
         * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
         */
        var HipsFitsLayer = function (hipsMetadata, options) {
            AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, options);

            this._ready = false;
            this.fitsSupported = true;

            // allsky
            this.levelZeroImage = null;

            // TODO use DynamicImage shaders by unifying shader programs between TileManager and ConvexPolygonRenderer
            //		* inverse Y coordinates, some var names refactor..
            this.rawFragShader = "precision lowp float; \n";
            this.rawFragShader += "varying vec2 texCoord;\n";
            this.rawFragShader += "uniform sampler2D colorTexture; \n";
            this.rawFragShader += "uniform float opacity; \n";
            this.rawFragShader += "uniform float inversed; \n";
            this.rawFragShader += "bool isnan(float val) {\n";
            this.rawFragShader += "		return (val <= 0.0 || 0.0 <= val) ? ((val == 5e-324) ? true : false) : true;\n";
            this.rawFragShader += "}\n";
            this.rawFragShader += "void main(void)\n";
            this.rawFragShader += "{\n";
            this.rawFragShader += "	vec4 color = texture2D(colorTexture, vec2(texCoord.x, (inversed == 1.) ? 1.0 - texCoord.y : texCoord.y));\n";
            this.rawFragShader += "	gl_FragColor = vec4(color.r,color.g,color.b, color.a*opacity);\n";
            this.rawFragShader += "	if (isnan( (gl_FragColor.r + gl_FragColor.g + gl_FragColor.b) / 3. ) )\n";
            this.rawFragShader += "	{\n";
            this.rawFragShader += "		gl_FragColor.a = 0.;\n";
            this.rawFragShader += "	}\n";
            this.rawFragShader += "}\n";

            this.colormapFragShader = "precision lowp float; \n";
            this.colormapFragShader += "varying vec2 texCoord;\n";
            this.colormapFragShader += "uniform sampler2D colorTexture; \n";
            this.colormapFragShader += "uniform sampler2D colormap; \n";
            this.colormapFragShader += "uniform float min; \n";
            this.colormapFragShader += "uniform float max; \n";
            this.colormapFragShader += "uniform float opacity; \n";
            this.colormapFragShader += "bool isnan(float val) {\n";
            this.colormapFragShader += "	return (val <= 0.0 || 0.0 <= val) ? false : true;\n";
            this.colormapFragShader += "}\n";
            this.colormapFragShader += "void main(void)\n";
            this.colormapFragShader += "{\n";
            this.colormapFragShader += "	float i = texture2D(colorTexture,vec2(texCoord.x, 1.0 - texCoord.y)).r;\n";
            this.colormapFragShader += "	float d = clamp( ( i - min ) / (max - min), 0.0, 1.0 );\n";
            this.colormapFragShader += "	vec4 cmValue = texture2D(colormap, vec2(d,0.));\n";
            this.colormapFragShader += "	gl_FragColor = vec4(cmValue.r,cmValue.g,cmValue.b, cmValue.a*opacity);\n";
            this.colormapFragShader += "	if (isnan( i ) )\n";
            this.colormapFragShader += "	{\n";
            this.colormapFragShader += "		 gl_FragColor.a = 0.;\n";
            this.colormapFragShader += "	}\n";
            this.colormapFragShader += "}\n";

            var self = this;

            this.customShader = {
                fragmentCode: this.rawFragShader,
                updateUniforms: function (gl, program) {
                    // Level zero image is required to init uniforms
                    gl.uniform1f(program.uniforms.inversed, self.inversed);
                    if (self.levelZeroImage) {
                        gl.uniform1f(program.uniforms.max, self.levelZeroImage.tmax);
                        gl.uniform1f(program.uniforms.min, self.levelZeroImage.tmin);

                        gl.activeTexture(gl.TEXTURE1);
                        gl.bindTexture(gl.TEXTURE_2D, self.levelZeroImage.colormapTex);
                        gl.uniform1i(program.uniforms.colormap, 1);
                        gl.uniform1f(program.uniforms.opacity, self.getOpacity());
                    }
                }
            };

            // Request for level zero image
            this.imageRequest = new ImageRequest({
                successCallback: function () {
                    var data, res;
                    self._ready = true;

                    if (self.format === "fits") {
                        // Unzip if g-zipped
                        try {
                            data = new Uint8Array(self.imageRequest.image);
                            res = gZip.unzip(data);
                            self.imageRequest.image = new Uint8Array(res).buffer;
                        }
                        catch (err) {
                            if (err !== 'Not a GZIP file') {
                                // G-zip error
                                console.error(err);
                                this.failCallback();
                                return;
                            } else {
                                // Image isn't g-zipped, handle image as fits
                                console.log("not gzipped");
                                data = null;
                            }
                        }

                        self.handleImage(self.imageRequest);
                        var fitsData = self.imageRequest.image;
                        if (self.globe) {
                            // Create level zero image
                            var gl = self.globe.renderContext.gl;
                            self.levelZeroImage = new DynamicImage(self.globe.renderContext, fitsData.typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);
                            self.getLevelZeroTexture = function () {
                                return self.levelZeroImage.texture;
                            };
                        }
                    }
                    else {
                        self.levelZeroImage = this.image;
                        self.getLevelZeroTexture = null;
                    }

                    // Call callback if set
                    if (options.onready && options.onready instanceof Function) {
                        options.onready(self);
                    }

                    // Request a frame
                    if (self.globe) {
                        self.globe.renderContext.requestFrame();
                    }
                },
                /**
                 * @fires Context#baseLayersError
                 */
                failCallback: function () {
                    if (self.globe) {
                        self.globe.publishEvent("baseLayersError", self);
                        self._ready = false;
                        console.log("Error while loading background");
                    }
                },
                abortCallback: function (iq) {
                    self._ready = false;
                    console.log("Background image request has been aborted");
                }
            });
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractHipsLayer, HipsFitsLayer);

        /**************************************************************************************************************/

        /**
         * Attach the Hips Fits layer to the globe
         * @function _attach
         * @memberof HipsFitsLayer.prototype
         * @param {AbstractGlobe} g Globe to attach
         * @private
         */
        HipsFitsLayer.prototype._attach = function (g) {
            AbstractHipsLayer.prototype._attach.call(this, g);

            // Enable float texture extension to have higher luminance range
            var gl = this.globe.renderContext.gl;

            this.requestLevelZeroImage();
            var ext = gl.getExtension("OES_texture_float");

            if (!ext) {
                // TODO
                console.error("no OES_texture_float");
                this.fitsSupported = false;
                //return;
            }
        };

        /**************************************************************************************************************/

        /**
         * Detach the Hips Fits layer from the globe
         * @function _detach
         * @memberof HipsFitsLayer#
         * @private
         */
        HipsFitsLayer.prototype._detach = function () {
            // Abort image request if in progress
            if (!this._ready) {
                this.imageRequest.abort();
            }
            this._ready = false;
            this.disposeResources();

            AbstractHipsLayer.prototype._detach.call(this);

        };

        /**************************************************************************************************************/

        /**
         * Get url from a given tile
         * @function getUrl
         * @memberof HipsFitsLayer#
         * @param {Tile} tile Tile object
         */
        HipsFitsLayer.prototype.getUrl = function (tile) {
            var url = this.baseUrl;

            url += "/Norder";
            url += tile.order;

            url += "/Dir";
            url += Math.floor(tile.pixelIndex / 10000.0) * 10000.0;

            url += "/Npix";
            url += tile.pixelIndex;
            url += "." + this.format;

            return url;
        };

        /**************************************************************************************************************/

        /**
         * Extracts fits data from levelZeroImage.pixels to fitsPixel according to pixel index
         * @function extractFitsData
         * @memberof HipsFitsLayer#
         * @param pi Pixel index
         * @param fitsPixel Resulting typed vector containing fits data
         * @param sx X-offset of fitsPixel
         * @param sy Y-offset of fitsPixel
         */
        HipsFitsLayer.prototype.extractFitsData = function (pi, fitsPixel, sx, sy) {
            var size = 64;
            var height = this.levelZeroImage.height;
            var width = this.levelZeroImage.width;
            var pixels = this.levelZeroImage.pixels;

            var startIndex = size * width * ( 28 - Math.floor(pi / 27) ) + ( pi % 27 ) * size;

            // Extract fits data
            var typedLine;
            for (var i = 0; i < size; i++) {
                typedLine = pixels.subarray(startIndex + i * width, startIndex + i * width + size);
                fitsPixel.set(typedLine, sy + i * 128 + sx);
            }
        };

        /**************************************************************************************************************/

        /**
         * Generates the level0 texture for the tiles
         * @function generateLevel0Textures
         * @memberof HipsFitsLayer#
         * @param tiles
         * @param tilePool
         */
        HipsFitsLayer.prototype.generateLevel0Textures = function (tiles, tilePool) {
            var fitsPixel;
            var pi, sx, sy;
            var i, tile;
            var imgData;
            if (this.format !== "fits") {
                // Create a canvas to build the texture
                var canvas = document.createElement("canvas");
                canvas.width = 128;
                canvas.height = 128;
                var context = canvas.getContext("2d");

                for (i = 0; i < tiles.length; i++) {
                    tile = tiles[i];

                    // Top left
                    pi = tile.pixelIndex * 4;
                    sx = ( pi % 27) * 64;
                    sy = ( Math.floor(pi / 27) ) * 64;
                    context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 0, 64, 64);

                    // Top right
                    pi = tile.pixelIndex * 4 + 2;
                    sx = ( pi % 27) * 64;
                    sy = ( Math.floor(pi / 27) ) * 64;
                    context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 0, 64, 64);

                    // Bottom left
                    pi = tile.pixelIndex * 4 + 1;
                    sx = ( pi % 27) * 64;
                    sy = ( Math.floor(pi / 27) ) * 64;
                    context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 64, 64, 64);

                    // Bottom right
                    pi = tile.pixelIndex * 4 + 3;
                    sx = ( pi % 27) * 64;
                    sy = ( Math.floor(pi / 27) ) * 64;
                    context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 64, 64, 64);

                    imgData = context.getImageData(0, 0, 128, 128);
                    imgData.dataType = 'byte';

                    tile.texture = tilePool.createGLTexture(imgData);
                    tile.imageSize = 128;
                }
            }
            else {
                for (i = 0; i < tiles.length; i++) {
                    tile = tiles[i];
                    fitsPixel = new Float32Array(128 * 128);

                    // Top left
                    pi = tile.pixelIndex * 4;
                    this.extractFitsData(pi, fitsPixel, 0, 128 * 64);

                    // Top right
                    pi = tile.pixelIndex * 4 + 2;
                    this.extractFitsData(pi, fitsPixel, 64, 128 * 64);

                    // Bottom left
                    pi = tile.pixelIndex * 4 + 1;
                    this.extractFitsData(pi, fitsPixel, 0, 0);

                    // Bottom right
                    pi = tile.pixelIndex * 4 + 3;
                    this.extractFitsData(pi, fitsPixel, 64, 0);

                    imgData = {
                        typedArray: fitsPixel,
                        width: 128,
                        height: 128,
                        dataType: 'float'
                    };

                    tile.texture = tilePool.createGLTexture(imgData);
                    tile.imageSize = 128;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Handles the fits image.
         * @function handleImage
         * @memberof HipsFitsLayer#
         * @param imgRequest
         */
        HipsFitsLayer.prototype.handleImage = function (imgRequest) {
            if (!(imgRequest.image instanceof Image)) {
                var fits = FitsLoader.parseFits(imgRequest.image);
                var fitsData = fits.getHDU().data;
                var bpe = fitsData.arrayType.BYTES_PER_ELEMENT;
                var float32array, float64array;
                var i;
                if (fitsData.arrayType.name === "Float64Array") {
                    float64array = new Float64Array(fitsData.view.buffer, fitsData.begin, fitsData.length / bpe); // bpe = 8
                    float32array = new Float32Array(fitsData.length / bpe);
                    // Create Float32Array from Float64Array
                    for (i = 0; i < float64array.length; i++) {
                        float32array[i] = float64array[i];
                    }
                }
                else {
                    float32array = new Float32Array(fitsData.view.buffer, fitsData.begin, fitsData.length / bpe); // with gl.FLOAT, bpe = 4
                }

                // // Handle different types/formats.. just in case.
                // var dataType;
                // var typedArray;
                // var gl = this.globe.renderContext.gl;
                // var glType;
                // if ( fitsData.arrayType.name == "Float32Array" )
                // {
                // 	typedArray = new Float32Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT );
                // 	dataType = "float";
                // 	glType = gl.FLOAT;
                // 	glFormat = gl.LUMINANCE;
                // }
                // else if ( fitsData.arrayType.name == "Uint8Array" )
                // {
                // 	typedArray = new Uint8Array( fitsData.view.buffer, fitsData.begin, fitsData.length/fitsData.arrayType.BYTES_PER_ELEMENT )
                // 	dataType = "int";
                // 	glType = gl.UNSIGNED_BYTE;
                // 	glFormat = gl.LUMINANCE;
                // }

                imgRequest.image = {
                    typedArray: float32array,
                    width: fitsData.width,
                    height: fitsData.height,
                    dataType: "float"
                };

            }
        };

        /**************************************************************************************************************/

        /**
         * Requests level zero image
         * @function requestLevelZeroImage
         * @memberof HipsFitsLayer#
         */
        HipsFitsLayer.prototype.requestLevelZeroImage = function () {
            // Set dataType always to jpg if fits isn't supported by graphic card
            if (!this.fitsSupported) {
                this.format = 'jpg';
            }

            // Revert to raw rendering
            this.customShader.fragmentCode = this.rawFragShader;
            if (this.format === "fits") {
                this.inversed = 1.0;
            }
            else {
                this.inversed = 0.0;
            }

            var url = this.baseUrl + "/Norder3/Allsky." + this.format;
            this.imageRequest.send(url);
        };

        /**************************************************************************************************************/

        /**
         * Disposes the allocated resources
         * @function disposeResources
         * @memberof HipsFitsLayer#
         */
        HipsFitsLayer.prototype.disposeResources = function () {
            // Dispose level zero image & texture
            if (this.levelZeroImage && this.levelZeroImage.dispose) {
                this.levelZeroImage.dispose();
            }
            if (this.levelZeroTexture) {
                this.globe.renderContext.gl.deleteTexture(this.levelZeroTexture);
            }

            this.levelZeroImage = null;
            this.levelZeroTexture = null;
        };

        /**************************************************************************************************************/

        /**
         *    Sets the format
         *    (currently never used)
         *    TODO: store basic format(could be 'png' or 'jpg'), to be
         *    able to revert from fits
         * @function setFormat
         * @memberof HipsFitsLayer#
         * @param {String} format Format
         */
        HipsFitsLayer.prototype.setFormat = function (format) {
            this.format = (isFits) ? 'fits' : 'jpg';
        };

        /**************************************************************************************************************/

        return HipsFitsLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/HipsGraphicLayer',['../Utils/Utils', '../Tiling/HEALPixTiling', './AbstractHipsLayer'],
    function (Utils, HEALPixTiling, AbstractHipsLayer) {

        /**************************************************************************************************************/

        /**
         * HipsFits configuration
         * @typedef {AbstractHipsLayer.configuration} AbstractHipsLayer.graphic_configuration
         * @property {Function} onready - Callback function
         */

        /**
         * @name HipsGraphicLayer
         * @class
         * This layer draws an Hips Image
         * @augments AbstractHipsLayer
         * @param {HipsMetadata} hipsMetadata
         * @param {AbstractHipsLayer.graphic_configuration} options - HipsGraphic configuration
         * @memberOf module:Layer
         * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
         * @fires Context#baseLayersError
         */
        var HipsGraphicLayer = function (hipsMetadata, options) {
            //options.format = options.format || "jpg";
            AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, options);

            // allsky
            this.levelZeroImage = new Image();
            var self = this;
            this.levelZeroImage.crossOrigin = '';
            this.levelZeroImage.onload = function () {
                self._ready = true;

                // Call callback if set
                if (options.onready && options.onready instanceof Function) {
                    options.onready(self);
                }

                // Request a frame
                if (self.globe) {
                    self.globe.renderContext.requestFrame();
                }
            };
            this.levelZeroImage.onerror = function (event) {
                self.globe.publishEvent("baseLayersError", self);
                self._ready = false;

                console.log("Cannot load " + self.levelZeroImage.src);
            };

            this._ready = false;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractHipsLayer, HipsGraphicLayer);

        /**************************************************************************************************************/

        /**
         * Attaches the raster layer to the planet.
         * @function _attach
         * @memberOf HipsGraphicLayer#
         * @param g Globe
         * @private
         */
        HipsGraphicLayer.prototype._attach = function (g) {
            AbstractHipsLayer.prototype._attach.call(this, g);

            // Load level zero image now, only for background
            if (!this._overlay) {
                this.levelZeroImage.src = this.proxify(this.baseUrl) + "/Norder3/Allsky." + this.format;
            }
        };

        /**************************************************************************************************************/

        /**
         * Returns an url from a given tile.
         * @function getUrl
         * @memberOf HipsGraphicLayer#
         * @param {Tile} tile Tile
         * @return {String} Url
         */
        HipsGraphicLayer.prototype.getUrl = function (tile) {
            var url = this.proxify(this.baseUrl);

            url += "/Norder";
            url += tile.order;

            url += "/Dir";
            var indexDirectory = Math.floor(tile.pixelIndex / 10000.0) * 10000.0;
            url += indexDirectory;

            url += "/Npix";
            url += tile.pixelIndex;
            url += "." + this.format;

            return url;
        };


        /**************************************************************************************************************/

        /**
         * Generates the level0 texture for the tiles.
         * @function generateLevel0Textures
         * @memberOf HipsGraphicLayer
         * @param {Tile} tiles
         * @param {TilePool} tilePool
         */
        HipsGraphicLayer.prototype.generateLevel0Textures = function (tiles, tilePool) {
            // Create a canvas to build the texture
            var canvas = document.createElement("canvas");
            canvas.width = 128;
            canvas.height = 128;
            var i,pi,sx,sy,tile;
            var context = canvas.getContext("2d");

            for (i = 0; i < tiles.length; i++) {
                tile = tiles[i];

                // Top left
                pi = tile.pixelIndex * 4;
                sx = ( pi % 27) * 64;
                sy = ( Math.floor(pi / 27) ) * 64;
                context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 0, 64, 64);

                // Top right
                pi = tile.pixelIndex * 4 + 2;
                sx = ( pi % 27) * 64;
                sy = ( Math.floor(pi / 27) ) * 64;
                context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 0, 64, 64);

                // Bottom left
                pi = tile.pixelIndex * 4 + 1;
                sx = ( pi % 27) * 64;
                sy = ( Math.floor(pi / 27) ) * 64;
                context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 0, 64, 64, 64);

                // Bottom right
                pi = tile.pixelIndex * 4 + 3;
                sx = ( pi % 27) * 64;
                sy = ( Math.floor(pi / 27) ) * 64;
                context.drawImage(this.levelZeroImage, sx, sy, 64, 64, 64, 64, 64, 64);

                var imgData = context.getImageData(0, 0, 128, 128);
                imgData.dataType = 'byte';

                tile.texture = tilePool.createGLTexture(imgData);
                tile.imageSize = 128;
            }
        };

        /**************************************************************************************************************/

        return HipsGraphicLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/


define('Layer/MocLayer',["jquery", "./AbstractLayer", '../Utils/Constants','../Renderer/FeatureStyle', "../Utils/Utils", "../Tiling/HEALPixBase", "./FitsLoader"],
    function ($, AbstractLayer, Constants, FeatureStyle, Utils, HEALPixBase, FitsLoader) {
        /**
         * MocLayer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.moc_configuration
         * @property {string} serviceUrl - service URL
         * @property {int} [startOrder = 2] - Starting order of HEALPix tiling
         * @property {Object} [style] - See {@link FeatureStyle} description
         */
        /**
         * @name MocLayer
         * @class
         * This layer draws a MOC data
         * @augments AbstractLayer
         * @param {AbstractLayer.moc_configuration} options - Moc layer configuration
         * @memberOf module:Layer
         * @see {@link http://www.ivoa.net/documents/MOC/20140602/index.html Moc}
         */
        var MocLayer = function (options) {
            options.dataType = Constants.GEOMETRY.LineString;
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.Moc, options);

            this.serviceUrl = this.proxify(options.serviceUrl);
            this.startOrder = options.startOrder || 2;

            // Set style
            if (options && options.style) {
                this.style = new FeatureStyle(options.style);
            }
            else {
                this.style = new FeatureStyle();
            }

            this.featuresSet = null;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, MocLayer);

        /**************************************************************************************************************/

        /**
         * Attaches the layer to the planet
         * @function _attach
         * @memberOf MocLayer#
         * @param g Planet
         * @protected
         */
        MocLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);

            var self = this;
            var i;

            if (String(self.serviceUrl).endsWith(".fits")) {
                FitsLoader.loadFits(self.serviceUrl, function (fits) {
                    var healpixMoc = {};
                    var binaryTable = fits.getHDU(1).data;

                    // setting startOrder with first order in dataTable
                    //self.startOrder = uniq2hpix(binaryTable.getRow(0)[binaryTable.columns[0]])[0];

                    for(i = 0; i < binaryTable.rows; i++) {
                        var uniq = binaryTable.getRow(i);
                        var hpix = HEALPixBase.uniq2hpix(uniq[binaryTable.columns[0]]);

                        var order = hpix[0];
                        if (healpixMoc[order] === undefined) {
                            healpixMoc[order] = [];
                        }
                        healpixMoc[order].push(hpix[1]);
                    }
                    // MIZAR CANNOT display MOC with order less than 3, convert the current moc to a moc starting a order 3
                    if(healpixMoc.hasOwnProperty("0") || healpixMoc.hasOwnProperty("1") || healpixMoc.hasOwnProperty("2")) {

                        for(i=0; i<3; i++) {
                            if(healpixMoc.hasOwnProperty(i)) {
                                var pixels = healpixMoc[i];
                                _.each(pixels, function(pixel) {
                                    var pix = HEALPixBase.getChildren(pixel);
                                    if(!healpixMoc.hasOwnProperty(i+1)){
                                        healpixMoc[i+1] = [];
                                    }
                                    healpixMoc[i+1].push(pix[0]);
                                    healpixMoc[i+1].push(pix[1]);
                                    healpixMoc[i+1].push(pix[2]);
                                    healpixMoc[i+1].push(pix[3]);
                                });
                                delete healpixMoc[i];
                            }
                        }
                    }
                    self.moc = healpixMoc;
                    self.handleDistribution(healpixMoc);
                    // TODO : comprendre la ligne suivante
                    // delete fits;
                });

            } else {
                $.ajax({
                    type: "GET",
                    url: self.serviceUrl,
                    dataType: 'json',
                    success: function (response) {
                        self.handleDistribution(response);
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        $('#addLayer_' + self.id).find('label').css("color", "red");
                        console.error(xhr.responseText);
                    }
                });
            }


            // As post renderer, moc layer will regenerate data on tiles in case of base imagery change
            g.tileManager.addPostRenderer(this);
        };

        /**************************************************************************************************************/

        /**
         * Generates moc data on tiles.
         * @function generate
         * @memberOf MocLayer#
         * @param {Tile} tile Tile
         */
        MocLayer.prototype.generate = function (tile) {
            if (this.featuresSet && tile.order === this.startOrder) {
                var geometries = this.featuresSet[tile.pixelIndex];
                if (geometries) {
                    for (var i = 0; i < geometries.length; i++) {
                        this.globe.vectorRendererManager.addGeometryToTile(this, geometries[i], this.style, tile);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Renders
         * @function render
         * @memberOf MocLayer#
         */
        MocLayer.prototype.render = function () {
            // No rendering
        };

        /**************************************************************************************************************/

        /**
         * Detaches the layer from the planet
         * @function _detach
         * @memberOf MocLayer#
         * @private
         */
        MocLayer.prototype._detach = function () {
            for (var tileIndex in this.featuresSet) {
                if(this.featuresSet.hasOwnProperty(tileIndex)) {
                    var tile = this.globe.tileManager.level0Tiles[tileIndex];
                    for (var i = 0; i < this.featuresSet[tileIndex].length; i++) {
                        this.globe.vectorRendererManager.removeGeometryFromTile(this.featuresSet[tileIndex][i], tile);
                    }
                }
            }
            this.featuresSet = null;
            this.globe.tileManager.removePostRenderer(this);

            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        /**
         * Returns children indices of starting tiling order.
         * @function findChildIndices
         * @memberOf MocLayer#
         * @param index Parent index
         * @param order Parent order
         */
        MocLayer.prototype.findChildIndices = function (index, order) {
            var childOrder = this.startOrder;
            var orderDepth = childOrder - order;
            var numSubTiles = Math.pow(4, orderDepth); // Number of subtiles depending on order
            var firstSubTileIndex = index * numSubTiles;
            var indices = [];
            for (var i = firstSubTileIndex; i < firstSubTileIndex + numSubTiles; i++) {
                indices.push(i);
            }

            return indices;
        };

        /**************************************************************************************************************/

        /**
         * Returns index of parent of starting tiling order.
         * @function findParentIndex
         * @memberOf MocLayer#
         * @param index Child index
         * @param order Child order
         */
        MocLayer.prototype.findParentIndex = function (index, order) {
            var parentOrder = this.startOrder;
            var orderDepth = order - parentOrder;
            return Math.floor(index / (Math.pow(4, orderDepth)));
        };

        /**************************************************************************************************************/

        /**
         * Handles MOC response.
         * @function handleDistribution
         * @memberOf MocLayer#
         * @param response MOC response
         */
        MocLayer.prototype.handleDistribution = function (response) {
            var gl = this.globe.tileManager.renderContext.gl;
            this.featuresSet = {};
            var parentIndex;
            var i,u,v;
            // For each order, compute rectangles geometry depending on the pixel index
            for (var key in response) {
                if(response.hasOwnProperty(key)) {
                    var order = parseInt(key, 10);
                    for (i = 0; i < response[key].length; i++) {
                        var pixelIndex = response[key][i];

                        if (order > this.startOrder) {
                            parentIndex = this.findParentIndex(pixelIndex, order);
                        }
                        else if (order === this.startOrder) {
                            parentIndex = pixelIndex;
                        }
                        else {
                            // Handle low orders(< 3) by creating children polygons of order 3
                            var indices = this.findChildIndices(pixelIndex, order);
                            if (response[this.startOrder.toString()] === undefined) {
                                response[this.startOrder.toString()] = response[0].concat(indices);
                            } else {
                                response[this.startOrder.toString()] = response[this.startOrder.toString()].concat(indices);

                            }
                            continue;
                        }

                        var geometry = {
                            type: Constants.GEOMETRY.Polygon,
                            gid: "moc" + this.id + "_" + order + "_" + pixelIndex,
                            coordinates: [[]]
                        };

                        // Build the vertices
                        var size = 2; // TODO
                        var step = 1;

                        // Tesselate only low-order tiles
                        if (order < 5) {
                            size = 5;
                            step = 1.0 / (size - 1);
                        }

                        var nside = Math.pow(2, order);
                        var pix = pixelIndex & (nside * nside - 1);
                        var ix = HEALPixBase.compress_bits(pix);
                        var iy = HEALPixBase.compress_bits(pix >>> 1);
                        var face = (pixelIndex >>> (2 * order));

                        var vertice, geo;

                        // Horizontal boudaries
                        for (u = 0; u < 2; u++) {
                            for (v = 0; v < size; v++) {
                                vertice = HEALPixBase.fxyf((ix + u * (size - 1) * step) / nside, (iy + v * step) / nside, face);
                                geo = this.globe.getCoordinateSystem().getWorldFrom3D(vertice);
                                if (u === 0) {
                                    // Invert to clockwise sense
                                    geometry.coordinates[0][2 * u * size + (size - 1) - v] = [geo[0], geo[1]];
                                }
                                else {
                                    geometry.coordinates[0][2 * u * size + v] = [geo[0], geo[1]];
                                }
                            }
                        }

                        // Vertical boundaries
                        for (v = 0; v < 2; v++) {
                            for (u = 0; u < size; u++) {
                                vertice = HEALPixBase.fxyf((ix + u * step) / nside, (iy + v * (size - 1) * step) / nside, face);
                                geo = this.globe.getCoordinateSystem().getWorldFrom3D(vertice);
                                if (v === 1) {
                                    // Invert to clockwise sense
                                    geometry.coordinates[0][size + 2 * v * size + (size - 1) - u] = [geo[0], geo[1]];
                                }
                                else {
                                    geometry.coordinates[0][size + 2 * v * size + u] = [geo[0], geo[1]];
                                }
                            }
                        }

                        var parentTile = this.globe.tileManager.level0Tiles[parentIndex];

                        if (!this.featuresSet[parentIndex]) {
                            this.featuresSet[parentIndex] = [];
                        }

                        this.featuresSet[parentIndex].push(geometry);
                        this.globe.vectorRendererManager.addGeometryToTile(this, geometry, this.style, parentTile);
                    }
                }
            }
        };

        return MocLayer;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/VectorRendererManager',[],function() {

/**************************************************************************************************************/

/**
  @name VectorRendererManager
  @class
	  VectorRendererManager constructor
  @param {AbstractGlobe} globe AbstractGlobe
  @constructor
  */
var VectorRendererManager = function(globe)
{
	// Create the registered renderers
	this.renderers = [];
	for ( var i = 0; i < VectorRendererManager.factory.length; i++ )
	{
		this.renderers.push( VectorRendererManager.factory[i](globe) );
	}


	// The array of renderables used during rendering
	this.renderables = [];

	// To uniquely identify buckets created by the renderers
	this.bucketId = 0;
};

/**************************************************************************************************************/

/**
	The factory for renderers
 */
VectorRendererManager.factory = [];

/**************************************************************************************************************/

/**
 * Get a renderer
 * @function getRenderer
 * @memberof VectorRendererManager.prototype
 * @param geometry
 * @param style
 * @return Renderer
 */
VectorRendererManager.prototype.getRenderer = function(geometry,style)
{
	for ( var i = 0; i < this.renderers.length; i++ )
	{
		if ( this.renderers[i].canApply(geometry.type,style) )
		{
			return this.renderers[i];
		}
	}

	return null;
};

/**************************************************************************************************************/

/**
 *	Generate the tile data
 * @function generate
 * @memberof VectorRendererManager.prototype
 * @param {Tile} tile Tile
 */
VectorRendererManager.prototype.generate = function(tile)
{
	var i;
	if ( !tile.parent )
	{
		for ( i=0; i < this.renderers.length; i++ )
		{
			this.renderers[i].generateLevelZero(tile);
		}
	}
	else
	{
		var tileData = tile.parent.extension.renderer;
		if ( tileData )
		{
			// delete renderer created at init time
			delete tile.extension.renderer;

			// Now generate renderables
			for ( i = 0; i < tileData.renderables.length; i++ )
			{
				var renderable = tileData.renderables[i];
				if ( renderable.generateChild )
				{
					renderable.generateChild( tile );
				}
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Add a geometry to the renderer
 * @function addGeometry
 * @memberof VectorRendererManager.prototype
 * @param layer
 * @param geometry
 * @param style
 */
VectorRendererManager.prototype.addGeometry = function(layer, geometry, style)
{
	var renderer = this.getRenderer(geometry,style);
	if (renderer) {
		renderer.addGeometry(layer, geometry, style);
	} else {
		console.log("No renderer for VectorRendererManager");
	}
};

/**************************************************************************************************************/

/**
 * Remove a geometry from the renderer
 * @function removeGeometry
 * @memberof VectorRendererManager.prototype
 * @param geometry
 * @param layer
 * @return {Boolean}
 */
VectorRendererManager.prototype.removeGeometry = function(geometry,layer)
{
	var bucket = geometry._bucket;
	if ( bucket && bucket.layer === layer )
	{
		bucket.renderer.removeGeometry(geometry);
		return true;
	}
	return false;
};

/**************************************************************************************************************/

/**
 * Add a geometry to a tile
 * @function addGeometryToTile
 * @memberof VectorRendererManager.prototype
 * @param layer
 * @param geometry
 * @param style
 * @param {Tile} tile Tile
 */
VectorRendererManager.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var renderer = this.getRenderer(geometry,style);
	renderer.addGeometryToTile(layer, geometry, style, tile);
};


/**************************************************************************************************************/

/**
 * Remove a geometry from a tile
 * @function removeGeometryFromTile
 * @memberof VectorRendererManager.prototype
 * @param geometry
 * @param {Tile} tile Tile
 */
VectorRendererManager.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var bucket = geometry._bucket;
	bucket.renderer.removeGeometryFromTile(geometry,tile);
};


/**************************************************************************************************************/

/**
 * Function to sort with zIndex, then bucket
 */
var renderableSort = function(r1,r2)
{
	var zdiff = r1.bucket.style.zIndex - r2.bucket.style.zIndex;
	if ( zdiff === 0 ) {
		return r1.bucket.id - r2.bucket.id;
	} else {
		return zdiff;
	}
};

/**************************************************************************************************************/

/**
 * Render all
 * @function render
 * @memberof VectorRendererManager.prototype
 */
VectorRendererManager.prototype.render = function()
{
	// Add main renderables
	var i,j;
	for ( j = 0; j < this.renderers.length; j++ )
	{

		var buckets = this.renderers[j].buckets;
		for ( i = 0; i < buckets.length; i++ )
		{
			if ( buckets[i].layer.isVisible() && buckets[i].mainRenderable)
			{
				this.renderables.push( buckets[i].mainRenderable );
			}
		}
	}

	// Renderable sort
	this.renderables.sort( renderableSort );

	//var renderCall = 0;

	i = 0;
	while ( i < this.renderables.length )
	{
		j = i + 1;
		var currentRenderer = this.renderables[i].bucket.renderer;
		while ( j < this.renderables.length && this.renderables[j].bucket.renderer === currentRenderer )
		{
			j++;
		}

		//var minLevel =  (this.renderables[i].bucket.layer.minLevel) ? this.renderables[i].bucket.layer.minLevel : 0;
		//var processedLevel = this.renderables[i].bucket.renderer.tileManager.processedLevel;
		//if(minLevel <= processedLevel) {
			currentRenderer.render(this.renderables, i, j);
		//}
		//renderCall++;

		i = j;
	}

	//console.log( "# of render calls "  + renderCall );

	this.renderables.length = 0;
};

/**************************************************************************************************************/

return VectorRendererManager;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/OpenSearch/OpenSearchUtils',[],function () {

    var OpenSearchUtils = {};

    /**
     *    Get attribute values from json
     */
    OpenSearchUtils.getAttributeValue = function (object,name) {
      var reconstructedName = "_attr"+name;
      if (typeof object[reconstructedName] !== 'undefined') {
        if (typeof object[reconstructedName]._value != 'undefined') {
          return object[reconstructedName]._value;
        }
      }
      return null;
    };

    OpenSearchUtils.getValue = function (object,name) {
      if (typeof object[name] !== 'undefined') {
        if (typeof object[name]._text !== 'undefined') {
          return object[name]._text;
        }
      }
      return null;
    };

    return OpenSearchUtils;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
 define('Layer/OpenSearch/OpenSearchParam',["./OpenSearchUtils"],
   function (OpenSearchUtils) {

   /**
    * @name OpenSearchParam
    * @class
    * All informations describing a parameter in an OpenSearch form
    * @param {Object} a json object describing the param
    * @memberOf module:Layer
    */
    var OpenSearchParam = function (paramJson) {
      // init all values
      this.name = null;         // Name of parameters
      this.value = null;        // Value identifying the parameters
      this.title = null;        // Title of parameter (for display)
      this.minInclusive = null; // (Level 1 Control - Number) Min value inclusive
      this.maxInclusive = null; // (Level 1 Control - Number) Max value inclusive
      this.pattern = null;      // (Level 1 Control - String) Pattern
      this.options = null;       // List of values if list provided

      this.parseJson(paramJson);
    };

    /**************************************************************************************************************/

    OpenSearchParam.prototype.parseJson = function (paramJson) {
      this.name = OpenSearchUtils.getAttributeValue(paramJson,"name");
      this.value = OpenSearchUtils.getAttributeValue(paramJson,"value");
      this.title = OpenSearchUtils.getAttributeValue(paramJson,"title");
      this.minInclusive = OpenSearchUtils.getAttributeValue(paramJson,"minInclusive");
      this.maxInclusive = OpenSearchUtils.getAttributeValue(paramJson,"maxInclusive");
      this.pattern = OpenSearchUtils.getAttributeValue(paramJson,"pattern");

      if (this.pattern === null) {
        this.patternAttribute = "";
      } else {
        this.patternAttribute = "pattern=\""+this.pattern+"\" ";
      }

      if (paramJson.Options !== undefined) {
        this.options = [];
        if (paramJson.Options.length !== undefined) {
          for (var i=0;i<paramJson.Options.length;i++) {
            this.options.push(OpenSearchUtils.getAttributeValue(paramJson.Options[i],"value"));
          }
        } else {
          this.options.push(OpenSearchUtils.getAttributeValue(paramJson.Options,"value"));
        }
      }

      if(this.options !== null) {
        this.type = "options";
      } else if ((this.minInclusive !== null) || (this.maxInclusive !== null)) {
        this.type = "number";
        if (this.title === null) {
          this.title = "";
        }
        if (this.maxInclusive === null) {
          this.title += "( >= "+this.minInclusive+" )";
        } else if (this.minInclusive === null) {
          this.title += "( <= "+this.maxInclusive+" )";
        } else {
          this.title += "( between "+this.minInclusive+" and "+this.maxInclusive+" )";
        }
      } else if (this.value.startsWith("{time:") === true) {
        this.type = "datetime";
      } else {
        this.type = "text";
      }

      if (this.title === null) {
        this.titleAttribute = "";
      } else {
        this.titleAttribute = "title=\""+this.title+"\" ";
      }
    };

    OpenSearchParam.prototype.toString = function () {
      var res = "";

      if (this.name !== null) {
        res+= "     name : "+this.name+"\n";
      }

      if (this.value !== null) {
        res+= "     value : "+this.value+"\n";
      }

      if (this.title !== null) {
        res+= "     title : "+this.title+"\n";
      }

      if (this.minInclusive !== null) {
        res+= "     minInclusive : "+this.minInclusive+"\n";
      }

      if (this.maxInclusive !== null) {
        res+= "     maxInclusive : "+this.maxInclusive+"\n";
      }

      if (this.pattern !== null) {
        res+= "     pattern : "+this.pattern+"\n";
      }

      if (this.options != null) {
        res+= "     options : ";
        for (var i=0;i<this.options.length;i++) {
          res+= this.options[i]+", ";
        }
        res+= "\n";
      }
      return res;
    }

    /*************************************************************************************************************/

    return OpenSearchParam;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
 define('Layer/OpenSearch/OpenSearchForm',["./OpenSearchParam","./OpenSearchUtils"],
   function (OpenSearchParam,OpenSearchUtils) {

   /**
    * @name OpenSearchForm
    * @class
    * All informations describing an OpenSearch form
    * @param {Object} paramsJson a json object describing the form
    * @param {String} type form to load (application/json or application/atom+xml)
    * @memberOf module:Layer
    */
    var OpenSearchForm = function (paramsJson,type) {
      // init all values
      this.type = null;         // type of form (only application/json supported)
      this.template = null;     // url template with params
      this.parameters = [];     // list of params

      this.parseJson(paramsJson,type);
    };

    /**************************************************************************************************************/

    OpenSearchForm.prototype.parseUrl = function (urlJson,type) {
      var typeValue = OpenSearchUtils.getAttributeValue(urlJson,"type");
      if (typeValue !== type) {
        // Not the good type, do not take it into account
        return;
      }
      this.type = typeValue;
      this.template = OpenSearchUtils.getAttributeValue(urlJson,"template");
      listParameters = urlJson.Parameter;
      if (typeof listParameters.length !== 'undefined') {
        for (var i=0;i<listParameters.length;i++) {
          this.parameters.push(new OpenSearchParam(listParameters[i]));
        }

      } else {
        this.parameters.push(new OpenSearchParam(listParameters));
      }
    }

    OpenSearchForm.prototype.toString = function () {
      var res = "";
      res+= "  type : "+this.type+"\n";
      res+= "  template : "+this.template+"\n";
      res+= "  parameters :\n";
      for (var i=0;i<this.parameters.length;i++) {
        res+= this.parameters[i].toString()+"\n";
      }
      return res;
    }

    OpenSearchForm.prototype.parseJson = function (paramsJson,type) {
      if (typeof paramsJson.length !== 'undefined') {
        // Management of an array
        for (var i=0;i<paramsJson.length;i++) {
          this.parseUrl(paramsJson[i],type);
        }
      } else {
        this.parseUrl(paramsJson,type);
      }
    };

    /*************************************************************************************************************/

    return OpenSearchForm;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
define('Layer/OpenSearchLayer',['../Renderer/FeatureStyle', '../Renderer/VectorRendererManager', '../Utils/Utils', './AbstractLayer', '../Renderer/RendererTileData', '../Tiling/Tile','../Utils/Constants','./OpenSearch/OpenSearchForm','./OpenSearch/OpenSearchUtils'],
    function (FeatureStyle, VectorRendererManager, Utils, AbstractLayer, RendererTileData, Tile, Constants,OpenSearchForm,OpenSearchUtils) {

        /**
         * @name OpenSearchLayer
         * @class
         * This layer draws an OpenSearch dynamic layer
         * @augments AbstractLayer
         * @param {Object} options Configuration properties for the layer. See {@link AbstractLayer} for base properties
         * @param {String} options.serviceUrl Url of OpenSearch description XML file
         * @param {int} [options.minOrder=5] Starting order for OpenSearch requests
         * @param {int} [options.maxRequests=2] Max request
         * @param {Boolean} [options.invertY=false] a boolean, if set all the image data of current layer is flipped along the vertical axis
         * @param {Boolean} [options.coordSystemRequired=true]
         * @param {FeatureStyle} [options.style=new FeatureStyle()]
         * @memberOf module:Layer
         */
          var OpenSearchLayer = function (options) {
            options.dataType = Constants.GEOMETRY.Point;
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.OpenSearch, options);

            if (typeof options.serviceUrl !== 'undefined') {
              this.serviceUrl = this.proxify(options.serviceUrl);
            }

            if (typeof options.getCapabilities !== 'undefined') {
              this.describeUrl = this.proxify(options.getCapabilities);
            }

            this.name = options.name;
            this.title = options.title;

            this.afterLoad = options.afterLoad;

            this.minOrder = options.minOrder || 5;
            this.maxRequests = options.maxRequests || 2;
            this.requestProperties = "";
            this.invertY = options.invertY || false;
            this.coordSystemRequired = options.hasOwnProperty('coordSystemRequired') ? options.coordSystemRequired : true;
            this.formDescription = null;

            this.extId = "os";

            // Used for picking management
            this.features = [];
            // Counter set, indicates how many times the feature has been requested
            this.featuresSet = {};

            // Maximum two requests for now
            this.freeRequests = [];
            this.tilesToLoad = [];

            // Build the request objects
            for (var i = 0; i < this.maxRequests; i++) {
                var xhr = new XMLHttpRequest();
                this.freeRequests.push(xhr);
            }

            if (typeof this.describeUrl !== 'undefined') {
              this.hasForm = true;
              this.loadGetCapabilities(this.manageCapabilities,this.describeUrl,this);
            } else {
              this.hasForm = false;
            }

        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, OpenSearchLayer);

        /**************************************************************************************************************/

        OpenSearchLayer.prototype.manageCapabilities = function (json,sourceObject) {
          // check if form description is well provided
          var dataForm = null;
          var openSearchRoot = json.OpenSearchDescription;
          if (typeof openSearchRoot !== 'undefined') {
            sourceObject.name  = (typeof sourceObject.name  !== 'undefined') ? sourceObject.name  : OpenSearchUtils.getValue(openSearchRoot,"ShortName");
            sourceObject.title = (typeof sourceObject.title !== 'undefined') ? sourceObject.title : OpenSearchUtils.getValue(openSearchRoot,"LongName");
            var urls = openSearchRoot.Url;
            if (typeof urls !== 'undefined') {
              dataForm = urls;
            }
          }
          if (dataForm != null) {
            // Load form description
            sourceObject.formDescription = new OpenSearchForm(dataForm,"application/json");
          } else {
            console.log("Form not correct");
          }

          if (typeof sourceObject.afterLoad === 'function') {
            // Update GUI !!
            sourceObject.afterLoad(sourceObject);

          }
        };

        /**************************************************************************************************************/


        /**
         * @name OSData
         * @class
         * OpenSearch renderable
         * @param {AbstractLayer} layer layer
         * @param {Tile} tile Tile
         * @param p Parent object
         */
        var OSData = function (layer, tile, p) {
            this.layer = layer;
            this.parent = p;
            this.tile = tile;
            this.featureIds = []; // exclusive parameter to remove from layer
            this.state = OpenSearchLayer.TileState.NOT_LOADED;
            this.complete = false;
            this.childrenCreated = false;
        };

        /**************************************************************************************************************/

        /**
         * Attaches the layer to the globe
         * @function _attach
         * @memberof OpenSearchLayer#
         * @param g The globe
         * @private
         */
        OpenSearchLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);
            this.extId += this.id;
            g.tileManager.addPostRenderer(this);
        };

        /**************************************************************************************************************/

        /**
         * Detach the layer from the globe
         * @function _detach
         * @memberof OpenSearchLayer#
         * @private
         */
        OpenSearchLayer.prototype._detach = function () {
            this.globe.tileManager.removePostRenderer(this);
            AbstractLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        /**
         * Launches request to the OpenSearch service.
         * @function launchRequest
         * @memberof OpenSearchLayer#
         * @param {Tile} tile Tile
         * @param {String} url Url
         * @fires Context#startLoad
         * @fires Context#endLoad
         * @fires Context#features:added
         */
        OpenSearchLayer.prototype.launchRequest = function (tile, url) {
            var tileData = tile.extension[this.extId];
            var index = null;

            if (this.freeRequests.length === 0) {
                return;
            }

            // Set that the tile is loading its data for OpenSearch
            tileData.state = OpenSearchLayer.TileState.LOADING;

            // Add request properties to length
            if (this.requestProperties !== "") {
                url += '&' + this.requestProperties;
            }

            // Pusblish the start load event, only if there is no pending requests
            if (this.maxRequests === this.freeRequests.length) {
                this.globe.publishEvent("startLoad", this);
            }

            var xhr = this.freeRequests.pop();
            var self = this;

            xhr.onreadystatechange = function (e) {
                var i,feature;
                var response;
                var alreadyAdded;
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        response = JSON.parse(xhr.response);

                        tileData.complete = (response.totalResults === response.features.length);
                        self.updateFeatures(response.features);

                        for (i = response.features.length - 1; i >= 0; i--) {
                            feature = response.features[i];
                            // Eliminate already added features from response
                            //Old version compatibily
                            if (!feature.hasOwnProperty("id")) {
                                feature.id = feature.properties.identifier;
                            }
                            alreadyAdded = self.featuresSet.hasOwnProperty(feature.id);
                            if (alreadyAdded) {
                                response.features.splice(i, 1);
                            }

                            self.addFeature(feature, tile);
                        }
                        self.globe.refresh();
                    }
                    else if (xhr.status >= 400) {
                        tileData.complete = true;
                        console.error(xhr.responseText);
                        return;
                    }

                    tileData.state = OpenSearchLayer.TileState.LOADED;
                    self.freeRequests.push(xhr);

                    // Publish event that layer have received new features
                    if (response !== undefined && response.features !== null && response.features.length > 0) {
                        self.globe.publishEvent("features:added", {layer: self, features: response.features});
                    }

                    // Publish the end load event, only if there is no pending requests
                    if (self.maxRequests === self.freeRequests.length) {
                        self.globe.publishEvent("endLoad", self);
                    }
                }
            };
            xhr.open("GET", url);
            xhr.send();
        };

        /**************************************************************************************************************/

        /**
         * Sets the new request properties
         * @function setRequestProperties
         * @memberof OpenSearchLayer#
         * @param properties
         */
        OpenSearchLayer.prototype.setRequestProperties = function (properties) {
            // clean renderers
            for (var x in this.featuresSet) {
                if(this.featuresSet.hasOwnProperty(x)) {
                    var featureData = this.featuresSet[x];
                    for (var i = 0; i < featureData.tiles.length; i++) {
                        var tile = featureData.tiles[i];
                        var feature = this.features[featureData.index];
                        this.globe.vectorRendererManager.removeGeometryFromTile(this, feature.geometry, tile);
                    }
                }
            }

            // Clean old results
            var self = this;
            this.globe.tileManager.visitTiles(function (tile) {
                if (tile.extension[self.extId]) {
                    tile.extension[self.extId].dispose();
                    tile.extension[self.extId].featureIds = []; // exclusive parameter to remove from layer
                    tile.extension[self.extId].state = OpenSearchLayer.TileState.NOT_LOADED;
                    tile.extension[self.extId].complete = false;
                }
            });
            this.featuresSet = {};
            this.features = [];

            // Set request properties
            this.requestProperties = "";
            for (var key in properties) {
                if (this.requestProperties !== "") {
                    this.requestProperties += '&';
                }
                this.requestProperties += key + '=' + properties[key];
            }

        };

        /**************************************************************************************************************/

        /**
         * Adds feature to the layer and to the tile extension.
         * @function addFeature
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {Tile} tile Tile
         */
        OpenSearchLayer.prototype.addFeature = function (feature, tile) {
            var tileData = tile.extension[this.extId];
            var featureData;

            // Add feature if it doesn't exist
            //if ( !this.featuresSet.hasOwnProperty(feature.properties.identifier) )
            if (!this.featuresSet.hasOwnProperty(feature.id)) {
                this.features.push(feature);
                featureData = {
                    index: this.features.length - 1,
                    tiles: [tile]
                };
                this.featuresSet[feature.properties.identifier] = featureData;
                this.featuresSet[feature.id] = featureData;
            }
            else {
                //featureData = this.featuresSet[feature.properties.identifier];
                featureData = this.featuresSet[feature.id];

                // Store the tile
                featureData.tiles.push(tile);

                // Always use the base feature to manage geometry indices
                feature = this.features[featureData.index];
            }

            // Add feature id
            //tileData.featureIds.push( feature.properties.identifier );
            tileData.featureIds.push(feature.id);

            // Set the identifier on the geometry
            //feature.geometry.gid = feature.properties.identifier;
            feature.geometry.gid = feature.id;

            // Add to renderer
            //this.addFeatureToRenderer(feature, tile);

            // MS: Feature could be added from ClusterOpenSearch which have features with different styles
            var style = feature.properties.style ? feature.properties.style : this.style;

            this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
        };


        /**************************************************************************************************************/

        /**
         * Removes feature from Dynamic OpenSearch layer.
         * @function removeFeature
         * @memberof OpenSearchLayer#
         * @param {String} identifier identifier
         * @param {Tile} tile Tile
         */
        OpenSearchLayer.prototype.removeFeature = function (identifier, tile) {
            var featureIt = this.featuresSet[identifier];

            if (!featureIt) {
                return;
            }

            // Remove tile from array
            var tileIndex = featureIt.tiles.indexOf(tile);
            if (tileIndex >= 0) {
                featureIt.tiles.splice(tileIndex, 1);
            }
            else {
                console.log('OpenSearchLayer internal error : tile not found when removing feature');
            }

            if (featureIt.tiles.length === 0) {
                // Remove it from the set
                delete this.featuresSet[identifier];

                // Remove it from the array by swapping it with the last feature to optimize removal.
                var lastFeature = this.features.pop();
                if (featureIt.index < this.features.length) {
                    // Set the last feature at the position of the removed feature
                    this.features[featureIt.index] = lastFeature;
                    // Update its index in the Set.
                    //this.featuresSet[ lastFeature.properties.identifier ].index = featureIt.index;
                    this.featuresSet[lastFeature.id].index = featureIt.index;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Modifies feature style.
         * @function modifyFeatureStyle
         * @memberof OpenSearchLayer#
         * @param {Feature} feature Feature
         * @param {FeatureStyle} style Style
         */
        OpenSearchLayer.prototype.modifyFeatureStyle = function (feature, style) {
            feature.properties.style = style;
            //var featureData = this.featuresSet[feature.properties.identifier];
            var featureData = this.featuresSet[feature.id];
            if (featureData) {
                for (var i = 0; i < featureData.tiles.length; i++) {
                    var tile = featureData.tiles[i];
                    this.globe.vectorRendererManager.removeGeometryFromTile(feature.geometry, tile);
                    this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
                }
            }
        };

        OpenSearchLayer.TileState = {
            LOADING: 0,
            LOADED: 1,
            NOT_LOADED: 2,
            INHERIT_PARENT: 3
        };


        /**************************************************************************************************************/

        /**
         * Generate the tile data
         * @function generate
         * @memberof OpenSearchLayer#
         * @param {Tile} tile Tile
         */
        OpenSearchLayer.prototype.generate = function (tile) {
            if (tile.order === this.minOrder) {
                tile.extension[this.extId] = new OSData(this, tile, null);
            }
        };

        /**************************************************************************************************************/

        /**
         * Traverse
         * @function traverse
         * @memberof OSData.prototype
         * @param {Tile} tile Tile
         */
        OSData.prototype.traverse = function (tile) {
            if (!this.layer.isVisible()) {
                return;
            }

            if (tile.state !== Tile.State.LOADED) {
                return;
            }

            // Check if the tile need to be loaded
            if (this.state === OpenSearchLayer.TileState.NOT_LOADED) {
                this.layer.tilesToLoad.push(this);
            }

            // Create children if needed
            if (this.state === OpenSearchLayer.TileState.LOADED && !this.complete && tile.state === Tile.State.LOADED && tile.children && !this.childrenCreated) {
                var i;
                for (i = 0; i < 4; i++) {
                    if (!tile.children[i].extension[this.layer.extId]) {
                        tile.children[i].extension[this.layer.extId] = new OSData(this.layer, tile.children[i], this);
                    }
                }
                this.childrenCreated = true;


                // HACK : set renderable to have children
                var renderables = tile.extension.renderer ? tile.extension.renderer.renderables : [];
                for (i = 0; i < renderables.length; i++) {
                    if (renderables[i].bucket.layer === this.layer) {
                        renderables[i].hasChildren = true;
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Dispose renderable data from tile
         * @function dispose
         * @memberof OSData.prototype
         * @param renderContext
         * @param tilePool
         */
        OSData.prototype.dispose = function (renderContext, tilePool) {
            var i;
            if (this.parent && this.parent.childrenCreated) {
                this.parent.childrenCreated = false;
                // HACK : set renderable to not have children!
                var renderables = this.parent.tile.extension.renderer ? this.parent.tile.extension.renderer.renderables : [];
                for (i = 0; i < renderables.length; i++) {
                    if (renderables[i].bucket.layer === this.layer) {
                        renderables[i].hasChildren = false;
                    }
                }
            }
            for (i = 0; i < this.featureIds.length; i++) {
                this.layer.removeFeature(this.featureIds[i], this.tile);
            }
            this.tile = null;
            this.parent = null;
        };

        /**************************************************************************************************************/

        /**
         * Build request url
         * @function buildUrl
         * @memberof OpenSearchLayer#
         * @param {Tile} tile tile
         * @return {String} Url
         */
        OpenSearchLayer.prototype.buildUrl = function (tile) {
            var url = this.serviceUrl + "/search?order=" + tile.order + "&healpix=" + tile.pixelIndex;

            /*if (this.transformer != undefined && typeof beforeHandle == 'function') {
                var url = this.transformer.beforeHandle(url);
            }*/

            if (this.coordSystemRequired) {
                // OpenSearchLayer always works in equatorial
                url += "&coordSystem=EQUATORIAL";
            }
            url += "&media=json";
            return url;
        };

        /**************************************************************************************************************/

        /**
         * Internal function to sort tiles
         * @function _sortTilesByDistance
         * @param {Tile} t1 First tile
         * @param {Tile} t2 Second tile
         * @private
         */
        function _sortTilesByDistance(t1, t2) {
            return t1.tile.distance - t2.tile.distance;
        }

        /**
         * Render function
         * @function render
         * @memberof OpenSearchLayer#
         * @param tiles The array of tiles to render
         */
        OpenSearchLayer.prototype.render = function (tiles) {
            if (!this.isVisible()) {
                return;
            }

            // Sort tiles
            this.tilesToLoad.sort(_sortTilesByDistance);

            // Load data for the tiles if needed
            for (var i = 0; i < this.tilesToLoad.length && this.freeRequests.length > 0; i++) {
                var tile = this.tilesToLoad[i].tile;
                var url = this.buildUrl(tile);
                if (url) {
                    this.launchRequest(tile, url);
                }
            }

            this.tilesToLoad.length = 0;
        };

        /**************************************************************************************************************/

        /**
         * Update features
         * @function updateFeatures
         * @memberof OpenSearchLayer#
         * @param {Array} features Array of features
         */
        OpenSearchLayer.prototype.updateFeatures = function (features) {
            for (var i = 0; i < features.length; i++) {
                var currentFeature = features[i];

                switch (currentFeature.geometry.type) {
                    case Constants.GEOMETRY.Point:

                        // Convert to default coordinate system if needed
                        /*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
                         {
                         currentFeature.geometry.coordinates = CoordinateSystem.convert(currentFeature.geometry.coordinates, this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
                         }*/

                        // Convert to geographic to simplify picking
                        if (currentFeature.geometry.coordinates[0] > 180) {
                            currentFeature.geometry.coordinates[0] -= 360;
                        }
                        break;
                    case Constants.GEOMETRY.Polygon:
                        var ring = currentFeature.geometry.coordinates[0];
                        for (var j = 0; j < ring.length; j++) {
                            // Convert to default coordinate system if needed
                            /*if ( "EQ" != this.globe.tileManager.imageryProvider.tiling.coordSystem )
                             {
                             ring[j] = CoordinateSystem.convert(ring[j], this.globe.tileManager.imageryProvider.tiling.coordSystem, "EQ");
                             }*/

                            // Convert to geographic to simplify picking
                            if (ring[j][0] > 180) {
                                ring[j][0] -= 360;
                            }
                        }
                        break;
                    default:
                        break;
                }
            }
        };

        /*************************************************************************************************************/

        return OpenSearchLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Layer/WMSElevationLayer',['../Utils/Utils', './WMSLayer'],
    function (Utils, WMSLayer) {

        /**
         * WCSElevation configuration
         * @typedef {AbstractRasterLayer.wms_configuration} AbstractRasterLayer.wmsElevation_configuration
         * @property {int} [tilePixelSize = 33]
         */

        /**
         * @name WMSElevationLayer
         * @class
         *    Creates a layer for elevation data using WMS protocol based on a GeoTiling(4, 2)
         *    with a pixelSize = 33 by default. The only supported format is currently image/x-aaigrid.
         * @augments WMSLayer
         * @param {AbstractLayer.wmsElevation_configuration} options - WMSElevation configuration
         * @constructor
         * @memberOf module:Layer
         */
        var WMSElevationLayer = function (options) {
            options.format = 'image/x-aaigrid';
            options.tilePixelSize = options.tilePixelSize || 33;
            WMSLayer.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(WMSLayer, WMSElevationLayer);

        /**************************************************************************************************************/

        /**
         * Parse a elevation response
         * @function parseElevations
         * @memberOf WMSElevationLayer#
         * @param {String} text Response as text
         * @return {float[]} Array of float
         */
        WMSElevationLayer.prototype.parseElevations = function (text) {
            var elevations = [];
            var lines = text.trim().split('\n');

            for (var i = 5; i < lines.length; i++) {
                var elts = lines[i].trim().split(/\s+/);
                for (var n = 0; n < elts.length; n++) {
                    elevations.push(parseInt(elts[n], 10));
                }
            }

            return elevations;
        };

        /**************************************************************************************************************/

        return WMSElevationLayer;

    });

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/utils',[],function () {

    var Utils = {};

    /**
     * Inherits from an object
     * @author Jean-Christophe Malapert
     */
    Utils.inherits = function(base, sub)
    {
        function tempCtor() {}
        tempCtor.prototype = base.prototype;
        sub.prototype = new tempCtor();
        sub.prototype.constructor = sub;
    };


    Utils.makeHttpObject = function() {
        try {
            return new XMLHttpRequest();
        }
        catch (erreur) {
        }
        try {
            return new ActiveXObject("Msxml2.XMLHTTP");
        }
        catch (erreur) {
        }
        try {
            return new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch (erreur) {
        }

        throw new Error("The object creation for making HTTP requests has failed.");
    };

    Utils.guid = function() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
            s4() + '-' + s4() + s4() + s4();
    };

    Utils.findValueByKeyword = function(listKeywords, keyword) {
        var result = undefined;
        for(i=0 ; i<listKeywords.length;i++) {
            var currentKeyword = listKeywords[i];
            if (currentKeyword[0] === keyword) {
                result = currentKeyword[1];
                break;
            }
        }
        return result;
    };

    Utils.parseXML = function (val) {
        if (document.implementation && document.implementation.createDocument) {
            xmlDoc = new DOMParser().parseFromString(val, 'text/xml');
        }
        else if (window.ActiveXObject) {
            xmlDoc = new ActiveXObject("Microsoft.XMLDOM");
            xmlDoc.loadXML(val);
        }
        else
        {
            alert('Your browser cannot handle this script');
            return null;
        }
        return xmlDoc;
    };

    return Utils;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/cache',[],function() {

    /**
     * Cache system for VOTable.
     * @exports Cache
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Cache = function () {
        this.nodeID = {};
        this.nodeName = {};
        this.warnings = [];
    };

    /**
     * Returns the cache of all nodes having an attribute ID.
     * @returns {Object.<String, AbstractNode>} the cache
     */
    Cache.prototype.getEltsByID = function() {
        return this.nodeID;
    };

    /**
     * Returns the cache of all nodes having an attribute name.
     * @returns {Object.<String, AbstractNode[]>} the cache
     */
    Cache.prototype.getEltsByName = function() {
        return this.nodeName;
    };

    /**
     * Returns the warnings.
     * @returns {String[]} the warnings
     */
    Cache.prototype.getWarnings = function() {
        return this.warnings;
    };

    /**
     * Add an entry to the cache.
     * @param {String} id the identifier of the VOTable element
     * @param {AbstractNode} node VOTable element
     */
    Cache.prototype.addEntryID = function(id, node) {
        this.nodeID[id] = node;
    };

    /**
     * Add an entry to the cache.
     * @param {String} name the identifier of the VOTable element
     * @param {AbstractNode} node VOTable element
     */
    Cache.prototype.addEntryName = function(name, node) {
        if(this.nodeName.hasOwnProperty(name)) {
            this.nodeName[name].push(node);
        } else {
            this.nodeName[name] = [];
            this.nodeName[name].push(node);
        }
    };

    /**
     * Stores a new warning;
     * @param warning warning
     */
    Cache.prototype.addWarning = function(warning) {
        this.warnings.push(warning);
    };

    return Cache;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/abstractNode',["./utils", "./cache"], function(Utils, Cache) {

    /**
     * Abstract node.
     *
     * Parses the attributes.
     *
     * @param {NodeList} childNode XML node
     * @exports AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var AbstractNode = function(childNode) {
        this.attributes = {};
        if (childNode!=null && childNode.nodeType == 1) {
            for(var i = 0, l = childNode.attributes.length; i < l; i++) {
                var attribute = childNode.attributes[i];
                this.attributes[attribute.name] = attribute.value;
            }
            if (this.attributes.hasOwnProperty("ID")) {
                var cache = Singleton.getInstance();
                cache.addEntryID(this.attributes["ID"], this);
            }
            if (this.attributes.hasOwnProperty("name")) {
                var cache = Singleton.getInstance();
                cache.addEntryName(this.attributes["name"], this);
            }
        }
    };

    /**
     * Returns the attributes of a tag.
     * @returns {String[]} the attributes
     */
    AbstractNode.prototype.getAttributes = function() {
        return this.attributes;
    };

    /**
     * Checks if the tag has the "name" as attribute
     * @param name the attribute name to test
     * @returns {boolean} true when the attribute is defined otherwose false
     */
    AbstractNode.prototype.hasAttribute = function(name) {
        return this.attributes.hasOwnProperty(name);
    };

    /**
     * Checks if the tag has attributes
     * @returns {boolean} true when the tag has at least one attribute otherwise false.
     */
    AbstractNode.prototype.hasAttributes = function() {
        return (Object.keys(this.attributes).length == 0) ? false : true;
    };

    /**
     * Returns the cache.
     * @returns {Cache}
     */
    AbstractNode.prototype.getCache = function() {
        return Singleton.getInstance();
    };

    /**
     * Creates a singeton for the cache.
     * @type {{getInstance}}
     */
    var Singleton = (function () {
        var instance;

        function createInstance() {
            var object = new Cache();
            return object;
        }

        return {
            getInstance: function () {
                if (!instance) {
                    instance = createInstance();
                }
                return instance;
            }
        };
    })();

    return AbstractNode;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/description',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Creates a Description object.
     * @param {NodeList} childNode
     * @exports Description
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Description = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.value;
        var element = childNode.childNodes[0];
        if (element!= null && element.nodeType == 3) {
            this.value = (element.textContent == null) ? null : element.textContent.trim();
        }

    };

    Utils.inherits(AbstractNode , Description);

    /**
     * Returns the content.
     * @returns {!String} the content
     */
    Description.prototype.getContent = function() {
        return this.value;
    };


    return Description;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/fieldref',["./utils", "./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Construct the Fieldref object.
     *
     * @example <caption>Fieldref schema</caption>
     * {@lang xml}
     *  <xs:complexType name="FieldRef">
     *      <xs:attribute name="ref" type="xs:IDREF" use="required"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the FieldRef node
     * @exports Fieldref
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Fieldref = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode , Fieldref );

    /**
     * Returns the ref value.
     * this attribute is required.
     * @returns {!String} the ref value
     */
    Fieldref.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Fieldref.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Fieldref.prototype.utype = function() {
        return this.attributes["utype"];
    };

    return Fieldref;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/paramref',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs the Paramref object.
     *
     * @example <caption>Paramref schema</caption>
     * {@lang xml}
     *  <xs:complexType name="ParamRef">
     *      <xs:attribute name="ref" type="xs:IDREF" use="required"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the ParamRef node
     * @exports Paramref
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Paramref = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode , Paramref );

    /**
     * Returns the ref value.
     * @returns {!String} the ref value
     */
    Paramref.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Paramref.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no value attribute.
     */
    Paramref.prototype.utype = function() {
        return this.attributes["utype"];
    };

    return Paramref;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/min',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Construct a Min object.
     *
     * @example <caption>Min schema</caption>
     * {@lang xml}
     *   <xs:complexType name="Min">
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *      <xs:attribute name="inclusive" type="yesno" default="yes"/>
     *   </xs:complexType>
     *
     * @param {NodeList} childNode the Min node
     * @exports Min
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Min = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode , Min );

    /**
     * Returns the value value.
     * @returns {!String} the value value
     */
    Min.prototype.value = function() {
        return this.attributes["value"];
    };

    /**
     * Returns the inclusive value.
     * @returns {?String} the inclusive value or null when no inclusive attribute.
     */
    Min.prototype.inclusive = function() {
        return this.attributes["inclusive"];
    };

    return Min;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/max',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs the Max object
     *
     * @example <caption>Max schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Max">
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *      <xs:attribute name="inclusive" type="yesno" default="yes"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Max node
     * @exports Max
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Max = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode , Max );

    /**
     * Returns the value value.
     * @returns {!String} the value value.
     */
    Max.prototype.value = function() {
        return this.attributes["value"];
    };

    /**
     * Returns the inclusive value.
     * @returns {?String} the inclusive value or null when no inclusive attribute.
     */
    Max.prototype.inclusive = function() {
        return this.attributes["inclusive"];
    };

    return Max;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/option',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs the Option object.
     *
     * @example <caption>Option schema</caption>
     * {@lang xml}     
     *  <xs:complexType name="Option">
     *      <xs:sequence>
     *          <xs:element name="OPTION" type="Option" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="value" type="xs:string" use="required"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Option node
     * @exports Option
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Option = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.options = parseOptionTag(childNode);
    };

    /**
     * Parses the Option node.
     * @param childNode the option node.
     * @returns {Option[]} the list of options
     */
    var parseOptionTag = function(childNode) {
        var options = [];
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "OPTION") {
                    options.push(new Option(element));
                }  else {
                    this.getCache().addWarning("unknown element "+nodeName+" in Option node");
                }
            }
        }
        return options;
    };

    Utils.inherits(AbstractNode , Option );

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Option.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the value value.
     * @returns {!String} the value value.
     */
    Option.prototype.value = function() {
        return this.attributes["value"];
    };

    /**
     * Returns the list of OPTION nodes.
     * @returns {?Option[]} the list of OPTION nodes or 0 length when no OPTION node.
     */
    Option.prototype.getOptions = function() {
        return this.options;
    };

    return Option;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/values',["./utils","./abstractNode","./min","./max","./option"], function(Utils, AbstractNode, Min, Max, Option) {

    /**
     * Constructs VALUES object.
     *
     * VALUES expresses the values that can be taken by the data in a column or by a parameter.
     *
     * @example <caption>Values schema</caption>
     * {@lang xml}
     * <xs:complexType name="Values">
     *  <xs:sequence>
     *      <xs:element name="MIN" type="Min" minOccurs="0"/>
     *      <xs:element name="MAX" type="Max" minOccurs="0"/>
     *      <xs:element name="OPTION" type="Option" minOccurs="0" maxOccurs="unbounded"/>
     *  </xs:sequence>
     *  <xs:attribute name="ID" type="xs:ID"/>
     *  <xs:attribute name="type" default="legal">
     *  <xs:simpleType>
     *      <xs:restriction base="xs:NMTOKEN">
     *          <xs:enumeration value="legal"/>
     *          <xs:enumeration value="actual"/>
     *      </xs:restriction>
     *  </xs:simpleType>
     *  </xs:attribute>
     *  <xs:attribute name="null" type="xs:token"/>
     *  <xs:attribute name="ref"  type="xs:IDREF"/>
     * </xs:complexType>
     *
     * @param {NodeList} childNode the VALUES node
     * @exports Values
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Values = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseValuesTag(childNode);
        this.min = result[0];
        this.max = result[1];
        this.options = result[2];
    };


    /**
     * Parses the VALUES node.
     *
     * @param {NodeList} childNode the VALUES node
     * @returns {Object.<Min,Max,Option[]>} the values
     */
    var parseValuesTag = function(childNode) {
        var min;
        var max;
        var options = [];
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "MIN":
                        min = new Min(element);
                        break;
                    case "MAX":
                        max = new Max(element);
                        break;
                    case "OPTION":
                        options.push(new Option(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Values node");
                }
            }
        }
        return [min, max, options];
    };

    Utils.inherits(AbstractNode , Values );

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} ID value or null when no ID attribute.
     */
    Values.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the type value of the attribute.
     * type attribute can get the following values:
     * <ul>
     *     <li>legal</li>
     *     <li>actual</li>
     * </ul>
     * @returns {!String} the type value.
     */
    Values.prototype.type = function() {
        return this.attributes["type"];
    };

    /**
     * Returns the null value of the attribute.
     * @returns {?String} the null value or null when no null attribute.
     */
    Values.prototype.null = function() {
        return this.attributes["null"];
    };

    /**
     * Returns the ref value of the attribute.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Values.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the Min object of the attribute.
     * @returns {?Min} the Min object or null when no Min node.
     */
    Values.prototype.getMin = function() {
        return this.min;
    };

    /**
     * Returns the Max object of the attribute.
     * @returns {?Max} the Max object or null when no Max node.
     */
    Values.prototype.getMax = function() {
        return this.max;
    };

    /**
     * Returns the list of Options objects.
     * 
     * Option is a sequence element of the Values node.
     * 
     * @returns {?Option[]} the list of Option objects or 0 length when no Option node.
     */
    Values.prototype.getOptions = function() {
        return this.options;
    };

    return Values;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/link',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs the Link object.
     *
     * @example <caption>Link schema</caption>
     * {@lang xml}
     * The LINK is a URL (href) or some other kind of reference (gref)
     * <xs:complexType name="Link">
     *      <xs:attribute name="ID" type="xs:ID"/>
     *      <xs:attribute name="content-role" type="xs:token"/>
     *      <xs:attribute name="content-type" type="xs:token"/>
     *      <xs:attribute name="title" type="xs:string"/>
     *      <xs:attribute name="value" type="xs:string"/>
     *      <xs:attribute name="href" type="xs:anyURI"/>
     *      <xs:attribute name="gref" type="xs:token"/>
     *      <xs:attribute name="action" type="xs:anyURI"/>
     * </xs:complexType>
     * 
     * @param {NodeList} childNode the Link node
     * @exports Link
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Link = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(AbstractNode , Link );

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Link.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the content-role value.
     * @returns {?String} the content-role value or null when no content-role attribute.
     */
    Link.prototype.content_role = function() {
        return this.attributes["content-role"];
    };

    /**
     * Returns the content-type value.
     * @returns {?String} the content-type value or null when no content-type attribute.
     */
    Link.prototype.content_type = function() {
        return this.attributes["content-type"];
    };

    /**
     * Returns the title value.
     * @returns {?String} the title value or null when no title attribute.
     */
    Link.prototype.title = function() {
        return this.attributes["title"];
    };

    /**
     * Returns the value value.
     * @returns {?String} the value value or null when no value attribute.
     */
    Link.prototype.value = function() {
        return this.attributes["value"];
    };

    /**
     * Returns the href value.
     * @returns {?String} the href value or null when no href attribute.
     */
    Link.prototype.href = function() {
        return this.attributes["href"];
    };

    /**
     * Returns the gref value.
     * @returns {?String} the gref value or null when no gref attribute.
     */
    Link.prototype.gref = function() {
        return this.attributes["gref"];
    };

    /**
     * Returns the action value.
     * @returns {?String} the action value or null when no action attribute.
     */
    Link.prototype.action = function() {
        return this.attributes["action"];
    };

    return Link;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/field',["./utils","./abstractNode","./description","./values","./link"], 
    function(Utils, AbstractNode, Description, Values, Link) {

    /**
     * Constructs the Field object.
     *
     * FIELD is the definition of what is in a column of the table.
     *
     * @example <caption>Field schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Field">
     *      <xs:sequence> <!-- minOccurs="0" maxOccurs="unbounded" -->
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="VALUES" type="Values" minOccurs="0"/> <!-- maxOccurs="2" -->
     *          <xs:element name="LINK" type="Link" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID" type="xs:ID"/>
     *      <xs:attribute name="unit" type="xs:token"/>
     *      <xs:attribute name="datatype" type="dataType" use="required"/>
     *      <xs:attribute name="precision" type="precType"/>
     *      <xs:attribute name="width" type="xs:positiveInteger"/>
     *      <xs:attribute name="xtype" type="xs:token"/>
     *      <xs:attribute name="ref" type="xs:IDREF"/>
     *      <xs:attribute name="name" type="xs:token" use="required"/>
     *      <xs:attribute name="ucd" type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="arraysize" type="xs:string"/>
     *      <xs:attribute name="type">
     *          <xs:simpleType>
     *              <xs:restriction base="xs:NMTOKEN">
     *                  <xs:enumeration value="hidden"/>
     *                  <xs:enumeration value="no_query"/>
     *                  <xs:enumeration value="trigger"/>
     *                  <xs:enumeration value="location"/>
     *              </xs:restriction>
     *          </xs:simpleType>
     *      </xs:attribute>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the FIELD node
     * @exports Field
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Field = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseField(childNode);
        this.description = result[0];
        this.values = result[1];
        this.links = result[2];
    };

    /**
     * Parses the FIELD node.
     * @param {NodeList} childNode the FIELD node
     * @returns {Object.<Description,Values,Link[]>} an array of description, values, link
     */
    var parseField = function(childNode) {
        var description;
        var values;
        var links = [];
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "VALUES":
                        values = new Values(element);
                        break;
                    case "LINK":
                        links.push(new Link(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Field node");
                }
            }
        }
        return [description, values, links];
    };

    Utils.inherits(AbstractNode , Field );

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Field.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the unit value.
     * @returns {?String} the unit value or null when no unit attribute.
     */
    Field.prototype.unit = function() {
        return this.attributes["unit"];
    };

    /**
     * Returns the datatype value.
     * @returns {!String} the datatype value
     */
    Field.prototype.datatype = function() {
        return this.attributes["datatype"];
    };

    /**
     * Returns the precision value.
     * @returns {?String} the precision value or null when no precision attribute.
     */
    Field.prototype.precision = function() {
        return this.attributes["precision"];
    };

    /**
     * Returns the width value.
     * @returns {?String} the width value or null when no width attribute.
     */
    Field.prototype.width = function() {
        return this.attributes["width"];
    };

    /**
     * Returns the xtype value.
     * @returns {?String} the xtype value or null when no xtype attribute.
     */
    Field.prototype.xtype = function() {
        return this.attributes["xtype"];
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Field.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the name value.
     * @returns {!String} the name value.
     */
    Field.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Field.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Field.prototype.utype = function() {
        return this.attributes["utype"];
    };

    /**
     * Returns the arraysize value.
     * @returns {?String} the arraysize value or null when no arraysize attribute.
     */
    Field.prototype.arraysize = function() {
        return this.attributes["arraysize"];
    };

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Field.prototype.type = function() {
        return this.attributes["type"];
    };

    /**
     * Returns the Description object
     * @returns {?Description} the Description object or null when no Description node.
     */
    Field.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the Values object.
     * @returns {?Values} the Values object or null when no Values node.
     */
    Field.prototype.getValues = function() {
        return this.values;
    };

    /**
     * Returns the set of Link objects.
     * @returns {?Link} the set of Link objects or null when no Link node
     */
    Field.prototype.getLinks = function() {
        return this.links;
    };

    return Field;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/param',["./utils","./field"], function(Utils, Field) {

    /**
     * Constructs the Param object.
     *
     * @example <caption>Param schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Param">
     *      <xs:complexContent>
     *          <xs:extension base="Field">
     *              <xs:attribute name="value" type="xs:string" use="required"/>
     *          </xs:extension>
     *      </xs:complexContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Param node
     * @exports Param
     * @augments Field
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Param = function(childNode) {
        Field.prototype.constructor.call(this, childNode);
    };

    Utils.inherits(Field , Param );

    /**
     * Returns the value value.
     * @returns {!String} the value value or null when no value attribute.
     */
    Param.prototype.value = function() {
        return this.attributes["value"];
    };

    return Param;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/group',["./utils","./abstractNode","./description","./fieldref","./paramref","./param"],
    function(Utils, AbstractNode, Description, Fieldref, Paramref, Param) {

    /**
     * Constructs the Group object.
     *
     * @example <caption>Group schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Group">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:choice minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="FIELDref" type="FieldRef"/>
     *              <xs:element name="PARAMref" type="ParamRef"/>
     *              <xs:element name="PARAM" type="Param"/>
     *              <xs:element name="GROUP" type="Group"/>
     *          </xs:choice>
     *      </xs:sequence>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ref"  type="xs:IDREF"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the GROUP node
     * @exports Group
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Group = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseGroup(childNode);
        this.description = result[0];
        this.fieldrefs = result[1];
        this.paramrefs = result[2];
        this.params = result[3];
        this.groups = result[4];
    };

    /**
     * Parses the GROUP node.
     * @param childNode the GROUP node
     * @returns {Object.<Description, Fieldref[], Paramref[], Param[], Group[]>} An array of description, fieldrefs, paramrefs, params, groups
     */
    var parseGroup = function(childNode) {
        var description;
        var fieldrefs = [];
        var paramrefs = [];
        var params = [];
        var groups = [];

        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "FIELDref":
                        fieldrefs.push(new Fieldref(element));
                        break;
                    case "PARAMref":
                        paramrefs.push(new Paramref(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Group node");
                }
            }
        }
        return [description, fieldrefs, paramrefs, params, groups];

    };

    Utils.inherits(AbstractNode , Group );

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Group.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Group.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Group.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Group.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Group.prototype.utype = function() {
        return this.attributes["utype"];
    };

    /**
     * Returns the Description object.
     * @returns {?Description} the Description object or null when no Description node.
     */
    Group.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the set of Fieldref objects.
     * @returns {?Fieldref[]} the set of Fieldref objects or 0 length when no Fieldref node.
     */
    Group.prototype.getFieldrefs = function() {
        return this.fieldrefs;
    };

    /**
     * Returns the set of Paramref objects.
     * @returns {?Paramref[]} the set of Paramref objects or 0 length when no Paramref node.
     */
    Group.prototype.getParamrefs = function() {
        return this.paramrefs;
    };

    /**
     * Returns the set of Param objects.
     * @returns {?Param[]} the set of Param objects or 0 length when no Param node.
     */
    Group.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the set of Group objects.
     * @returns {?Group[]} the set of Group objects or 0 length when non Group node.
     */
    Group.prototype.getGroups = function() {
        return this.groups;
    };

    return Group;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/coosys',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs a CoordinateSystem object.
     *
     * @example <caption>CoordinateSystem schema</caption>
     * {@lang xml}
     *  <xs:complexType name="CoordinateSystem">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="ID" type="xs:ID" use="required"/>
     *              <xs:attribute name="equinox" type="astroYear"/>
     *              <xs:attribute name="epoch" type="astroYear"/>
     *              <xs:attribute name="system" default="eq_FK5">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="eq_FK4"/>
     *                          <xs:enumeration value="eq_FK5"/>
     *                          <xs:enumeration value="ICRS"/>
     *                          <xs:enumeration value="ecl_FK4"/>
     *                          <xs:enumeration value="ecl_FK5"/>
     *                          <xs:enumeration value="galactic"/>
     *                          <xs:enumeration value="supergalactic"/>
     *                          <xs:enumeration value="xy"/>
     *                          <xs:enumeration value="barycentric"/>
     *                          <xs:enumeration value="geo_app"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the CoordinateSystem node
     * @exports Coosys
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Coosys = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.value = parseCoordinateSystem(childNode);
    };

    Utils.inherits(AbstractNode , Coosys );

    /**
     * Parses the CoordinateSystem node.
     * @param {NodeList} childNode the CoordinateSystem node
     * @returns {String} the content of CoordinateSysem node
     */
    var parseCoordinateSystem = function(childNode) {
        var value;
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element!=null && element.nodeType == 3) {
                value = (element.textContent == null) ? null : element.textContent.trim();
            } else {
                this.getCache().addWarning("unknown element "+element+" in Coosys node");
            }
        }
        return value;
    };

    /**
     * Returns the ID value.
     * @returns {!String} the ID value
     */
    Coosys.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the equinox value.
     * @returns {?String} the equinox value or null when no equinox attribute.
     */
    Coosys.prototype.equinox = function() {
        return this.attributes["equinox"];
    };

    /**
     * Returns the epoch value.
     * @returns {?String} the epoch value or null when no epoch attribute.
     */
    Coosys.prototype.epoch = function() {
        return this.attributes["epoch"];
    };

    /**
     * Returns the system value.
     * @returns {?String} the system value or null when no system attribute.
     */
    Coosys.prototype.system = function() {
        return this.attributes["system"];
    };

    /**
     * Returns the content of CoordinateSystem.
     * @returns {String} the content of CoordinateSystem.
     */
    Coosys.prototype.getContent = function() {
        return this.value;
    };

    return Coosys;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/definitions',["./utils","./abstractNode","./group","./param","./coosys"], function (Utils, AbstractNode, Group, Param, Coosys) {

    /**
     * Constructs a Definitions object.
     *
     * @example <caption>Definitions schema</caption>
     * {@lang xml}     
     *  <xs:complexType name="Definitions">
     *      <xs:choice minOccurs="0" maxOccurs="unbounded">
     *          <xs:element name="COOSYS" type="CoordinateSystem"/>
     *          <xs:element name="PARAM" type="Param"/>
     *      </xs:choice>
     *  </xs:complexType>
     *  
     * @param {NodeList} childNode the DEFINITIONS node
     * @exports Definitions
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Definitions = function (childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseDefinitions(childNode);
        this.coosys = result[0];
        this.param = result[1];
    };

    /**
     * Parses the DEFINITIONS node
     * @param {NodeList} childNode the DEFINITIONS node
     * @returns {Object.<Coosys[],Param[]>} Returns coosyss, params
     */
    var parseDefinitions = function(childNode) {
        var coosyss = [];
        var params = [];

        for (var i = 0; childNode!=null && i < childNode.childNodes.length; i++) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "COOSYS":
                        coosyss.push(new Coosys(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Definitions node");
                }
                if (nodeName == "COOSYS") {
                    coosyss.push(new Coosys(element));
                } else if (nodeName == "PARAM") {
                    params.push(new Param(element));
                } else {
                    this.getCache().addWarning("unknown element "+nodeName+" in Definitions node");

                }
            }
        }
        return [coosyss, params];
    };

    Utils.inherits(AbstractNode , Definitions );

    /**
     * Returns the list of Coosys objects.
     * @returns {?Coosys[]} the list of Coosys objects or 0 length when no Coosys node.
     */
    Definitions.prototype.getCoosyss = function() {
        return this.coosys;
    };

    /**
     * Returns the list of Param objects.
     * @returns {?Param[]} the list of Param objects or 0 length when no Param node.
     */
    Definitions.prototype.getParams = function() {
        return this.param;
    };

    return Definitions;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/info',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Constructs the Info object.
     *
     * @example <caption>Info schema</caption>
     * {@lang xml}
     * <xs:complexType name="Info">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="ID" type="xs:ID"/>
     *              <xs:attribute name="name"  type="xs:token" use="required"/>
     *              <xs:attribute name="value" type="xs:string" use="required"/>
     *              <xs:attribute name="unit"  type="xs:token"/>
     *              <xs:attribute name="xtype" type="xs:token"/>
     *              <xs:attribute name="ref"   type="xs:IDREF"/>
     *              <xs:attribute name="ucd"   type="ucdType"/>
     *              <xs:attribute name="utype" type="xs:string"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     * @param {NodeList} childNode the Info node
     * @exports Info
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Info = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var element = childNode.childNodes[0];
        if (element!=null && element.nodeType == 3) {
            this.value = (element.textContent == null) ? null : element.textContent.trim();
        }
    };

    /**
     * Returns the name value.
     * @returns {!String} the name value
     */
    Info.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the value value.
     * @returns {!String} the value value
     */
    Info.prototype.value = function() {
        return this.attributes["value"];
    };

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Info.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the unit value.
     * @returns {?String} the unit value or null when no unit attribute.
     */
    Info.prototype.unit = function() {
        return this.attributes["unit"];
    };

    /**
     * Returns the xtype value.
     * @returns {?String} the xtype value or null when no xtype attribute.
     */
    Info.prototype.xtype = function() {
        return this.attributes["xtype"];
    };

    /**
     * Returns the ref value.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Info.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the ucd value.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Info.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Info.prototype.utype = function() {
        return this.attributes["utype"];
    };

    /**
     * Returns the content of INFO node.
     * @returns {?String} the content of INFO node
     */
    Info.prototype.getContent = function() {
        return this.value;
    };

    return Info;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/td',["./utils","./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Construct the Td object.
     *
     * @example <caption>Td schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Td">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <!-- xs:attribute name="ref" type="xs:IDREF"/ -->
                    <xs:annotation><xs:documentation>
     *                  The 'encoding' attribute is added here to avoid
     *                  problems of code generators which do not properly
     *                  interpret the TR/TD structures.
     *                  'encoding' was chosen because it appears in
     *                  appendix A.5
     *              </xs:documentation></xs:annotation>
     *              <xs:attribute name="encoding" type="encodingType"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Td node
     * @exports Td
     * @augments AbstractNode
     * @param {string} options the value provided while parsing a base64 stream
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Td = function(childNode,options) {
        AbstractNode.prototype.constructor.call(this, childNode);
        if (options == null) {
            this.value = (childNode.textContent == null) ? "" : childNode.textContent.trim();
        } else {
            this.value = (options == null) ? "" : options.trim();
        }
    };

    Utils.inherits(AbstractNode , Td );

    /**
     * Returns the encoding value.
     * @returns {?String} the encoding value or null when no encoding attribute.
     */
    Td.prototype.encoding = function() {
        return this.attributes["encoding"];
    };

    /**
     * Returns the content of the name.
     * @returns {string} the content
     */
    Td.prototype.getContent = function() {
        return this.value;
    }

    return Td;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/tr',["./utils","./abstractNode","./td"], function(Utils, AbstractNode, Td) {

    /**
     * Constructs the Tr object.
     *
     * @example <caption>Tr schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Tr">
     *      <xs:annotation><xs:documentation>
     *      The ID attribute is added here to the TR tag to avoid
     *      problems of code generators which do not properly
     *      interpret the TR/TD structures
     *      </xs:documentation></xs:annotation>
     *      <xs:sequence>
     *          <xs:element name="TD" type="Td" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID" type="xs:ID"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Tr node
     * @param {Array} options the tds provided while parsing a base64 stream
     * @exports Tr
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Tr = function(childNode, options) {
        AbstractNode.prototype.constructor.call(this, childNode);
        if (options == null) {
            this.tds = parseTr(childNode);
        } else {
            this.tds = [];
            for (var i=0;i<options.length;i++) {
                this.tds.push(new Td(null, options[i]));
            }
        }
    };

    /**
     * Parses the Tr node.
     * @param {NodeList} childNode the Tr node
     * @returns {!Td[]} an array of Td
     */
    var parseTr = function(childNode) {
        var tds = [];
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "TD") {
                    tds.push(new Td(element));
                }  else {
                    this.getCache().addWarning("unknown element "+nodeName+" in Tr node");
                }
            }
        }
        return tds;
    };

    Utils.inherits(AbstractNode , Tr );

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Tr.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the list of Td objects.
     *
     * Td is the sequence element of the Tr node.
     *
     * @returns {Td[]} the list of Td objects or 0 length when no TD node.
     */
    Tr.prototype.getTds = function() {
        return this.tds;
    };

    return Tr;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/abstractData',["./utils", "./abstractNode"], function(Utils, AbstractNode) {

    /**
     * Stores the name of the data implementation
     * @param {NodeList} childNode XML node
     * @param {String} name name of the data implementation
     * @exports AbstractData
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var AbstractData = function(childNode, name) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.name = name;
    };

    Utils.inherits(AbstractNode , AbstractData );

    AbstractData.prototype.getName = function() {
        return this.name;
    };

    return AbstractData;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/tabledata',["./utils","./tr","./abstractData"], function(Utils, Tr, AbstractData) {

    /**
     * Construct a TableData object.
     *
     * @example <caption>Tabledata schema</caption>
     * {@lang xml}
     *  <xs:complexType name="TableData">
     *      <xs:sequence>
     *          <xs:element name="TR" type="Tr" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the TableData node
     * @param {Array} options the trs provided by {@link Base64#decode} while parsing a base64 stream
     * @exports TableData
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var TableData = function(childNode, options) {
        AbstractData.prototype.constructor.call(this, childNode, "TableData");
        if (options == null) {
            this.trs = parseTableData(childNode);
        } else {
            this.trs = [];
            for(var i=0;i<options.length; i++) {
                this.trs.push(new Tr(null, options[i]));
            }
        }
    };

    /**
     * Parses the TableData node.
     * @param {NodeList} childNode the TableData node
     * @returns {Tr[]} A list of Tr object
     */
    var parseTableData = function(childNode) {
        var trs = [];
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "TR") {
                    trs.push(new Tr(element));
                }  else {
                    this.getCache().addWarning("unknown element "+nodeName+" in TableData node");
                }
            }
        }
        return trs;
    };

    Utils.inherits(AbstractData , TableData );

    /**
     * Returns the list of Tr objects.
     *
     * Tr is the sequence element of the TableData node.
     *
     * @returns {?Tr[]} the list of Tr objects or 0 length when no Tr node.
     */
    TableData.prototype.getTrs = function() {
        return this.trs;
    };

    return TableData;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/converter/base64',[],function() {

    var TAB_DATA_SIZE = {short: 16, int: 32, float: 32, double: 64, unsignedByte: 8};

    /**
     * Creates a base64 constructor based on the description of the different data types.
     * This description is needed to decode the information encoding in base64
     *
     * A part of the methods comes from {@link http://github.com/aschaaff/votable.js}
     *
     * @param fields the description of the data types based on {@link Field}
     * @exports Base64
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Base64 = function(fields) {
        this.ptrStream = 0;
        this.bufferTabBits = [];
        this.fields = fields;
    };

    /**
     * Computes the data size in bits
     * @param datatype type of the data (e.g char, int, ...)
     * @param fieldNumber the current {@link Field}
     * @param stream the base64 stream
     * @returns {number} the number of bits
     */
    Base64.prototype.computeDataSize = function(datatype, fieldNumber, stream) {
        var dataSize = 0;
        if (datatype === 'char') {
            if (/\*/.test(this.fields[fieldNumber].arraysize())) { // if size is variable (ex: arraysize="16*")

                var tabBits = this.streamB64(32, stream);
                dataSize =  (8 * bin2uint32(tabBits));
                tabBits = [];
            } else { // fix size
                dataSize = (8 * this.fields[fieldNumber].arraysize());
            }
        } else {
            dataSize = TAB_DATA_SIZE[datatype];
        }
        return dataSize;
    };

    /**
     * Reads base 64 data, and return binary array.
     * @param datasize the number of bits of the data
     * @param stream the base 64 data
     * @returns {Array} an array of bits
     */
    Base64.prototype.streamB64 = function(datasize, stream) {
        var tabBits = [];
        var bufferLength = this.bufferTabBits.length;
        var needBit = Math.ceil((datasize - bufferLength) / 6);
        for (var i = 0; i < bufferLength; i += 1) {
            tabBits.push(this.bufferTabBits[i]);
        }
        this.bufferTabBits = []; // delete old data

        for (var i = 0; i < needBit; i += 1) {

            if (stream.charCodeAt(this.ptrStream) == 10) { // Line Feed (Fin de ligne)
                i -= 1;
            } else {
                var nb = b64ToUint6(stream.charCodeAt(this.ptrStream));

                for (var z = 32; z > 0; z >>= 1) {
                    if (tabBits.length !== datasize) {
                        tabBits.push(((nb & z) === z) ? "1" : "0");
                    } else {
                        this.bufferTabBits.push(((nb & z) === z) ? "1" : "0");
                    }
                }
            }
            this.ptrStream += 1;
        }
        return tabBits;
    };

    /**
     * Decodes a value read from the stream.
     * @param datatype the datatype
     * @param datasize the datasize in bits
     * @param fieldNumber the current {@link Field}
     * @param stream the base64 stream
     * @returns {string} a value such a string or a number
     */
    Base64.prototype.decodeValue = function(datatype, datasize, fieldNumber, stream) {
        var value;
        var tabBits = [];
        //extracts bits from the datasize
        if(datatype != 'NULL') {
            tabBits = this.streamB64(datasize, stream);
        }

        //converts the bits in human readable value
        switch (datatype) {
            case 'short':
                value = bin2short16(tabBits);
                break;
            case 'int':
                value = bin2int32(tabBits);
                break;
            case 'float':
                value = bin2float32(tabBits);
                value = value.toFixed(this.fields[fieldNumber].precision()); // round (arrondi)
                break;
            case 'double':
                value = bin2double64(tabBits);
                value = value.toFixed(this.fields[fieldNumber].precision()) // round (arrondi)
                break;
            case 'unsignedByte':
                value = bin2ubyte8(tabBits);
                break;
            case 'char':
                value = bin2string(tabBits);
                break;
            case 'NULL': // Empty Data
                value = 'NULL';
                break;
        }
        if(value === 'NaN' || value === 'NULL' || value === 0) {
            value = '';
        }
        return value;
    };

    /**
     * Decodes a stream.
     * @param stream the base64 stream
     * @returns {Array} the table value [td[],td[],..]
     */
    Base64.prototype.decode = function(stream) {
        var trs = [];
        var fieldNumber = 0;
        var tabBits = [];
        var streamLength = stream.length;
        var nbFields = this.fields.length;
        var tds = [];
        do {
            var datatype =this.fields[fieldNumber].datatype();
            var datasize = this.computeDataSize(datatype, fieldNumber,stream);
            if(datasize == 0) {
                datatype = 'NULL';
            }
            var value = this.decodeValue(datatype, datasize, fieldNumber, stream);
            tds.push(value);
            if(fieldNumber === (nbFields - 1)) {
                fieldNumber = 0;
                trs.push(tds);
                tds = [];
            } else {
                fieldNumber += 1;
            }

        } while (this.ptrStream < streamLength);
        return trs;
    };

    /***
     * Converts binary array to int 16 bits (signed).
     *
     * Example :
     * Input : array(0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1)
     * Ouput : 21 549
     *
     * @param {Array} TabBits Binary array
     * @return {int} int (16 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2short16(TabBits) {
        'use strict';
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(2);
        dataview = new DataView(buffer);
        binary = TabBits.join('');
        dataview.setUint16(0, parseInt(binary, 2));

        return dataview.getInt16(0);
    }

    /***
     * Converts binary array to int 32 bits (signed).
     *
     * Example :
     * Input : array(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 0)
     * Ouput : 1 049 834
     *
     * @param {array} TabBits Binary array
     * @return {int} int (32 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2int32(TabBits) {
        'use strict';
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join('');
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getInt32(0);
    }

    /***
     * Converts binary array to float 32 bits.
     *
     * Example :
     * Input : array(0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0)
     * Ouput : 0.302
     *
     * @param {Array} TabBits Binary array
     * @return {float} float (32 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2float32(TabBits) {
        'use strict';
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join('');
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getFloat32(0);
    }

    /***
     * Converts binary array to double 64 bits.
     *
     * Example :
     * Input : array(0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 0, 1)
     * Ouput : 265.083811
     *
     * @param {Array} TabBits binary array
     * @return {float} (64 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2double64(TabBits) {
        'use strict';
        var buffer, dataview, lenght, binary;

        buffer = new ArrayBuffer(8);
        dataview = new DataView(buffer);

        binary = TabBits.slice(0, 32).join('');
        dataview.setUint32(0, parseInt(binary, 2));
        binary = '';

        binary =  TabBits.slice(32, 64).join('');
        dataview.setUint32(4, parseInt(binary, 2));

        return dataview.getFloat64(0);
    }

    /***
     * Converts binary array to int 8 bits (unsigned : 0 - 255).
     *
     * Example :
     * Input : array(1, 0, 0, 0, 1, 1, 0, 0)
     * Ouput : 140
     *
     * @param {Array} TabBits Binary array
     * @return {int} int (8 bit)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2ubyte8(TabBits) {
        'use strict';
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(1);
        dataview = new DataView(buffer);
        binary = TabBits.join('');
        dataview.setUint8(0, parseInt(binary, 2));

        return dataview.getUint8(0);
    }

    /***
     * Converts binary array to string.
     *
     * Example :
     * Input : array(0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1)
     * Ouput : Hi!
     *
     * @param {Array} TabBits binary array
     * @return {string} string (min : 1 char)
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2string(TabBits) {
        'use strict';
        var lenght, binary, i, j, str;

        lenght = ((TabBits.length) / 8);
        binary = [];
        str = '';
        j = 0;

        for(i = 0; i < lenght; i += 1) {
            binary = TabBits.slice(j, (j + 8));
            str = str.concat(String.fromCharCode(bin2ubyte8(binary)));
            binary = [];
            j += 8;
        }

        return str;
    }

    /***
     * Converts binary array to int 32 bits (unsigned).
     *
     * Example :
     * Input : array(0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0)
     * Ouput : 248 973 430
     *
     * @param {Array} TabBits a binary array
     * @return {int} 32 bit value
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function bin2uint32(TabBits) {
        'use strict';
        var buffer, dataview, binary;

        buffer = new ArrayBuffer(4);
        dataview = new DataView(buffer);
        binary = TabBits.join('');
        dataview.setUint32(0, parseInt(binary, 2));

        return dataview.getUint32(0);
    }

    /***
     * Converts Ascii code to base 64 value.
     *
     * Example :
     * Input : 104 (Ascii code of h)
     * Ouput : 33 (value of h in base 64)
     *
     * @param {int} character ASCII code
     * @return {byte} base 64 value
     * @author Thomas Rolling (CDS / UTBM)
     * @licence GPL-V3
     * @see {@link http://github.com/aschaaff/votable.js} for further information
     ***/

    function b64ToUint6(caractere) {
        var byte;

        if (caractere > 64 && caractere < 91) {  // char A-Z
            byte = caractere - 65;
        } else if (caractere > 96 && caractere < 123) { // char a-z
            byte = caractere - 71;
        } else if (caractere > 47 && caractere < 58) { // number 0-9
            byte = caractere + 4;
        } else if (caractere === 43) { // char +
            byte = 62;
        } else if (caractere === 47) { // char /
            byte = 63;
        }

        return byte;
    }

    return Base64;

});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/stream',["./utils", "./abstractNode","./converter/base64","./tabledata"], function (Utils, AbstractNode, Base64, TableData) {

    /**
     * Constructs the Stream object.
     *
     * STREAM can be local or remote, encoded or not
     *
     * @example <caption>Stream schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Stream">
     *      <xs:simpleContent>
     *          <xs:extension base="xs:string">
     *              <xs:attribute name="type" default="locator">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="locator"/>
     *                          <xs:enumeration value="other"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *              <xs:attribute name="href" type="xs:anyURI"/>
     *              <xs:attribute name="actuate" default="onRequest">
     *                  <xs:simpleType>
     *                      <xs:restriction base="xs:NMTOKEN">
     *                          <xs:enumeration value="onLoad"/>
     *                          <xs:enumeration value="onRequest"/>
     *                          <xs:enumeration value="other"/>
     *                          <xs:enumeration value="none"/>
     *                      </xs:restriction>
     *                  </xs:simpleType>
     *              </xs:attribute>
     *              <xs:attribute name="encoding" type="encodingType" default="none"/>
     *              <xs:attribute name="expires" type="xs:dateTime"/>
     *              <xs:attribute name="rights" type="xs:token"/>
     *          </xs:extension>
     *      </xs:simpleContent>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Stream node
     * @exports Stream
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Stream = function (childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        this.value = childNode.textContent;
    };

    Utils.inherits(AbstractNode, Stream);

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Stream.prototype.type = function () {
        return this.attributes["type"];
    };

    /**
     * Returns the href value.
     * @returns {?String} the href value or null when no href attribute.
     */
    Stream.prototype.href = function () {
        return this.attributes["href"];
    };

    /**
     * Returns the actuate value.
     * @returns {?String} the actuate value or null when no actuate attribute.
     */
    Stream.prototype.actuate = function () {
        return this.attributes["actuate"];
    };

    /**
     * Returns the encoding value.
     * @returns {!String} the encoding value or null when no encoding attribute.
     */
    Stream.prototype.encoding = function () {
        return this.attributes["encoding"];
    };

    /**
     * Returns the expires value.
     * @returns {?String} the expires value or null when no expires attribute.
     */
    Stream.prototype.expires = function () {
        return this.attributes["expires"];
    };

    /**
     * Returns the rights value.
     * @returns {?String} the rights value or null when no rights attribute.
     */
    Stream.prototype.rights = function () {
        return this.attributes["rights"];
    };

    /**
     * Returns the content.
     * @returns {!String} the content
     */
    Stream.prototype.getContent = function (decode, fields) {
        var result;
        if (decode == null || decode == false) {
            result = this.value;
        } else {
            var base64 = new Base64(fields);
            result = new TableData(null,base64.decode(this.value));
        }
        return result;
    };




    return Stream;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/binary',["./utils","./stream","./abstractData"], function(Utils, Stream, AbstractData) {

    /**
     * Constructs the Binary object.
     *
     * @example <caption>Binary schema</caption>
     * {@lang xml}     
     *  <xs:complexType name="Binary">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Binary node
     * @exports Binary
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Binary = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Binary");
        this.stream = parseBinary(childNode);
    };

    /**
     * Parses the Binary node.
     * @param {NodeList} childNode the Binary node
     * @returns {!Stream} the Stream
     * @throws "Unknown element"
     */
    var parseBinary = function(childNode) {
        var stream;
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Stream(element);
                } else {
                    throw "Unknown element";
                }
            }
        }
        return stream;
    };

    Utils.inherits(AbstractData , Binary );


    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object
     */
    Binary.prototype.getStream = function(){
        return this.stream;
    };

    return Binary;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/binary2',["./utils","./stream","./abstractData"], function(Utils, Stream, AbstractData) {

    /**
     * Constructs the Binary2 object.
     *
     * @example <caption>Binary2 schema</caption>
     * {@lang xml}     
     *  <xs:complexType name="Binary2">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Binary2 node
     * @exports Binary2
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Binary2 = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Binary2");
        this.stream = parseBinary2(childNode);
    };

    /**
     * Parses the Binary2 node.
     * @param {NodeList} childNode the Binary node
     * @returns {!String} the Stream
     */
    var parseBinary2 = function(childNode) {
        var stream;
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Definitions(element);
                } else {
                    this.getCache().addWarning("unknown element "+nodeName+" in Binary2 node");
                }
            }
        }
        return stream;
    };

    Utils.inherits(AbstractData , Binary2 );

    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object
     */
    Binary2.prototype.getStream = function(){
        return this.stream;
    };
    
    return Binary2;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/fits',["./utils","./abstractData","./stream"], function(Utils, AbstractData, Stream) {

    /**
     * Constructs the Fits object.
     *
     * @example <caption>Fits schema</caption>
     * {@lang xml}
     *  <xs:complexType name="FITS">
     *      <xs:sequence>
     *          <xs:element name="STREAM" type="Stream"/>
     *      </xs:sequence>
     *      <xs:attribute name="extnum" type="xs:positiveInteger"/>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Fits node
     * @exports Fits
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Fits = function(childNode) {
        AbstractData.prototype.constructor.call(this, childNode, "Fits");
        this.stream = parseFits(childNode);
    };

    /**
     * Parses the Fits node.
     * @param childNode the Fits node
     * @returns {Stream} the stream
     */
    var parseFits = function(childNode) {
        var stream;
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                if (nodeName == "STREAM") {
                    stream = new Definitions(element);
                } else {
                    this.getCache().addWarning("unknown element "+nodeName+" in Fits node");
                }
            }
        }
        return stream;
    }

    Utils.inherits(AbstractData , Fits );

    /**
     * Returns the Stream object.
     * @returns {!Stream} the Stream object.
     */
    Fits.prototype.getStream = function(){
        return this.stream;
    };

    /**
     * Returns te extnum value.
     * @returns {!String} the extnum value.
     */
    Fits.prototype.extnum = function(){
        return this.attributes['extnum'];
    };

    return Fits;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/data',["./utils","./abstractNode","./tabledata","./binary","./binary2","./fits","./info"],
    function(Utils, AbstractNode, TableData, Binary, Binary2, Fits, Info) {

    /**
     * Constructs a Data object.
     *
     * @example <caption>Data schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Data">
     *      <xs:sequence>
     *          <xs:choice>
     *              <xs:element name="TABLEDATA" type="TableData"/>
     *              <xs:element name="BINARY" type="Binary"/>
     *              <xs:element name="BINARY2" type="Binary2"/>
     *              <xs:element name="FITS" type="FITS"/>
     *          </xs:choice>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *  </xs:complexType>
     *
     * @param {NodeList} childNode the Data node
     * @exports Data
     * @augments AbstractData
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Data = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseData(childNode);
        this.data = result[0];
        this.infos = result[1];
    };

    /**
     * Parses the Data node.
     * @param {NodeList} childNode the Data node
     * @returns {Object.<TableData|Binary|Binary2|Fits, Info[]>} the data
     */
    var parseData = function(childNode) {
        var data;
        var infos = [];

        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++){
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "TABLEDATA":
                        data = new TableData(element);
                        break;
                    case "BINARY":
                        data = new Binary(element);
                        break;
                    case "BINARY2":
                        data = new Binary2(element);
                        break;
                    case "FITS":
                        data = new Fits(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element " + nodeName + " in Data node");
                }
            }
        }
        return [data, infos];
    };
        
    Utils.inherits(AbstractNode , Data );

    /**
     * Returns the data.
     * @returns {!TableData|Binary|Binary2|Fits}
     */
    Data.prototype.getData = function() {
        return this.data;
    };

    /**
     * Returns the name of the data implementation.
     * @returns {!string} the name of the data implementation
     */
    Data.prototype.getDataImplementationName = function() {
        return this.data.getName();
    };

    /**
     * Returns the Infos object.
     * @returns {?Info[]} the Infos object or 0 length when no Info node.
     */
    Data.prototype.getInfos = function() {
        return this.infos;
    };

    return Data;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/table',["./utils", "./abstractNode", "./description", "./field", "./param", "./group", "./link", "./data", "./info"],
    function(Utils, AbstractNode, Description, Field, Param, Group, Link, Data, Info) {

    /**
     * Constructs the Table object.
     *
     * A TABLE is a sequence of FIELD/PARAMs and LINKS and DESCRIPTION, possibly followed by a DATA section
     *
     * @example <caption>Table schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Table">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          <xs:choice minOccurs="1" maxOccurs="unbounded">
     *              <xs:element name="FIELD" type="Field"/>
     *              <xs:element name="PARAM" type="Param"/>
     *              <xs:element name="GROUP" type="Group"/>
     *          </xs:choice>
     *          <xs:element name="DATA" type="Data" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ref"  type="xs:IDREF"/>
     *      <xs:attribute name="ucd"  type="ucdType"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="nrows" type="xs:nonNegativeInteger"/>
     *  </xs:complexType>
     * @param {NodeList} childNode the Table node
     * @exports Table
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Table = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);

        var result = parseTable(childNode);
        this.fields = result[0];
        this.params = result[1];
        this.groups = result[2];
        this.links = result[3];
        this.data = result[4];
        this.description = result[5];
        this.infos = result[6];
    };

    /**
     * Parses the Table node.
     * @param {NodeList} childNodes the Table node
     * @returns {Object.<Field[],Param[],Group[],Link[],Data,Description,Info[]>} an array of fields, params, groups, links, data, description, infos
     */
    var parseTable = function(childNodes) {
        var fields = [];
        var params = [];
        var groups = [];
        var links = [];
        var data;
        var description;
        var infos = [];
        for(var i = 0; childNodes!=null && i< childNodes.childNodes.length; i++){
            var element = childNodes.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "FIELD":
                        fields.push(new Field(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    case "LINK":
                        links.push(new Link(element));
                        break;
                    case "DATA":
                        data = new Data(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Table node");
                }
            }
        }
        return [fields, params, groups, links, data, description, infos];
    };

    Utils.inherits(AbstractNode , Table );

    /**
     * Returns the ID value of the attribute.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Table.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the name value of the attribute.
     * @returns {?String} the name value or null when no name attribute.
     */
    Table.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the ref value of the attribute.
     * @returns {?String} the ref value or null when no ref attribute.
     */
    Table.prototype.ref = function() {
        return this.attributes["ref"];
    };

    /**
     * Returns the ucd value of the attribute.
     * @returns {?String} the ucd value or null when no ucd attribute.
     */
    Table.prototype.ucd = function() {
        return this.attributes["ucd"];
    };

    /**
     * Returns the utype value of the attribute.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Table.prototype.utype = function() {
        return this.attributes["utype"];
    };

    /**
     * Returns the nrows value of the attribute.
     * @returns {?String} the nrows value or null when no nrows attribute.
     */
    Table.prototype.nrows = function() {
        return this.attributes["nrows"];
    };

    /**
     * Returns the list of Field objects.
     *
     * Field is one of the sequence element of the Table node.
     *
     * @returns {!Field[]} the list of Field objects or 0 length when no Field node.
     */
    Table.prototype.getFields = function() {
        return this.fields
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the Table node.
     *
     * @returns {!Param[]} the list of Param objects
     */
    Table.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the Table node.
     *
     * @returns {!Group[]} the list of Group objects
     */
    Table.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Link objects.
     *
     * Link is one of the sequence element of the Table node.
     *
     * @returns {?Link[]} the list of Link objects or 0 length when no Link node
     */
    Table.prototype.getLinks = function() {
        return this.links;
    };

    /**
     * Returns the Data object
     *
     * Data is one of the sequence element of the Table node.
     *
     * @returns {?Data} the Data object or null when no Data node.
     */
    Table.prototype.getData = function() {
        return this.data;
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the Table node.
     *
     * @returns {?Info[]} the list of Info objects or 0 length when non Info node.
     */
    Table.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the description.
     *
     * Description is one of the sequence element of the Table node.
     *
     * @returns {string} the description.
     */
    Table.prototype.getDescription = function() {
        return this.description;
    };

    return Table;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/resource',["./utils","./abstractNode","./description","./info","./table","./link","./coosys","./param","./group"], 
    function(Utils, AbstractNode, Description, Info, Table, Link, Coosys, Param, Group) {

    /**
     * Constructs the Resource object.
     *
     * RESOURCES can contain DESCRIPTION, (INFO|PARAM|COSYS), LINK, TABLEs
     *
     * @example <caption>Resource schema</caption>
     * {@lang xml}
     *  <xs:complexType name="Resource">
     *      <xs:sequence>
     *          <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *          <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          <xs:choice minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="COOSYS" type="CoordinateSystem"/><!-- Deprecated in V1.2 -->
     *              <xs:element name="GROUP" type="Group" />
     *              <xs:element name="PARAM" type="Param" />
     *          </xs:choice>
     *          <xs:sequence minOccurs="0" maxOccurs="unbounded">
     *              <xs:element name="LINK" type="Link" minOccurs="0" maxOccurs="unbounded"/>
     *              <xs:choice>
     *                  <xs:element name="TABLE" type="Table" />
     *                  <xs:element name="RESOURCE" type="Resource" />
     *              </xs:choice>
     *              <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          </xs:sequence>
     *          <!-- Suggested Doug Tody, to include new RESOURCE types -->
     *          <xs:any namespace="##other" processContents="lax" minOccurs="0" maxOccurs="unbounded"/>
     *      </xs:sequence>
     *      <xs:attribute name="name" type="xs:token"/>
     *      <xs:attribute name="ID"   type="xs:ID"/>
     *      <xs:attribute name="utype" type="xs:string"/>
     *      <xs:attribute name="type" default="results">
     *          <xs:simpleType>
     *              <xs:restriction base="xs:NMTOKEN">
     *                  <xs:enumeration value="results"/>
     *                  <xs:enumeration value="meta"/>
     *              </xs:restriction>
     *          </xs:simpleType>
     *      </xs:attribute>
     *      <!-- Suggested Doug Tody, to include new RESOURCE attributes -->
     *      <xs:anyAttribute namespace="##other" processContents="lax"/>
     *  </xs:complexType>
     *  
     *  @example <caption>Get a table</caption>
     *  var listResourcesOrTable = resource.getResourcesOrTables();
     *  var resourceOrTable = listResourcesOrTable[0];
     *  var table = resourceOrTable["TABLE"];
     *
     * @param {NodeList} childNode The Resource node
     * @exports Resource
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var Resource = function(childNode) {
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseResource(childNode);
        this.description = result[0];
        this.infos = result[1];
        this.coosyss = result[2];
        this.params = result[3];
        this.groups = result[4];
        this.abstractSequences = result[5];
    };

    /**
     * Parses the Resource node.
     * @param {NodeList} childNode the Resource node
     * @returns {Object.<Description,Info[],Coosys[],Param[],Group[],Object>} an array of description, infos, coosyss, params, groups, abstractSequences
     */
    var parseResource = function(childNode) {
        var description;
        var infos = [];
        var coosyss = [];
        var groups = [];
        var params = [];
        var abstractSequences = [];
        var end = 0;
        for(var i = 0; childNode!=null && i< childNode.childNodes.length; i++) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    case "COOSYS":
                        coosyss.push(new Coosys);
                        break;
                    case "GROUP":
                        groups.push(new Group);
                        break;
                    case "PARAM":
                        params.push(new Param);
                        break;
                    default:
                        end = i;
                }
            }
            if (end!=0) {
                break;
            }
        }
        var seqElts = {};
        var seqLinks = [];
        var seqInfos = [];
        for(var i = end; childNode!=null && i< childNode.childNodes.length; i++) {
            var element = childNode.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "LINK":
                        if (seqElts.hasOwnProperty("TABLE") || seqElts.hasOwnProperty("RESOURCE")) {
                            seqElts["LINKS"] = seqLinks;
                            seqElts["INFOS"] = seqInfos;
                            abstractSequences.push(seqElts);
                            seqElts = {};
                            seqLinks = [];
                            seqInfos = [];
                        } else {
                            seqLinks.push(new Link(element));
                        }
                        break;
                    case "TABLE":
                        seqElts["TABLE"] = new Table(element);
                        break;
                    case "RESOURCE":
                        seqElts["RESOURCE"] = new Resource(element);
                        break;
                    case "INFO":
                        seqInfos.push(new Info(element));
                        break;
                    default:
                        this.getCache().addWarning("Unkknown element "+nodeName+" in RESOURCE node");
                }
            }
        }
        if(Object.keys(seqElts).length != 0) {
            abstractSequences.push(seqElts);
        }
        return [description, infos, coosyss, params, groups, abstractSequences];
    };

    Utils.inherits(AbstractNode , Resource );

    /**
     * Returns the ID value.
     * @returns {?String} the ID value or null when no ID attribute.
     */
    Resource.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the name value.
     * @returns {?String} the name value or null when no name attribute.
     */
    Resource.prototype.name = function() {
        return this.attributes["name"];
    };

    /**
     * Returns the utype value.
     * @returns {?String} the utype value or null when no utype attribute.
     */
    Resource.prototype.utype = function() {
        return this.attributes["utype"];
    };

    /**
     * Returns the type value.
     * @returns {?String} the type value or null when no type attribute.
     */
    Resource.prototype.type = function() {
        return this.attributes["type"];
    };

    /**
     * Returns the Description object.
     *
     * Description is one of the sequence element of the Resource node.
     *
     * @returns {?Description} the Description object or null when no Description node.
     */
    Resource.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the Resource node.
     *
     * @returns {?Info[]} the list of Info objects or 0 length when no Info node
     */
    Resource.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the list of Coosys objects.
     *
     * Coosys is one of the sequence element of the Resource node.
     *
     * @returns {?Coosys[]} the list of Coosys objects or 0 length when no Coosys value.
     */
    Resource.prototype.getCoosyss = function() {
        return this.coosyss;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the Resource node.
     *
     * @returns {?Group[]} the list of Group objects or 0 length when no Group node.
     */
    Resource.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the Resource node.
     *
     * @returns {?Param[]} the list of Param objects or 0 length when no Param node.
     */
    Resource.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the list of Resource or Table objects.
     * @returns {?Object.<Description,Info[],Coosys[],Param[],Group[],Resource[]|Table[]>} the list of Resource or Table objects
     */
    Resource.prototype.getResourcesOrTables = function() {
        return this.abstractSequences;
    };

    return Resource;
});

/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/JsVotable/converter/geojson',["../utils"], function (Utils) {

    var UCD_ID = ["meta.record","meta.id;meta.main","VOX:Image_Titleq"];
    var UCD_RA = ["pos.eq.ra;meta.main","POS_EQ_RA_MAIN"];
    var UCD_DEC = ["pos.eq.dec;meta.main","POS_EQ_DEC_MAIN"];

    /**
     * Contructs a GeoJSON.
     * @param votable Votable format
     * @exports GeoJson
     * @constructor
     * @author Jean-Christophe Malapert
     */
    var GeoJson = function(votable) {
        this.votable = votable;
        this.featureCollection = process(this.votable);
    };

    /**
     * Retrieves a GeoJson.
     * @param {Boolean} option sets to true to get a pretty output of the GeoJSON. By default, option is set to false
     * @returns {String} the GeoJson output of the VOTable
     */
    GeoJson.prototype.getGeoJSon = function(option) {
        var pretty = option | false;
        return JSON.stringify(this.featureCollection, null, pretty);
    };

    /**
     * Process the transformation of the Votable into GeoJson.
     * @param {Votable} votable the votable
     * @return {{type: string, features: Array}} The GeoJson as hash
     */
    function process(votable) {
        var featureCollection = {
            "type":"FeatureCollection",
            "features":[]
        };
        var coosys = findAndGetGlobalCoosys(votable);
        if(coosys != null) {
            featureCollection["crs"] = {
                    "type": "name",
                    "properties": {
                        "name": coosys
                    }
            };
        }
        var features = [];
        var resources = votable.getResources();
        for(var i=0; i<resources.length;i++) {
            processResource(resources[i], features);
        }
        featureCollection["features"] = features;

        /**
         * Finds and get the Coosys if this one is set global to the Votable.
         * @param {Votable} votable the Votable
         * @return {Coosys} The coordinate system
         */
        function findAndGetGlobalCoosys(votable) {
            var coosys;
            var defs = votable.getDefinitions();
            if (defs != null) {
                coosys = defs.getCoosyss()[0];
            }
            if(votable.getCoosyss()[0] != null) {
                coosys = votable.getCoosyss()[0];
            }
            return coosys;
        }

        return featureCollection;
    }

    /**
     * Process a resource.
     * @param {Resource} resource the resource to process
     * @param features the features to fill
     */
    function processResource(resource, features) {
        var resourcesOrTables = resource.getResourcesOrTables();
        for (var i=0;i<resourcesOrTables.length;i++) {
            var resourceOrTable = resourcesOrTables[i];
            if (resourceOrTable.hasOwnProperty("RESOURCE")) {
                processResource(resourceOrTable["RESOURCE"], features);
            } else if (resourceOrTable.hasOwnProperty("TABLE")) {
                processTable(resourceOrTable["TABLE"], features);
            }
        }
    }

    /**
     * Process a table.
     * @param {Table} table the table to process
     * @param features the features to fill
     */
    function processTable(table, features) {
        var fields = table.getFields();
        var data = table.getData();
        var trs;
        var infos = table.getInfos();
        switch (data.getDataImplementationName()) {
            case "TableData":
                var tableData = data.getData();
                trs = tableData.getTrs();
                break;
            case "Binary":
                var binary = data.getData();
                var tableData = binary.getStream().getContent(true, fields);
                trs = tableData.getTrs();
                break;
            case "Binary2":
                var binary2 = data.getData();
                throw new Error("Binary2 not implemented");
                break;
            case "Fits":
                var fits = data.getData();
                throw new Error("Fits not implemented");
                break;
            default:
                throw new Error("Type of data not implemented");
        }
        creatureFeatures(fields, infos, trs, features);
    }

    /**
     * Creates the features.
     * @param {Field[]} fields the fields
     * @param {Info[]} infos the infos
     * @param {Tr[]} trs the rows
     * @param features the features to fill
     */
    function creatureFeatures(fields, infos, trs, features) {
        for (var i=0 ; i<trs.length; i++) {
            var tds = trs[i].getTds();
            features.push(createFeature(fields, infos, tds));
        }
    }

    /**
     * Creates a feature.
     * The infos are set in the GeoJSon properties.
     * @param {Field[]} fields the fields
     * @param {Info[]] infos the infos
     * @param {Td[]} tds the values
     * @return {{type: string, geometry: null, properties: {}}}
     */
    function createFeature(fields, infos, tds) {
        var feature = {
            "type":"Feature",
            "geometry":null,
            "properties":{}
        };
        var coreMetadata = {};
        for (var i=0;i<tds.length;i++) {
            var td = tds[i];
            var field = fields[i];
            var values = field.getValues();
            var nullValue = (values != null) ? values.null() : null;
            var ucd = field.ucd();
            var datatype = field.datatype();
            var value = td.getContent();
            var name = field.name();
            if (filter(UCD_RA,ucd)) {
                coreMetadata["RA"] = Number.parseFloat(value);
                coreMetadata["COOSYS"] = field.ref();
            } else if(filter(UCD_DEC,ucd)) {
                coreMetadata["DEC"] = Number.parseFloat(value);
            } else if(filter(UCD_ID,ucd)) {
                coreMetadata["ID"] = value;
            } else {
                var properties = feature.properties;
                if(value != nullValue) {
                    properties[name] = parseDatatype(value, datatype);
                }
            }
        }
        if(!coreMetadata.hasOwnProperty("ID")) {
            coreMetadata["ID"] = Utils.guid();
        }
        for(var i=0 ;i<infos.length; i++) {
            var info = infos[i];
            properties[info.name()] = info.value();
        }
        checkCoreMetadata(coreMetadata);
        var geometry = {
            "type":"Point",
            "coordinates":[coreMetadata.RA, coreMetadata.DEC],
            "crs":{
                "type": "name",
                "properties": {
                    "name": coreMetadata.COOSYS
                }
            }
        };
        feature["geometry"] = geometry;

        /**
         * Checks if the core metadata is filled.
         * @param coreMetadata
         */
        function checkCoreMetadata(coreMetadata) {
            if (!(coreMetadata.hasOwnProperty("RA") && coreMetadata.hasOwnProperty("DEC")
            && coreMetadata.hasOwnProperty("COOSYS") && coreMetadata.hasOwnProperty("ID"))) {
                throw new Error("core metadata missing "+JSON.stringify(coreMetadata));
            }
        }

        /**
         * Parses along the datatype (number or string).
         * @param value
         * @param type
         * @return {*}
         */
        function parseDatatype(value, type) {
            var result;
            switch (type) {
                case "short":
                case "int":
                case "long":
                    result = Number.parseInt(value);
                    break;
                case "float":
                case "double":
                    result = Number.parseFloat(value);
                    break;
                default:
                    result = value;
            }
            return result;
        }

        /**
         * Search a criteria in an array.
         * @param arr array
         * @param criteria criteria
         * @return {boolean} True when the criteria is found
         */
        function filter(arr, criteria) {
            var result= arr.filter(function(obj) {
                return (obj === criteria);
            });
            return (result.length == 0) ? false : true;
        }

        return feature;

    }

    return GeoJson;

});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/JsVotable/votable',["./utils","./abstractNode", "./definitions","./info","./resource", "./description","./coosys","./group","./param","./converter/geojson"],
    function(Utils, AbstractNode, Definitions, Info, Resource, Description, Coosys, Group, Param, GeoJson) {

    /**
     * Contructs a Votable object.
     *
     * @example <caption>VOTable schema</caption>
     * {@lang xml}
     * <xs:element name="VOTABLE">
     *      <xs:complexType>
     *          <xs:sequence>
     *              <xs:element name="DESCRIPTION" type="anyTEXT" minOccurs="0"/>
     *              <xs:element name="DEFINITIONS" type="Definitions" minOccurs="0"/><!-- Deprecated -->
     *                  <xs:choice minOccurs="0" maxOccurs="unbounded">
     *                      <xs:element name="COOSYS" type="CoordinateSystem"/><!-- Deprecated in V1.2 -->
     *                      <xs:element name="GROUP" type="Group" />
     *                      <xs:element name="PARAM" type="Param" />
     *                      <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *                  </xs:choice>
     *              <xs:element name="RESOURCE" type="Resource" minOccurs="1" maxOccurs="unbounded"/>
     *              <xs:element name="INFO" type="Info" minOccurs="0" maxOccurs="unbounded"/>
     *          </xs:sequence>
     *          <xs:attribute name="ID" type="xs:ID"/>
     *          <xs:attribute name="version">
     *              <xs:simpleType>
     *                  <xs:restriction base="xs:NMTOKEN">
     *                      <xs:enumeration value="1.3"/>
     *                  </xs:restriction>
     *              </xs:simpleType>
     *          </xs:attribute>
     *      </xs:complexType>
     *  </xs:element>
     *
     *
     * @example <caption>How to load a VOTable</caption>
     * var httpRequest = Utils.makeHttpObject();
     * httpRequest.open("GET", '"http://axel.u-strasbg.fr/HiPSCatService/I/284/out/metadata.xml', false);
     * httpRequest.send(null);
     * var xml = httpRequest.responseXML;
     * var votable = new Votable(xml);
     * @exports Votable
     * @augments AbstractNode
     * @constructor
     * @author Jean-Christophe Malapert
     * @throws {Error} can be one of the following errors : "xml cannot be null", "This object is not supported", "his input is not a VOTable"
     */
    var Votable = function(xml) {
        xml = checkInputFormat(xml);
        var childNode = xml.documentElement;
        AbstractNode.prototype.constructor.call(this, childNode);
        var result = parseVotableTag(childNode);
        this.definitions = result[0];
        this.infos = result[1];
        this.resources = result[2];
        this.description = result[3];
        this.coosyss = result[4];
        this.groups = result[5];
        this.params = result[6];
    };

    /**
     * Checks the xml format and converts the xml in a XMLDocument.
     * The different tests applied to the format are :
     * <ul>
     *     <li>checking for a null value</li>
     *     <li>checking for the type of the input<li>
     *     <li>checking for VOTABLE tag</li>
     * </ul>
     * @param {Object} xml the input
     * @returns {XMLDocument} the xml document
     * @throws {Error} can be one of the following errors : "xml cannot be null", "This object is not supported", "his input is not a VOTable"
     */
    function checkInputFormat(xml) {
        if(xml == null) {
            throw new Error("xml cannot be null");
        } else if (typeof xml === "string") {
            var parser = new DOMParser();
            xml = parser.parseFromString(xml, "application/xml");
        } else if (xml.documentElement != null) {
            // everything is fine
        } else {
            throw new Error("This object is not supported");
        }
        var tag = xml.documentElement.localName;
        if(tag != 'VOTABLE') {
            throw new Error("This input is not a VOTable");
        }
        return xml;
    }

    /**
     * Parses the VOTable elements and returns the VOTable sequence elements.
     *
     * The VOTable sequence elements are the following :
     * <ul>
     *     <li>the DEFINITIONS element,</li>
     *     <li>the list of INFO elements,</li>
     *     <li>the list of RESOURCE elements,</li>
     *     <li>the DESCRIPTION element</li>
     *     <li>the list of COOSYS elements</li>
     *     <li>the list of GROUP elements</li>
     *     <li>the list of PARAM elements</li>
     * </ul>
     *
     * @param {NodeList} childNode The VOTable node
     * @returns {Object.<Definitions,Info[],Resource[],Description,Coosys[],Group[],Param[]>} The sequence which has been parsed
     */
    var parseVotableTag = function(childNode) {
        var root = childNode;
        var definitions;
        var infos = [];
        var resources = [];
        var description;
        var coosyss = [];
        var groups = [];
        var params = [];

        for(var i = 0; i< root.childNodes.length; i++){
            var element = root.childNodes[i];
            if (element.nodeType == 1) {
                var nodeName = element.localName;
                switch (nodeName) {
                    case "DEFINITIONS":
                        definitions = new Definitions(element);
                        break;
                    case "INFO":
                        infos.push(new Info(element));
                        break;
                    case "RESOURCE":
                        resources.push(new Resource(element));
                        break;
                    case "DESCRIPTION":
                        description = new Description(element);
                        break;
                    case "COOSYS":
                        coosyss.push(new Coosys(element));
                        break;
                    case "GROUP":
                        groups.push(new Group(element));
                        break;
                    case "PARAM":
                        params.push(new Param(element));
                        break;
                    default:
                        this.getCache().addWarning("unknown element "+nodeName+" in Votable node");
                }
            }
        }
        return [definitions, infos, resources, description, coosyss, groups, params];

    };

    Utils.inherits(AbstractNode , Votable );

    /**
      * Returns the ID value of the attribute.
     * @returns {?String} the ID value
     */
    Votable.prototype.ID = function() {
        return this.attributes["ID"];
    };

    /**
     * Returns the version value of the attribute.
     * @returns {?String} the version value
     */
    Votable.prototype.version = function() {
        return this.attributes["version"];
    };

    /**
     * Returns the list of Info objects.
     *
     * Info is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Info>} the list of Info objects or 0 length when no Info node.
     */
    Votable.prototype.getInfos = function() {
        return this.infos;
    };

    /**
     * Returns the list of Definitions object.
     *
     * Definitions is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Definitions>} the list of Definitions object or 0 length when no Definitions node.
     */
    Votable.prototype.getDefinitions = function() {
        return this.definitions;
    };

    /**
     * Returns the list of Resource objects.
     *
     * Resource is one of the sequence element of the VOTable node.
     *
     * @returns {!Array.<Resource>} the list of Resource objects
     */
    Votable.prototype.getResources = function() {
        return this.resources;
    };

    /**
     * Returns the list of Coosys objects.
     *
     * Coosys is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Coosys>} the list of Coosys objects or 0 length when no Coosys node.
     */
    Votable.prototype.getCoosyss = function() {
        return this.coosyss;
    };

    /**
     * Returns the list of Group objects.
     *
     * Group is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Group>} the list of Group objects or 0 length when no Group node.
     */
    Votable.prototype.getGroups = function() {
        return this.groups;
    };

    /**
     * Returns the list of Param objects.
     *
     * Param is one of the sequence element of the VOTable node.
     *
     * @returns {?Array.<Param>} the list of Param objects or 0 length when no Param node.
     */
    Votable.prototype.getParams = function() {
        return this.params;
    };

    /**
     * Returns the Description object.
     *
     * Description is one of the sequence element of the VOTable node.
     *
     * @returns {?Description} the Description object or null when no Description node.
     */
    Votable.prototype.getDescription = function() {
        return this.description;
    };

    /**
     * Returns the VOTable element by its identifier.
     * @param {String] ID identifier of the VOTable element
     * @returns {?AbstractNode} the VOTable element or null when the ID is not found.
     */
    Votable.prototype.getVotableEltByID = function(ID) {
        return this.getCache().getEltsByID()[ID];
    };

    /**
     * Returns the VOTable elements by its name.
     * @param {String} name name of the VOTable element
     * @returns {AbstractNode[]} the VOTable elements or null when the name is not found.
     */
    Votable.prototype.getVotableEltsByName = function(name) {
        return this.getCache().getEltsByName()[name];
    };

    /**
     * Converts the VOTable to GeoJSON.
     * @param {Boolean} option sets to true to get a pretty output of the GeoJSON. By default, option is set to false
     * @returns {String} the GeoJson output of the VOTable
     */
    Votable.prototype.convertToGeoJSon = function(option) {
        var geoJson = new GeoJson(this);
        return geoJson.getGeoJSon(option);
    };

    return Votable;
});
/*******************************************************************************
 * Copyright 2016 - Jean-Christophe Malapert
 *
 * This file is part of JsVotable.
 *
 * JsVotable is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JsVotable is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with JVotable.  If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define( 'Layer/JsVotable/JsVotable',["./votable","./binary","./binary2","./coosys","./data","./definitions","./description","./field","./fieldref",
    "./fits","./group","./info","./link","./max","./min","./option","./param","./paramref","./resource","./stream",
    "./table","./tabledata","./td","./tr","./values"],
    function(Votable, Binary, Binary2, Coosys, Data, Definitions, Description, Field, Fieldref, Fits, Group, Info, Link,
    Max, Min, Option, Param, Paramref,Resource, Stream, Table, TableData, Td, Tr, Values) {

    var JsVotable = {};

    JsVotable.Votable = Votable;
    JsVotable.Binary = Binary;
    JsVotable.Binary2 = Binary2;
    JsVotable.Coosys = Coosys;
    JsVotable.Data = Data;
    JsVotable.Definitions = Definitions;
    JsVotable.Description = Description;
    JsVotable.Field = Field;
    JsVotable.Fieldref = Fieldref;
    JsVotable.Fits = Fits;
    JsVotable.Group = Group;
    JsVotable.Info = Info;
    JsVotable.Link = Link;
    JsVotable.Max = Max;
    JsVotable.Min = Min;
    JsVotable.Option = Option;
    JsVotable.Param = Param;
    JsVotable.Paramref = Paramref;
    JsVotable.Resource = Resource;
    JsVotable.Stream = Stream;
    JsVotable.Table = Table;
    JsVotable.TableData = TableData;
    JsVotable.Td = Td;
    JsVotable.Tr = Tr;
    JsVotable.Values = Values;
    JsVotable.version = {
        major : 1,
        minor : 1,
        patch : 0,
        date : "2016-10-12",
        toString : function () {
            return this.major+ "." + this.minor + "." + this.patch;
        }
    };

    window.JsVotable = JsVotable;

    return JsVotable;
});

define('Layer/JsCSV/csv',[], function () {
    var PREFIX_COMMENT = '#';

    var JsCSV = function (csv, commonSeparator, headerInfo) {
        csv = checkInputFormat(csv);
        this.store = parseCSV(csv,commonSeparator,headerInfo)
    };

    function checkInputFormat(csv) {
        if (csv == null) {
            throw new Error("csv cannot be null");
        } else if (typeof csv !== "string") {
            throw new Error("This object is not supported");
        } else {
            // everything is fine
        }
        return csv;
    }

    function parseCSV(csv, commonSeparator, headerInfo) {
        var rows = csv.split("\n");
        var lineWithData = 0;
        for (var i = 0; i < rows.length && isUselessRow(rows[i],commonSeparator, headerInfo.name); i++) {
            lineWithData++
        }
        return parseRows(rows, lineWithData, commonSeparator, headerInfo);

    }

    function isUselessRow(row,commonSeparator,headerName) {
        return (row.startsWith(PREFIX_COMMENT) || row.length == 0 || headerName.toString() == row.split(commonSeparator).toString());
    }

    function parseRows(rows, lineWithData, commonSeparator, headerInfo) {
        var store = [];
        for (var i=lineWithData; i<rows.length; i++) {
            if(rows[i].length !== 0) {
                store.push(parseRow(rows[i], commonSeparator, headerInfo));
            }
        }
        return store;
    }

    function parseRow(row, commonSeparator, headerInfo) {
        var store = {};
        var tds = row.split(commonSeparator);
        for(var i=0; i<tds.length; i++) {
            store[headerInfo.name[i]] = parseDatatype(tds[i], headerInfo.datatype[i]);
        }
        return store;
    }

    function parseDatatype(value, type) {
        var result;
        switch (type) {
            case "short":
            case "int":
            case "long":
                result = Number.parseInt(value);
                break;
            case "float":
            case "double":
                result = Number.parseFloat(value);
                break;
            default:
                result = value;
        }
        return result;
    }

    JsCSV.prototype.getStore = function() {
        return this.store;
    };

    JsCSV.prototype.getGeoJSon = function(mapping, frame) {
      var RA = mapping.RA;
      var DEC = mapping.DEC;
      var ID = mapping.ID;
      //var CRS_NAME = mapping.CRS_NAME;
      var features = [];
      for(var i=0; i<this.store.length; i++) {

          var feature = {
              "type":"Feature",
              "id":this.store[i][ID],
              "geometry":{
                  "type":"Point",
                  "coordinates":[
                      this.store[i][RA],this.store[i][DEC]
                  ],
                  "crs":{
                      "type": "name",
                      "properties": {
                          "name": frame
                      }
                  }
              }
          };
          var newStore = JSON.parse(JSON.stringify(this.store[i]));
          delete newStore[RA];
          delete newStore[DEC];
          delete newStore[ID];
          feature["properties"] = newStore;

          features.push(feature);
      }
      var featureCollection = {
          "type": "FeatureCollection",
          "features":features
      };
      return featureCollection;
    };


    return JsCSV;

});
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Layer/HipsCatLayer',['./AbstractHipsLayer', '../Renderer/FeatureStyle', '../Renderer/VectorRendererManager', '../Utils/Utils',
    '../Renderer/RendererTileData', '../Tiling/Tile',
    './JsVotable/JsVotable', './JsVotable/utils','./JsCSV/csv', '../Utils/Constants'],
    function (AbstractHipsLayer, FeatureStyle, VectorRendererManager, Utils, RendererTileData, Tile, JsVotable, UtilsJsVotable, CSV, Constants) {

        /**************************************************************************************************************/

        function _setDefaultOptions(options) {
            options.icon = options.icon || "css/images/star16x16.png";
            options.background = false;
            options.category = options.category || "Catalog";
            options.pickable = options.pickable || true;
            return options;
        }


        /**
         * Hips catalogue configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.hipsCat_configuration
         * @property {string} serviceUrl - Endpoint to reach the Hips catalogue
         * @property {int} [minOrder = 2] - min order
         * @property {int} [maxRequests = 4] - Max requests in parallel
         * @property {boolean} [invertY = false]
         */

        /**
         * Create a HIPS catalogue
         * @param {AbstractLayer.hipsCat_configuration} options - Hip catalogue configuration
         * @constructor
         * @memberOf module:Layer
         * @see {@link http://www.ivoa.net/documents/HiPS/20170406/index.html Hips standard}
         */
        var HipsCatLayer = function (hipsMetadata, options) {
            AbstractHipsLayer.prototype.constructor.call(this, hipsMetadata, _setDefaultOptions(options));
            var i;
            var propertiesObj = new Properties(this.proxify(options.baseUrl) + '/properties');
            var properties = propertiesObj.getProperties();
            var hips_order = properties['hips_order'];
            this.serviceUrl = this.proxify(options.baseUrl);
            this.minOrder = options.minOrder || 2;
            this.maxOrder = Number.parseInt(hips_order, 10);
            this.maxRequests = options.maxRequests || 4;
            this.invertY = options.invertY || false;
            var xhr = UtilsJsVotable.makeHttpObject();
            xhr.open('GET', this.proxify(options.baseUrl) + '/metadata.xml', false);
            xhr.send(null);
            var jsVotable = new JsVotable.Votable(xhr.responseXML);
            var resource = jsVotable.getResources()[0];
            var table = resource.getResourcesOrTables()[0]["TABLE"];
            this.fields = table.getFields();
            this.raColNumber = null;
            this.decColNumber = null;
            this.sourceId = null;
            for (i = 0; i < this.fields.length; i++) {
                var ucd = this.fields[i].ucd();
                if (ucd === 'pos.eq.ra;meta.main') {
                    this.raColNumber = this.fields[i].name();
                } else if (ucd === 'pos.eq.dec;meta.main') {
                    this.decColNumber = this.fields[i].name();
                } else if (ucd === 'meta.id;meta.main') {
                    this.sourceId = this.fields[i].name();
                }
            }


            this.extId = "hipsCat";

            // Used for picking management
            this.features = [];
            // Counter set, indicates how many times the feature has been requested
            this.featuresSet = {};

            // Maximum two requests for now
            this.freeRequests = [];
            this.tilesToLoad = [];

            // Build the request objects
            for (i = 0; i < this.maxRequests; i++) {
                xhr = new XMLHttpRequest();
                this.freeRequests.push(xhr);
            }
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractHipsLayer, HipsCatLayer);

        /**************************************************************************************************************/

        /**
         * Parse properties file of the Hips catalogue
         * @param url
         * @constructor
         */
        var Properties = function (url) {
            this.properties = {};
            var i;
            var xhr = new XMLHttpRequest();
            xhr.open("GET", url, false);
            xhr.send();
            var content = xhr.responseText;
            content.trim();
            var lines = content.split('\n');
            for (i = 0; lines !== null && i < lines.length; i++) {
                var line = lines[i];
                if (line !== null && (line.indexOf("#") > -1 || !line.trim() )) {
                    continue;
                }
                var keywordValue = line.split("=");
                var keyword = keywordValue[0].replace(/^\s+|\s+$/g, "");
                var value = keywordValue[1].replace(/^\s+|\s+$/g, "");
                this.properties[keyword] = value;
            }
        };

        /**
         * Returns the properties
         * @return {{}}
         */
        Properties.prototype.getProperties = function () {
            return this.properties;
        };

        /**
         * Attaches the layer to the globe
         * @param g The globe
         * @private
         */
        HipsCatLayer.prototype._attach = function (g) {
            AbstractHipsLayer.prototype._attach.call(this, g);
            this.extId += this.id;
            g.tileManager.addPostRenderer(this);
        };

        /**************************************************************************************************************/

        /**
         * Detaches the layer from the globe
         * @private
         */
        HipsCatLayer.prototype._detach = function () {
            this.globe.tileManager.removePostRenderer(this);
            AbstractHipsLayer.prototype._detach.call(this);
        };

        /**************************************************************************************************************/

        /**
         * Launches request to the HipsCatLayer service
         * @param tile
         * @param url
         * @fires Context#startLoad
         * @fires Context#endLoad
         * @fires Context#features:added
         */
        HipsCatLayer.prototype.launchRequest = function (tile, url) {
            var tileData = tile.extension[this.extId];
            var index = null;

            if (this.freeRequests.length === 0) {
                return;
            }

            // Set that the tile is loading its data for HipsCatLayer
            tileData.state = HipsCatLayer.TileState.LOADING;

            // Pusblish the start load event, only if there is no pending requests
            if (this.maxRequests === this.freeRequests.length) {
                this.globe.publishEvent("startLoad", this);
            }

            var xhr = this.freeRequests.pop();
            var self = this;
            xhr.open("GET", url);
            xhr.send(null);
            xhr.onreadystatechange = function (e) {
                if (xhr.readyState === 4) {
                    if (xhr.status === 200) {
                        var response = {};
                        var headerInfo = {
                            'name':[],
                            'datatype':[]
                        };
                        self.fields.forEach(function(field) {
                            headerInfo.name.push(field.name());
                            headerInfo.datatype.push(field.datatype());
                        });
                        var csv = new CSV(xhr.response,"\t",headerInfo);
                        var geoJson = csv.getGeoJSon({"RA":self.raColNumber,"DEC":self.decColNumber,"ID":self.sourceId}, "Equatorial");
                        var features = geoJson.features;
                        response["features"] = features;
                        response["totalResults"] = features.length;

                        //var response = JSON.parse(xhr.response);

                        tileData.complete = (response.totalResults === response.features.length);

                        //self.updateFeatures(response.features);

                        var i;
                        for (i = response.features.length - 1; i >= 0; i--) {
                            var feature = response.features[i];
                            // Eliminate already added features from response
                            var alreadyAdded = self.featuresSet.hasOwnProperty(feature.id);
                            if (alreadyAdded)
                                response.features.splice(i, 1);

                            feature.properties.style = this.style;
                            self.addFeature(feature, tile);
                        }
                        self.globe.refresh();

                        // Publish event that layer have received new features
                        if (response.hasOwnProperty(features) && response.features.length > 0) {
                            self.globe.publishEvent("features:added", {layer: self, features: response.features});
                        }
                    }
                    else if (xhr.status >= 400) {
                        tileData.complete = true;
                    }

                    tileData.state = HipsCatLayer.TileState.LOADED;
                    self.freeRequests.push(xhr);

                    // Publish the end load event, only if there is no pending requests
                    if (self.maxRequests === self.freeRequests.length) {
                        self.globe.publishEvent("endLoad", self);
                    }
                }
            };
        };




        /**************************************************************************************************************/

        /**
         * Adds feature to the layer and to the tile extension
         * @param feature
         * @param tile
         */
        HipsCatLayer.prototype.addFeature = function (feature, tile) {
            var tileData = tile.extension[this.extId];
            var featureData;

            // Add feature if it doesn't exist
            if (!this.featuresSet.hasOwnProperty(feature.id)) {
                this.features.push(feature);
                featureData = {
                    index: this.features.length - 1,
                    tiles: [tile]
                };
                this.featuresSet[feature.id] = featureData;
            }
            else {
                featureData = this.featuresSet[feature.id];

                // Store the tile
                featureData.tiles.push(tile);

                // Always use the base feature to manage geometry indices
                feature = this.features[featureData.index];
            }

            // Add feature id
            tileData.featureIds.push(feature.id);

            // Set the identifier on the geometry
            feature.geometry.gid = feature.id;

            // Add to renderer
            //this.addFeatureToRenderer(feature, tile);

            // MS: Feature could be added from ClusterOpenSearch which have features with different styles
            var style = feature.properties.style ? feature.properties.style : this.style;

            this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
        };


        /**************************************************************************************************************/

        /**
         * Removes feature from Dynamic HipsCatLayer layer
         * @param identifier
         * @param tile
         */
        HipsCatLayer.prototype.removeFeature = function (identifier, tile) {
            var featureIt = this.featuresSet[identifier];

            if (!featureIt) {
                return;
            }

            // Remove tile from array
            var tileIndex = featureIt.tiles.indexOf(tile);
            if (tileIndex >= 0) {
                featureIt.tiles.splice(tileIndex, 1);
            }
            else {
                console.log('HipsCatLayer internal error : tile not found when removing feature');
            }

            if (featureIt.tiles.length === 0) {
                // Remove it from the set
                delete this.featuresSet[identifier];

                // Remove it from the array by swapping it with the last feature to optimize removal.
                var lastFeature = this.features.pop();
                if (featureIt.index < this.features.length) {
                    // Set the last feature at the position of the removed feature
                    this.features[featureIt.index] = lastFeature;
                    // Update its index in the Set.
                    this.featuresSet[lastFeature.id].index = featureIt.index;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Modifies feature style
         * @param feature
         * @param style
         */
        HipsCatLayer.prototype.modifyFeatureStyle = function (feature, style) {
            feature.properties.style = style;
            var featureData = this.featuresSet[feature.id];
            if (featureData) {
                var i;
                for (i = 0; i < featureData.tiles.length; i++) {
                    var tile = featureData.tiles[i];
                    this.globe.vectorRendererManager.removeGeometryFromTile(feature.geometry, tile);
                    this.globe.vectorRendererManager.addGeometryToTile(this, feature.geometry, style, tile);
                }

            }
        };

        HipsCatLayer.TileState = {
            LOADING: 0,
            LOADED: 1,
            NOT_LOADED: 2,
            INHERIT_PARENT: 3
        };


        /**************************************************************************************************************/

        /**
         * Generates the tile data
         * @param tile
         */
        HipsCatLayer.prototype.generate = function (tile) {
            if (this.minOrder <= tile.order && tile.order <= this.maxOrder) {
                tile.extension[this.extId] = new OSData(this, tile, null);
            }

        };

        /**************************************************************************************************************/

        /**
         * HipsCatLayer renderable
         * @param layer
         * @param tile
         * @param p
         * @constructor
         */
        var OSData = function (layer, tile, p) {
            this.layer = layer;
            this.parent = p;
            this.tile = tile;
            this.featureIds = []; // exclusive parameter to remove from layer
            this.state = HipsCatLayer.TileState.NOT_LOADED;
            this.complete = false;
            this.childrenCreated = false;
        };

        /**************************************************************************************************************/

        /**
         * Traverse
         * @param tile
         */
        OSData.prototype.traverse = function (tile) {
            var i;
            if (!this.layer.visible)
                return;

            if (tile.state !== Tile.State.LOADED)
                return;

            // Check if the tile need to be loaded
            if (this.state === HipsCatLayer.TileState.NOT_LOADED) {
                this.layer.tilesToLoad.push(this);
            }

            // Create children if needed
            if (this.state === HipsCatLayer.TileState.LOADED && !this.complete
                && tile.state === Tile.State.LOADED && tile.children && !this.childrenCreated) {
                for (i = 0; i < 4; i++) {
                    if (!tile.children[i].extension[this.layer.extId])
                        tile.children[i].extension[this.layer.extId] = new OSData(this.layer, tile.children[i], this);
                }
                this.childrenCreated = true;


                // HACK : set renderable to have children
                var renderables = tile.extension.renderer ? tile.extension.renderer.renderables : [];
                for (i = 0; i < renderables.length; i++) {
                    if (renderables[i].bucket.layer === this.layer)
                        renderables[i].hasChildren = true;
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Disposes renderable data from tile
         * @param renderContext
         * @param tilePool
         */
        OSData.prototype.dispose = function (renderContext, tilePool) {
            var i;
            if (this.parent && this.parent.childrenCreated) {
                this.parent.childrenCreated = false;
                // HACK : set renderable to not have children!
                var renderables = this.parent.tile.extension.renderer ? this.parent.tile.extension.renderer.renderables : [];
                for (i = 0; i < renderables.length; i++) {
                    if (renderables[i].bucket.layer === this.layer)
                        renderables[i].hasChildren = false;
                }
            }

            for (i = 0; i < this.featureIds.length; i++) {
                this.layer.removeFeature(this.featureIds[i], this.tile);
            }
            this.tile = null;
            this.parent = null;
        };

        /**************************************************************************************************************/

        /**
         * Builds URL
         * @param tile
         * @return {*}
         */
        HipsCatLayer.prototype.buildUrl = function (tile) {
            var url;
            if (tile.order <= 0) {
                url = this.serviceUrl + "/Norder" + tile.order + "/Allsky.xml";
            } else {
                url = this.serviceUrl;

                url += "/Norder";
                url += tile.order;

                url += "/Dir";
                var indexDirectory = Math.floor(tile.pixelIndex / 10000) * 10000;
                url += indexDirectory;

                url += "/Npix";
                url += tile.pixelIndex;
                url += ".tsv";
            }
            return url;
        };

        /**
         * Get Tile URL.
         * @param tile
         * @returns {*}
         */
        HipsCatLayer.prototype.getUrl = function (tile) {
            return this.buildUrl(tile);
        };

        /**************************************************************************************************************/

        /**
         * Internal function to sort tiles
         * @param t1
         * @param t2
         * @return {number}
         * @private
         */
        function _sortTilesByDistance(t1, t2) {
            return t1.tile.distance - t2.tile.distance;
        }

        /**
         * Render function
         *
         * @param tiles The array of tiles to render
         */
        HipsCatLayer.prototype.render = function (tiles) {
            var i;
            if (!this.visible)
                return;

            // Sort tiles
            this.tilesToLoad.sort(_sortTilesByDistance);

            // Load data for the tiles if needed
            for (i = 0; i < this.tilesToLoad.length && this.freeRequests.length > 0; i++) {
                var tile = this.tilesToLoad[i].tile;
                var url = this.buildUrl(tile);
                if (url) {
                    this.launchRequest(tile, url);
                }
            }

            this.tilesToLoad.length = 0;
        };


        /*************************************************************************************************************/

        return HipsCatLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Layer/GeoJsonLayer',['../Utils/Utils', './AbstractLayer', '../Utils/Constants'],
    function (Utils, AbstractLayer, Constants) {
        /**
         * GeoJson layer configuration
         * @typedef {AbstractLayer.configuration} AbstractLayer.geojson_configuration
         * @property {string} url - the url of json data to load when attaching to globe
         * @property {int} [minLevel = 0] - minimum rendering level depending on tile level
         * @property {int} [maxLevel = 15] - maximum rendering level depending on tile level
         * @property {function} [callback] - the callback function called when data are loaded. Data loaded are passed in parameter of the function.
         */
        /**
         * @name GeoJsonLayer
         * @class
         *    Create a layer to display vector data in GeoJSON format.
         * @augments AbstractLayer
         * @param {AbstractLayer.geojson_configuration} options - GeoJsonLayer configuration
         * @constructor
         * @memberOf module:Layer
         */
        var GeoJsonLayer = function (options) {
            AbstractLayer.prototype.constructor.call(this, Constants.LAYER.GeoJSON, options);

            this.url = this.proxify(options.url);
            this.gid = 0;


            if (options && options.callback) {
                this.callback = options.callback;
            } else {
                this.callback = null;
            }

            this.minLevel = options && options.hasOwnProperty('minLevel') ? options.minLevel : 0.0;
            this.maxLevel = options && options.hasOwnProperty('maxLevel') ? options.maxLevel : 15.0;

            this.features = [];

        };

        /**
         * Check if the GeoJSon has a valid geometry attribute
         * @param {Object} feature - GeoJSON feature
         * @throws {RangeError} Invalid GeoJson
         * @private
         */
        function _checkValidGeoJson(feature) {
            var geometry = feature.geometry;
            if (!geometry || !geometry.type) {
                throw new RangeError("Invalid GeoJson", "GeoJsonLayer.js");
            }
        }

        /**
         * Set the global crs when the geometry has not crs.
         * If no globalCrs, then WGS84 is set
         * @param {Object} feature - GeoJSON feature
         * @param {Object} globalCrs - GeoJSON crs element
         * @returns {Object} the feature
         * @private
         */
        function _setCrs(feature, globalCrs) {
            if(!feature.geometry.crs) {
                feature.geometry.crs = (globalCrs) ? globalCrs :  {
                    type: "name",
                    properties: {
                        name: Constants.CRS.WGS84
                    }
                };
            }
            return feature;
        }

        /**
         * Sets an unique ID of the GeoJSON geometry
         * @param {Object} feature - GeoJSON feature
         * @returns {Object} GeoJSON feature
         * @private
         */
        function _setID(feature) {
            feature.geometry.gid = "GeoJSON_" + this.gid;
            this.gid++;
            return feature;
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractLayer, GeoJsonLayer);

        /**************************************************************************************************************/

        /**
         * Attach the vector layer to the planet
         * @function _attach
         * @memberOf GeoJsonLayer#
         * @param {Planet} g globe
         * @private
         */
        GeoJsonLayer.prototype._attach = function (g) {
            AbstractLayer.prototype._attach.call(this, g);
            // Add the feature to renderers
            for (var i = 0; i < this.features.length; i++) {
                this._addFeatureToRenderers(this.features[i]);
            }
        };

        /**************************************************************************************************************/

        /**
         * Detach the vector layer from the planet
         * @function _detach
         * @memberOf GeoJsonLayer#
         * @private
         */
        GeoJsonLayer.prototype._detach = function () {
            // Remove feature from renderers
            for (var i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }

            this.features = [];

            AbstractLayer.prototype._detach.call(this);
        };


        /**
         * Adds a feature collection, in GeoJSON format
         * @function addFeatureCollection
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} featureCollection Feature Collection
         * @throws {ReferenceError} Error, featureCollection is null
         */
        GeoJsonLayer.prototype.addFeatureCollection = function (featureCollection) {
            // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
            if ((featureCollection === null) || (featureCollection === undefined)) {
                throw new ReferenceError("Error, featureCollection is null", "GeoJsonLayer.js");
            }

            var defaultCrs = {
                type: "name",
                properties: {
                    name: Constants.CRS.WGS84
                }
            };

            //check if crs is global at the featureCollection
            var crs = (featureCollection.crs) ? featureCollection.crs : defaultCrs;


            var features = featureCollection.features;
            if (features) {
                for (var i = 0; i < features.length; i++) {
                    this.addFeature(features[i], crs);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Removes a feature collection, in GeoJSON format
         * @function removeFeatureCollection
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} featureCollection Feature Collection
         */
        GeoJsonLayer.prototype.removeFeatureCollection = function (featureCollection) {
            // Note : use property defined as ['']  to avoid renaming when compiled in advanced mode with the closure compiler
            var features = featureCollection.features;
            if (features) {
                for (var i = 0; i < features.length; i++) {
                    this.removeFeature(features[i]);
                }
            }
            this.features = [];
        };

        /**************************************************************************************************************/

        /**
         * Add a feature to renderers
         * @function _addFeatureToRenderers
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        GeoJsonLayer.prototype._addFeatureToRenderers = function (feature) {
            var geometry = feature.geometry;

            // Manage style, if undefined try with properties, otherwise use defaultStyle
            var style = this.style;
            var props = feature.properties;
            if (props && props.style) {
                style = props.style;
            }

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                for (var i = 0; i < geoms.length; i++) {
                    this.globe.vectorRendererManager.addGeometry(this, geoms[i], style);
                }
            }
            else {
                // Add geometry to renderers
                this.globe.vectorRendererManager.addGeometry(this, geometry, style);
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove a feature from renderers
         * @function _removeFeatureFromRenderers
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @private
         */
        GeoJsonLayer.prototype._removeFeatureFromRenderers = function (feature) {
            var geometry = feature.geometry;

            // Manage geometry collection
            if (geometry.type === "GeometryCollection") {
                var geoms = geometry.geometries;
                var res = false;
                if (this.globe && this.globe.vectorRendererManager) {
                    for (var i = 0; i < geoms.length; i++) {
                        res = this.globe.vectorRendererManager.removeGeometry(geoms[i], this);
                    }
                }
                return res;
            }
            else {
                if (this.globe && this.globe.vectorRendererManager) {
                    return this.globe.vectorRendererManager.removeGeometry(geometry, this);
                }
            }
        };

        /**
         * Set data type of the GeoJSON : Point or LineString
         * @param feature
         * @memberOf GeoJsonLayer#
         * @private
         */
        GeoJsonLayer.prototype._setDataType = function(feature) {
            if (!this.datatype) {
                if (feature.geometry.type.startsWith(Constants.GEOMETRY.Point)) {
                    this.dataType = Constants.GEOMETRY.Point;
                } else {
                    this.dataType = Constants.GEOMETRY.LineString;
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Add a feature to the layer
         * @function addFeature
         * @memberOf GeoJsonLayer.prototype
         * @param {GeoJSON} feature Feature
         */
        GeoJsonLayer.prototype.addFeature = function (feature, globalCrs) {
            _checkValidGeoJson.call(this, feature);
            feature = _setCrs.call(this, feature, globalCrs);
            feature = _setID.call(this, feature);

            this._setDataType(feature);
            this.features.push(feature);

            // Add features to renderer if layer is attached to planet
            if (this.globe) {
                this._addFeatureToRenderers(feature);
                if (this.isVisible()) {
                    this.globe.renderContext.requestFrame();
                }
            }
        };

        /**************************************************************************************************************/
        /**
         * Remove a feature from the layer
         * @function removeFeature
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         */
        GeoJsonLayer.prototype.removeFeature = function (feature) {
            var index = this.features.indexOf(feature);
            this.features.splice(index, 1);
            if (this.globe) {
                this._removeFeatureFromRenderers(feature);
                if (this.isVisible()) {
                    this.globe.renderContext.requestFrame();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove all feature from the layer
         * @function removeAllFeatures
         * @memberOf GeoJsonLayer#
         */
        GeoJsonLayer.prototype.removeAllFeatures = function () {
            // Remove feature from renderers
            if (this.globe) {
                for (var i = 0; i < this.features.length; i++) {
                    this._removeFeatureFromRenderers(this.features[i]);
                }
            }
            this.features.length = 0;

            // Refresh rendering if needed
            if (this.globe && this.isVisible()) {
                this.globe.renderContext.requestFrame();
            }
        };

        /**************************************************************************************************************/
        /**
         * Modify feature style
         * @function modifyFeatureStyle
         * @memberOf GeoJsonLayer#
         * @param {GeoJSON} feature Feature
         * @param {FeatureStyle} style Feature style
         */
        GeoJsonLayer.prototype.modifyFeatureStyle = function (feature, style) {
            if (this._removeFeatureFromRenderers(feature)) {
                feature.properties.style = style;
                this._addFeatureToRenderers(feature);
            }
        };

        /**************************************************************************************************************/

        /**
         * Modify the vector layer style
         * @function modifyStyle
         * @memberOf GeoJsonLayer#
         * @param {FeatureStyle} style Feature style
         */
        GeoJsonLayer.prototype.modifyStyle = function (style) {
            var i;
            for (i = 0; i < this.features.length; i++) {
                this._removeFeatureFromRenderers(this.features[i]);
            }

            this.style = style;

            for (i = 0; i < this.features.length; i++) {
                this._addFeatureToRenderers(this.features[i]);
            }
        };

        /**************************************************************************************************************/

        /**
         * Get the vector layer style
         * @function getStyle
         * @memberOf GeoJsonLayer#
         * @return {FeatureStyle}  Feature style
         */
        GeoJsonLayer.prototype.getStyle = function () {
            return this.style;
        };

        /**
         * Set the vector layer style
         * @function setStyle
         * @memberOf GeoJsonLayer#
         * @param {FeatureStyle} arg Feature style
         */
        GeoJsonLayer.prototype.setStyle = function (arg) {
            this.style = arg;
        };

        return GeoJsonLayer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name LayerFactory
 * @class
 * Factory to create a layer
 * @memberOf module:Layer
 */
define('Layer/LayerFactory',["jquery","../Utils/Constants", "./WMSLayer", "./WMTSLayer", "./WCSElevationLayer", "./VectorLayer",
        "./AtmosphereLayer", "./BingLayer", "./GroundOverlayLayer", "./OSMLayer",
        "./TileWireframeLayer", "./CoordinateGridLayer",
        "./HipsFitsLayer",
        "./HipsGraphicLayer",
        "./MocLayer",
        "./OpenSearchLayer",
        "./WMSElevationLayer","./HipsMetadata","./HipsCatLayer", "./GeoJsonLayer"
    ],
    function ($, Constants, WMSLayer, WMTSLayer, WCSElevationLayer, VectorLayer, AtmosphereLayer,
              BingLayer, GroundOverlayLayer, OSMLayer, TileWireframeLayer, CoordinateGridLayer,
              HipsFitsLayer,
              HipsGraphicLayer,
              MocLayer,
              OpenSearchLayer,
              WMSElevationLayer, HipsMetadata, HipsCatLayer, GeoJsonLayer) {

        this.proxy = {
          url : null,
          use : false
        };


        function createHips(hipsMetadata, options) {
            options.proxy = this.proxy;
            var hipsProperties = (typeof hipsMetadata === 'undefined') ? new HipsMetadata(options.baseUrl) : hipsMetadata;

            var metadata = hipsProperties.getHipsMetadata();

            var formats = options.hasOwnProperty('hips_tile_format') ? options.hips_tile_format : metadata.hips_tile_format;
            var dataProducts = options.hasOwnProperty('dataproduct_type') ? options.dataproduct_type : metadata.dataproduct_type;

            var layer;

            switch(dataProducts) {
                case hipsProperties.DataProductType.catalog:
                    layer =  createHipsCats(metadata, options);
                    break;
                case hipsProperties.DataProductType.cube:
                    throw new RangeError("Hips : cannot handle cube dataproduct", "LayerFactor.js");
                    break;
                case hipsProperties.DataProductType.image:
                    options.category = options.hasOwnProperty('category') ? options.category : "Image";
                    var hasPNG = ($.inArray(hipsProperties.HipsTileFormat.png, formats) !== -1);
                    var hasJPEG = ($.inArray(hipsProperties.HipsTileFormat.jpeg, formats) !== -1);
                    var hasFits = ($.inArray(hipsProperties.HipsTileFormat.fits, formats) !== -1);
                    options.format = hasPNG ? hipsProperties.HipsTileFormat.png : "jpg";
                    //if(hasFits) {
                    //    layer = createHipsFits(metadata, options);
                    //} else {
                        layer = createHipsGraphic(metadata, options);
                    //}
                    break;
                case hipsProperties.DataProductType.meta:
                    throw new RangeError("Hips : cannot handle META dataproduct", "LayerFactor.js");
                    break;
                default:
                    throw new RangeError("Hips : Unknown dataproduct type", "LayerFactor.js");
            }
            //if(fileExists(options.baseUrl+"/Moc.fits") === 200) {
            //    options.serviceUrl = options.baseUrl+"/Moc.fits";
            //    layer.services.push(this.createMoc(options));
            //}
            return layer;
        }

        function createHipsFits(hipsMetadata, options) {
            options.proxy = this.proxy;
            return new HipsFitsLayer(hipsMetadata, options);
        }

        function createHipsGraphic(hipsMetadata, options) {
            options.proxy = this.proxy;
            return new HipsGraphicLayer(hipsMetadata, options);
        }

        function createHipsCats(hipsMetadata, options) {
            options.proxy = this.proxy;
            return new HipsCatLayer(hipsMetadata, options);
        }


        /**
         Create and get a MOC Layer
         @function createMoc
         @private
         @memberOf LayerFactory.prototype
         @param options Configuration properties for the MOC layer. See {@link MocLayer} for properties
         @return {MocLayer} layer
         */
        function createMoc(options) {
            options.proxy = this.proxy;
            options.style.fill = true;
            options.style.fillColor[3] = 0.3; // make transparent
            var layer = new MocLayer(options);
            layer.dataType = "line";
            return layer;
        }

        /**
         Create and get an OpenSearch Layer
         @function createOpenSearch
         @private
         @memberOf LayerFactory.prototype
         @param options Configuration properties for the OpenSearch layer. See {@link OpenSearchLayer} for properties
         @return {OpenSearchLayer} layer
         */
        function createOpenSearch(options) {
            options.proxy = this.proxy;
            var layer = new OpenSearchLayer(options);
            if (options.displayProperties) {
                layer.displayProperties = options.displayProperties;
            }
            layer.pickable = options.hasOwnProperty('pickable') ? options.pickable : true;
            layer.availableServices = options.availableServices;
            return layer;
        }


        return {
            /**
             * Factory for Layer.
             * @param {Object} options - See the base properties {@link AbstractLayer.configuration} and specific properties for specific layers
             * @param {string} options.type - one of the following value {Constants.Layer}
             * @return {AbstractLayer} - Object to handle Layer
             * @alias module:Layer.LayerFactory.create
             * @throws RangeError - "Unable to create the layer"
             * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
             * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
             * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
             * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
             * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
             * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
             * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
             * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
             * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
             * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
             * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
             * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
             * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
             * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
             * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
             * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
             * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
             */
            create: function (options) {
                var proxy = this.proxy;
                var layer;
                switch (options.type) {
                    case Constants.LAYER.WMS :
                        layer = new WMSLayer(options);
                        break;
                    case Constants.LAYER.WMTS :
                        layer = new WMTSLayer(options);
                        break;
                    case Constants.LAYER.WMSElevation :
                        layer = new WMSElevationLayer(options);
                        break;
                    case Constants.LAYER.WCSElevation :
                        layer = new WCSElevationLayer(options);
                        break;
                    case Constants.LAYER.GeoJSON:
                        layer = new GeoJsonLayer(options);
                        layer.pickable = options.hasOwnProperty('pickable') ? options.pickable : true;
                        break;
                    case Constants.LAYER.Vector :
                        layer = new VectorLayer(options);
                        layer.pickable = options.hasOwnProperty('pickable') ? options.pickable : true;
                        layer.deletable = options.hasOwnProperty('deletable') ? options.deletable : false;
                        break;
                    case Constants.LAYER.Atmosphere :
                        layer = new AtmosphereLayer(options);
                        break;
                    case Constants.LAYER.Bing :
                        layer = new BingLayer(options);
                        break;
                    case Constants.LAYER.GroundOverlay :
                        layer = new GroundOverlayLayer(options);
                        break;
                    case Constants.LAYER.OSM :
                        layer = new OSMLayer(options);
                        break;
                    case Constants.LAYER.HipsGrid:
                    case Constants.LAYER.TileWireframe :
                        layer = new TileWireframeLayer(options);
                        break;
                    case Constants.LAYER.HipsCat:
                        layer = new HipsCatLayer(options.hipsMetadata, options);
                        break;
                    case Constants.LAYER.CoordinateGrid :
                        layer = new CoordinateGridLayer(options);
                        break;
                    case Constants.LAYER.Hips :
                        layer = createHips(options.hipsMetadata, options);
                        break;
                    case Constants.LAYER.Moc :
                        layer = createMoc(options);
                        break;
                    case Constants.LAYER.OpenSearch :
                        layer = createOpenSearch(options);
                        break;
                    default :
                        throw new RangeError("Unable to create the layer " + options.type, "LayerFactor.js");
                }
                return layer;

            }

        }
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Image manager
 */
define('Services/FitsVisu',["jquery",
        "../Renderer/FeatureStyle", "../Renderer/DynamicImage", "../Layer/FitsLoader", "fits"],
    function ($,
              FeatureStyle, DynamicImage, FitsLoader) {

        var mizarAPI;

        /**********************************************************************************************/

        /**
         *    Send XHR request for FITS file
         *    @param featureData Feature data(layer,feature)
         *    @param {String} url Url of fits file
         *    @param {Function} preprocessing function if needed
         *    @fires Mizar#image:download
         */
        function computeFits(featureData, url, preprocessing) {

            // Store xhr on feature data object to cancel it if needed
            featureData.xhr = FitsLoader.loadFits(url, function (fits) {
                delete featureData.xhr;

                var fitsData = fits.getHDU().data;
                if (preprocessing) {
                    preprocessing(featureData, fits);
                }

                handleFits(fitsData, featureData);
            });
            mizarAPI.publish("image:download", featureData);
        }

        /**********************************************************************************************/

        /**
         * Handle fits data on the given feature
         * @param fitsData
         * @param featureData
         * @returns {Image} image
         */
        function handleFits(fitsData, featureData) {
            // Create new image coming from Fits
            var typedArray = new Float32Array(fitsData.view.buffer, fitsData.begin, fitsData.length / 4); // with gl.FLOAT
            var gl = mizarAPI.getRenderContext().gl;
            var image = new DynamicImage(mizarAPI.getRenderContext(), typedArray, gl.LUMINANCE, gl.FLOAT, fitsData.width, fitsData.height);

            var feature = featureData.feature;
            var layer = featureData.layer;
            // Attach texture to style
            var targetStyle;
            if (feature.properties.style) {
                targetStyle = new FeatureStyle(feature.properties.style);
            }
            else {
                targetStyle = new FeatureStyle(layer.style);
            }
            targetStyle.fillTexture = image.texture;
            targetStyle.uniformValues = image;
            targetStyle.fill = true;
            layer.modifyFeatureStyle(feature, targetStyle);

            // Store image url for zScale processing
            if (feature.services) {
                image.url = mizarAPI._getUrl(feature.services.download.url);
            }

            return image;
        }

        /**********************************************************************************************/

        function parseFits(response) {
            return FitsLoader.parseFits(response);
        }

        /**********************************************************************************************/

        /**
         * Remove fits texture from feature
         * @param featureData
         */
        function removeFitsFromRenderer(featureData) {
            // Abort xhr if inprogress
            if (featureData.xhr) {
                featureData.xhr.abort();
                delete featureData.xhr;
            }

            var gl = mizarAPI.getRenderContext().gl;
            if (featureData.feature.properties.style.uniformValues) {
                featureData.feature.properties.style.uniformValues.dispose();
            }
            // TODO : style could still contain fillTextures, is it normal ?
            var texture = featureData.feature.properties.style.fillTexture;
            if (texture) {
                gl.deleteTexture(texture);
            }
            var targetStyle = new FeatureStyle(featureData.feature.properties.style);
            targetStyle.fillTexture = null;
            targetStyle.fill = false;

            // Remove rendering
            targetStyle.fillShader = {
                fragmentCode: null,
                updateUniforms: null
            };
            delete targetStyle.uniformValues;

            featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
        }

        /**********************************************************************************************/

        return {

            /**
             * Initialize ImageManagerCore
             * @param m
             * @param configuration
             *      <ul>
             *          <li>sitoolsBaseUrl : the base sitools url used as proxy here
             *      </ul>
             */
            init: function (m, configuration) {
                mizarAPI = m;
                sitoolsBaseUrl = configuration.sitoolsBaseUrl;
                // Enable float texture extension to have higher luminance range
                var ext = mizarAPI.getRenderContext().gl.getExtension("OES_texture_float");
            },

            /**********************************************************************************************/

            /**
             * Hide image
             * @param {Feature} featureData
             */
            hideImage: function (featureData) {
                var style = new FeatureStyle(featureData.feature.properties.style);
                style.fill = false;
                featureData.layer.modifyFeatureStyle(featureData.feature, style);
            },

            /**********************************************************************************************/

            /**
             * Show image
             * @param {Feature} featureData
             */
            showImage: function (featureData) {
                // Attach texture to style
                var targetStyle = new FeatureStyle(featureData.feature.properties.style);
                targetStyle.fill = true;
                featureData.layer.modifyFeatureStyle(featureData.feature, targetStyle);
            },

            /**********************************************************************************************/

            /**
             * Remove image from renderer
             * @param {Feature} featureData
             * @fires Mizar#image:remove
             */
            removeImage: function (featureData) {

                // Publish event that the image of the given feature will be removed
                mizarAPI.publish("image:remove", featureData);
                if (featureData.isFits) {
                    removeFitsFromRenderer(featureData);
                    $('#quicklookFits').removeClass('selected');
                }
                else {
                    var style = featureData.feature.properties.style;
                    style.fill = false;
                    style.fillTextureUrl = null;
                    featureData.layer.modifyFeatureStyle(featureData.feature, style);
                    $('#quicklook').removeClass('selected');
                }
                mizarAPI.getActivatedContext().refresh();
            },

            /**********************************************************************************************/

            /**
             *    Start download of texture
             *    @param {Feature} featureData
             *    @fires Mizar#image:add
             */
            addImage: function (featureData) {
                var feature = featureData.feature;
                // Set fill to true while loading
                var style = new FeatureStyle(feature.properties.style);
                style.fill = true;

                // Publish event that the image for the given feature will be loaded
                mizarAPI.publish("image:add", featureData);

                if (featureData.isFits) {
                    //var url = proxyUrl + encodeURIComponent(feature.services.download.url);
                    //var url = encodeURIComponent(feature.services.download.url);*
                    var url = mizarAPI._getUrl(feature.services.download.url);
                    this.computeFits(featureData, url);
                    $('#quicklookFits').addClass('selected');
                }
                else {
                    style.fillTextureUrl =  mizarAPI._getUrl(feature.properties.quicklook);
                    //style.fillTextureUrl = feature.properties.quicklook;
                    // For DEBUG : 'upload/ADP_WFI_30DOR_RGB_V1.0_degraded.jpg';
                    $('#quicklook').addClass('selected');
                }
                featureData.layer.modifyFeatureStyle(feature, style);
                mizarAPI.getActivatedContext().refresh();
            },

            computeFits: computeFits,
            handleFits: handleFits,
            parseFits: parseFits
        };

        /**********************************************************************************************/

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Triangle Object use in Histogram classe
 */
define('Services/Triangle',[], function () {

  /**************************************************************************************************************/

  /**
   *    Test returning true if p1 and p2 are both lying on the same side of a-b, false otherwise
   */
  function _sameSide(p1, p2, a, b) {
      var temp1 = [];
      var temp2 = [];
      var temp3 = [];
      var cp1 = [];
      var cp2 = [];
      vec3.cross(vec3.subtract(b, a, temp1), vec3.subtract(p1, a, temp2), cp1);
      vec3.cross(temp1, vec3.subtract(p2, a, temp3), cp2);
      return vec3.dot(cp1, cp2) >= 0;
  }

  /**************************************************************************************************************/

  /**
   *    Private function to check if point is inside the given triangle
   *    If the point was on the same side of a-b as c and is also on the same side of b-c as a and on the same side of c-a as b, then it is in the triangle
   */
  function _pointInTriangle(p, a, b, c) {
      return (_sameSide(p, a, b, c) && _sameSide(p, b, a, c) && _sameSide(p, c, a, b));
  }

    /**************************************************************************************************************/

    /**
     *    Isoscele triangle object for thresholds manipulation
     *
     *    @param a Pointer of threshold pointing on histogram
     *    @param b Isoscele point 1
     *    @param c Isoscele point 2
     */
    var Triangle = function (a, b, c) {
        this.initA = a.slice(0);
        this.initB = b.slice(0);
        this.initC = c.slice(0);

        this.a = a; // Pointer to histogram
        this.b = b; // Isoscele point 1
        this.c = c; // Isoscele point 2

        this.dragging = false;
        this.hover = false;
        this.halfWidth = Math.abs((c[0] - b[0]) / 2);
    };


    /**************************************************************************************************************/

    /**
     *    Reset to initial position
     */
    Triangle.prototype.reset = function () {
        this.a = this.initA.slice(0);
        this.b = this.initB.slice(0);
        this.c = this.initC.slice(0);
    };

    /**************************************************************************************************************/

    /**
     *    Test if triangle contains the given point
     *    @param {Array} p point
     */
    Triangle.prototype.contains = function (p) {
        return _pointInTriangle(p, this.a, this.b, this.c);
    };

    /**************************************************************************************************************/

    /**
     * Draw the triangle
     * @param ctx the context
     * @param options
     *      <ul>
     *          <li>draggingColor : color used when moving triangle</li>
     *          <li>noDraggingColor : color used when triangle do not move</li>
     */
    Triangle.prototype.draw = function (ctx, options) {
        if (this.dragging) {
            ctx.fillStyle = options.draggingColor | "#FF0";
        }
        else {
            ctx.fillStyle = options.noDraggingColor | "#F00";
        }

        ctx.beginPath();
        ctx.moveTo(this.a[0], this.a[1]);
        ctx.lineTo(this.b[0], this.b[1]);
        ctx.lineTo(this.c[0], this.c[1]);
        ctx.closePath();
        ctx.fill();

        if (!this.dragging && this.hover) {
            ctx.strokeStyle = options.draggingColor | "#FF0";
            ctx.stroke();
        }
    };

    /**************************************************************************************************************/

    /**
     *    Modify triangle's position by the given "pointer" point
     *    (could be modified only by X-axis)
     *    @param {Array} point point
     */
    Triangle.prototype.modifyPosition = function (point) {
        this.a[0] = point[0];
        this.b[0] = point[0] - this.halfWidth;
        this.c[0] = point[0] + this.halfWidth;
    };

    /**************************************************************************************************************/

    return Triangle;
});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Histogram module : create histogram to the given image
 */
define('Services/HistogramCore',["./Triangle"], function (Triangle) {

    // Private variables
    var nbBins;
    var self;

    var canvas;
    var hist = [];
    var hmax; // histogram max to scale in image space

    // Origin histogram point
    var originX;
    var originY;
    var hwidth;
    var paddingBottom;
    var triangleHalfWidth;

    /**************************************************************************************************************/

    /**
     * Get mouse position on canvas
     * @param {HTMLElement} canvas
     * @param {Event} evt
     * @returns {{x: number, y: number}}
     */
    function _getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        return {
            x: evt.clientX - rect.left,
            y: evt.clientY - rect.top
        };
    }

    function _handleMouseDown (evt) {
        var mousePos = this._getMousePos(canvas, evt);

        if (self.minThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.minThreshold.dragging = true;
            self.minThreshold.draw(self.ctx);
        }

        if (self.maxThreshold.contains([mousePos.x, mousePos.y, 0])) {
            self.maxThreshold.dragging = true;
            self.maxThreshold.draw(self.ctx);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseUp (evt) {
        self.minThreshold.dragging = false;
        self.maxThreshold.dragging = false;

        if (self.onUpdate) {
            var min = self.getHistValue(self.minThreshold.a);
            var max = self.getHistValue(self.maxThreshold.a);

            self.minThreshold.reset();
            self.maxThreshold.reset();

            self.onUpdate(min, max);
        }
    }

    /**************************************************************************************************************/

    function _handleMouseMove (evt) {
        var mousePos = this._getMousePos(canvas, evt);

        self.ctx.clearRect(0.0, originY, canvas.width, paddingBottom);

        self.minThreshold.hover = self.minThreshold.contains([mousePos.x, mousePos.y, 0]);

        self.maxThreshold.hover = self.maxThreshold.contains([mousePos.x, mousePos.y, 0]);

        // Draw threshold controls
        if (self.minThreshold.dragging && mousePos.x >= self.minThreshold.initA[0] && mousePos.x < self.maxThreshold.a[0]) {
            self.minThreshold.modifyPosition([mousePos.x, self.minThreshold.a[1]]);
        }

        if (self.maxThreshold.dragging && mousePos.x <= self.maxThreshold.initA[0] && mousePos.x > self.minThreshold.a[0]) {
            self.maxThreshold.modifyPosition([mousePos.x, self.maxThreshold.a[1]]);
        }
        self.drawThresholdControls();

        // Don't draw histogram values if the mouse is out of histogram canvas
        if (mousePos.y > canvas.height || mousePos.y < 0.0 || mousePos.x > originX + nbBins || mousePos.x < originX) {
            return;
        }

        // Draw the text indicating the histogram value on mouse position
        self.ctx.font = '8pt Calibri';
        self.ctx.fillStyle = 'yellow';
        var thresholdValue = self.getHistValue([mousePos.x, mousePos.y]);
        self.ctx.fillText(thresholdValue, canvas.width / 2 - 15.0, originY + paddingBottom);
        // Draw a tiny line indicating the mouse position on X-axis
        self.ctx.fillRect(mousePos.x, originY, 1, 2);
    }

    /**************************************************************************************************************/

    /**
     * Get histogram value from the given X-position on canvas
     * @param {Array} position
     * @returns {number} value
     */
    function getHistValue(position) {
        return Math.floor((((position[0] - originX) / 256.0) * (this.image.tmax - this.image.tmin) + this.image.tmin) * Math.pow(10, this.accuracy)) / Math.pow(10, this.accuracy);
    }

    /**************************************************************************************************************/

    /**
     * Init Thresholds by creating to
     */
    function initThresholds() {

        originY = canvas.height - paddingBottom;
        hwidth = nbBins + originX > canvas.width ? canvas.width : nbBins + originX;

        this.minThreshold = new Triangle(
            [originX, originY + 1, 0],
            [originX - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [originX + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );

        this.maxThreshold = new Triangle(
            [hwidth, originY + 1, 0],
            [hwidth - triangleHalfWidth, originY + paddingBottom - 1, 0],
            [hwidth + triangleHalfWidth, originY + paddingBottom - 1, 0]
        );
    }

    /**************************************************************************************************************/

    function drawThresholdControls() {
        this.minThreshold.draw(this.ctx,  {});
        this.maxThreshold.draw(this.ctx, {});
    }

    /**************************************************************************************************************/

    /**
     * Draw histogram
     * @param {Object} options
     *        <ul>
     *            <li>color: inside graph color</li>
     *        </ul>
     *
     */
    function drawHistogram(options) {
        this.ctx.fillStyle = options.color || "blue";
        for (var i = 0; i < hist.length; i++) {
            // Scale to y-axis height
            var rectHeight = (hist[i] / hmax) * originY;
            this.ctx.fillRect(originX + i, originY, 1, -rectHeight);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw histogram axis
     */
    function drawAxes() {

        var leftY, rightX;
        leftY = 0;
        rightX = originX + hwidth;
        // Draw y axis.
        this.ctx.beginPath();
        this.ctx.moveTo(originX, leftY);
        this.ctx.lineTo(originX, originY);

        // Draw x axis.
        this.ctx.moveTo(originX, originY);
        this.ctx.lineTo(rightX, originY);

        // Define style and stroke lines.
        this.ctx.closePath();
        this.ctx.strokeStyle = "#fff";
        this.ctx.stroke();
    }

    /**************************************************************************************************************/

    /**
     *    Draw transfer function(linear, log, asin, sqrt, sqr)
     *    @param {Object} options
     *        <ul>
     *            <li>color: transfer stroke color</li>
     *        </ul>
     */
    function drawTransferFunction(options) {
        // Draw transfer functions
        // "Grey" colormap for now(luminance curve only)
        this.ctx.fillStyle = options.color || "red";
        for (var i = 0; i < nbBins; i++) {
            var value = i;
            var posX = originX + value;

            var scaledValue;
            switch (this.image.transferFn) {
                case "linear":
                    scaledValue = (value / nbBins) * originY;
                    break;
                case "log":
                    scaledValue = Math.log(value / 10.0 + 1) / Math.log(nbBins / 10.0 + 1) * originY;
                    break;
                case "sqrt":
                    scaledValue = Math.sqrt(value / 10.0) / Math.sqrt(nbBins / 10.0) * originY;
                    break;
                case "sqr":
                    scaledValue = Math.pow(value, 2) / Math.pow(nbBins, 2) * originY;
                    break;
                case "asin":
                    scaledValue = Math.log(value + Math.sqrt(Math.pow(value, 2) + 1.0)) / Math.log(nbBins + Math.sqrt(Math.pow(nbBins, 2) + 1.0)) * originY;
                    break;
                default:
                    break;
            }

            if (!this.image.inverse) {
                scaledValue = originY - scaledValue
            }
            this.ctx.fillRect(posX, scaledValue, 1, 1);
        }
    }

    /**************************************************************************************************************/

    /**
     *    Draw the histogram in canvas
     */
    function draw() {
        this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);
        this.drawHistogram();
        this.drawTransferFunction();
        this.drawAxes();
        this.drawThresholdControls();
    }

    /**************************************************************************************************************/

    /**
     *    TODO : create different module
     *    Compute histogram values
     */
    function compute() {
        var image = this.image;
        // Initialize histogram
        hist = new Array(nbBins);
        for (var i = 0; i < hist.length; i++) {
            hist[i] = 0;
        }

        // Compute histogram
        hmax = Number.MIN_VALUE;
        for (i = 0; i < image.pixels.length; i++) {
            var val = image.pixels[i];

            // Skip NaN
            if (isNaN(val)) {
                continue;
            }
            // Take only values which belongs to the interval [tmin,tmax]
            if (val < image.tmin) {
                continue;
            }
            if (val >= image.tmax) {
                continue;
            }

            // Scale to [0,255]
            var bin = Math.floor(nbBins * (val - image.tmin) / (image.tmax - image.tmin));
            hist[bin]++;

            // Compute histogram max value
            if (hist[bin] > hmax) {
                hmax = hist[bin];
            }
        }

        // Logarithmic scale for better layout
        for (i = 0; i < hist.length; i++) {
            hist[i] = Math.log(1 + hist[i]);
        }
        hmax = Math.log(1 + hmax);
    }

    /**************************************************************************************************************/

    /**
     *    Set image
     *    @param {Image} image
     */
    function setImage(image) {
        this.image = image;
    }

    /**************************************************************************************************************/

    return {
        /**
         *    Histogram contructor
         *    @param options Histogram options
         *        <ul>
         *            <li>canvas: The canvas context where to draw Histogram</li>
         *            <li>image: The image which is represented by current histogram(required)</li>
         *            <li>nbBins: Number of bins, representing the sampling of histogram(optional)</li>
         *            <li>onUpdate: On update callback
         *            <li>accuracy: The accuracy of histogram(numbers after floating point)
         *            <li>paddingBottom: space at the bottom
         *            <li>triangleHalfWidth: half width of the triangle to draw
         *            <li>originX
         *        </ul>
         */
        init : function (options) {
            this.image = options.image;
            this.onUpdate = options.onUpdate;
            this.accuracy = options.accuracy || 6;

            self = this;
            nbBins = options.nbBins || 256;
            paddingBottom = options.paddingBottom || 15.0;
            originX = options.originX || 5.0;
            triangleHalfWidth = options.triangleHalfWidth || 5;

            // Init canvas
            canvas = document.getElementById(options.canvas);
            this.ctx = canvas.getContext('2d');

            this.initThresholds();
        },
        initThresholds : initThresholds
    };
});

/*! jQuery UI - v1.12.1 - 2016-09-14
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/draggable.js, widgets/droppable.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/resizable.js, widgets/selectable.js, widgets/selectmenu.js, widgets/slider.js, widgets/sortable.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function(t){"function"==typeof define&&define.amd?define('jquery.ui',["jquery"],t):t(jQuery)})(function(t){function e(t){for(var e=t.css("visibility");"inherit"===e;)t=t.parent(),e=t.css("visibility");return"hidden"!==e}function i(t){for(var e,i;t.length&&t[0]!==document;){if(e=t.css("position"),("absolute"===e||"relative"===e||"fixed"===e)&&(i=parseInt(t.css("zIndex"),10),!isNaN(i)&&0!==i))return i;t=t.parent()}return 0}function s(){this._curInst=null,this._keyEvent=!1,this._disabledInputs=[],this._datepickerShowing=!1,this._inDialog=!1,this._mainDivId="ui-datepicker-div",this._inlineClass="ui-datepicker-inline",this._appendClass="ui-datepicker-append",this._triggerClass="ui-datepicker-trigger",this._dialogClass="ui-datepicker-dialog",this._disableClass="ui-datepicker-disabled",this._unselectableClass="ui-datepicker-unselectable",this._currentClass="ui-datepicker-current-day",this._dayOverClass="ui-datepicker-days-cell-over",this.regional=[],this.regional[""]={closeText:"Done",prevText:"Prev",nextText:"Next",currentText:"Today",monthNames:["January","February","March","April","May","June","July","August","September","October","November","December"],monthNamesShort:["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"],dayNames:["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"],dayNamesShort:["Sun","Mon","Tue","Wed","Thu","Fri","Sat"],dayNamesMin:["Su","Mo","Tu","We","Th","Fr","Sa"],weekHeader:"Wk",dateFormat:"mm/dd/yy",firstDay:0,isRTL:!1,showMonthAfterYear:!1,yearSuffix:""},this._defaults={showOn:"focus",showAnim:"fadeIn",showOptions:{},defaultDate:null,appendText:"",buttonText:"...",buttonImage:"",buttonImageOnly:!1,hideIfNoPrevNext:!1,navigationAsDateFormat:!1,gotoCurrent:!1,changeMonth:!1,changeYear:!1,yearRange:"c-10:c+10",showOtherMonths:!1,selectOtherMonths:!1,showWeek:!1,calculateWeek:this.iso8601Week,shortYearCutoff:"+10",minDate:null,maxDate:null,duration:"fast",beforeShowDay:null,beforeShow:null,onSelect:null,onChangeMonthYear:null,onClose:null,numberOfMonths:1,showCurrentAtPos:0,stepMonths:1,stepBigMonths:12,altField:"",altFormat:"",constrainInput:!0,showButtonPanel:!1,autoSize:!1,disabled:!1},t.extend(this._defaults,this.regional[""]),this.regional.en=t.extend(!0,{},this.regional[""]),this.regional["en-US"]=t.extend(!0,{},this.regional.en),this.dpDiv=n(t("<div id='"+this._mainDivId+"' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>"))}function n(e){var i="button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";return e.on("mouseout",i,function(){t(this).removeClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).removeClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).removeClass("ui-datepicker-next-hover")}).on("mouseover",i,o)}function o(){t.datepicker._isDisabledDatepicker(m.inline?m.dpDiv.parent()[0]:m.input[0])||(t(this).parents(".ui-datepicker-calendar").find("a").removeClass("ui-state-hover"),t(this).addClass("ui-state-hover"),-1!==this.className.indexOf("ui-datepicker-prev")&&t(this).addClass("ui-datepicker-prev-hover"),-1!==this.className.indexOf("ui-datepicker-next")&&t(this).addClass("ui-datepicker-next-hover"))}function a(e,i){t.extend(e,i);for(var s in i)null==i[s]&&(e[s]=i[s]);return e}function r(t){return function(){var e=this.element.val();t.apply(this,arguments),this._refresh(),e!==this.element.val()&&this._trigger("change")}}t.ui=t.ui||{},t.ui.version="1.12.1";var h=0,l=Array.prototype.slice;t.cleanData=function(e){return function(i){var s,n,o;for(o=0;null!=(n=i[o]);o++)try{s=t._data(n,"events"),s&&s.remove&&t(n).triggerHandler("remove")}catch(a){}e(i)}}(t.cleanData),t.widget=function(e,i,s){var n,o,a,r={},h=e.split(".")[0];e=e.split(".")[1];var l=h+"-"+e;return s||(s=i,i=t.Widget),t.isArray(s)&&(s=t.extend.apply(null,[{}].concat(s))),t.expr[":"][l.toLowerCase()]=function(e){return!!t.data(e,l)},t[h]=t[h]||{},n=t[h][e],o=t[h][e]=function(t,e){return this._createWidget?(arguments.length&&this._createWidget(t,e),void 0):new o(t,e)},t.extend(o,n,{version:s.version,_proto:t.extend({},s),_childConstructors:[]}),a=new i,a.options=t.widget.extend({},a.options),t.each(s,function(e,s){return t.isFunction(s)?(r[e]=function(){function t(){return i.prototype[e].apply(this,arguments)}function n(t){return i.prototype[e].apply(this,t)}return function(){var e,i=this._super,o=this._superApply;return this._super=t,this._superApply=n,e=s.apply(this,arguments),this._super=i,this._superApply=o,e}}(),void 0):(r[e]=s,void 0)}),o.prototype=t.widget.extend(a,{widgetEventPrefix:n?a.widgetEventPrefix||e:e},r,{constructor:o,namespace:h,widgetName:e,widgetFullName:l}),n?(t.each(n._childConstructors,function(e,i){var s=i.prototype;t.widget(s.namespace+"."+s.widgetName,o,i._proto)}),delete n._childConstructors):i._childConstructors.push(o),t.widget.bridge(e,o),o},t.widget.extend=function(e){for(var i,s,n=l.call(arguments,1),o=0,a=n.length;a>o;o++)for(i in n[o])s=n[o][i],n[o].hasOwnProperty(i)&&void 0!==s&&(e[i]=t.isPlainObject(s)?t.isPlainObject(e[i])?t.widget.extend({},e[i],s):t.widget.extend({},s):s);return e},t.widget.bridge=function(e,i){var s=i.prototype.widgetFullName||e;t.fn[e]=function(n){var o="string"==typeof n,a=l.call(arguments,1),r=this;return o?this.length||"instance"!==n?this.each(function(){var i,o=t.data(this,s);return"instance"===n?(r=o,!1):o?t.isFunction(o[n])&&"_"!==n.charAt(0)?(i=o[n].apply(o,a),i!==o&&void 0!==i?(r=i&&i.jquery?r.pushStack(i.get()):i,!1):void 0):t.error("no such method '"+n+"' for "+e+" widget instance"):t.error("cannot call methods on "+e+" prior to initialization; "+"attempted to call method '"+n+"'")}):r=void 0:(a.length&&(n=t.widget.extend.apply(null,[n].concat(a))),this.each(function(){var e=t.data(this,s);e?(e.option(n||{}),e._init&&e._init()):t.data(this,s,new i(n,this))})),r}},t.Widget=function(){},t.Widget._childConstructors=[],t.Widget.prototype={widgetName:"widget",widgetEventPrefix:"",defaultElement:"<div>",options:{classes:{},disabled:!1,create:null},_createWidget:function(e,i){i=t(i||this.defaultElement||this)[0],this.element=t(i),this.uuid=h++,this.eventNamespace="."+this.widgetName+this.uuid,this.bindings=t(),this.hoverable=t(),this.focusable=t(),this.classesElementLookup={},i!==this&&(t.data(i,this.widgetFullName,this),this._on(!0,this.element,{remove:function(t){t.target===i&&this.destroy()}}),this.document=t(i.style?i.ownerDocument:i.document||i),this.window=t(this.document[0].defaultView||this.document[0].parentWindow)),this.options=t.widget.extend({},this.options,this._getCreateOptions(),e),this._create(),this.options.disabled&&this._setOptionDisabled(this.options.disabled),this._trigger("create",null,this._getCreateEventData()),this._init()},_getCreateOptions:function(){return{}},_getCreateEventData:t.noop,_create:t.noop,_init:t.noop,destroy:function(){var e=this;this._destroy(),t.each(this.classesElementLookup,function(t,i){e._removeClass(i,t)}),this.element.off(this.eventNamespace).removeData(this.widgetFullName),this.widget().off(this.eventNamespace).removeAttr("aria-disabled"),this.bindings.off(this.eventNamespace)},_destroy:t.noop,widget:function(){return this.element},option:function(e,i){var s,n,o,a=e;if(0===arguments.length)return t.widget.extend({},this.options);if("string"==typeof e)if(a={},s=e.split("."),e=s.shift(),s.length){for(n=a[e]=t.widget.extend({},this.options[e]),o=0;s.length-1>o;o++)n[s[o]]=n[s[o]]||{},n=n[s[o]];if(e=s.pop(),1===arguments.length)return void 0===n[e]?null:n[e];n[e]=i}else{if(1===arguments.length)return void 0===this.options[e]?null:this.options[e];a[e]=i}return this._setOptions(a),this},_setOptions:function(t){var e;for(e in t)this._setOption(e,t[e]);return this},_setOption:function(t,e){return"classes"===t&&this._setOptionClasses(e),this.options[t]=e,"disabled"===t&&this._setOptionDisabled(e),this},_setOptionClasses:function(e){var i,s,n;for(i in e)n=this.classesElementLookup[i],e[i]!==this.options.classes[i]&&n&&n.length&&(s=t(n.get()),this._removeClass(n,i),s.addClass(this._classes({element:s,keys:i,classes:e,add:!0})))},_setOptionDisabled:function(t){this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,!!t),t&&(this._removeClass(this.hoverable,null,"ui-state-hover"),this._removeClass(this.focusable,null,"ui-state-focus"))},enable:function(){return this._setOptions({disabled:!1})},disable:function(){return this._setOptions({disabled:!0})},_classes:function(e){function i(i,o){var a,r;for(r=0;i.length>r;r++)a=n.classesElementLookup[i[r]]||t(),a=e.add?t(t.unique(a.get().concat(e.element.get()))):t(a.not(e.element).get()),n.classesElementLookup[i[r]]=a,s.push(i[r]),o&&e.classes[i[r]]&&s.push(e.classes[i[r]])}var s=[],n=this;return e=t.extend({element:this.element,classes:this.options.classes||{}},e),this._on(e.element,{remove:"_untrackClassesElement"}),e.keys&&i(e.keys.match(/\S+/g)||[],!0),e.extra&&i(e.extra.match(/\S+/g)||[]),s.join(" ")},_untrackClassesElement:function(e){var i=this;t.each(i.classesElementLookup,function(s,n){-1!==t.inArray(e.target,n)&&(i.classesElementLookup[s]=t(n.not(e.target).get()))})},_removeClass:function(t,e,i){return this._toggleClass(t,e,i,!1)},_addClass:function(t,e,i){return this._toggleClass(t,e,i,!0)},_toggleClass:function(t,e,i,s){s="boolean"==typeof s?s:i;var n="string"==typeof t||null===t,o={extra:n?e:i,keys:n?t:e,element:n?this.element:t,add:s};return o.element.toggleClass(this._classes(o),s),this},_on:function(e,i,s){var n,o=this;"boolean"!=typeof e&&(s=i,i=e,e=!1),s?(i=n=t(i),this.bindings=this.bindings.add(i)):(s=i,i=this.element,n=this.widget()),t.each(s,function(s,a){function r(){return e||o.options.disabled!==!0&&!t(this).hasClass("ui-state-disabled")?("string"==typeof a?o[a]:a).apply(o,arguments):void 0}"string"!=typeof a&&(r.guid=a.guid=a.guid||r.guid||t.guid++);var h=s.match(/^([\w:-]*)\s*(.*)$/),l=h[1]+o.eventNamespace,c=h[2];c?n.on(l,c,r):i.on(l,r)})},_off:function(e,i){i=(i||"").split(" ").join(this.eventNamespace+" ")+this.eventNamespace,e.off(i).off(i),this.bindings=t(this.bindings.not(e).get()),this.focusable=t(this.focusable.not(e).get()),this.hoverable=t(this.hoverable.not(e).get())},_delay:function(t,e){function i(){return("string"==typeof t?s[t]:t).apply(s,arguments)}var s=this;return setTimeout(i,e||0)},_hoverable:function(e){this.hoverable=this.hoverable.add(e),this._on(e,{mouseenter:function(e){this._addClass(t(e.currentTarget),null,"ui-state-hover")},mouseleave:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-hover")}})},_focusable:function(e){this.focusable=this.focusable.add(e),this._on(e,{focusin:function(e){this._addClass(t(e.currentTarget),null,"ui-state-focus")},focusout:function(e){this._removeClass(t(e.currentTarget),null,"ui-state-focus")}})},_trigger:function(e,i,s){var n,o,a=this.options[e];if(s=s||{},i=t.Event(i),i.type=(e===this.widgetEventPrefix?e:this.widgetEventPrefix+e).toLowerCase(),i.target=this.element[0],o=i.originalEvent)for(n in o)n in i||(i[n]=o[n]);return this.element.trigger(i,s),!(t.isFunction(a)&&a.apply(this.element[0],[i].concat(s))===!1||i.isDefaultPrevented())}},t.each({show:"fadeIn",hide:"fadeOut"},function(e,i){t.Widget.prototype["_"+e]=function(s,n,o){"string"==typeof n&&(n={effect:n});var a,r=n?n===!0||"number"==typeof n?i:n.effect||i:e;n=n||{},"number"==typeof n&&(n={duration:n}),a=!t.isEmptyObject(n),n.complete=o,n.delay&&s.delay(n.delay),a&&t.effects&&t.effects.effect[r]?s[e](n):r!==e&&s[r]?s[r](n.duration,n.easing,o):s.queue(function(i){t(this)[e](),o&&o.call(s[0]),i()})}}),t.widget,function(){function e(t,e,i){return[parseFloat(t[0])*(u.test(t[0])?e/100:1),parseFloat(t[1])*(u.test(t[1])?i/100:1)]}function i(e,i){return parseInt(t.css(e,i),10)||0}function s(e){var i=e[0];return 9===i.nodeType?{width:e.width(),height:e.height(),offset:{top:0,left:0}}:t.isWindow(i)?{width:e.width(),height:e.height(),offset:{top:e.scrollTop(),left:e.scrollLeft()}}:i.preventDefault?{width:0,height:0,offset:{top:i.pageY,left:i.pageX}}:{width:e.outerWidth(),height:e.outerHeight(),offset:e.offset()}}var n,o=Math.max,a=Math.abs,r=/left|center|right/,h=/top|center|bottom/,l=/[\+\-]\d+(\.[\d]+)?%?/,c=/^\w+/,u=/%$/,d=t.fn.position;t.position={scrollbarWidth:function(){if(void 0!==n)return n;var e,i,s=t("<div style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>"),o=s.children()[0];return t("body").append(s),e=o.offsetWidth,s.css("overflow","scroll"),i=o.offsetWidth,e===i&&(i=s[0].clientWidth),s.remove(),n=e-i},getScrollInfo:function(e){var i=e.isWindow||e.isDocument?"":e.element.css("overflow-x"),s=e.isWindow||e.isDocument?"":e.element.css("overflow-y"),n="scroll"===i||"auto"===i&&e.width<e.element[0].scrollWidth,o="scroll"===s||"auto"===s&&e.height<e.element[0].scrollHeight;return{width:o?t.position.scrollbarWidth():0,height:n?t.position.scrollbarWidth():0}},getWithinInfo:function(e){var i=t(e||window),s=t.isWindow(i[0]),n=!!i[0]&&9===i[0].nodeType,o=!s&&!n;return{element:i,isWindow:s,isDocument:n,offset:o?t(e).offset():{left:0,top:0},scrollLeft:i.scrollLeft(),scrollTop:i.scrollTop(),width:i.outerWidth(),height:i.outerHeight()}}},t.fn.position=function(n){if(!n||!n.of)return d.apply(this,arguments);n=t.extend({},n);var u,p,f,g,m,_,v=t(n.of),b=t.position.getWithinInfo(n.within),y=t.position.getScrollInfo(b),w=(n.collision||"flip").split(" "),k={};return _=s(v),v[0].preventDefault&&(n.at="left top"),p=_.width,f=_.height,g=_.offset,m=t.extend({},g),t.each(["my","at"],function(){var t,e,i=(n[this]||"").split(" ");1===i.length&&(i=r.test(i[0])?i.concat(["center"]):h.test(i[0])?["center"].concat(i):["center","center"]),i[0]=r.test(i[0])?i[0]:"center",i[1]=h.test(i[1])?i[1]:"center",t=l.exec(i[0]),e=l.exec(i[1]),k[this]=[t?t[0]:0,e?e[0]:0],n[this]=[c.exec(i[0])[0],c.exec(i[1])[0]]}),1===w.length&&(w[1]=w[0]),"right"===n.at[0]?m.left+=p:"center"===n.at[0]&&(m.left+=p/2),"bottom"===n.at[1]?m.top+=f:"center"===n.at[1]&&(m.top+=f/2),u=e(k.at,p,f),m.left+=u[0],m.top+=u[1],this.each(function(){var s,r,h=t(this),l=h.outerWidth(),c=h.outerHeight(),d=i(this,"marginLeft"),_=i(this,"marginTop"),x=l+d+i(this,"marginRight")+y.width,C=c+_+i(this,"marginBottom")+y.height,D=t.extend({},m),I=e(k.my,h.outerWidth(),h.outerHeight());"right"===n.my[0]?D.left-=l:"center"===n.my[0]&&(D.left-=l/2),"bottom"===n.my[1]?D.top-=c:"center"===n.my[1]&&(D.top-=c/2),D.left+=I[0],D.top+=I[1],s={marginLeft:d,marginTop:_},t.each(["left","top"],function(e,i){t.ui.position[w[e]]&&t.ui.position[w[e]][i](D,{targetWidth:p,targetHeight:f,elemWidth:l,elemHeight:c,collisionPosition:s,collisionWidth:x,collisionHeight:C,offset:[u[0]+I[0],u[1]+I[1]],my:n.my,at:n.at,within:b,elem:h})}),n.using&&(r=function(t){var e=g.left-D.left,i=e+p-l,s=g.top-D.top,r=s+f-c,u={target:{element:v,left:g.left,top:g.top,width:p,height:f},element:{element:h,left:D.left,top:D.top,width:l,height:c},horizontal:0>i?"left":e>0?"right":"center",vertical:0>r?"top":s>0?"bottom":"middle"};l>p&&p>a(e+i)&&(u.horizontal="center"),c>f&&f>a(s+r)&&(u.vertical="middle"),u.important=o(a(e),a(i))>o(a(s),a(r))?"horizontal":"vertical",n.using.call(this,t,u)}),h.offset(t.extend(D,{using:r}))})},t.ui.position={fit:{left:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollLeft:s.offset.left,a=s.width,r=t.left-e.collisionPosition.marginLeft,h=n-r,l=r+e.collisionWidth-a-n;e.collisionWidth>a?h>0&&0>=l?(i=t.left+h+e.collisionWidth-a-n,t.left+=h-i):t.left=l>0&&0>=h?n:h>l?n+a-e.collisionWidth:n:h>0?t.left+=h:l>0?t.left-=l:t.left=o(t.left-r,t.left)},top:function(t,e){var i,s=e.within,n=s.isWindow?s.scrollTop:s.offset.top,a=e.within.height,r=t.top-e.collisionPosition.marginTop,h=n-r,l=r+e.collisionHeight-a-n;e.collisionHeight>a?h>0&&0>=l?(i=t.top+h+e.collisionHeight-a-n,t.top+=h-i):t.top=l>0&&0>=h?n:h>l?n+a-e.collisionHeight:n:h>0?t.top+=h:l>0?t.top-=l:t.top=o(t.top-r,t.top)}},flip:{left:function(t,e){var i,s,n=e.within,o=n.offset.left+n.scrollLeft,r=n.width,h=n.isWindow?n.scrollLeft:n.offset.left,l=t.left-e.collisionPosition.marginLeft,c=l-h,u=l+e.collisionWidth-r-h,d="left"===e.my[0]?-e.elemWidth:"right"===e.my[0]?e.elemWidth:0,p="left"===e.at[0]?e.targetWidth:"right"===e.at[0]?-e.targetWidth:0,f=-2*e.offset[0];0>c?(i=t.left+d+p+f+e.collisionWidth-r-o,(0>i||a(c)>i)&&(t.left+=d+p+f)):u>0&&(s=t.left-e.collisionPosition.marginLeft+d+p+f-h,(s>0||u>a(s))&&(t.left+=d+p+f))},top:function(t,e){var i,s,n=e.within,o=n.offset.top+n.scrollTop,r=n.height,h=n.isWindow?n.scrollTop:n.offset.top,l=t.top-e.collisionPosition.marginTop,c=l-h,u=l+e.collisionHeight-r-h,d="top"===e.my[1],p=d?-e.elemHeight:"bottom"===e.my[1]?e.elemHeight:0,f="top"===e.at[1]?e.targetHeight:"bottom"===e.at[1]?-e.targetHeight:0,g=-2*e.offset[1];0>c?(s=t.top+p+f+g+e.collisionHeight-r-o,(0>s||a(c)>s)&&(t.top+=p+f+g)):u>0&&(i=t.top-e.collisionPosition.marginTop+p+f+g-h,(i>0||u>a(i))&&(t.top+=p+f+g))}},flipfit:{left:function(){t.ui.position.flip.left.apply(this,arguments),t.ui.position.fit.left.apply(this,arguments)},top:function(){t.ui.position.flip.top.apply(this,arguments),t.ui.position.fit.top.apply(this,arguments)}}}}(),t.ui.position,t.extend(t.expr[":"],{data:t.expr.createPseudo?t.expr.createPseudo(function(e){return function(i){return!!t.data(i,e)}}):function(e,i,s){return!!t.data(e,s[3])}}),t.fn.extend({disableSelection:function(){var t="onselectstart"in document.createElement("div")?"selectstart":"mousedown";return function(){return this.on(t+".ui-disableSelection",function(t){t.preventDefault()})}}(),enableSelection:function(){return this.off(".ui-disableSelection")}});var c="ui-effects-",u="ui-effects-style",d="ui-effects-animated",p=t;t.effects={effect:{}},function(t,e){function i(t,e,i){var s=u[e.type]||{};return null==t?i||!e.def?null:e.def:(t=s.floor?~~t:parseFloat(t),isNaN(t)?e.def:s.mod?(t+s.mod)%s.mod:0>t?0:t>s.max?s.max:t)}function s(i){var s=l(),n=s._rgba=[];return i=i.toLowerCase(),f(h,function(t,o){var a,r=o.re.exec(i),h=r&&o.parse(r),l=o.space||"rgba";return h?(a=s[l](h),s[c[l].cache]=a[c[l].cache],n=s._rgba=a._rgba,!1):e}),n.length?("0,0,0,0"===n.join()&&t.extend(n,o.transparent),s):o[i]}function n(t,e,i){return i=(i+1)%1,1>6*i?t+6*(e-t)*i:1>2*i?e:2>3*i?t+6*(e-t)*(2/3-i):t}var o,a="backgroundColor borderBottomColor borderLeftColor borderRightColor borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",r=/^([\-+])=\s*(\d+\.?\d*)/,h=[{re:/rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[t[1],t[2],t[3],t[4]]}},{re:/rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,parse:function(t){return[2.55*t[1],2.55*t[2],2.55*t[3],t[4]]}},{re:/#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,parse:function(t){return[parseInt(t[1],16),parseInt(t[2],16),parseInt(t[3],16)]}},{re:/#([a-f0-9])([a-f0-9])([a-f0-9])/,parse:function(t){return[parseInt(t[1]+t[1],16),parseInt(t[2]+t[2],16),parseInt(t[3]+t[3],16)]}},{re:/hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,space:"hsla",parse:function(t){return[t[1],t[2]/100,t[3]/100,t[4]]}}],l=t.Color=function(e,i,s,n){return new t.Color.fn.parse(e,i,s,n)},c={rgba:{props:{red:{idx:0,type:"byte"},green:{idx:1,type:"byte"},blue:{idx:2,type:"byte"}}},hsla:{props:{hue:{idx:0,type:"degrees"},saturation:{idx:1,type:"percent"},lightness:{idx:2,type:"percent"}}}},u={"byte":{floor:!0,max:255},percent:{max:1},degrees:{mod:360,floor:!0}},d=l.support={},p=t("<p>")[0],f=t.each;p.style.cssText="background-color:rgba(1,1,1,.5)",d.rgba=p.style.backgroundColor.indexOf("rgba")>-1,f(c,function(t,e){e.cache="_"+t,e.props.alpha={idx:3,type:"percent",def:1}}),l.fn=t.extend(l.prototype,{parse:function(n,a,r,h){if(n===e)return this._rgba=[null,null,null,null],this;(n.jquery||n.nodeType)&&(n=t(n).css(a),a=e);var u=this,d=t.type(n),p=this._rgba=[];return a!==e&&(n=[n,a,r,h],d="array"),"string"===d?this.parse(s(n)||o._default):"array"===d?(f(c.rgba.props,function(t,e){p[e.idx]=i(n[e.idx],e)}),this):"object"===d?(n instanceof l?f(c,function(t,e){n[e.cache]&&(u[e.cache]=n[e.cache].slice())}):f(c,function(e,s){var o=s.cache;f(s.props,function(t,e){if(!u[o]&&s.to){if("alpha"===t||null==n[t])return;u[o]=s.to(u._rgba)}u[o][e.idx]=i(n[t],e,!0)}),u[o]&&0>t.inArray(null,u[o].slice(0,3))&&(u[o][3]=1,s.from&&(u._rgba=s.from(u[o])))}),this):e},is:function(t){var i=l(t),s=!0,n=this;return f(c,function(t,o){var a,r=i[o.cache];return r&&(a=n[o.cache]||o.to&&o.to(n._rgba)||[],f(o.props,function(t,i){return null!=r[i.idx]?s=r[i.idx]===a[i.idx]:e})),s}),s},_space:function(){var t=[],e=this;return f(c,function(i,s){e[s.cache]&&t.push(i)}),t.pop()},transition:function(t,e){var s=l(t),n=s._space(),o=c[n],a=0===this.alpha()?l("transparent"):this,r=a[o.cache]||o.to(a._rgba),h=r.slice();return s=s[o.cache],f(o.props,function(t,n){var o=n.idx,a=r[o],l=s[o],c=u[n.type]||{};null!==l&&(null===a?h[o]=l:(c.mod&&(l-a>c.mod/2?a+=c.mod:a-l>c.mod/2&&(a-=c.mod)),h[o]=i((l-a)*e+a,n)))}),this[n](h)},blend:function(e){if(1===this._rgba[3])return this;var i=this._rgba.slice(),s=i.pop(),n=l(e)._rgba;return l(t.map(i,function(t,e){return(1-s)*n[e]+s*t}))},toRgbaString:function(){var e="rgba(",i=t.map(this._rgba,function(t,e){return null==t?e>2?1:0:t});return 1===i[3]&&(i.pop(),e="rgb("),e+i.join()+")"},toHslaString:function(){var e="hsla(",i=t.map(this.hsla(),function(t,e){return null==t&&(t=e>2?1:0),e&&3>e&&(t=Math.round(100*t)+"%"),t});return 1===i[3]&&(i.pop(),e="hsl("),e+i.join()+")"},toHexString:function(e){var i=this._rgba.slice(),s=i.pop();return e&&i.push(~~(255*s)),"#"+t.map(i,function(t){return t=(t||0).toString(16),1===t.length?"0"+t:t}).join("")},toString:function(){return 0===this._rgba[3]?"transparent":this.toRgbaString()}}),l.fn.parse.prototype=l.fn,c.hsla.to=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e,i,s=t[0]/255,n=t[1]/255,o=t[2]/255,a=t[3],r=Math.max(s,n,o),h=Math.min(s,n,o),l=r-h,c=r+h,u=.5*c;return e=h===r?0:s===r?60*(n-o)/l+360:n===r?60*(o-s)/l+120:60*(s-n)/l+240,i=0===l?0:.5>=u?l/c:l/(2-c),[Math.round(e)%360,i,u,null==a?1:a]},c.hsla.from=function(t){if(null==t[0]||null==t[1]||null==t[2])return[null,null,null,t[3]];var e=t[0]/360,i=t[1],s=t[2],o=t[3],a=.5>=s?s*(1+i):s+i-s*i,r=2*s-a;return[Math.round(255*n(r,a,e+1/3)),Math.round(255*n(r,a,e)),Math.round(255*n(r,a,e-1/3)),o]},f(c,function(s,n){var o=n.props,a=n.cache,h=n.to,c=n.from;l.fn[s]=function(s){if(h&&!this[a]&&(this[a]=h(this._rgba)),s===e)return this[a].slice();var n,r=t.type(s),u="array"===r||"object"===r?s:arguments,d=this[a].slice();return f(o,function(t,e){var s=u["object"===r?t:e.idx];null==s&&(s=d[e.idx]),d[e.idx]=i(s,e)}),c?(n=l(c(d)),n[a]=d,n):l(d)},f(o,function(e,i){l.fn[e]||(l.fn[e]=function(n){var o,a=t.type(n),h="alpha"===e?this._hsla?"hsla":"rgba":s,l=this[h](),c=l[i.idx];return"undefined"===a?c:("function"===a&&(n=n.call(this,c),a=t.type(n)),null==n&&i.empty?this:("string"===a&&(o=r.exec(n),o&&(n=c+parseFloat(o[2])*("+"===o[1]?1:-1))),l[i.idx]=n,this[h](l)))})})}),l.hook=function(e){var i=e.split(" ");f(i,function(e,i){t.cssHooks[i]={set:function(e,n){var o,a,r="";if("transparent"!==n&&("string"!==t.type(n)||(o=s(n)))){if(n=l(o||n),!d.rgba&&1!==n._rgba[3]){for(a="backgroundColor"===i?e.parentNode:e;(""===r||"transparent"===r)&&a&&a.style;)try{r=t.css(a,"backgroundColor"),a=a.parentNode}catch(h){}n=n.blend(r&&"transparent"!==r?r:"_default")}n=n.toRgbaString()}try{e.style[i]=n}catch(h){}}},t.fx.step[i]=function(e){e.colorInit||(e.start=l(e.elem,i),e.end=l(e.end),e.colorInit=!0),t.cssHooks[i].set(e.elem,e.start.transition(e.end,e.pos))}})},l.hook(a),t.cssHooks.borderColor={expand:function(t){var e={};return f(["Top","Right","Bottom","Left"],function(i,s){e["border"+s+"Color"]=t}),e}},o=t.Color.names={aqua:"#00ffff",black:"#000000",blue:"#0000ff",fuchsia:"#ff00ff",gray:"#808080",green:"#008000",lime:"#00ff00",maroon:"#800000",navy:"#000080",olive:"#808000",purple:"#800080",red:"#ff0000",silver:"#c0c0c0",teal:"#008080",white:"#ffffff",yellow:"#ffff00",transparent:[null,null,null,0],_default:"#ffffff"}}(p),function(){function e(e){var i,s,n=e.ownerDocument.defaultView?e.ownerDocument.defaultView.getComputedStyle(e,null):e.currentStyle,o={};if(n&&n.length&&n[0]&&n[n[0]])for(s=n.length;s--;)i=n[s],"string"==typeof n[i]&&(o[t.camelCase(i)]=n[i]);else for(i in n)"string"==typeof n[i]&&(o[i]=n[i]);return o}function i(e,i){var s,o,a={};for(s in i)o=i[s],e[s]!==o&&(n[s]||(t.fx.step[s]||!isNaN(parseFloat(o)))&&(a[s]=o));return a}var s=["add","remove","toggle"],n={border:1,borderBottom:1,borderColor:1,borderLeft:1,borderRight:1,borderTop:1,borderWidth:1,margin:1,padding:1};t.each(["borderLeftStyle","borderRightStyle","borderBottomStyle","borderTopStyle"],function(e,i){t.fx.step[i]=function(t){("none"!==t.end&&!t.setAttr||1===t.pos&&!t.setAttr)&&(p.style(t.elem,i,t.end),t.setAttr=!0)}}),t.fn.addBack||(t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.effects.animateClass=function(n,o,a,r){var h=t.speed(o,a,r);return this.queue(function(){var o,a=t(this),r=a.attr("class")||"",l=h.children?a.find("*").addBack():a;l=l.map(function(){var i=t(this);return{el:i,start:e(this)}}),o=function(){t.each(s,function(t,e){n[e]&&a[e+"Class"](n[e])})},o(),l=l.map(function(){return this.end=e(this.el[0]),this.diff=i(this.start,this.end),this}),a.attr("class",r),l=l.map(function(){var e=this,i=t.Deferred(),s=t.extend({},h,{queue:!1,complete:function(){i.resolve(e)}});return this.el.animate(this.diff,s),i.promise()}),t.when.apply(t,l.get()).done(function(){o(),t.each(arguments,function(){var e=this.el;t.each(this.diff,function(t){e.css(t,"")})}),h.complete.call(a[0])})})},t.fn.extend({addClass:function(e){return function(i,s,n,o){return s?t.effects.animateClass.call(this,{add:i},s,n,o):e.apply(this,arguments)}}(t.fn.addClass),removeClass:function(e){return function(i,s,n,o){return arguments.length>1?t.effects.animateClass.call(this,{remove:i},s,n,o):e.apply(this,arguments)}}(t.fn.removeClass),toggleClass:function(e){return function(i,s,n,o,a){return"boolean"==typeof s||void 0===s?n?t.effects.animateClass.call(this,s?{add:i}:{remove:i},n,o,a):e.apply(this,arguments):t.effects.animateClass.call(this,{toggle:i},s,n,o)}}(t.fn.toggleClass),switchClass:function(e,i,s,n,o){return t.effects.animateClass.call(this,{add:i,remove:e},s,n,o)}})}(),function(){function e(e,i,s,n){return t.isPlainObject(e)&&(i=e,e=e.effect),e={effect:e},null==i&&(i={}),t.isFunction(i)&&(n=i,s=null,i={}),("number"==typeof i||t.fx.speeds[i])&&(n=s,s=i,i={}),t.isFunction(s)&&(n=s,s=null),i&&t.extend(e,i),s=s||i.duration,e.duration=t.fx.off?0:"number"==typeof s?s:s in t.fx.speeds?t.fx.speeds[s]:t.fx.speeds._default,e.complete=n||i.complete,e}function i(e){return!e||"number"==typeof e||t.fx.speeds[e]?!0:"string"!=typeof e||t.effects.effect[e]?t.isFunction(e)?!0:"object"!=typeof e||e.effect?!1:!0:!0}function s(t,e){var i=e.outerWidth(),s=e.outerHeight(),n=/^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,o=n.exec(t)||["",0,i,s,0];return{top:parseFloat(o[1])||0,right:"auto"===o[2]?i:parseFloat(o[2]),bottom:"auto"===o[3]?s:parseFloat(o[3]),left:parseFloat(o[4])||0}}t.expr&&t.expr.filters&&t.expr.filters.animated&&(t.expr.filters.animated=function(e){return function(i){return!!t(i).data(d)||e(i)}}(t.expr.filters.animated)),t.uiBackCompat!==!1&&t.extend(t.effects,{save:function(t,e){for(var i=0,s=e.length;s>i;i++)null!==e[i]&&t.data(c+e[i],t[0].style[e[i]])},restore:function(t,e){for(var i,s=0,n=e.length;n>s;s++)null!==e[s]&&(i=t.data(c+e[s]),t.css(e[s],i))},setMode:function(t,e){return"toggle"===e&&(e=t.is(":hidden")?"show":"hide"),e},createWrapper:function(e){if(e.parent().is(".ui-effects-wrapper"))return e.parent();var i={width:e.outerWidth(!0),height:e.outerHeight(!0),"float":e.css("float")},s=t("<div></div>").addClass("ui-effects-wrapper").css({fontSize:"100%",background:"transparent",border:"none",margin:0,padding:0}),n={width:e.width(),height:e.height()},o=document.activeElement;try{o.id}catch(a){o=document.body}return e.wrap(s),(e[0]===o||t.contains(e[0],o))&&t(o).trigger("focus"),s=e.parent(),"static"===e.css("position")?(s.css({position:"relative"}),e.css({position:"relative"})):(t.extend(i,{position:e.css("position"),zIndex:e.css("z-index")}),t.each(["top","left","bottom","right"],function(t,s){i[s]=e.css(s),isNaN(parseInt(i[s],10))&&(i[s]="auto")}),e.css({position:"relative",top:0,left:0,right:"auto",bottom:"auto"})),e.css(n),s.css(i).show()},removeWrapper:function(e){var i=document.activeElement;return e.parent().is(".ui-effects-wrapper")&&(e.parent().replaceWith(e),(e[0]===i||t.contains(e[0],i))&&t(i).trigger("focus")),e}}),t.extend(t.effects,{version:"1.12.1",define:function(e,i,s){return s||(s=i,i="effect"),t.effects.effect[e]=s,t.effects.effect[e].mode=i,s},scaledDimensions:function(t,e,i){if(0===e)return{height:0,width:0,outerHeight:0,outerWidth:0};var s="horizontal"!==i?(e||100)/100:1,n="vertical"!==i?(e||100)/100:1;return{height:t.height()*n,width:t.width()*s,outerHeight:t.outerHeight()*n,outerWidth:t.outerWidth()*s}},clipToBox:function(t){return{width:t.clip.right-t.clip.left,height:t.clip.bottom-t.clip.top,left:t.clip.left,top:t.clip.top}},unshift:function(t,e,i){var s=t.queue();e>1&&s.splice.apply(s,[1,0].concat(s.splice(e,i))),t.dequeue()},saveStyle:function(t){t.data(u,t[0].style.cssText)},restoreStyle:function(t){t[0].style.cssText=t.data(u)||"",t.removeData(u)},mode:function(t,e){var i=t.is(":hidden");return"toggle"===e&&(e=i?"show":"hide"),(i?"hide"===e:"show"===e)&&(e="none"),e},getBaseline:function(t,e){var i,s;switch(t[0]){case"top":i=0;break;case"middle":i=.5;break;case"bottom":i=1;break;default:i=t[0]/e.height}switch(t[1]){case"left":s=0;break;case"center":s=.5;break;case"right":s=1;break;default:s=t[1]/e.width}return{x:s,y:i}},createPlaceholder:function(e){var i,s=e.css("position"),n=e.position();return e.css({marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()),/^(static|relative)/.test(s)&&(s="absolute",i=t("<"+e[0].nodeName+">").insertAfter(e).css({display:/^(inline|ruby)/.test(e.css("display"))?"inline-block":"block",visibility:"hidden",marginTop:e.css("marginTop"),marginBottom:e.css("marginBottom"),marginLeft:e.css("marginLeft"),marginRight:e.css("marginRight"),"float":e.css("float")}).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).addClass("ui-effects-placeholder"),e.data(c+"placeholder",i)),e.css({position:s,left:n.left,top:n.top}),i},removePlaceholder:function(t){var e=c+"placeholder",i=t.data(e);i&&(i.remove(),t.removeData(e))},cleanUp:function(e){t.effects.restoreStyle(e),t.effects.removePlaceholder(e)},setTransition:function(e,i,s,n){return n=n||{},t.each(i,function(t,i){var o=e.cssUnit(i);o[0]>0&&(n[i]=o[0]*s+o[1])}),n}}),t.fn.extend({effect:function(){function i(e){function i(){r.removeData(d),t.effects.cleanUp(r),"hide"===s.mode&&r.hide(),a()}function a(){t.isFunction(h)&&h.call(r[0]),t.isFunction(e)&&e()}var r=t(this);s.mode=c.shift(),t.uiBackCompat===!1||o?"none"===s.mode?(r[l](),a()):n.call(r[0],s,i):(r.is(":hidden")?"hide"===l:"show"===l)?(r[l](),a()):n.call(r[0],s,a)}var s=e.apply(this,arguments),n=t.effects.effect[s.effect],o=n.mode,a=s.queue,r=a||"fx",h=s.complete,l=s.mode,c=[],u=function(e){var i=t(this),s=t.effects.mode(i,l)||o;i.data(d,!0),c.push(s),o&&("show"===s||s===o&&"hide"===s)&&i.show(),o&&"none"===s||t.effects.saveStyle(i),t.isFunction(e)&&e()};return t.fx.off||!n?l?this[l](s.duration,h):this.each(function(){h&&h.call(this)}):a===!1?this.each(u).each(i):this.queue(r,u).queue(r,i)},show:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="show",this.effect.call(this,n)
}}(t.fn.show),hide:function(t){return function(s){if(i(s))return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="hide",this.effect.call(this,n)}}(t.fn.hide),toggle:function(t){return function(s){if(i(s)||"boolean"==typeof s)return t.apply(this,arguments);var n=e.apply(this,arguments);return n.mode="toggle",this.effect.call(this,n)}}(t.fn.toggle),cssUnit:function(e){var i=this.css(e),s=[];return t.each(["em","px","%","pt"],function(t,e){i.indexOf(e)>0&&(s=[parseFloat(i),e])}),s},cssClip:function(t){return t?this.css("clip","rect("+t.top+"px "+t.right+"px "+t.bottom+"px "+t.left+"px)"):s(this.css("clip"),this)},transfer:function(e,i){var s=t(this),n=t(e.to),o="fixed"===n.css("position"),a=t("body"),r=o?a.scrollTop():0,h=o?a.scrollLeft():0,l=n.offset(),c={top:l.top-r,left:l.left-h,height:n.innerHeight(),width:n.innerWidth()},u=s.offset(),d=t("<div class='ui-effects-transfer'></div>").appendTo("body").addClass(e.className).css({top:u.top-r,left:u.left-h,height:s.innerHeight(),width:s.innerWidth(),position:o?"fixed":"absolute"}).animate(c,e.duration,e.easing,function(){d.remove(),t.isFunction(i)&&i()})}}),t.fx.step.clip=function(e){e.clipInit||(e.start=t(e.elem).cssClip(),"string"==typeof e.end&&(e.end=s(e.end,e.elem)),e.clipInit=!0),t(e.elem).cssClip({top:e.pos*(e.end.top-e.start.top)+e.start.top,right:e.pos*(e.end.right-e.start.right)+e.start.right,bottom:e.pos*(e.end.bottom-e.start.bottom)+e.start.bottom,left:e.pos*(e.end.left-e.start.left)+e.start.left})}}(),function(){var e={};t.each(["Quad","Cubic","Quart","Quint","Expo"],function(t,i){e[i]=function(e){return Math.pow(e,t+2)}}),t.extend(e,{Sine:function(t){return 1-Math.cos(t*Math.PI/2)},Circ:function(t){return 1-Math.sqrt(1-t*t)},Elastic:function(t){return 0===t||1===t?t:-Math.pow(2,8*(t-1))*Math.sin((80*(t-1)-7.5)*Math.PI/15)},Back:function(t){return t*t*(3*t-2)},Bounce:function(t){for(var e,i=4;((e=Math.pow(2,--i))-1)/11>t;);return 1/Math.pow(4,3-i)-7.5625*Math.pow((3*e-2)/22-t,2)}}),t.each(e,function(e,i){t.easing["easeIn"+e]=i,t.easing["easeOut"+e]=function(t){return 1-i(1-t)},t.easing["easeInOut"+e]=function(t){return.5>t?i(2*t)/2:1-i(-2*t+2)/2}})}();var f=t.effects;t.effects.define("blind","hide",function(e,i){var s={up:["bottom","top"],vertical:["bottom","top"],down:["top","bottom"],left:["right","left"],horizontal:["right","left"],right:["left","right"]},n=t(this),o=e.direction||"up",a=n.cssClip(),r={clip:t.extend({},a)},h=t.effects.createPlaceholder(n);r.clip[s[o][0]]=r.clip[s[o][1]],"show"===e.mode&&(n.cssClip(r.clip),h&&h.css(t.effects.clipToBox(r)),r.clip=a),h&&h.animate(t.effects.clipToBox(r),e.duration,e.easing),n.animate(r,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("bounce",function(e,i){var s,n,o,a=t(this),r=e.mode,h="hide"===r,l="show"===r,c=e.direction||"up",u=e.distance,d=e.times||5,p=2*d+(l||h?1:0),f=e.duration/p,g=e.easing,m="up"===c||"down"===c?"top":"left",_="up"===c||"left"===c,v=0,b=a.queue().length;for(t.effects.createPlaceholder(a),o=a.css(m),u||(u=a["top"===m?"outerHeight":"outerWidth"]()/3),l&&(n={opacity:1},n[m]=o,a.css("opacity",0).css(m,_?2*-u:2*u).animate(n,f,g)),h&&(u/=Math.pow(2,d-1)),n={},n[m]=o;d>v;v++)s={},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g).animate(n,f,g),u=h?2*u:u/2;h&&(s={opacity:0},s[m]=(_?"-=":"+=")+u,a.animate(s,f,g)),a.queue(i),t.effects.unshift(a,b,p+1)}),t.effects.define("clip","hide",function(e,i){var s,n={},o=t(this),a=e.direction||"vertical",r="both"===a,h=r||"horizontal"===a,l=r||"vertical"===a;s=o.cssClip(),n.clip={top:l?(s.bottom-s.top)/2:s.top,right:h?(s.right-s.left)/2:s.right,bottom:l?(s.bottom-s.top)/2:s.bottom,left:h?(s.right-s.left)/2:s.left},t.effects.createPlaceholder(o),"show"===e.mode&&(o.cssClip(n.clip),n.clip=s),o.animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("drop","hide",function(e,i){var s,n=t(this),o=e.mode,a="show"===o,r=e.direction||"left",h="up"===r||"down"===r?"top":"left",l="up"===r||"left"===r?"-=":"+=",c="+="===l?"-=":"+=",u={opacity:0};t.effects.createPlaceholder(n),s=e.distance||n["top"===h?"outerHeight":"outerWidth"](!0)/2,u[h]=l+s,a&&(n.css(u),u[h]=c+s,u.opacity=1),n.animate(u,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("explode","hide",function(e,i){function s(){b.push(this),b.length===u*d&&n()}function n(){p.css({visibility:"visible"}),t(b).remove(),i()}var o,a,r,h,l,c,u=e.pieces?Math.round(Math.sqrt(e.pieces)):3,d=u,p=t(this),f=e.mode,g="show"===f,m=p.show().css("visibility","hidden").offset(),_=Math.ceil(p.outerWidth()/d),v=Math.ceil(p.outerHeight()/u),b=[];for(o=0;u>o;o++)for(h=m.top+o*v,c=o-(u-1)/2,a=0;d>a;a++)r=m.left+a*_,l=a-(d-1)/2,p.clone().appendTo("body").wrap("<div></div>").css({position:"absolute",visibility:"visible",left:-a*_,top:-o*v}).parent().addClass("ui-effects-explode").css({position:"absolute",overflow:"hidden",width:_,height:v,left:r+(g?l*_:0),top:h+(g?c*v:0),opacity:g?0:1}).animate({left:r+(g?0:l*_),top:h+(g?0:c*v),opacity:g?1:0},e.duration||500,e.easing,s)}),t.effects.define("fade","toggle",function(e,i){var s="show"===e.mode;t(this).css("opacity",s?0:1).animate({opacity:s?1:0},{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("fold","hide",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=e.size||15,h=/([0-9]+)%/.exec(r),l=!!e.horizFirst,c=l?["right","bottom"]:["bottom","right"],u=e.duration/2,d=t.effects.createPlaceholder(s),p=s.cssClip(),f={clip:t.extend({},p)},g={clip:t.extend({},p)},m=[p[c[0]],p[c[1]]],_=s.queue().length;h&&(r=parseInt(h[1],10)/100*m[a?0:1]),f.clip[c[0]]=r,g.clip[c[0]]=r,g.clip[c[1]]=0,o&&(s.cssClip(g.clip),d&&d.css(t.effects.clipToBox(g)),g.clip=p),s.queue(function(i){d&&d.animate(t.effects.clipToBox(f),u,e.easing).animate(t.effects.clipToBox(g),u,e.easing),i()}).animate(f,u,e.easing).animate(g,u,e.easing).queue(i),t.effects.unshift(s,_,4)}),t.effects.define("highlight","show",function(e,i){var s=t(this),n={backgroundColor:s.css("backgroundColor")};"hide"===e.mode&&(n.opacity=0),t.effects.saveStyle(s),s.css({backgroundImage:"none",backgroundColor:e.color||"#ffff99"}).animate(n,{queue:!1,duration:e.duration,easing:e.easing,complete:i})}),t.effects.define("size",function(e,i){var s,n,o,a=t(this),r=["fontSize"],h=["borderTopWidth","borderBottomWidth","paddingTop","paddingBottom"],l=["borderLeftWidth","borderRightWidth","paddingLeft","paddingRight"],c=e.mode,u="effect"!==c,d=e.scale||"both",p=e.origin||["middle","center"],f=a.css("position"),g=a.position(),m=t.effects.scaledDimensions(a),_=e.from||m,v=e.to||t.effects.scaledDimensions(a,0);t.effects.createPlaceholder(a),"show"===c&&(o=_,_=v,v=o),n={from:{y:_.height/m.height,x:_.width/m.width},to:{y:v.height/m.height,x:v.width/m.width}},("box"===d||"both"===d)&&(n.from.y!==n.to.y&&(_=t.effects.setTransition(a,h,n.from.y,_),v=t.effects.setTransition(a,h,n.to.y,v)),n.from.x!==n.to.x&&(_=t.effects.setTransition(a,l,n.from.x,_),v=t.effects.setTransition(a,l,n.to.x,v))),("content"===d||"both"===d)&&n.from.y!==n.to.y&&(_=t.effects.setTransition(a,r,n.from.y,_),v=t.effects.setTransition(a,r,n.to.y,v)),p&&(s=t.effects.getBaseline(p,m),_.top=(m.outerHeight-_.outerHeight)*s.y+g.top,_.left=(m.outerWidth-_.outerWidth)*s.x+g.left,v.top=(m.outerHeight-v.outerHeight)*s.y+g.top,v.left=(m.outerWidth-v.outerWidth)*s.x+g.left),a.css(_),("content"===d||"both"===d)&&(h=h.concat(["marginTop","marginBottom"]).concat(r),l=l.concat(["marginLeft","marginRight"]),a.find("*[width]").each(function(){var i=t(this),s=t.effects.scaledDimensions(i),o={height:s.height*n.from.y,width:s.width*n.from.x,outerHeight:s.outerHeight*n.from.y,outerWidth:s.outerWidth*n.from.x},a={height:s.height*n.to.y,width:s.width*n.to.x,outerHeight:s.height*n.to.y,outerWidth:s.width*n.to.x};n.from.y!==n.to.y&&(o=t.effects.setTransition(i,h,n.from.y,o),a=t.effects.setTransition(i,h,n.to.y,a)),n.from.x!==n.to.x&&(o=t.effects.setTransition(i,l,n.from.x,o),a=t.effects.setTransition(i,l,n.to.x,a)),u&&t.effects.saveStyle(i),i.css(o),i.animate(a,e.duration,e.easing,function(){u&&t.effects.restoreStyle(i)})})),a.animate(v,{queue:!1,duration:e.duration,easing:e.easing,complete:function(){var e=a.offset();0===v.opacity&&a.css("opacity",_.opacity),u||(a.css("position","static"===f?"relative":f).offset(e),t.effects.saveStyle(a)),i()}})}),t.effects.define("scale",function(e,i){var s=t(this),n=e.mode,o=parseInt(e.percent,10)||(0===parseInt(e.percent,10)?0:"effect"!==n?0:100),a=t.extend(!0,{from:t.effects.scaledDimensions(s),to:t.effects.scaledDimensions(s,o,e.direction||"both"),origin:e.origin||["middle","center"]},e);e.fade&&(a.from.opacity=1,a.to.opacity=0),t.effects.effect.size.call(this,a,i)}),t.effects.define("puff","hide",function(e,i){var s=t.extend(!0,{},e,{fade:!0,percent:parseInt(e.percent,10)||150});t.effects.effect.scale.call(this,s,i)}),t.effects.define("pulsate","show",function(e,i){var s=t(this),n=e.mode,o="show"===n,a="hide"===n,r=o||a,h=2*(e.times||5)+(r?1:0),l=e.duration/h,c=0,u=1,d=s.queue().length;for((o||!s.is(":visible"))&&(s.css("opacity",0).show(),c=1);h>u;u++)s.animate({opacity:c},l,e.easing),c=1-c;s.animate({opacity:c},l,e.easing),s.queue(i),t.effects.unshift(s,d,h+1)}),t.effects.define("shake",function(e,i){var s=1,n=t(this),o=e.direction||"left",a=e.distance||20,r=e.times||3,h=2*r+1,l=Math.round(e.duration/h),c="up"===o||"down"===o?"top":"left",u="up"===o||"left"===o,d={},p={},f={},g=n.queue().length;for(t.effects.createPlaceholder(n),d[c]=(u?"-=":"+=")+a,p[c]=(u?"+=":"-=")+2*a,f[c]=(u?"-=":"+=")+2*a,n.animate(d,l,e.easing);r>s;s++)n.animate(p,l,e.easing).animate(f,l,e.easing);n.animate(p,l,e.easing).animate(d,l/2,e.easing).queue(i),t.effects.unshift(n,g,h+1)}),t.effects.define("slide","show",function(e,i){var s,n,o=t(this),a={up:["bottom","top"],down:["top","bottom"],left:["right","left"],right:["left","right"]},r=e.mode,h=e.direction||"left",l="up"===h||"down"===h?"top":"left",c="up"===h||"left"===h,u=e.distance||o["top"===l?"outerHeight":"outerWidth"](!0),d={};t.effects.createPlaceholder(o),s=o.cssClip(),n=o.position()[l],d[l]=(c?-1:1)*u+n,d.clip=o.cssClip(),d.clip[a[h][1]]=d.clip[a[h][0]],"show"===r&&(o.cssClip(d.clip),o.css(l,d[l]),d.clip=s,d[l]=n),o.animate(d,{queue:!1,duration:e.duration,easing:e.easing,complete:i})});var f;t.uiBackCompat!==!1&&(f=t.effects.define("transfer",function(e,i){t(this).transfer(e,i)})),t.ui.focusable=function(i,s){var n,o,a,r,h,l=i.nodeName.toLowerCase();return"area"===l?(n=i.parentNode,o=n.name,i.href&&o&&"map"===n.nodeName.toLowerCase()?(a=t("img[usemap='#"+o+"']"),a.length>0&&a.is(":visible")):!1):(/^(input|select|textarea|button|object)$/.test(l)?(r=!i.disabled,r&&(h=t(i).closest("fieldset")[0],h&&(r=!h.disabled))):r="a"===l?i.href||s:s,r&&t(i).is(":visible")&&e(t(i)))},t.extend(t.expr[":"],{focusable:function(e){return t.ui.focusable(e,null!=t.attr(e,"tabindex"))}}),t.ui.focusable,t.fn.form=function(){return"string"==typeof this[0].form?this.closest("form"):t(this[0].form)},t.ui.formResetMixin={_formResetHandler:function(){var e=t(this);setTimeout(function(){var i=e.data("ui-form-reset-instances");t.each(i,function(){this.refresh()})})},_bindFormResetHandler:function(){if(this.form=this.element.form(),this.form.length){var t=this.form.data("ui-form-reset-instances")||[];t.length||this.form.on("reset.ui-form-reset",this._formResetHandler),t.push(this),this.form.data("ui-form-reset-instances",t)}},_unbindFormResetHandler:function(){if(this.form.length){var e=this.form.data("ui-form-reset-instances");e.splice(t.inArray(this,e),1),e.length?this.form.data("ui-form-reset-instances",e):this.form.removeData("ui-form-reset-instances").off("reset.ui-form-reset")}}},"1.7"===t.fn.jquery.substring(0,3)&&(t.each(["Width","Height"],function(e,i){function s(e,i,s,o){return t.each(n,function(){i-=parseFloat(t.css(e,"padding"+this))||0,s&&(i-=parseFloat(t.css(e,"border"+this+"Width"))||0),o&&(i-=parseFloat(t.css(e,"margin"+this))||0)}),i}var n="Width"===i?["Left","Right"]:["Top","Bottom"],o=i.toLowerCase(),a={innerWidth:t.fn.innerWidth,innerHeight:t.fn.innerHeight,outerWidth:t.fn.outerWidth,outerHeight:t.fn.outerHeight};t.fn["inner"+i]=function(e){return void 0===e?a["inner"+i].call(this):this.each(function(){t(this).css(o,s(this,e)+"px")})},t.fn["outer"+i]=function(e,n){return"number"!=typeof e?a["outer"+i].call(this,e):this.each(function(){t(this).css(o,s(this,e,!0,n)+"px")})}}),t.fn.addBack=function(t){return this.add(null==t?this.prevObject:this.prevObject.filter(t))}),t.ui.keyCode={BACKSPACE:8,COMMA:188,DELETE:46,DOWN:40,END:35,ENTER:13,ESCAPE:27,HOME:36,LEFT:37,PAGE_DOWN:34,PAGE_UP:33,PERIOD:190,RIGHT:39,SPACE:32,TAB:9,UP:38},t.ui.escapeSelector=function(){var t=/([!"#$%&'()*+,.\/:;<=>?@[\]^`{|}~])/g;return function(e){return e.replace(t,"\\$1")}}(),t.fn.labels=function(){var e,i,s,n,o;return this[0].labels&&this[0].labels.length?this.pushStack(this[0].labels):(n=this.eq(0).parents("label"),s=this.attr("id"),s&&(e=this.eq(0).parents().last(),o=e.add(e.length?e.siblings():this.siblings()),i="label[for='"+t.ui.escapeSelector(s)+"']",n=n.add(o.find(i).addBack(i))),this.pushStack(n))},t.fn.scrollParent=function(e){var i=this.css("position"),s="absolute"===i,n=e?/(auto|scroll|hidden)/:/(auto|scroll)/,o=this.parents().filter(function(){var e=t(this);return s&&"static"===e.css("position")?!1:n.test(e.css("overflow")+e.css("overflow-y")+e.css("overflow-x"))}).eq(0);return"fixed"!==i&&o.length?o:t(this[0].ownerDocument||document)},t.extend(t.expr[":"],{tabbable:function(e){var i=t.attr(e,"tabindex"),s=null!=i;return(!s||i>=0)&&t.ui.focusable(e,s)}}),t.fn.extend({uniqueId:function(){var t=0;return function(){return this.each(function(){this.id||(this.id="ui-id-"+ ++t)})}}(),removeUniqueId:function(){return this.each(function(){/^ui-id-\d+$/.test(this.id)&&t(this).removeAttr("id")})}}),t.widget("ui.accordion",{version:"1.12.1",options:{active:0,animate:{},classes:{"ui-accordion-header":"ui-corner-top","ui-accordion-header-collapsed":"ui-corner-all","ui-accordion-content":"ui-corner-bottom"},collapsible:!1,event:"click",header:"> li > :first-child, > :not(li):even",heightStyle:"auto",icons:{activeHeader:"ui-icon-triangle-1-s",header:"ui-icon-triangle-1-e"},activate:null,beforeActivate:null},hideProps:{borderTopWidth:"hide",borderBottomWidth:"hide",paddingTop:"hide",paddingBottom:"hide",height:"hide"},showProps:{borderTopWidth:"show",borderBottomWidth:"show",paddingTop:"show",paddingBottom:"show",height:"show"},_create:function(){var e=this.options;this.prevShow=this.prevHide=t(),this._addClass("ui-accordion","ui-widget ui-helper-reset"),this.element.attr("role","tablist"),e.collapsible||e.active!==!1&&null!=e.active||(e.active=0),this._processPanels(),0>e.active&&(e.active+=this.headers.length),this._refresh()},_getCreateEventData:function(){return{header:this.active,panel:this.active.length?this.active.next():t()}},_createIcons:function(){var e,i,s=this.options.icons;s&&(e=t("<span>"),this._addClass(e,"ui-accordion-header-icon","ui-icon "+s.header),e.prependTo(this.headers),i=this.active.children(".ui-accordion-header-icon"),this._removeClass(i,s.header)._addClass(i,null,s.activeHeader)._addClass(this.headers,"ui-accordion-icons"))},_destroyIcons:function(){this._removeClass(this.headers,"ui-accordion-icons"),this.headers.children(".ui-accordion-header-icon").remove()},_destroy:function(){var t;this.element.removeAttr("role"),this.headers.removeAttr("role aria-expanded aria-selected aria-controls tabIndex").removeUniqueId(),this._destroyIcons(),t=this.headers.next().css("display","").removeAttr("role aria-hidden aria-labelledby").removeUniqueId(),"content"!==this.options.heightStyle&&t.css("height","")},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):("event"===t&&(this.options.event&&this._off(this.headers,this.options.event),this._setupEvents(e)),this._super(t,e),"collapsible"!==t||e||this.options.active!==!1||this._activate(0),"icons"===t&&(this._destroyIcons(),e&&this._createIcons()),void 0)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t),this._toggleClass(this.headers.add(this.headers.next()),null,"ui-state-disabled",!!t)},_keydown:function(e){if(!e.altKey&&!e.ctrlKey){var i=t.ui.keyCode,s=this.headers.length,n=this.headers.index(e.target),o=!1;switch(e.keyCode){case i.RIGHT:case i.DOWN:o=this.headers[(n+1)%s];break;case i.LEFT:case i.UP:o=this.headers[(n-1+s)%s];break;case i.SPACE:case i.ENTER:this._eventHandler(e);break;case i.HOME:o=this.headers[0];break;case i.END:o=this.headers[s-1]}o&&(t(e.target).attr("tabIndex",-1),t(o).attr("tabIndex",0),t(o).trigger("focus"),e.preventDefault())}},_panelKeyDown:function(e){e.keyCode===t.ui.keyCode.UP&&e.ctrlKey&&t(e.currentTarget).prev().trigger("focus")},refresh:function(){var e=this.options;this._processPanels(),e.active===!1&&e.collapsible===!0||!this.headers.length?(e.active=!1,this.active=t()):e.active===!1?this._activate(0):this.active.length&&!t.contains(this.element[0],this.active[0])?this.headers.length===this.headers.find(".ui-state-disabled").length?(e.active=!1,this.active=t()):this._activate(Math.max(0,e.active-1)):e.active=this.headers.index(this.active),this._destroyIcons(),this._refresh()},_processPanels:function(){var t=this.headers,e=this.panels;this.headers=this.element.find(this.options.header),this._addClass(this.headers,"ui-accordion-header ui-accordion-header-collapsed","ui-state-default"),this.panels=this.headers.next().filter(":not(.ui-accordion-content-active)").hide(),this._addClass(this.panels,"ui-accordion-content","ui-helper-reset ui-widget-content"),e&&(this._off(t.not(this.headers)),this._off(e.not(this.panels)))},_refresh:function(){var e,i=this.options,s=i.heightStyle,n=this.element.parent();this.active=this._findActive(i.active),this._addClass(this.active,"ui-accordion-header-active","ui-state-active")._removeClass(this.active,"ui-accordion-header-collapsed"),this._addClass(this.active.next(),"ui-accordion-content-active"),this.active.next().show(),this.headers.attr("role","tab").each(function(){var e=t(this),i=e.uniqueId().attr("id"),s=e.next(),n=s.uniqueId().attr("id");e.attr("aria-controls",n),s.attr("aria-labelledby",i)}).next().attr("role","tabpanel"),this.headers.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}).next().attr({"aria-hidden":"true"}).hide(),this.active.length?this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}).next().attr({"aria-hidden":"false"}):this.headers.eq(0).attr("tabIndex",0),this._createIcons(),this._setupEvents(i.event),"fill"===s?(e=n.height(),this.element.siblings(":visible").each(function(){var i=t(this),s=i.css("position");"absolute"!==s&&"fixed"!==s&&(e-=i.outerHeight(!0))}),this.headers.each(function(){e-=t(this).outerHeight(!0)}),this.headers.next().each(function(){t(this).height(Math.max(0,e-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===s&&(e=0,this.headers.next().each(function(){var i=t(this).is(":visible");i||t(this).show(),e=Math.max(e,t(this).css("height","").height()),i||t(this).hide()}).height(e))},_activate:function(e){var i=this._findActive(e)[0];i!==this.active[0]&&(i=i||this.active[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return"number"==typeof e?this.headers.eq(e):t()},_setupEvents:function(e){var i={keydown:"_keydown"};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.headers.add(this.headers.next())),this._on(this.headers,i),this._on(this.headers.next(),{keydown:"_panelKeyDown"}),this._hoverable(this.headers),this._focusable(this.headers)},_eventHandler:function(e){var i,s,n=this.options,o=this.active,a=t(e.currentTarget),r=a[0]===o[0],h=r&&n.collapsible,l=h?t():a.next(),c=o.next(),u={oldHeader:o,oldPanel:c,newHeader:h?t():a,newPanel:l};e.preventDefault(),r&&!n.collapsible||this._trigger("beforeActivate",e,u)===!1||(n.active=h?!1:this.headers.index(a),this.active=r?t():a,this._toggle(u),this._removeClass(o,"ui-accordion-header-active","ui-state-active"),n.icons&&(i=o.children(".ui-accordion-header-icon"),this._removeClass(i,null,n.icons.activeHeader)._addClass(i,null,n.icons.header)),r||(this._removeClass(a,"ui-accordion-header-collapsed")._addClass(a,"ui-accordion-header-active","ui-state-active"),n.icons&&(s=a.children(".ui-accordion-header-icon"),this._removeClass(s,null,n.icons.header)._addClass(s,null,n.icons.activeHeader)),this._addClass(a.next(),"ui-accordion-content-active")))},_toggle:function(e){var i=e.newPanel,s=this.prevShow.length?this.prevShow:e.oldPanel;this.prevShow.add(this.prevHide).stop(!0,!0),this.prevShow=i,this.prevHide=s,this.options.animate?this._animate(i,s,e):(s.hide(),i.show(),this._toggleComplete(e)),s.attr({"aria-hidden":"true"}),s.prev().attr({"aria-selected":"false","aria-expanded":"false"}),i.length&&s.length?s.prev().attr({tabIndex:-1,"aria-expanded":"false"}):i.length&&this.headers.filter(function(){return 0===parseInt(t(this).attr("tabIndex"),10)}).attr("tabIndex",-1),i.attr("aria-hidden","false").prev().attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_animate:function(t,e,i){var s,n,o,a=this,r=0,h=t.css("box-sizing"),l=t.length&&(!e.length||t.index()<e.index()),c=this.options.animate||{},u=l&&c.down||c,d=function(){a._toggleComplete(i)};return"number"==typeof u&&(o=u),"string"==typeof u&&(n=u),n=n||u.easing||c.easing,o=o||u.duration||c.duration,e.length?t.length?(s=t.show().outerHeight(),e.animate(this.hideProps,{duration:o,easing:n,step:function(t,e){e.now=Math.round(t)}}),t.hide().animate(this.showProps,{duration:o,easing:n,complete:d,step:function(t,i){i.now=Math.round(t),"height"!==i.prop?"content-box"===h&&(r+=i.now):"content"!==a.options.heightStyle&&(i.now=Math.round(s-e.outerHeight()-r),r=0)}}),void 0):e.animate(this.hideProps,o,n,d):t.animate(this.showProps,o,n,d)},_toggleComplete:function(t){var e=t.oldPanel,i=e.prev();this._removeClass(e,"ui-accordion-content-active"),this._removeClass(i,"ui-accordion-header-active")._addClass(i,"ui-accordion-header-collapsed"),e.length&&(e.parent()[0].className=e.parent()[0].className),this._trigger("activate",null,t)}}),t.ui.safeActiveElement=function(t){var e;try{e=t.activeElement}catch(i){e=t.body}return e||(e=t.body),e.nodeName||(e=t.body),e},t.widget("ui.menu",{version:"1.12.1",defaultElement:"<ul>",delay:300,options:{icons:{submenu:"ui-icon-caret-1-e"},items:"> *",menus:"ul",position:{my:"left top",at:"right top"},role:"menu",blur:null,focus:null,select:null},_create:function(){this.activeMenu=this.element,this.mouseHandled=!1,this.element.uniqueId().attr({role:this.options.role,tabIndex:0}),this._addClass("ui-menu","ui-widget ui-widget-content"),this._on({"mousedown .ui-menu-item":function(t){t.preventDefault()},"click .ui-menu-item":function(e){var i=t(e.target),s=t(t.ui.safeActiveElement(this.document[0]));!this.mouseHandled&&i.not(".ui-state-disabled").length&&(this.select(e),e.isPropagationStopped()||(this.mouseHandled=!0),i.has(".ui-menu").length?this.expand(e):!this.element.is(":focus")&&s.closest(".ui-menu").length&&(this.element.trigger("focus",[!0]),this.active&&1===this.active.parents(".ui-menu").length&&clearTimeout(this.timer)))},"mouseenter .ui-menu-item":function(e){if(!this.previousFilter){var i=t(e.target).closest(".ui-menu-item"),s=t(e.currentTarget);i[0]===s[0]&&(this._removeClass(s.siblings().children(".ui-state-active"),null,"ui-state-active"),this.focus(e,s))}},mouseleave:"collapseAll","mouseleave .ui-menu":"collapseAll",focus:function(t,e){var i=this.active||this.element.find(this.options.items).eq(0);e||this.focus(t,i)},blur:function(e){this._delay(function(){var i=!t.contains(this.element[0],t.ui.safeActiveElement(this.document[0]));i&&this.collapseAll(e)})},keydown:"_keydown"}),this.refresh(),this._on(this.document,{click:function(t){this._closeOnDocumentClick(t)&&this.collapseAll(t),this.mouseHandled=!1}})},_destroy:function(){var e=this.element.find(".ui-menu-item").removeAttr("role aria-disabled"),i=e.children(".ui-menu-item-wrapper").removeUniqueId().removeAttr("tabIndex role aria-haspopup");this.element.removeAttr("aria-activedescendant").find(".ui-menu").addBack().removeAttr("role aria-labelledby aria-expanded aria-hidden aria-disabled tabIndex").removeUniqueId().show(),i.children().each(function(){var e=t(this);e.data("ui-menu-submenu-caret")&&e.remove()})},_keydown:function(e){var i,s,n,o,a=!0;switch(e.keyCode){case t.ui.keyCode.PAGE_UP:this.previousPage(e);break;case t.ui.keyCode.PAGE_DOWN:this.nextPage(e);break;case t.ui.keyCode.HOME:this._move("first","first",e);break;case t.ui.keyCode.END:this._move("last","last",e);break;case t.ui.keyCode.UP:this.previous(e);break;case t.ui.keyCode.DOWN:this.next(e);break;case t.ui.keyCode.LEFT:this.collapse(e);break;case t.ui.keyCode.RIGHT:this.active&&!this.active.is(".ui-state-disabled")&&this.expand(e);break;case t.ui.keyCode.ENTER:case t.ui.keyCode.SPACE:this._activate(e);break;case t.ui.keyCode.ESCAPE:this.collapse(e);break;default:a=!1,s=this.previousFilter||"",o=!1,n=e.keyCode>=96&&105>=e.keyCode?""+(e.keyCode-96):String.fromCharCode(e.keyCode),clearTimeout(this.filterTimer),n===s?o=!0:n=s+n,i=this._filterMenuItems(n),i=o&&-1!==i.index(this.active.next())?this.active.nextAll(".ui-menu-item"):i,i.length||(n=String.fromCharCode(e.keyCode),i=this._filterMenuItems(n)),i.length?(this.focus(e,i),this.previousFilter=n,this.filterTimer=this._delay(function(){delete this.previousFilter},1e3)):delete this.previousFilter}a&&e.preventDefault()},_activate:function(t){this.active&&!this.active.is(".ui-state-disabled")&&(this.active.children("[aria-haspopup='true']").length?this.expand(t):this.select(t))},refresh:function(){var e,i,s,n,o,a=this,r=this.options.icons.submenu,h=this.element.find(this.options.menus);this._toggleClass("ui-menu-icons",null,!!this.element.find(".ui-icon").length),s=h.filter(":not(.ui-menu)").hide().attr({role:this.options.role,"aria-hidden":"true","aria-expanded":"false"}).each(function(){var e=t(this),i=e.prev(),s=t("<span>").data("ui-menu-submenu-caret",!0);a._addClass(s,"ui-menu-icon","ui-icon "+r),i.attr("aria-haspopup","true").prepend(s),e.attr("aria-labelledby",i.attr("id"))}),this._addClass(s,"ui-menu","ui-widget ui-widget-content ui-front"),e=h.add(this.element),i=e.find(this.options.items),i.not(".ui-menu-item").each(function(){var e=t(this);a._isDivider(e)&&a._addClass(e,"ui-menu-divider","ui-widget-content")}),n=i.not(".ui-menu-item, .ui-menu-divider"),o=n.children().not(".ui-menu").uniqueId().attr({tabIndex:-1,role:this._itemRole()}),this._addClass(n,"ui-menu-item")._addClass(o,"ui-menu-item-wrapper"),i.filter(".ui-state-disabled").attr("aria-disabled","true"),this.active&&!t.contains(this.element[0],this.active[0])&&this.blur()},_itemRole:function(){return{menu:"menuitem",listbox:"option"}[this.options.role]},_setOption:function(t,e){if("icons"===t){var i=this.element.find(".ui-menu-icon");this._removeClass(i,null,this.options.icons.submenu)._addClass(i,null,e.submenu)}this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t+""),this._toggleClass(null,"ui-state-disabled",!!t)},focus:function(t,e){var i,s,n;this.blur(t,t&&"focus"===t.type),this._scrollIntoView(e),this.active=e.first(),s=this.active.children(".ui-menu-item-wrapper"),this._addClass(s,null,"ui-state-active"),this.options.role&&this.element.attr("aria-activedescendant",s.attr("id")),n=this.active.parent().closest(".ui-menu-item").children(".ui-menu-item-wrapper"),this._addClass(n,null,"ui-state-active"),t&&"keydown"===t.type?this._close():this.timer=this._delay(function(){this._close()},this.delay),i=e.children(".ui-menu"),i.length&&t&&/^mouse/.test(t.type)&&this._startOpening(i),this.activeMenu=e.parent(),this._trigger("focus",t,{item:e})},_scrollIntoView:function(e){var i,s,n,o,a,r;this._hasScroll()&&(i=parseFloat(t.css(this.activeMenu[0],"borderTopWidth"))||0,s=parseFloat(t.css(this.activeMenu[0],"paddingTop"))||0,n=e.offset().top-this.activeMenu.offset().top-i-s,o=this.activeMenu.scrollTop(),a=this.activeMenu.height(),r=e.outerHeight(),0>n?this.activeMenu.scrollTop(o+n):n+r>a&&this.activeMenu.scrollTop(o+n-a+r))},blur:function(t,e){e||clearTimeout(this.timer),this.active&&(this._removeClass(this.active.children(".ui-menu-item-wrapper"),null,"ui-state-active"),this._trigger("blur",t,{item:this.active}),this.active=null)},_startOpening:function(t){clearTimeout(this.timer),"true"===t.attr("aria-hidden")&&(this.timer=this._delay(function(){this._close(),this._open(t)},this.delay))},_open:function(e){var i=t.extend({of:this.active},this.options.position);clearTimeout(this.timer),this.element.find(".ui-menu").not(e.parents(".ui-menu")).hide().attr("aria-hidden","true"),e.show().removeAttr("aria-hidden").attr("aria-expanded","true").position(i)},collapseAll:function(e,i){clearTimeout(this.timer),this.timer=this._delay(function(){var s=i?this.element:t(e&&e.target).closest(this.element.find(".ui-menu"));s.length||(s=this.element),this._close(s),this.blur(e),this._removeClass(s.find(".ui-state-active"),null,"ui-state-active"),this.activeMenu=s},this.delay)},_close:function(t){t||(t=this.active?this.active.parent():this.element),t.find(".ui-menu").hide().attr("aria-hidden","true").attr("aria-expanded","false")},_closeOnDocumentClick:function(e){return!t(e.target).closest(".ui-menu").length},_isDivider:function(t){return!/[^\-\u2014\u2013\s]/.test(t.text())},collapse:function(t){var e=this.active&&this.active.parent().closest(".ui-menu-item",this.element);e&&e.length&&(this._close(),this.focus(t,e))},expand:function(t){var e=this.active&&this.active.children(".ui-menu ").find(this.options.items).first();e&&e.length&&(this._open(e.parent()),this._delay(function(){this.focus(t,e)}))},next:function(t){this._move("next","first",t)},previous:function(t){this._move("prev","last",t)},isFirstItem:function(){return this.active&&!this.active.prevAll(".ui-menu-item").length},isLastItem:function(){return this.active&&!this.active.nextAll(".ui-menu-item").length},_move:function(t,e,i){var s;this.active&&(s="first"===t||"last"===t?this.active["first"===t?"prevAll":"nextAll"](".ui-menu-item").eq(-1):this.active[t+"All"](".ui-menu-item").eq(0)),s&&s.length&&this.active||(s=this.activeMenu.find(this.options.items)[e]()),this.focus(i,s)},nextPage:function(e){var i,s,n;return this.active?(this.isLastItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.nextAll(".ui-menu-item").each(function(){return i=t(this),0>i.offset().top-s-n}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items)[this.active?"last":"first"]())),void 0):(this.next(e),void 0)},previousPage:function(e){var i,s,n;return this.active?(this.isFirstItem()||(this._hasScroll()?(s=this.active.offset().top,n=this.element.height(),this.active.prevAll(".ui-menu-item").each(function(){return i=t(this),i.offset().top-s+n>0}),this.focus(e,i)):this.focus(e,this.activeMenu.find(this.options.items).first())),void 0):(this.next(e),void 0)},_hasScroll:function(){return this.element.outerHeight()<this.element.prop("scrollHeight")},select:function(e){this.active=this.active||t(e.target).closest(".ui-menu-item");var i={item:this.active};this.active.has(".ui-menu").length||this.collapseAll(e,!0),this._trigger("select",e,i)},_filterMenuItems:function(e){var i=e.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&"),s=RegExp("^"+i,"i");return this.activeMenu.find(this.options.items).filter(".ui-menu-item").filter(function(){return s.test(t.trim(t(this).children(".ui-menu-item-wrapper").text()))})}}),t.widget("ui.autocomplete",{version:"1.12.1",defaultElement:"<input>",options:{appendTo:null,autoFocus:!1,delay:300,minLength:1,position:{my:"left top",at:"left bottom",collision:"none"},source:null,change:null,close:null,focus:null,open:null,response:null,search:null,select:null},requestIndex:0,pending:0,_create:function(){var e,i,s,n=this.element[0].nodeName.toLowerCase(),o="textarea"===n,a="input"===n;
this.isMultiLine=o||!a&&this._isContentEditable(this.element),this.valueMethod=this.element[o||a?"val":"text"],this.isNewMenu=!0,this._addClass("ui-autocomplete-input"),this.element.attr("autocomplete","off"),this._on(this.element,{keydown:function(n){if(this.element.prop("readOnly"))return e=!0,s=!0,i=!0,void 0;e=!1,s=!1,i=!1;var o=t.ui.keyCode;switch(n.keyCode){case o.PAGE_UP:e=!0,this._move("previousPage",n);break;case o.PAGE_DOWN:e=!0,this._move("nextPage",n);break;case o.UP:e=!0,this._keyEvent("previous",n);break;case o.DOWN:e=!0,this._keyEvent("next",n);break;case o.ENTER:this.menu.active&&(e=!0,n.preventDefault(),this.menu.select(n));break;case o.TAB:this.menu.active&&this.menu.select(n);break;case o.ESCAPE:this.menu.element.is(":visible")&&(this.isMultiLine||this._value(this.term),this.close(n),n.preventDefault());break;default:i=!0,this._searchTimeout(n)}},keypress:function(s){if(e)return e=!1,(!this.isMultiLine||this.menu.element.is(":visible"))&&s.preventDefault(),void 0;if(!i){var n=t.ui.keyCode;switch(s.keyCode){case n.PAGE_UP:this._move("previousPage",s);break;case n.PAGE_DOWN:this._move("nextPage",s);break;case n.UP:this._keyEvent("previous",s);break;case n.DOWN:this._keyEvent("next",s)}}},input:function(t){return s?(s=!1,t.preventDefault(),void 0):(this._searchTimeout(t),void 0)},focus:function(){this.selectedItem=null,this.previous=this._value()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(clearTimeout(this.searching),this.close(t),this._change(t),void 0)}}),this._initSource(),this.menu=t("<ul>").appendTo(this._appendTo()).menu({role:null}).hide().menu("instance"),this._addClass(this.menu.element,"ui-autocomplete","ui-front"),this._on(this.menu.element,{mousedown:function(e){e.preventDefault(),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,this.element[0]!==t.ui.safeActiveElement(this.document[0])&&this.element.trigger("focus")})},menufocus:function(e,i){var s,n;return this.isNewMenu&&(this.isNewMenu=!1,e.originalEvent&&/^mouse/.test(e.originalEvent.type))?(this.menu.blur(),this.document.one("mousemove",function(){t(e.target).trigger(e.originalEvent)}),void 0):(n=i.item.data("ui-autocomplete-item"),!1!==this._trigger("focus",e,{item:n})&&e.originalEvent&&/^key/.test(e.originalEvent.type)&&this._value(n.value),s=i.item.attr("aria-label")||n.value,s&&t.trim(s).length&&(this.liveRegion.children().hide(),t("<div>").text(s).appendTo(this.liveRegion)),void 0)},menuselect:function(e,i){var s=i.item.data("ui-autocomplete-item"),n=this.previous;this.element[0]!==t.ui.safeActiveElement(this.document[0])&&(this.element.trigger("focus"),this.previous=n,this._delay(function(){this.previous=n,this.selectedItem=s})),!1!==this._trigger("select",e,{item:s})&&this._value(s.value),this.term=this._value(),this.close(e),this.selectedItem=s}}),this.liveRegion=t("<div>",{role:"status","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_destroy:function(){clearTimeout(this.searching),this.element.removeAttr("autocomplete"),this.menu.element.remove(),this.liveRegion.remove()},_setOption:function(t,e){this._super(t,e),"source"===t&&this._initSource(),"appendTo"===t&&this.menu.element.appendTo(this._appendTo()),"disabled"===t&&e&&this.xhr&&this.xhr.abort()},_isEventTargetInWidget:function(e){var i=this.menu.element[0];return e.target===this.element[0]||e.target===i||t.contains(i,e.target)},_closeOnClickOutside:function(t){this._isEventTargetInWidget(t)||this.close()},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_initSource:function(){var e,i,s=this;t.isArray(this.options.source)?(e=this.options.source,this.source=function(i,s){s(t.ui.autocomplete.filter(e,i.term))}):"string"==typeof this.options.source?(i=this.options.source,this.source=function(e,n){s.xhr&&s.xhr.abort(),s.xhr=t.ajax({url:i,data:e,dataType:"json",success:function(t){n(t)},error:function(){n([])}})}):this.source=this.options.source},_searchTimeout:function(t){clearTimeout(this.searching),this.searching=this._delay(function(){var e=this.term===this._value(),i=this.menu.element.is(":visible"),s=t.altKey||t.ctrlKey||t.metaKey||t.shiftKey;(!e||e&&!i&&!s)&&(this.selectedItem=null,this.search(null,t))},this.options.delay)},search:function(t,e){return t=null!=t?t:this._value(),this.term=this._value(),t.length<this.options.minLength?this.close(e):this._trigger("search",e)!==!1?this._search(t):void 0},_search:function(t){this.pending++,this._addClass("ui-autocomplete-loading"),this.cancelSearch=!1,this.source({term:t},this._response())},_response:function(){var e=++this.requestIndex;return t.proxy(function(t){e===this.requestIndex&&this.__response(t),this.pending--,this.pending||this._removeClass("ui-autocomplete-loading")},this)},__response:function(t){t&&(t=this._normalize(t)),this._trigger("response",null,{content:t}),!this.options.disabled&&t&&t.length&&!this.cancelSearch?(this._suggest(t),this._trigger("open")):this._close()},close:function(t){this.cancelSearch=!0,this._close(t)},_close:function(t){this._off(this.document,"mousedown"),this.menu.element.is(":visible")&&(this.menu.element.hide(),this.menu.blur(),this.isNewMenu=!0,this._trigger("close",t))},_change:function(t){this.previous!==this._value()&&this._trigger("change",t,{item:this.selectedItem})},_normalize:function(e){return e.length&&e[0].label&&e[0].value?e:t.map(e,function(e){return"string"==typeof e?{label:e,value:e}:t.extend({},e,{label:e.label||e.value,value:e.value||e.label})})},_suggest:function(e){var i=this.menu.element.empty();this._renderMenu(i,e),this.isNewMenu=!0,this.menu.refresh(),i.show(),this._resizeMenu(),i.position(t.extend({of:this.element},this.options.position)),this.options.autoFocus&&this.menu.next(),this._on(this.document,{mousedown:"_closeOnClickOutside"})},_resizeMenu:function(){var t=this.menu.element;t.outerWidth(Math.max(t.width("").outerWidth()+1,this.element.outerWidth()))},_renderMenu:function(e,i){var s=this;t.each(i,function(t,i){s._renderItemData(e,i)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-autocomplete-item",e)},_renderItem:function(e,i){return t("<li>").append(t("<div>").text(i.label)).appendTo(e)},_move:function(t,e){return this.menu.element.is(":visible")?this.menu.isFirstItem()&&/^previous/.test(t)||this.menu.isLastItem()&&/^next/.test(t)?(this.isMultiLine||this._value(this.term),this.menu.blur(),void 0):(this.menu[t](e),void 0):(this.search(null,e),void 0)},widget:function(){return this.menu.element},_value:function(){return this.valueMethod.apply(this.element,arguments)},_keyEvent:function(t,e){(!this.isMultiLine||this.menu.element.is(":visible"))&&(this._move(t,e),e.preventDefault())},_isContentEditable:function(t){if(!t.length)return!1;var e=t.prop("contentEditable");return"inherit"===e?this._isContentEditable(t.parent()):"true"===e}}),t.extend(t.ui.autocomplete,{escapeRegex:function(t){return t.replace(/[\-\[\]{}()*+?.,\\\^$|#\s]/g,"\\$&")},filter:function(e,i){var s=RegExp(t.ui.autocomplete.escapeRegex(i),"i");return t.grep(e,function(t){return s.test(t.label||t.value||t)})}}),t.widget("ui.autocomplete",t.ui.autocomplete,{options:{messages:{noResults:"No search results.",results:function(t){return t+(t>1?" results are":" result is")+" available, use up and down arrow keys to navigate."}}},__response:function(e){var i;this._superApply(arguments),this.options.disabled||this.cancelSearch||(i=e&&e.length?this.options.messages.results(e.length):this.options.messages.noResults,this.liveRegion.children().hide(),t("<div>").text(i).appendTo(this.liveRegion))}}),t.ui.autocomplete;var g=/ui-corner-([a-z]){2,6}/g;t.widget("ui.controlgroup",{version:"1.12.1",defaultElement:"<div>",options:{direction:"horizontal",disabled:null,onlyVisible:!0,items:{button:"input[type=button], input[type=submit], input[type=reset], button, a",controlgroupLabel:".ui-controlgroup-label",checkboxradio:"input[type='checkbox'], input[type='radio']",selectmenu:"select",spinner:".ui-spinner-input"}},_create:function(){this._enhance()},_enhance:function(){this.element.attr("role","toolbar"),this.refresh()},_destroy:function(){this._callChildMethod("destroy"),this.childWidgets.removeData("ui-controlgroup-data"),this.element.removeAttr("role"),this.options.items.controlgroupLabel&&this.element.find(this.options.items.controlgroupLabel).find(".ui-controlgroup-label-contents").contents().unwrap()},_initWidgets:function(){var e=this,i=[];t.each(this.options.items,function(s,n){var o,a={};return n?"controlgroupLabel"===s?(o=e.element.find(n),o.each(function(){var e=t(this);e.children(".ui-controlgroup-label-contents").length||e.contents().wrapAll("<span class='ui-controlgroup-label-contents'></span>")}),e._addClass(o,null,"ui-widget ui-widget-content ui-state-default"),i=i.concat(o.get()),void 0):(t.fn[s]&&(a=e["_"+s+"Options"]?e["_"+s+"Options"]("middle"):{classes:{}},e.element.find(n).each(function(){var n=t(this),o=n[s]("instance"),r=t.widget.extend({},a);if("button"!==s||!n.parent(".ui-spinner").length){o||(o=n[s]()[s]("instance")),o&&(r.classes=e._resolveClassesValues(r.classes,o)),n[s](r);var h=n[s]("widget");t.data(h[0],"ui-controlgroup-data",o?o:n[s]("instance")),i.push(h[0])}})),void 0):void 0}),this.childWidgets=t(t.unique(i)),this._addClass(this.childWidgets,"ui-controlgroup-item")},_callChildMethod:function(e){this.childWidgets.each(function(){var i=t(this),s=i.data("ui-controlgroup-data");s&&s[e]&&s[e]()})},_updateCornerClass:function(t,e){var i="ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all",s=this._buildSimpleOptions(e,"label").classes.label;this._removeClass(t,null,i),this._addClass(t,null,s)},_buildSimpleOptions:function(t,e){var i="vertical"===this.options.direction,s={classes:{}};return s.classes[e]={middle:"",first:"ui-corner-"+(i?"top":"left"),last:"ui-corner-"+(i?"bottom":"right"),only:"ui-corner-all"}[t],s},_spinnerOptions:function(t){var e=this._buildSimpleOptions(t,"ui-spinner");return e.classes["ui-spinner-up"]="",e.classes["ui-spinner-down"]="",e},_buttonOptions:function(t){return this._buildSimpleOptions(t,"ui-button")},_checkboxradioOptions:function(t){return this._buildSimpleOptions(t,"ui-checkboxradio-label")},_selectmenuOptions:function(t){var e="vertical"===this.options.direction;return{width:e?"auto":!1,classes:{middle:{"ui-selectmenu-button-open":"","ui-selectmenu-button-closed":""},first:{"ui-selectmenu-button-open":"ui-corner-"+(e?"top":"tl"),"ui-selectmenu-button-closed":"ui-corner-"+(e?"top":"left")},last:{"ui-selectmenu-button-open":e?"":"ui-corner-tr","ui-selectmenu-button-closed":"ui-corner-"+(e?"bottom":"right")},only:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"}}[t]}},_resolveClassesValues:function(e,i){var s={};return t.each(e,function(n){var o=i.options.classes[n]||"";o=t.trim(o.replace(g,"")),s[n]=(o+" "+e[n]).replace(/\s+/g," ")}),s},_setOption:function(t,e){return"direction"===t&&this._removeClass("ui-controlgroup-"+this.options.direction),this._super(t,e),"disabled"===t?(this._callChildMethod(e?"disable":"enable"),void 0):(this.refresh(),void 0)},refresh:function(){var e,i=this;this._addClass("ui-controlgroup ui-controlgroup-"+this.options.direction),"horizontal"===this.options.direction&&this._addClass(null,"ui-helper-clearfix"),this._initWidgets(),e=this.childWidgets,this.options.onlyVisible&&(e=e.filter(":visible")),e.length&&(t.each(["first","last"],function(t,s){var n=e[s]().data("ui-controlgroup-data");if(n&&i["_"+n.widgetName+"Options"]){var o=i["_"+n.widgetName+"Options"](1===e.length?"only":s);o.classes=i._resolveClassesValues(o.classes,n),n.element[n.widgetName](o)}else i._updateCornerClass(e[s](),s)}),this._callChildMethod("refresh"))}}),t.widget("ui.checkboxradio",[t.ui.formResetMixin,{version:"1.12.1",options:{disabled:null,label:null,icon:!0,classes:{"ui-checkboxradio-label":"ui-corner-all","ui-checkboxradio-icon":"ui-corner-all"}},_getCreateOptions:function(){var e,i,s=this,n=this._super()||{};return this._readType(),i=this.element.labels(),this.label=t(i[i.length-1]),this.label.length||t.error("No label found for checkboxradio widget"),this.originalLabel="",this.label.contents().not(this.element[0]).each(function(){s.originalLabel+=3===this.nodeType?t(this).text():this.outerHTML}),this.originalLabel&&(n.label=this.originalLabel),e=this.element[0].disabled,null!=e&&(n.disabled=e),n},_create:function(){var t=this.element[0].checked;this._bindFormResetHandler(),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled),this._setOption("disabled",this.options.disabled),this._addClass("ui-checkboxradio","ui-helper-hidden-accessible"),this._addClass(this.label,"ui-checkboxradio-label","ui-button ui-widget"),"radio"===this.type&&this._addClass(this.label,"ui-checkboxradio-radio-label"),this.options.label&&this.options.label!==this.originalLabel?this._updateLabel():this.originalLabel&&(this.options.label=this.originalLabel),this._enhance(),t&&(this._addClass(this.label,"ui-checkboxradio-checked","ui-state-active"),this.icon&&this._addClass(this.icon,null,"ui-state-hover")),this._on({change:"_toggleClasses",focus:function(){this._addClass(this.label,null,"ui-state-focus ui-visual-focus")},blur:function(){this._removeClass(this.label,null,"ui-state-focus ui-visual-focus")}})},_readType:function(){var e=this.element[0].nodeName.toLowerCase();this.type=this.element[0].type,"input"===e&&/radio|checkbox/.test(this.type)||t.error("Can't create checkboxradio on element.nodeName="+e+" and element.type="+this.type)},_enhance:function(){this._updateIcon(this.element[0].checked)},widget:function(){return this.label},_getRadioGroup:function(){var e,i=this.element[0].name,s="input[name='"+t.ui.escapeSelector(i)+"']";return i?(e=this.form.length?t(this.form[0].elements).filter(s):t(s).filter(function(){return 0===t(this).form().length}),e.not(this.element)):t([])},_toggleClasses:function(){var e=this.element[0].checked;this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",e),this.options.icon&&"checkbox"===this.type&&this._toggleClass(this.icon,null,"ui-icon-check ui-state-checked",e)._toggleClass(this.icon,null,"ui-icon-blank",!e),"radio"===this.type&&this._getRadioGroup().each(function(){var e=t(this).checkboxradio("instance");e&&e._removeClass(e.label,"ui-checkboxradio-checked","ui-state-active")})},_destroy:function(){this._unbindFormResetHandler(),this.icon&&(this.icon.remove(),this.iconSpace.remove())},_setOption:function(t,e){return"label"!==t||e?(this._super(t,e),"disabled"===t?(this._toggleClass(this.label,null,"ui-state-disabled",e),this.element[0].disabled=e,void 0):(this.refresh(),void 0)):void 0},_updateIcon:function(e){var i="ui-icon ui-icon-background ";this.options.icon?(this.icon||(this.icon=t("<span>"),this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-checkboxradio-icon-space")),"checkbox"===this.type?(i+=e?"ui-icon-check ui-state-checked":"ui-icon-blank",this._removeClass(this.icon,null,e?"ui-icon-blank":"ui-icon-check")):i+="ui-icon-blank",this._addClass(this.icon,"ui-checkboxradio-icon",i),e||this._removeClass(this.icon,null,"ui-icon-check ui-state-checked"),this.icon.prependTo(this.label).after(this.iconSpace)):void 0!==this.icon&&(this.icon.remove(),this.iconSpace.remove(),delete this.icon)},_updateLabel:function(){var t=this.label.contents().not(this.element[0]);this.icon&&(t=t.not(this.icon[0])),this.iconSpace&&(t=t.not(this.iconSpace[0])),t.remove(),this.label.append(this.options.label)},refresh:function(){var t=this.element[0].checked,e=this.element[0].disabled;this._updateIcon(t),this._toggleClass(this.label,"ui-checkboxradio-checked","ui-state-active",t),null!==this.options.label&&this._updateLabel(),e!==this.options.disabled&&this._setOptions({disabled:e})}}]),t.ui.checkboxradio,t.widget("ui.button",{version:"1.12.1",defaultElement:"<button>",options:{classes:{"ui-button":"ui-corner-all"},disabled:null,icon:null,iconPosition:"beginning",label:null,showLabel:!0},_getCreateOptions:function(){var t,e=this._super()||{};return this.isInput=this.element.is("input"),t=this.element[0].disabled,null!=t&&(e.disabled=t),this.originalLabel=this.isInput?this.element.val():this.element.html(),this.originalLabel&&(e.label=this.originalLabel),e},_create:function(){!this.option.showLabel&!this.options.icon&&(this.options.showLabel=!0),null==this.options.disabled&&(this.options.disabled=this.element[0].disabled||!1),this.hasTitle=!!this.element.attr("title"),this.options.label&&this.options.label!==this.originalLabel&&(this.isInput?this.element.val(this.options.label):this.element.html(this.options.label)),this._addClass("ui-button","ui-widget"),this._setOption("disabled",this.options.disabled),this._enhance(),this.element.is("a")&&this._on({keyup:function(e){e.keyCode===t.ui.keyCode.SPACE&&(e.preventDefault(),this.element[0].click?this.element[0].click():this.element.trigger("click"))}})},_enhance:function(){this.element.is("button")||this.element.attr("role","button"),this.options.icon&&(this._updateIcon("icon",this.options.icon),this._updateTooltip())},_updateTooltip:function(){this.title=this.element.attr("title"),this.options.showLabel||this.title||this.element.attr("title",this.options.label)},_updateIcon:function(e,i){var s="iconPosition"!==e,n=s?this.options.iconPosition:i,o="top"===n||"bottom"===n;this.icon?s&&this._removeClass(this.icon,null,this.options.icon):(this.icon=t("<span>"),this._addClass(this.icon,"ui-button-icon","ui-icon"),this.options.showLabel||this._addClass("ui-button-icon-only")),s&&this._addClass(this.icon,null,i),this._attachIcon(n),o?(this._addClass(this.icon,null,"ui-widget-icon-block"),this.iconSpace&&this.iconSpace.remove()):(this.iconSpace||(this.iconSpace=t("<span> </span>"),this._addClass(this.iconSpace,"ui-button-icon-space")),this._removeClass(this.icon,null,"ui-wiget-icon-block"),this._attachIconSpace(n))},_destroy:function(){this.element.removeAttr("role"),this.icon&&this.icon.remove(),this.iconSpace&&this.iconSpace.remove(),this.hasTitle||this.element.removeAttr("title")},_attachIconSpace:function(t){this.icon[/^(?:end|bottom)/.test(t)?"before":"after"](this.iconSpace)},_attachIcon:function(t){this.element[/^(?:end|bottom)/.test(t)?"append":"prepend"](this.icon)},_setOptions:function(t){var e=void 0===t.showLabel?this.options.showLabel:t.showLabel,i=void 0===t.icon?this.options.icon:t.icon;e||i||(t.showLabel=!0),this._super(t)},_setOption:function(t,e){"icon"===t&&(e?this._updateIcon(t,e):this.icon&&(this.icon.remove(),this.iconSpace&&this.iconSpace.remove())),"iconPosition"===t&&this._updateIcon(t,e),"showLabel"===t&&(this._toggleClass("ui-button-icon-only",null,!e),this._updateTooltip()),"label"===t&&(this.isInput?this.element.val(e):(this.element.html(e),this.icon&&(this._attachIcon(this.options.iconPosition),this._attachIconSpace(this.options.iconPosition)))),this._super(t,e),"disabled"===t&&(this._toggleClass(null,"ui-state-disabled",e),this.element[0].disabled=e,e&&this.element.blur())},refresh:function(){var t=this.element.is("input, button")?this.element[0].disabled:this.element.hasClass("ui-button-disabled");t!==this.options.disabled&&this._setOptions({disabled:t}),this._updateTooltip()}}),t.uiBackCompat!==!1&&(t.widget("ui.button",t.ui.button,{options:{text:!0,icons:{primary:null,secondary:null}},_create:function(){this.options.showLabel&&!this.options.text&&(this.options.showLabel=this.options.text),!this.options.showLabel&&this.options.text&&(this.options.text=this.options.showLabel),this.options.icon||!this.options.icons.primary&&!this.options.icons.secondary?this.options.icon&&(this.options.icons.primary=this.options.icon):this.options.icons.primary?this.options.icon=this.options.icons.primary:(this.options.icon=this.options.icons.secondary,this.options.iconPosition="end"),this._super()},_setOption:function(t,e){return"text"===t?(this._super("showLabel",e),void 0):("showLabel"===t&&(this.options.text=e),"icon"===t&&(this.options.icons.primary=e),"icons"===t&&(e.primary?(this._super("icon",e.primary),this._super("iconPosition","beginning")):e.secondary&&(this._super("icon",e.secondary),this._super("iconPosition","end"))),this._superApply(arguments),void 0)}}),t.fn.button=function(e){return function(){return!this.length||this.length&&"INPUT"!==this[0].tagName||this.length&&"INPUT"===this[0].tagName&&"checkbox"!==this.attr("type")&&"radio"!==this.attr("type")?e.apply(this,arguments):(t.ui.checkboxradio||t.error("Checkboxradio widget missing"),0===arguments.length?this.checkboxradio({icon:!1}):this.checkboxradio.apply(this,arguments))}}(t.fn.button),t.fn.buttonset=function(){return t.ui.controlgroup||t.error("Controlgroup widget missing"),"option"===arguments[0]&&"items"===arguments[1]&&arguments[2]?this.controlgroup.apply(this,[arguments[0],"items.button",arguments[2]]):"option"===arguments[0]&&"items"===arguments[1]?this.controlgroup.apply(this,[arguments[0],"items.button"]):("object"==typeof arguments[0]&&arguments[0].items&&(arguments[0].items={button:arguments[0].items}),this.controlgroup.apply(this,arguments))}),t.ui.button,t.extend(t.ui,{datepicker:{version:"1.12.1"}});var m;t.extend(s.prototype,{markerClassName:"hasDatepicker",maxRows:4,_widgetDatepicker:function(){return this.dpDiv},setDefaults:function(t){return a(this._defaults,t||{}),this},_attachDatepicker:function(e,i){var s,n,o;s=e.nodeName.toLowerCase(),n="div"===s||"span"===s,e.id||(this.uuid+=1,e.id="dp"+this.uuid),o=this._newInst(t(e),n),o.settings=t.extend({},i||{}),"input"===s?this._connectDatepicker(e,o):n&&this._inlineDatepicker(e,o)},_newInst:function(e,i){var s=e[0].id.replace(/([^A-Za-z0-9_\-])/g,"\\\\$1");return{id:s,input:e,selectedDay:0,selectedMonth:0,selectedYear:0,drawMonth:0,drawYear:0,inline:i,dpDiv:i?n(t("<div class='"+this._inlineClass+" ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>")):this.dpDiv}},_connectDatepicker:function(e,i){var s=t(e);i.append=t([]),i.trigger=t([]),s.hasClass(this.markerClassName)||(this._attachments(s,i),s.addClass(this.markerClassName).on("keydown",this._doKeyDown).on("keypress",this._doKeyPress).on("keyup",this._doKeyUp),this._autoSize(i),t.data(e,"datepicker",i),i.settings.disabled&&this._disableDatepicker(e))},_attachments:function(e,i){var s,n,o,a=this._get(i,"appendText"),r=this._get(i,"isRTL");i.append&&i.append.remove(),a&&(i.append=t("<span class='"+this._appendClass+"'>"+a+"</span>"),e[r?"before":"after"](i.append)),e.off("focus",this._showDatepicker),i.trigger&&i.trigger.remove(),s=this._get(i,"showOn"),("focus"===s||"both"===s)&&e.on("focus",this._showDatepicker),("button"===s||"both"===s)&&(n=this._get(i,"buttonText"),o=this._get(i,"buttonImage"),i.trigger=t(this._get(i,"buttonImageOnly")?t("<img/>").addClass(this._triggerClass).attr({src:o,alt:n,title:n}):t("<button type='button'></button>").addClass(this._triggerClass).html(o?t("<img/>").attr({src:o,alt:n,title:n}):n)),e[r?"before":"after"](i.trigger),i.trigger.on("click",function(){return t.datepicker._datepickerShowing&&t.datepicker._lastInput===e[0]?t.datepicker._hideDatepicker():t.datepicker._datepickerShowing&&t.datepicker._lastInput!==e[0]?(t.datepicker._hideDatepicker(),t.datepicker._showDatepicker(e[0])):t.datepicker._showDatepicker(e[0]),!1}))},_autoSize:function(t){if(this._get(t,"autoSize")&&!t.inline){var e,i,s,n,o=new Date(2009,11,20),a=this._get(t,"dateFormat");a.match(/[DM]/)&&(e=function(t){for(i=0,s=0,n=0;t.length>n;n++)t[n].length>i&&(i=t[n].length,s=n);return s},o.setMonth(e(this._get(t,a.match(/MM/)?"monthNames":"monthNamesShort"))),o.setDate(e(this._get(t,a.match(/DD/)?"dayNames":"dayNamesShort"))+20-o.getDay())),t.input.attr("size",this._formatDate(t,o).length)}},_inlineDatepicker:function(e,i){var s=t(e);s.hasClass(this.markerClassName)||(s.addClass(this.markerClassName).append(i.dpDiv),t.data(e,"datepicker",i),this._setDate(i,this._getDefaultDate(i),!0),this._updateDatepicker(i),this._updateAlternate(i),i.settings.disabled&&this._disableDatepicker(e),i.dpDiv.css("display","block"))},_dialogDatepicker:function(e,i,s,n,o){var r,h,l,c,u,d=this._dialogInst;return d||(this.uuid+=1,r="dp"+this.uuid,this._dialogInput=t("<input type='text' id='"+r+"' style='position: absolute; top: -100px; width: 0px;'/>"),this._dialogInput.on("keydown",this._doKeyDown),t("body").append(this._dialogInput),d=this._dialogInst=this._newInst(this._dialogInput,!1),d.settings={},t.data(this._dialogInput[0],"datepicker",d)),a(d.settings,n||{}),i=i&&i.constructor===Date?this._formatDate(d,i):i,this._dialogInput.val(i),this._pos=o?o.length?o:[o.pageX,o.pageY]:null,this._pos||(h=document.documentElement.clientWidth,l=document.documentElement.clientHeight,c=document.documentElement.scrollLeft||document.body.scrollLeft,u=document.documentElement.scrollTop||document.body.scrollTop,this._pos=[h/2-100+c,l/2-150+u]),this._dialogInput.css("left",this._pos[0]+20+"px").css("top",this._pos[1]+"px"),d.settings.onSelect=s,this._inDialog=!0,this.dpDiv.addClass(this._dialogClass),this._showDatepicker(this._dialogInput[0]),t.blockUI&&t.blockUI(this.dpDiv),t.data(this._dialogInput[0],"datepicker",d),this},_destroyDatepicker:function(e){var i,s=t(e),n=t.data(e,"datepicker");s.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),t.removeData(e,"datepicker"),"input"===i?(n.append.remove(),n.trigger.remove(),s.removeClass(this.markerClassName).off("focus",this._showDatepicker).off("keydown",this._doKeyDown).off("keypress",this._doKeyPress).off("keyup",this._doKeyUp)):("div"===i||"span"===i)&&s.removeClass(this.markerClassName).empty(),m===n&&(m=null))},_enableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!1,o.trigger.filter("button").each(function(){this.disabled=!1}).end().filter("img").css({opacity:"1.0",cursor:""})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().removeClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!1)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}))},_disableDatepicker:function(e){var i,s,n=t(e),o=t.data(e,"datepicker");n.hasClass(this.markerClassName)&&(i=e.nodeName.toLowerCase(),"input"===i?(e.disabled=!0,o.trigger.filter("button").each(function(){this.disabled=!0}).end().filter("img").css({opacity:"0.5",cursor:"default"})):("div"===i||"span"===i)&&(s=n.children("."+this._inlineClass),s.children().addClass("ui-state-disabled"),s.find("select.ui-datepicker-month, select.ui-datepicker-year").prop("disabled",!0)),this._disabledInputs=t.map(this._disabledInputs,function(t){return t===e?null:t}),this._disabledInputs[this._disabledInputs.length]=e)},_isDisabledDatepicker:function(t){if(!t)return!1;for(var e=0;this._disabledInputs.length>e;e++)if(this._disabledInputs[e]===t)return!0;return!1},_getInst:function(e){try{return t.data(e,"datepicker")}catch(i){throw"Missing instance data for this datepicker"}},_optionDatepicker:function(e,i,s){var n,o,r,h,l=this._getInst(e);return 2===arguments.length&&"string"==typeof i?"defaults"===i?t.extend({},t.datepicker._defaults):l?"all"===i?t.extend({},l.settings):this._get(l,i):null:(n=i||{},"string"==typeof i&&(n={},n[i]=s),l&&(this._curInst===l&&this._hideDatepicker(),o=this._getDateDatepicker(e,!0),r=this._getMinMaxDate(l,"min"),h=this._getMinMaxDate(l,"max"),a(l.settings,n),null!==r&&void 0!==n.dateFormat&&void 0===n.minDate&&(l.settings.minDate=this._formatDate(l,r)),null!==h&&void 0!==n.dateFormat&&void 0===n.maxDate&&(l.settings.maxDate=this._formatDate(l,h)),"disabled"in n&&(n.disabled?this._disableDatepicker(e):this._enableDatepicker(e)),this._attachments(t(e),l),this._autoSize(l),this._setDate(l,o),this._updateAlternate(l),this._updateDatepicker(l)),void 0)},_changeDatepicker:function(t,e,i){this._optionDatepicker(t,e,i)},_refreshDatepicker:function(t){var e=this._getInst(t);e&&this._updateDatepicker(e)},_setDateDatepicker:function(t,e){var i=this._getInst(t);i&&(this._setDate(i,e),this._updateDatepicker(i),this._updateAlternate(i))},_getDateDatepicker:function(t,e){var i=this._getInst(t);return i&&!i.inline&&this._setDateFromField(i,e),i?this._getDate(i):null},_doKeyDown:function(e){var i,s,n,o=t.datepicker._getInst(e.target),a=!0,r=o.dpDiv.is(".ui-datepicker-rtl");if(o._keyEvent=!0,t.datepicker._datepickerShowing)switch(e.keyCode){case 9:t.datepicker._hideDatepicker(),a=!1;break;case 13:return n=t("td."+t.datepicker._dayOverClass+":not(."+t.datepicker._currentClass+")",o.dpDiv),n[0]&&t.datepicker._selectDay(e.target,o.selectedMonth,o.selectedYear,n[0]),i=t.datepicker._get(o,"onSelect"),i?(s=t.datepicker._formatDate(o),i.apply(o.input?o.input[0]:null,[s,o])):t.datepicker._hideDatepicker(),!1;case 27:t.datepicker._hideDatepicker();break;case 33:t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 34:t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 35:(e.ctrlKey||e.metaKey)&&t.datepicker._clearDate(e.target),a=e.ctrlKey||e.metaKey;break;case 36:(e.ctrlKey||e.metaKey)&&t.datepicker._gotoToday(e.target),a=e.ctrlKey||e.metaKey;break;case 37:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?1:-1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?-t.datepicker._get(o,"stepBigMonths"):-t.datepicker._get(o,"stepMonths"),"M");break;case 38:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,-7,"D"),a=e.ctrlKey||e.metaKey;break;case 39:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,r?-1:1,"D"),a=e.ctrlKey||e.metaKey,e.originalEvent.altKey&&t.datepicker._adjustDate(e.target,e.ctrlKey?+t.datepicker._get(o,"stepBigMonths"):+t.datepicker._get(o,"stepMonths"),"M");break;case 40:(e.ctrlKey||e.metaKey)&&t.datepicker._adjustDate(e.target,7,"D"),a=e.ctrlKey||e.metaKey;break;default:a=!1}else 36===e.keyCode&&e.ctrlKey?t.datepicker._showDatepicker(this):a=!1;a&&(e.preventDefault(),e.stopPropagation())},_doKeyPress:function(e){var i,s,n=t.datepicker._getInst(e.target);return t.datepicker._get(n,"constrainInput")?(i=t.datepicker._possibleChars(t.datepicker._get(n,"dateFormat")),s=String.fromCharCode(null==e.charCode?e.keyCode:e.charCode),e.ctrlKey||e.metaKey||" ">s||!i||i.indexOf(s)>-1):void 0},_doKeyUp:function(e){var i,s=t.datepicker._getInst(e.target);if(s.input.val()!==s.lastVal)try{i=t.datepicker.parseDate(t.datepicker._get(s,"dateFormat"),s.input?s.input.val():null,t.datepicker._getFormatConfig(s)),i&&(t.datepicker._setDateFromField(s),t.datepicker._updateAlternate(s),t.datepicker._updateDatepicker(s))}catch(n){}return!0},_showDatepicker:function(e){if(e=e.target||e,"input"!==e.nodeName.toLowerCase()&&(e=t("input",e.parentNode)[0]),!t.datepicker._isDisabledDatepicker(e)&&t.datepicker._lastInput!==e){var s,n,o,r,h,l,c;s=t.datepicker._getInst(e),t.datepicker._curInst&&t.datepicker._curInst!==s&&(t.datepicker._curInst.dpDiv.stop(!0,!0),s&&t.datepicker._datepickerShowing&&t.datepicker._hideDatepicker(t.datepicker._curInst.input[0])),n=t.datepicker._get(s,"beforeShow"),o=n?n.apply(e,[e,s]):{},o!==!1&&(a(s.settings,o),s.lastVal=null,t.datepicker._lastInput=e,t.datepicker._setDateFromField(s),t.datepicker._inDialog&&(e.value=""),t.datepicker._pos||(t.datepicker._pos=t.datepicker._findPos(e),t.datepicker._pos[1]+=e.offsetHeight),r=!1,t(e).parents().each(function(){return r|="fixed"===t(this).css("position"),!r}),h={left:t.datepicker._pos[0],top:t.datepicker._pos[1]},t.datepicker._pos=null,s.dpDiv.empty(),s.dpDiv.css({position:"absolute",display:"block",top:"-1000px"}),t.datepicker._updateDatepicker(s),h=t.datepicker._checkOffset(s,h,r),s.dpDiv.css({position:t.datepicker._inDialog&&t.blockUI?"static":r?"fixed":"absolute",display:"none",left:h.left+"px",top:h.top+"px"}),s.inline||(l=t.datepicker._get(s,"showAnim"),c=t.datepicker._get(s,"duration"),s.dpDiv.css("z-index",i(t(e))+1),t.datepicker._datepickerShowing=!0,t.effects&&t.effects.effect[l]?s.dpDiv.show(l,t.datepicker._get(s,"showOptions"),c):s.dpDiv[l||"show"](l?c:null),t.datepicker._shouldFocusInput(s)&&s.input.trigger("focus"),t.datepicker._curInst=s))
}},_updateDatepicker:function(e){this.maxRows=4,m=e,e.dpDiv.empty().append(this._generateHTML(e)),this._attachHandlers(e);var i,s=this._getNumberOfMonths(e),n=s[1],a=17,r=e.dpDiv.find("."+this._dayOverClass+" a");r.length>0&&o.apply(r.get(0)),e.dpDiv.removeClass("ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4").width(""),n>1&&e.dpDiv.addClass("ui-datepicker-multi-"+n).css("width",a*n+"em"),e.dpDiv[(1!==s[0]||1!==s[1]?"add":"remove")+"Class"]("ui-datepicker-multi"),e.dpDiv[(this._get(e,"isRTL")?"add":"remove")+"Class"]("ui-datepicker-rtl"),e===t.datepicker._curInst&&t.datepicker._datepickerShowing&&t.datepicker._shouldFocusInput(e)&&e.input.trigger("focus"),e.yearshtml&&(i=e.yearshtml,setTimeout(function(){i===e.yearshtml&&e.yearshtml&&e.dpDiv.find("select.ui-datepicker-year:first").replaceWith(e.yearshtml),i=e.yearshtml=null},0))},_shouldFocusInput:function(t){return t.input&&t.input.is(":visible")&&!t.input.is(":disabled")&&!t.input.is(":focus")},_checkOffset:function(e,i,s){var n=e.dpDiv.outerWidth(),o=e.dpDiv.outerHeight(),a=e.input?e.input.outerWidth():0,r=e.input?e.input.outerHeight():0,h=document.documentElement.clientWidth+(s?0:t(document).scrollLeft()),l=document.documentElement.clientHeight+(s?0:t(document).scrollTop());return i.left-=this._get(e,"isRTL")?n-a:0,i.left-=s&&i.left===e.input.offset().left?t(document).scrollLeft():0,i.top-=s&&i.top===e.input.offset().top+r?t(document).scrollTop():0,i.left-=Math.min(i.left,i.left+n>h&&h>n?Math.abs(i.left+n-h):0),i.top-=Math.min(i.top,i.top+o>l&&l>o?Math.abs(o+r):0),i},_findPos:function(e){for(var i,s=this._getInst(e),n=this._get(s,"isRTL");e&&("hidden"===e.type||1!==e.nodeType||t.expr.filters.hidden(e));)e=e[n?"previousSibling":"nextSibling"];return i=t(e).offset(),[i.left,i.top]},_hideDatepicker:function(e){var i,s,n,o,a=this._curInst;!a||e&&a!==t.data(e,"datepicker")||this._datepickerShowing&&(i=this._get(a,"showAnim"),s=this._get(a,"duration"),n=function(){t.datepicker._tidyDialog(a)},t.effects&&(t.effects.effect[i]||t.effects[i])?a.dpDiv.hide(i,t.datepicker._get(a,"showOptions"),s,n):a.dpDiv["slideDown"===i?"slideUp":"fadeIn"===i?"fadeOut":"hide"](i?s:null,n),i||n(),this._datepickerShowing=!1,o=this._get(a,"onClose"),o&&o.apply(a.input?a.input[0]:null,[a.input?a.input.val():"",a]),this._lastInput=null,this._inDialog&&(this._dialogInput.css({position:"absolute",left:"0",top:"-100px"}),t.blockUI&&(t.unblockUI(),t("body").append(this.dpDiv))),this._inDialog=!1)},_tidyDialog:function(t){t.dpDiv.removeClass(this._dialogClass).off(".ui-datepicker-calendar")},_checkExternalClick:function(e){if(t.datepicker._curInst){var i=t(e.target),s=t.datepicker._getInst(i[0]);(i[0].id!==t.datepicker._mainDivId&&0===i.parents("#"+t.datepicker._mainDivId).length&&!i.hasClass(t.datepicker.markerClassName)&&!i.closest("."+t.datepicker._triggerClass).length&&t.datepicker._datepickerShowing&&(!t.datepicker._inDialog||!t.blockUI)||i.hasClass(t.datepicker.markerClassName)&&t.datepicker._curInst!==s)&&t.datepicker._hideDatepicker()}},_adjustDate:function(e,i,s){var n=t(e),o=this._getInst(n[0]);this._isDisabledDatepicker(n[0])||(this._adjustInstDate(o,i+("M"===s?this._get(o,"showCurrentAtPos"):0),s),this._updateDatepicker(o))},_gotoToday:function(e){var i,s=t(e),n=this._getInst(s[0]);this._get(n,"gotoCurrent")&&n.currentDay?(n.selectedDay=n.currentDay,n.drawMonth=n.selectedMonth=n.currentMonth,n.drawYear=n.selectedYear=n.currentYear):(i=new Date,n.selectedDay=i.getDate(),n.drawMonth=n.selectedMonth=i.getMonth(),n.drawYear=n.selectedYear=i.getFullYear()),this._notifyChange(n),this._adjustDate(s)},_selectMonthYear:function(e,i,s){var n=t(e),o=this._getInst(n[0]);o["selected"+("M"===s?"Month":"Year")]=o["draw"+("M"===s?"Month":"Year")]=parseInt(i.options[i.selectedIndex].value,10),this._notifyChange(o),this._adjustDate(n)},_selectDay:function(e,i,s,n){var o,a=t(e);t(n).hasClass(this._unselectableClass)||this._isDisabledDatepicker(a[0])||(o=this._getInst(a[0]),o.selectedDay=o.currentDay=t("a",n).html(),o.selectedMonth=o.currentMonth=i,o.selectedYear=o.currentYear=s,this._selectDate(e,this._formatDate(o,o.currentDay,o.currentMonth,o.currentYear)))},_clearDate:function(e){var i=t(e);this._selectDate(i,"")},_selectDate:function(e,i){var s,n=t(e),o=this._getInst(n[0]);i=null!=i?i:this._formatDate(o),o.input&&o.input.val(i),this._updateAlternate(o),s=this._get(o,"onSelect"),s?s.apply(o.input?o.input[0]:null,[i,o]):o.input&&o.input.trigger("change"),o.inline?this._updateDatepicker(o):(this._hideDatepicker(),this._lastInput=o.input[0],"object"!=typeof o.input[0]&&o.input.trigger("focus"),this._lastInput=null)},_updateAlternate:function(e){var i,s,n,o=this._get(e,"altField");o&&(i=this._get(e,"altFormat")||this._get(e,"dateFormat"),s=this._getDate(e),n=this.formatDate(i,s,this._getFormatConfig(e)),t(o).val(n))},noWeekends:function(t){var e=t.getDay();return[e>0&&6>e,""]},iso8601Week:function(t){var e,i=new Date(t.getTime());return i.setDate(i.getDate()+4-(i.getDay()||7)),e=i.getTime(),i.setMonth(0),i.setDate(1),Math.floor(Math.round((e-i)/864e5)/7)+1},parseDate:function(e,i,s){if(null==e||null==i)throw"Invalid arguments";if(i="object"==typeof i?""+i:i+"",""===i)return null;var n,o,a,r,h=0,l=(s?s.shortYearCutoff:null)||this._defaults.shortYearCutoff,c="string"!=typeof l?l:(new Date).getFullYear()%100+parseInt(l,10),u=(s?s.dayNamesShort:null)||this._defaults.dayNamesShort,d=(s?s.dayNames:null)||this._defaults.dayNames,p=(s?s.monthNamesShort:null)||this._defaults.monthNamesShort,f=(s?s.monthNames:null)||this._defaults.monthNames,g=-1,m=-1,_=-1,v=-1,b=!1,y=function(t){var i=e.length>n+1&&e.charAt(n+1)===t;return i&&n++,i},w=function(t){var e=y(t),s="@"===t?14:"!"===t?20:"y"===t&&e?4:"o"===t?3:2,n="y"===t?s:1,o=RegExp("^\\d{"+n+","+s+"}"),a=i.substring(h).match(o);if(!a)throw"Missing number at position "+h;return h+=a[0].length,parseInt(a[0],10)},k=function(e,s,n){var o=-1,a=t.map(y(e)?n:s,function(t,e){return[[e,t]]}).sort(function(t,e){return-(t[1].length-e[1].length)});if(t.each(a,function(t,e){var s=e[1];return i.substr(h,s.length).toLowerCase()===s.toLowerCase()?(o=e[0],h+=s.length,!1):void 0}),-1!==o)return o+1;throw"Unknown name at position "+h},x=function(){if(i.charAt(h)!==e.charAt(n))throw"Unexpected literal at position "+h;h++};for(n=0;e.length>n;n++)if(b)"'"!==e.charAt(n)||y("'")?x():b=!1;else switch(e.charAt(n)){case"d":_=w("d");break;case"D":k("D",u,d);break;case"o":v=w("o");break;case"m":m=w("m");break;case"M":m=k("M",p,f);break;case"y":g=w("y");break;case"@":r=new Date(w("@")),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"!":r=new Date((w("!")-this._ticksTo1970)/1e4),g=r.getFullYear(),m=r.getMonth()+1,_=r.getDate();break;case"'":y("'")?x():b=!0;break;default:x()}if(i.length>h&&(a=i.substr(h),!/^\s+/.test(a)))throw"Extra/unparsed characters found in date: "+a;if(-1===g?g=(new Date).getFullYear():100>g&&(g+=(new Date).getFullYear()-(new Date).getFullYear()%100+(c>=g?0:-100)),v>-1)for(m=1,_=v;;){if(o=this._getDaysInMonth(g,m-1),o>=_)break;m++,_-=o}if(r=this._daylightSavingAdjust(new Date(g,m-1,_)),r.getFullYear()!==g||r.getMonth()+1!==m||r.getDate()!==_)throw"Invalid date";return r},ATOM:"yy-mm-dd",COOKIE:"D, dd M yy",ISO_8601:"yy-mm-dd",RFC_822:"D, d M y",RFC_850:"DD, dd-M-y",RFC_1036:"D, d M y",RFC_1123:"D, d M yy",RFC_2822:"D, d M yy",RSS:"D, d M y",TICKS:"!",TIMESTAMP:"@",W3C:"yy-mm-dd",_ticksTo1970:1e7*60*60*24*(718685+Math.floor(492.5)-Math.floor(19.7)+Math.floor(4.925)),formatDate:function(t,e,i){if(!e)return"";var s,n=(i?i.dayNamesShort:null)||this._defaults.dayNamesShort,o=(i?i.dayNames:null)||this._defaults.dayNames,a=(i?i.monthNamesShort:null)||this._defaults.monthNamesShort,r=(i?i.monthNames:null)||this._defaults.monthNames,h=function(e){var i=t.length>s+1&&t.charAt(s+1)===e;return i&&s++,i},l=function(t,e,i){var s=""+e;if(h(t))for(;i>s.length;)s="0"+s;return s},c=function(t,e,i,s){return h(t)?s[e]:i[e]},u="",d=!1;if(e)for(s=0;t.length>s;s++)if(d)"'"!==t.charAt(s)||h("'")?u+=t.charAt(s):d=!1;else switch(t.charAt(s)){case"d":u+=l("d",e.getDate(),2);break;case"D":u+=c("D",e.getDay(),n,o);break;case"o":u+=l("o",Math.round((new Date(e.getFullYear(),e.getMonth(),e.getDate()).getTime()-new Date(e.getFullYear(),0,0).getTime())/864e5),3);break;case"m":u+=l("m",e.getMonth()+1,2);break;case"M":u+=c("M",e.getMonth(),a,r);break;case"y":u+=h("y")?e.getFullYear():(10>e.getFullYear()%100?"0":"")+e.getFullYear()%100;break;case"@":u+=e.getTime();break;case"!":u+=1e4*e.getTime()+this._ticksTo1970;break;case"'":h("'")?u+="'":d=!0;break;default:u+=t.charAt(s)}return u},_possibleChars:function(t){var e,i="",s=!1,n=function(i){var s=t.length>e+1&&t.charAt(e+1)===i;return s&&e++,s};for(e=0;t.length>e;e++)if(s)"'"!==t.charAt(e)||n("'")?i+=t.charAt(e):s=!1;else switch(t.charAt(e)){case"d":case"m":case"y":case"@":i+="0123456789";break;case"D":case"M":return null;case"'":n("'")?i+="'":s=!0;break;default:i+=t.charAt(e)}return i},_get:function(t,e){return void 0!==t.settings[e]?t.settings[e]:this._defaults[e]},_setDateFromField:function(t,e){if(t.input.val()!==t.lastVal){var i=this._get(t,"dateFormat"),s=t.lastVal=t.input?t.input.val():null,n=this._getDefaultDate(t),o=n,a=this._getFormatConfig(t);try{o=this.parseDate(i,s,a)||n}catch(r){s=e?"":s}t.selectedDay=o.getDate(),t.drawMonth=t.selectedMonth=o.getMonth(),t.drawYear=t.selectedYear=o.getFullYear(),t.currentDay=s?o.getDate():0,t.currentMonth=s?o.getMonth():0,t.currentYear=s?o.getFullYear():0,this._adjustInstDate(t)}},_getDefaultDate:function(t){return this._restrictMinMax(t,this._determineDate(t,this._get(t,"defaultDate"),new Date))},_determineDate:function(e,i,s){var n=function(t){var e=new Date;return e.setDate(e.getDate()+t),e},o=function(i){try{return t.datepicker.parseDate(t.datepicker._get(e,"dateFormat"),i,t.datepicker._getFormatConfig(e))}catch(s){}for(var n=(i.toLowerCase().match(/^c/)?t.datepicker._getDate(e):null)||new Date,o=n.getFullYear(),a=n.getMonth(),r=n.getDate(),h=/([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,l=h.exec(i);l;){switch(l[2]||"d"){case"d":case"D":r+=parseInt(l[1],10);break;case"w":case"W":r+=7*parseInt(l[1],10);break;case"m":case"M":a+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a));break;case"y":case"Y":o+=parseInt(l[1],10),r=Math.min(r,t.datepicker._getDaysInMonth(o,a))}l=h.exec(i)}return new Date(o,a,r)},a=null==i||""===i?s:"string"==typeof i?o(i):"number"==typeof i?isNaN(i)?s:n(i):new Date(i.getTime());return a=a&&"Invalid Date"==""+a?s:a,a&&(a.setHours(0),a.setMinutes(0),a.setSeconds(0),a.setMilliseconds(0)),this._daylightSavingAdjust(a)},_daylightSavingAdjust:function(t){return t?(t.setHours(t.getHours()>12?t.getHours()+2:0),t):null},_setDate:function(t,e,i){var s=!e,n=t.selectedMonth,o=t.selectedYear,a=this._restrictMinMax(t,this._determineDate(t,e,new Date));t.selectedDay=t.currentDay=a.getDate(),t.drawMonth=t.selectedMonth=t.currentMonth=a.getMonth(),t.drawYear=t.selectedYear=t.currentYear=a.getFullYear(),n===t.selectedMonth&&o===t.selectedYear||i||this._notifyChange(t),this._adjustInstDate(t),t.input&&t.input.val(s?"":this._formatDate(t))},_getDate:function(t){var e=!t.currentYear||t.input&&""===t.input.val()?null:this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return e},_attachHandlers:function(e){var i=this._get(e,"stepMonths"),s="#"+e.id.replace(/\\\\/g,"\\");e.dpDiv.find("[data-handler]").map(function(){var e={prev:function(){t.datepicker._adjustDate(s,-i,"M")},next:function(){t.datepicker._adjustDate(s,+i,"M")},hide:function(){t.datepicker._hideDatepicker()},today:function(){t.datepicker._gotoToday(s)},selectDay:function(){return t.datepicker._selectDay(s,+this.getAttribute("data-month"),+this.getAttribute("data-year"),this),!1},selectMonth:function(){return t.datepicker._selectMonthYear(s,this,"M"),!1},selectYear:function(){return t.datepicker._selectMonthYear(s,this,"Y"),!1}};t(this).on(this.getAttribute("data-event"),e[this.getAttribute("data-handler")])})},_generateHTML:function(t){var e,i,s,n,o,a,r,h,l,c,u,d,p,f,g,m,_,v,b,y,w,k,x,C,D,I,T,P,M,S,H,z,O,A,N,W,E,F,L,R=new Date,B=this._daylightSavingAdjust(new Date(R.getFullYear(),R.getMonth(),R.getDate())),Y=this._get(t,"isRTL"),j=this._get(t,"showButtonPanel"),q=this._get(t,"hideIfNoPrevNext"),K=this._get(t,"navigationAsDateFormat"),U=this._getNumberOfMonths(t),V=this._get(t,"showCurrentAtPos"),$=this._get(t,"stepMonths"),X=1!==U[0]||1!==U[1],G=this._daylightSavingAdjust(t.currentDay?new Date(t.currentYear,t.currentMonth,t.currentDay):new Date(9999,9,9)),Q=this._getMinMaxDate(t,"min"),J=this._getMinMaxDate(t,"max"),Z=t.drawMonth-V,te=t.drawYear;if(0>Z&&(Z+=12,te--),J)for(e=this._daylightSavingAdjust(new Date(J.getFullYear(),J.getMonth()-U[0]*U[1]+1,J.getDate())),e=Q&&Q>e?Q:e;this._daylightSavingAdjust(new Date(te,Z,1))>e;)Z--,0>Z&&(Z=11,te--);for(t.drawMonth=Z,t.drawYear=te,i=this._get(t,"prevText"),i=K?this.formatDate(i,this._daylightSavingAdjust(new Date(te,Z-$,1)),this._getFormatConfig(t)):i,s=this._canAdjustMonth(t,-1,te,Z)?"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>":q?"":"<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='"+i+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"e":"w")+"'>"+i+"</span></a>",n=this._get(t,"nextText"),n=K?this.formatDate(n,this._daylightSavingAdjust(new Date(te,Z+$,1)),this._getFormatConfig(t)):n,o=this._canAdjustMonth(t,1,te,Z)?"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>":q?"":"<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='"+n+"'><span class='ui-icon ui-icon-circle-triangle-"+(Y?"w":"e")+"'>"+n+"</span></a>",a=this._get(t,"currentText"),r=this._get(t,"gotoCurrent")&&t.currentDay?G:B,a=K?this.formatDate(a,r,this._getFormatConfig(t)):a,h=t.inline?"":"<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>"+this._get(t,"closeText")+"</button>",l=j?"<div class='ui-datepicker-buttonpane ui-widget-content'>"+(Y?h:"")+(this._isInRange(t,r)?"<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'>"+a+"</button>":"")+(Y?"":h)+"</div>":"",c=parseInt(this._get(t,"firstDay"),10),c=isNaN(c)?0:c,u=this._get(t,"showWeek"),d=this._get(t,"dayNames"),p=this._get(t,"dayNamesMin"),f=this._get(t,"monthNames"),g=this._get(t,"monthNamesShort"),m=this._get(t,"beforeShowDay"),_=this._get(t,"showOtherMonths"),v=this._get(t,"selectOtherMonths"),b=this._getDefaultDate(t),y="",k=0;U[0]>k;k++){for(x="",this.maxRows=4,C=0;U[1]>C;C++){if(D=this._daylightSavingAdjust(new Date(te,Z,t.selectedDay)),I=" ui-corner-all",T="",X){if(T+="<div class='ui-datepicker-group",U[1]>1)switch(C){case 0:T+=" ui-datepicker-group-first",I=" ui-corner-"+(Y?"right":"left");break;case U[1]-1:T+=" ui-datepicker-group-last",I=" ui-corner-"+(Y?"left":"right");break;default:T+=" ui-datepicker-group-middle",I=""}T+="'>"}for(T+="<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix"+I+"'>"+(/all|left/.test(I)&&0===k?Y?o:s:"")+(/all|right/.test(I)&&0===k?Y?s:o:"")+this._generateMonthYearHeader(t,Z,te,Q,J,k>0||C>0,f,g)+"</div><table class='ui-datepicker-calendar'><thead>"+"<tr>",P=u?"<th class='ui-datepicker-week-col'>"+this._get(t,"weekHeader")+"</th>":"",w=0;7>w;w++)M=(w+c)%7,P+="<th scope='col'"+((w+c+6)%7>=5?" class='ui-datepicker-week-end'":"")+">"+"<span title='"+d[M]+"'>"+p[M]+"</span></th>";for(T+=P+"</tr></thead><tbody>",S=this._getDaysInMonth(te,Z),te===t.selectedYear&&Z===t.selectedMonth&&(t.selectedDay=Math.min(t.selectedDay,S)),H=(this._getFirstDayOfMonth(te,Z)-c+7)%7,z=Math.ceil((H+S)/7),O=X?this.maxRows>z?this.maxRows:z:z,this.maxRows=O,A=this._daylightSavingAdjust(new Date(te,Z,1-H)),N=0;O>N;N++){for(T+="<tr>",W=u?"<td class='ui-datepicker-week-col'>"+this._get(t,"calculateWeek")(A)+"</td>":"",w=0;7>w;w++)E=m?m.apply(t.input?t.input[0]:null,[A]):[!0,""],F=A.getMonth()!==Z,L=F&&!v||!E[0]||Q&&Q>A||J&&A>J,W+="<td class='"+((w+c+6)%7>=5?" ui-datepicker-week-end":"")+(F?" ui-datepicker-other-month":"")+(A.getTime()===D.getTime()&&Z===t.selectedMonth&&t._keyEvent||b.getTime()===A.getTime()&&b.getTime()===D.getTime()?" "+this._dayOverClass:"")+(L?" "+this._unselectableClass+" ui-state-disabled":"")+(F&&!_?"":" "+E[1]+(A.getTime()===G.getTime()?" "+this._currentClass:"")+(A.getTime()===B.getTime()?" ui-datepicker-today":""))+"'"+(F&&!_||!E[2]?"":" title='"+E[2].replace(/'/g,"&#39;")+"'")+(L?"":" data-handler='selectDay' data-event='click' data-month='"+A.getMonth()+"' data-year='"+A.getFullYear()+"'")+">"+(F&&!_?"&#xa0;":L?"<span class='ui-state-default'>"+A.getDate()+"</span>":"<a class='ui-state-default"+(A.getTime()===B.getTime()?" ui-state-highlight":"")+(A.getTime()===G.getTime()?" ui-state-active":"")+(F?" ui-priority-secondary":"")+"' href='#'>"+A.getDate()+"</a>")+"</td>",A.setDate(A.getDate()+1),A=this._daylightSavingAdjust(A);T+=W+"</tr>"}Z++,Z>11&&(Z=0,te++),T+="</tbody></table>"+(X?"</div>"+(U[0]>0&&C===U[1]-1?"<div class='ui-datepicker-row-break'></div>":""):""),x+=T}y+=x}return y+=l,t._keyEvent=!1,y},_generateMonthYearHeader:function(t,e,i,s,n,o,a,r){var h,l,c,u,d,p,f,g,m=this._get(t,"changeMonth"),_=this._get(t,"changeYear"),v=this._get(t,"showMonthAfterYear"),b="<div class='ui-datepicker-title'>",y="";if(o||!m)y+="<span class='ui-datepicker-month'>"+a[e]+"</span>";else{for(h=s&&s.getFullYear()===i,l=n&&n.getFullYear()===i,y+="<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>",c=0;12>c;c++)(!h||c>=s.getMonth())&&(!l||n.getMonth()>=c)&&(y+="<option value='"+c+"'"+(c===e?" selected='selected'":"")+">"+r[c]+"</option>");y+="</select>"}if(v||(b+=y+(!o&&m&&_?"":"&#xa0;")),!t.yearshtml)if(t.yearshtml="",o||!_)b+="<span class='ui-datepicker-year'>"+i+"</span>";else{for(u=this._get(t,"yearRange").split(":"),d=(new Date).getFullYear(),p=function(t){var e=t.match(/c[+\-].*/)?i+parseInt(t.substring(1),10):t.match(/[+\-].*/)?d+parseInt(t,10):parseInt(t,10);return isNaN(e)?d:e},f=p(u[0]),g=Math.max(f,p(u[1]||"")),f=s?Math.max(f,s.getFullYear()):f,g=n?Math.min(g,n.getFullYear()):g,t.yearshtml+="<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";g>=f;f++)t.yearshtml+="<option value='"+f+"'"+(f===i?" selected='selected'":"")+">"+f+"</option>";t.yearshtml+="</select>",b+=t.yearshtml,t.yearshtml=null}return b+=this._get(t,"yearSuffix"),v&&(b+=(!o&&m&&_?"":"&#xa0;")+y),b+="</div>"},_adjustInstDate:function(t,e,i){var s=t.selectedYear+("Y"===i?e:0),n=t.selectedMonth+("M"===i?e:0),o=Math.min(t.selectedDay,this._getDaysInMonth(s,n))+("D"===i?e:0),a=this._restrictMinMax(t,this._daylightSavingAdjust(new Date(s,n,o)));t.selectedDay=a.getDate(),t.drawMonth=t.selectedMonth=a.getMonth(),t.drawYear=t.selectedYear=a.getFullYear(),("M"===i||"Y"===i)&&this._notifyChange(t)},_restrictMinMax:function(t,e){var i=this._getMinMaxDate(t,"min"),s=this._getMinMaxDate(t,"max"),n=i&&i>e?i:e;return s&&n>s?s:n},_notifyChange:function(t){var e=this._get(t,"onChangeMonthYear");e&&e.apply(t.input?t.input[0]:null,[t.selectedYear,t.selectedMonth+1,t])},_getNumberOfMonths:function(t){var e=this._get(t,"numberOfMonths");return null==e?[1,1]:"number"==typeof e?[1,e]:e},_getMinMaxDate:function(t,e){return this._determineDate(t,this._get(t,e+"Date"),null)},_getDaysInMonth:function(t,e){return 32-this._daylightSavingAdjust(new Date(t,e,32)).getDate()},_getFirstDayOfMonth:function(t,e){return new Date(t,e,1).getDay()},_canAdjustMonth:function(t,e,i,s){var n=this._getNumberOfMonths(t),o=this._daylightSavingAdjust(new Date(i,s+(0>e?e:n[0]*n[1]),1));return 0>e&&o.setDate(this._getDaysInMonth(o.getFullYear(),o.getMonth())),this._isInRange(t,o)},_isInRange:function(t,e){var i,s,n=this._getMinMaxDate(t,"min"),o=this._getMinMaxDate(t,"max"),a=null,r=null,h=this._get(t,"yearRange");return h&&(i=h.split(":"),s=(new Date).getFullYear(),a=parseInt(i[0],10),r=parseInt(i[1],10),i[0].match(/[+\-].*/)&&(a+=s),i[1].match(/[+\-].*/)&&(r+=s)),(!n||e.getTime()>=n.getTime())&&(!o||e.getTime()<=o.getTime())&&(!a||e.getFullYear()>=a)&&(!r||r>=e.getFullYear())},_getFormatConfig:function(t){var e=this._get(t,"shortYearCutoff");return e="string"!=typeof e?e:(new Date).getFullYear()%100+parseInt(e,10),{shortYearCutoff:e,dayNamesShort:this._get(t,"dayNamesShort"),dayNames:this._get(t,"dayNames"),monthNamesShort:this._get(t,"monthNamesShort"),monthNames:this._get(t,"monthNames")}},_formatDate:function(t,e,i,s){e||(t.currentDay=t.selectedDay,t.currentMonth=t.selectedMonth,t.currentYear=t.selectedYear);var n=e?"object"==typeof e?e:this._daylightSavingAdjust(new Date(s,i,e)):this._daylightSavingAdjust(new Date(t.currentYear,t.currentMonth,t.currentDay));return this.formatDate(this._get(t,"dateFormat"),n,this._getFormatConfig(t))}}),t.fn.datepicker=function(e){if(!this.length)return this;t.datepicker.initialized||(t(document).on("mousedown",t.datepicker._checkExternalClick),t.datepicker.initialized=!0),0===t("#"+t.datepicker._mainDivId).length&&t("body").append(t.datepicker.dpDiv);var i=Array.prototype.slice.call(arguments,1);return"string"!=typeof e||"isDisabled"!==e&&"getDate"!==e&&"widget"!==e?"option"===e&&2===arguments.length&&"string"==typeof arguments[1]?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i)):this.each(function(){"string"==typeof e?t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this].concat(i)):t.datepicker._attachDatepicker(this,e)}):t.datepicker["_"+e+"Datepicker"].apply(t.datepicker,[this[0]].concat(i))},t.datepicker=new s,t.datepicker.initialized=!1,t.datepicker.uuid=(new Date).getTime(),t.datepicker.version="1.12.1",t.datepicker,t.ui.ie=!!/msie [\w.]+/.exec(navigator.userAgent.toLowerCase());var _=!1;t(document).on("mouseup",function(){_=!1}),t.widget("ui.mouse",{version:"1.12.1",options:{cancel:"input, textarea, button, select, option",distance:1,delay:0},_mouseInit:function(){var e=this;this.element.on("mousedown."+this.widgetName,function(t){return e._mouseDown(t)}).on("click."+this.widgetName,function(i){return!0===t.data(i.target,e.widgetName+".preventClickEvent")?(t.removeData(i.target,e.widgetName+".preventClickEvent"),i.stopImmediatePropagation(),!1):void 0}),this.started=!1},_mouseDestroy:function(){this.element.off("."+this.widgetName),this._mouseMoveDelegate&&this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate)},_mouseDown:function(e){if(!_){this._mouseMoved=!1,this._mouseStarted&&this._mouseUp(e),this._mouseDownEvent=e;var i=this,s=1===e.which,n="string"==typeof this.options.cancel&&e.target.nodeName?t(e.target).closest(this.options.cancel).length:!1;return s&&!n&&this._mouseCapture(e)?(this.mouseDelayMet=!this.options.delay,this.mouseDelayMet||(this._mouseDelayTimer=setTimeout(function(){i.mouseDelayMet=!0},this.options.delay)),this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(e)!==!1,!this._mouseStarted)?(e.preventDefault(),!0):(!0===t.data(e.target,this.widgetName+".preventClickEvent")&&t.removeData(e.target,this.widgetName+".preventClickEvent"),this._mouseMoveDelegate=function(t){return i._mouseMove(t)},this._mouseUpDelegate=function(t){return i._mouseUp(t)},this.document.on("mousemove."+this.widgetName,this._mouseMoveDelegate).on("mouseup."+this.widgetName,this._mouseUpDelegate),e.preventDefault(),_=!0,!0)):!0}},_mouseMove:function(e){if(this._mouseMoved){if(t.ui.ie&&(!document.documentMode||9>document.documentMode)&&!e.button)return this._mouseUp(e);if(!e.which)if(e.originalEvent.altKey||e.originalEvent.ctrlKey||e.originalEvent.metaKey||e.originalEvent.shiftKey)this.ignoreMissingWhich=!0;else if(!this.ignoreMissingWhich)return this._mouseUp(e)}return(e.which||e.button)&&(this._mouseMoved=!0),this._mouseStarted?(this._mouseDrag(e),e.preventDefault()):(this._mouseDistanceMet(e)&&this._mouseDelayMet(e)&&(this._mouseStarted=this._mouseStart(this._mouseDownEvent,e)!==!1,this._mouseStarted?this._mouseDrag(e):this._mouseUp(e)),!this._mouseStarted)},_mouseUp:function(e){this.document.off("mousemove."+this.widgetName,this._mouseMoveDelegate).off("mouseup."+this.widgetName,this._mouseUpDelegate),this._mouseStarted&&(this._mouseStarted=!1,e.target===this._mouseDownEvent.target&&t.data(e.target,this.widgetName+".preventClickEvent",!0),this._mouseStop(e)),this._mouseDelayTimer&&(clearTimeout(this._mouseDelayTimer),delete this._mouseDelayTimer),this.ignoreMissingWhich=!1,_=!1,e.preventDefault()},_mouseDistanceMet:function(t){return Math.max(Math.abs(this._mouseDownEvent.pageX-t.pageX),Math.abs(this._mouseDownEvent.pageY-t.pageY))>=this.options.distance},_mouseDelayMet:function(){return this.mouseDelayMet},_mouseStart:function(){},_mouseDrag:function(){},_mouseStop:function(){},_mouseCapture:function(){return!0}}),t.ui.plugin={add:function(e,i,s){var n,o=t.ui[e].prototype;for(n in s)o.plugins[n]=o.plugins[n]||[],o.plugins[n].push([i,s[n]])},call:function(t,e,i,s){var n,o=t.plugins[e];if(o&&(s||t.element[0].parentNode&&11!==t.element[0].parentNode.nodeType))for(n=0;o.length>n;n++)t.options[o[n][0]]&&o[n][1].apply(t.element,i)}},t.ui.safeBlur=function(e){e&&"body"!==e.nodeName.toLowerCase()&&t(e).trigger("blur")},t.widget("ui.draggable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"drag",options:{addClasses:!0,appendTo:"parent",axis:!1,connectToSortable:!1,containment:!1,cursor:"auto",cursorAt:!1,grid:!1,handle:!1,helper:"original",iframeFix:!1,opacity:!1,refreshPositions:!1,revert:!1,revertDuration:500,scope:"default",scroll:!0,scrollSensitivity:20,scrollSpeed:20,snap:!1,snapMode:"both",snapTolerance:20,stack:!1,zIndex:!1,drag:null,start:null,stop:null},_create:function(){"original"===this.options.helper&&this._setPositionRelative(),this.options.addClasses&&this._addClass("ui-draggable"),this._setHandleClassName(),this._mouseInit()},_setOption:function(t,e){this._super(t,e),"handle"===t&&(this._removeHandleClassName(),this._setHandleClassName())},_destroy:function(){return(this.helper||this.element).is(".ui-draggable-dragging")?(this.destroyOnClear=!0,void 0):(this._removeHandleClassName(),this._mouseDestroy(),void 0)},_mouseCapture:function(e){var i=this.options;return this.helper||i.disabled||t(e.target).closest(".ui-resizable-handle").length>0?!1:(this.handle=this._getHandle(e),this.handle?(this._blurActiveElement(e),this._blockFrames(i.iframeFix===!0?"iframe":i.iframeFix),!0):!1)},_blockFrames:function(e){this.iframeBlocks=this.document.find(e).map(function(){var e=t(this);return t("<div>").css("position","absolute").appendTo(e.parent()).outerWidth(e.outerWidth()).outerHeight(e.outerHeight()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_blurActiveElement:function(e){var i=t.ui.safeActiveElement(this.document[0]),s=t(e.target);s.closest(i).length||t.ui.safeBlur(i)},_mouseStart:function(e){var i=this.options;return this.helper=this._createHelper(e),this._addClass(this.helper,"ui-draggable-dragging"),this._cacheHelperProportions(),t.ui.ddmanager&&(t.ui.ddmanager.current=this),this._cacheMargins(),this.cssPosition=this.helper.css("position"),this.scrollParent=this.helper.scrollParent(!0),this.offsetParent=this.helper.offsetParent(),this.hasFixedAncestor=this.helper.parents().filter(function(){return"fixed"===t(this).css("position")}).length>0,this.positionAbs=this.element.offset(),this._refreshOffsets(e),this.originalPosition=this.position=this._generatePosition(e,!1),this.originalPageX=e.pageX,this.originalPageY=e.pageY,i.cursorAt&&this._adjustOffsetFromHelper(i.cursorAt),this._setContainment(),this._trigger("start",e)===!1?(this._clear(),!1):(this._cacheHelperProportions(),t.ui.ddmanager&&!i.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this._mouseDrag(e,!0),t.ui.ddmanager&&t.ui.ddmanager.dragStart(this,e),!0)},_refreshOffsets:function(t){this.offset={top:this.positionAbs.top-this.margins.top,left:this.positionAbs.left-this.margins.left,scroll:!1,parent:this._getParentOffset(),relative:this._getRelativeOffset()},this.offset.click={left:t.pageX-this.offset.left,top:t.pageY-this.offset.top}},_mouseDrag:function(e,i){if(this.hasFixedAncestor&&(this.offset.parent=this._getParentOffset()),this.position=this._generatePosition(e,!0),this.positionAbs=this._convertPositionTo("absolute"),!i){var s=this._uiHash();if(this._trigger("drag",e,s)===!1)return this._mouseUp(new t.Event("mouseup",e)),!1;this.position=s.position}return this.helper[0].style.left=this.position.left+"px",this.helper[0].style.top=this.position.top+"px",t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),!1},_mouseStop:function(e){var i=this,s=!1;return t.ui.ddmanager&&!this.options.dropBehaviour&&(s=t.ui.ddmanager.drop(this,e)),this.dropped&&(s=this.dropped,this.dropped=!1),"invalid"===this.options.revert&&!s||"valid"===this.options.revert&&s||this.options.revert===!0||t.isFunction(this.options.revert)&&this.options.revert.call(this.element,s)?t(this.helper).animate(this.originalPosition,parseInt(this.options.revertDuration,10),function(){i._trigger("stop",e)!==!1&&i._clear()}):this._trigger("stop",e)!==!1&&this._clear(),!1},_mouseUp:function(e){return this._unblockFrames(),t.ui.ddmanager&&t.ui.ddmanager.dragStop(this,e),this.handleElement.is(e.target)&&this.element.trigger("focus"),t.ui.mouse.prototype._mouseUp.call(this,e)},cancel:function(){return this.helper.is(".ui-draggable-dragging")?this._mouseUp(new t.Event("mouseup",{target:this.element[0]})):this._clear(),this},_getHandle:function(e){return this.options.handle?!!t(e.target).closest(this.element.find(this.options.handle)).length:!0},_setHandleClassName:function(){this.handleElement=this.options.handle?this.element.find(this.options.handle):this.element,this._addClass(this.handleElement,"ui-draggable-handle")},_removeHandleClassName:function(){this._removeClass(this.handleElement,"ui-draggable-handle")},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper),n=s?t(i.helper.apply(this.element[0],[e])):"clone"===i.helper?this.element.clone().removeAttr("id"):this.element;return n.parents("body").length||n.appendTo("parent"===i.appendTo?this.element[0].parentNode:i.appendTo),s&&n[0]===this.element[0]&&this._setPositionRelative(),n[0]===this.element[0]||/(fixed|absolute)/.test(n.css("position"))||n.css("position","absolute"),n},_setPositionRelative:function(){/^(?:r|a|f)/.test(this.element.css("position"))||(this.element[0].style.position="relative")},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_isRootNode:function(t){return/(html|body)/i.test(t.tagName)||t===this.document[0]},_getParentOffset:function(){var e=this.offsetParent.offset(),i=this.document[0];return"absolute"===this.cssPosition&&this.scrollParent[0]!==i&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),this._isRootNode(this.offsetParent[0])&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"!==this.cssPosition)return{top:0,left:0};var t=this.element.position(),e=this._isRootNode(this.scrollParent[0]);return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+(e?0:this.scrollParent.scrollTop()),left:t.left-(parseInt(this.helper.css("left"),10)||0)+(e?0:this.scrollParent.scrollLeft())}
},_cacheMargins:function(){this.margins={left:parseInt(this.element.css("marginLeft"),10)||0,top:parseInt(this.element.css("marginTop"),10)||0,right:parseInt(this.element.css("marginRight"),10)||0,bottom:parseInt(this.element.css("marginBottom"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options,o=this.document[0];return this.relativeContainer=null,n.containment?"window"===n.containment?(this.containment=[t(window).scrollLeft()-this.offset.relative.left-this.offset.parent.left,t(window).scrollTop()-this.offset.relative.top-this.offset.parent.top,t(window).scrollLeft()+t(window).width()-this.helperProportions.width-this.margins.left,t(window).scrollTop()+(t(window).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):"document"===n.containment?(this.containment=[0,0,t(o).width()-this.helperProportions.width-this.margins.left,(t(o).height()||o.body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top],void 0):n.containment.constructor===Array?(this.containment=n.containment,void 0):("parent"===n.containment&&(n.containment=this.helper[0].parentNode),i=t(n.containment),s=i[0],s&&(e=/(scroll|auto)/.test(i.css("overflow")),this.containment=[(parseInt(i.css("borderLeftWidth"),10)||0)+(parseInt(i.css("paddingLeft"),10)||0),(parseInt(i.css("borderTopWidth"),10)||0)+(parseInt(i.css("paddingTop"),10)||0),(e?Math.max(s.scrollWidth,s.offsetWidth):s.offsetWidth)-(parseInt(i.css("borderRightWidth"),10)||0)-(parseInt(i.css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left-this.margins.right,(e?Math.max(s.scrollHeight,s.offsetHeight):s.offsetHeight)-(parseInt(i.css("borderBottomWidth"),10)||0)-(parseInt(i.css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top-this.margins.bottom],this.relativeContainer=i),void 0):(this.containment=null,void 0)},_convertPositionTo:function(t,e){e||(e=this.position);var i="absolute"===t?1:-1,s=this._isRootNode(this.scrollParent[0]);return{top:e.top+this.offset.relative.top*i+this.offset.parent.top*i-("fixed"===this.cssPosition?-this.offset.scroll.top:s?0:this.offset.scroll.top)*i,left:e.left+this.offset.relative.left*i+this.offset.parent.left*i-("fixed"===this.cssPosition?-this.offset.scroll.left:s?0:this.offset.scroll.left)*i}},_generatePosition:function(t,e){var i,s,n,o,a=this.options,r=this._isRootNode(this.scrollParent[0]),h=t.pageX,l=t.pageY;return r&&this.offset.scroll||(this.offset.scroll={top:this.scrollParent.scrollTop(),left:this.scrollParent.scrollLeft()}),e&&(this.containment&&(this.relativeContainer?(s=this.relativeContainer.offset(),i=[this.containment[0]+s.left,this.containment[1]+s.top,this.containment[2]+s.left,this.containment[3]+s.top]):i=this.containment,t.pageX-this.offset.click.left<i[0]&&(h=i[0]+this.offset.click.left),t.pageY-this.offset.click.top<i[1]&&(l=i[1]+this.offset.click.top),t.pageX-this.offset.click.left>i[2]&&(h=i[2]+this.offset.click.left),t.pageY-this.offset.click.top>i[3]&&(l=i[3]+this.offset.click.top)),a.grid&&(n=a.grid[1]?this.originalPageY+Math.round((l-this.originalPageY)/a.grid[1])*a.grid[1]:this.originalPageY,l=i?n-this.offset.click.top>=i[1]||n-this.offset.click.top>i[3]?n:n-this.offset.click.top>=i[1]?n-a.grid[1]:n+a.grid[1]:n,o=a.grid[0]?this.originalPageX+Math.round((h-this.originalPageX)/a.grid[0])*a.grid[0]:this.originalPageX,h=i?o-this.offset.click.left>=i[0]||o-this.offset.click.left>i[2]?o:o-this.offset.click.left>=i[0]?o-a.grid[0]:o+a.grid[0]:o),"y"===a.axis&&(h=this.originalPageX),"x"===a.axis&&(l=this.originalPageY)),{top:l-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.offset.scroll.top:r?0:this.offset.scroll.top),left:h-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.offset.scroll.left:r?0:this.offset.scroll.left)}},_clear:function(){this._removeClass(this.helper,"ui-draggable-dragging"),this.helper[0]===this.element[0]||this.cancelHelperRemoval||this.helper.remove(),this.helper=null,this.cancelHelperRemoval=!1,this.destroyOnClear&&this.destroy()},_trigger:function(e,i,s){return s=s||this._uiHash(),t.ui.plugin.call(this,e,[i,s,this],!0),/^(drag|start|stop)/.test(e)&&(this.positionAbs=this._convertPositionTo("absolute"),s.offset=this.positionAbs),t.Widget.prototype._trigger.call(this,e,i,s)},plugins:{},_uiHash:function(){return{helper:this.helper,position:this.position,originalPosition:this.originalPosition,offset:this.positionAbs}}}),t.ui.plugin.add("draggable","connectToSortable",{start:function(e,i,s){var n=t.extend({},i,{item:s.element});s.sortables=[],t(s.options.connectToSortable).each(function(){var i=t(this).sortable("instance");i&&!i.options.disabled&&(s.sortables.push(i),i.refreshPositions(),i._trigger("activate",e,n))})},stop:function(e,i,s){var n=t.extend({},i,{item:s.element});s.cancelHelperRemoval=!1,t.each(s.sortables,function(){var t=this;t.isOver?(t.isOver=0,s.cancelHelperRemoval=!0,t.cancelHelperRemoval=!1,t._storedCSS={position:t.placeholder.css("position"),top:t.placeholder.css("top"),left:t.placeholder.css("left")},t._mouseStop(e),t.options.helper=t.options._helper):(t.cancelHelperRemoval=!0,t._trigger("deactivate",e,n))})},drag:function(e,i,s){t.each(s.sortables,function(){var n=!1,o=this;o.positionAbs=s.positionAbs,o.helperProportions=s.helperProportions,o.offset.click=s.offset.click,o._intersectsWith(o.containerCache)&&(n=!0,t.each(s.sortables,function(){return this.positionAbs=s.positionAbs,this.helperProportions=s.helperProportions,this.offset.click=s.offset.click,this!==o&&this._intersectsWith(this.containerCache)&&t.contains(o.element[0],this.element[0])&&(n=!1),n})),n?(o.isOver||(o.isOver=1,s._parent=i.helper.parent(),o.currentItem=i.helper.appendTo(o.element).data("ui-sortable-item",!0),o.options._helper=o.options.helper,o.options.helper=function(){return i.helper[0]},e.target=o.currentItem[0],o._mouseCapture(e,!0),o._mouseStart(e,!0,!0),o.offset.click.top=s.offset.click.top,o.offset.click.left=s.offset.click.left,o.offset.parent.left-=s.offset.parent.left-o.offset.parent.left,o.offset.parent.top-=s.offset.parent.top-o.offset.parent.top,s._trigger("toSortable",e),s.dropped=o.element,t.each(s.sortables,function(){this.refreshPositions()}),s.currentItem=s.element,o.fromOutside=s),o.currentItem&&(o._mouseDrag(e),i.position=o.position)):o.isOver&&(o.isOver=0,o.cancelHelperRemoval=!0,o.options._revert=o.options.revert,o.options.revert=!1,o._trigger("out",e,o._uiHash(o)),o._mouseStop(e,!0),o.options.revert=o.options._revert,o.options.helper=o.options._helper,o.placeholder&&o.placeholder.remove(),i.helper.appendTo(s._parent),s._refreshOffsets(e),i.position=s._generatePosition(e,!0),s._trigger("fromSortable",e),s.dropped=!1,t.each(s.sortables,function(){this.refreshPositions()}))})}}),t.ui.plugin.add("draggable","cursor",{start:function(e,i,s){var n=t("body"),o=s.options;n.css("cursor")&&(o._cursor=n.css("cursor")),n.css("cursor",o.cursor)},stop:function(e,i,s){var n=s.options;n._cursor&&t("body").css("cursor",n._cursor)}}),t.ui.plugin.add("draggable","opacity",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("opacity")&&(o._opacity=n.css("opacity")),n.css("opacity",o.opacity)},stop:function(e,i,s){var n=s.options;n._opacity&&t(i.helper).css("opacity",n._opacity)}}),t.ui.plugin.add("draggable","scroll",{start:function(t,e,i){i.scrollParentNotHidden||(i.scrollParentNotHidden=i.helper.scrollParent(!1)),i.scrollParentNotHidden[0]!==i.document[0]&&"HTML"!==i.scrollParentNotHidden[0].tagName&&(i.overflowOffset=i.scrollParentNotHidden.offset())},drag:function(e,i,s){var n=s.options,o=!1,a=s.scrollParentNotHidden[0],r=s.document[0];a!==r&&"HTML"!==a.tagName?(n.axis&&"x"===n.axis||(s.overflowOffset.top+a.offsetHeight-e.pageY<n.scrollSensitivity?a.scrollTop=o=a.scrollTop+n.scrollSpeed:e.pageY-s.overflowOffset.top<n.scrollSensitivity&&(a.scrollTop=o=a.scrollTop-n.scrollSpeed)),n.axis&&"y"===n.axis||(s.overflowOffset.left+a.offsetWidth-e.pageX<n.scrollSensitivity?a.scrollLeft=o=a.scrollLeft+n.scrollSpeed:e.pageX-s.overflowOffset.left<n.scrollSensitivity&&(a.scrollLeft=o=a.scrollLeft-n.scrollSpeed))):(n.axis&&"x"===n.axis||(e.pageY-t(r).scrollTop()<n.scrollSensitivity?o=t(r).scrollTop(t(r).scrollTop()-n.scrollSpeed):t(window).height()-(e.pageY-t(r).scrollTop())<n.scrollSensitivity&&(o=t(r).scrollTop(t(r).scrollTop()+n.scrollSpeed))),n.axis&&"y"===n.axis||(e.pageX-t(r).scrollLeft()<n.scrollSensitivity?o=t(r).scrollLeft(t(r).scrollLeft()-n.scrollSpeed):t(window).width()-(e.pageX-t(r).scrollLeft())<n.scrollSensitivity&&(o=t(r).scrollLeft(t(r).scrollLeft()+n.scrollSpeed)))),o!==!1&&t.ui.ddmanager&&!n.dropBehaviour&&t.ui.ddmanager.prepareOffsets(s,e)}}),t.ui.plugin.add("draggable","snap",{start:function(e,i,s){var n=s.options;s.snapElements=[],t(n.snap.constructor!==String?n.snap.items||":data(ui-draggable)":n.snap).each(function(){var e=t(this),i=e.offset();this!==s.element[0]&&s.snapElements.push({item:this,width:e.outerWidth(),height:e.outerHeight(),top:i.top,left:i.left})})},drag:function(e,i,s){var n,o,a,r,h,l,c,u,d,p,f=s.options,g=f.snapTolerance,m=i.offset.left,_=m+s.helperProportions.width,v=i.offset.top,b=v+s.helperProportions.height;for(d=s.snapElements.length-1;d>=0;d--)h=s.snapElements[d].left-s.margins.left,l=h+s.snapElements[d].width,c=s.snapElements[d].top-s.margins.top,u=c+s.snapElements[d].height,h-g>_||m>l+g||c-g>b||v>u+g||!t.contains(s.snapElements[d].item.ownerDocument,s.snapElements[d].item)?(s.snapElements[d].snapping&&s.options.snap.release&&s.options.snap.release.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=!1):("inner"!==f.snapMode&&(n=g>=Math.abs(c-b),o=g>=Math.abs(u-v),a=g>=Math.abs(h-_),r=g>=Math.abs(l-m),n&&(i.position.top=s._convertPositionTo("relative",{top:c-s.helperProportions.height,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h-s.helperProportions.width}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l}).left)),p=n||o||a||r,"outer"!==f.snapMode&&(n=g>=Math.abs(c-v),o=g>=Math.abs(u-b),a=g>=Math.abs(h-m),r=g>=Math.abs(l-_),n&&(i.position.top=s._convertPositionTo("relative",{top:c,left:0}).top),o&&(i.position.top=s._convertPositionTo("relative",{top:u-s.helperProportions.height,left:0}).top),a&&(i.position.left=s._convertPositionTo("relative",{top:0,left:h}).left),r&&(i.position.left=s._convertPositionTo("relative",{top:0,left:l-s.helperProportions.width}).left)),!s.snapElements[d].snapping&&(n||o||a||r||p)&&s.options.snap.snap&&s.options.snap.snap.call(s.element,e,t.extend(s._uiHash(),{snapItem:s.snapElements[d].item})),s.snapElements[d].snapping=n||o||a||r||p)}}),t.ui.plugin.add("draggable","stack",{start:function(e,i,s){var n,o=s.options,a=t.makeArray(t(o.stack)).sort(function(e,i){return(parseInt(t(e).css("zIndex"),10)||0)-(parseInt(t(i).css("zIndex"),10)||0)});a.length&&(n=parseInt(t(a[0]).css("zIndex"),10)||0,t(a).each(function(e){t(this).css("zIndex",n+e)}),this.css("zIndex",n+a.length))}}),t.ui.plugin.add("draggable","zIndex",{start:function(e,i,s){var n=t(i.helper),o=s.options;n.css("zIndex")&&(o._zIndex=n.css("zIndex")),n.css("zIndex",o.zIndex)},stop:function(e,i,s){var n=s.options;n._zIndex&&t(i.helper).css("zIndex",n._zIndex)}}),t.ui.draggable,t.widget("ui.resizable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"resize",options:{alsoResize:!1,animate:!1,animateDuration:"slow",animateEasing:"swing",aspectRatio:!1,autoHide:!1,classes:{"ui-resizable-se":"ui-icon ui-icon-gripsmall-diagonal-se"},containment:!1,ghost:!1,grid:!1,handles:"e,s,se",helper:!1,maxHeight:null,maxWidth:null,minHeight:10,minWidth:10,zIndex:90,resize:null,start:null,stop:null},_num:function(t){return parseFloat(t)||0},_isNumber:function(t){return!isNaN(parseFloat(t))},_hasScroll:function(e,i){if("hidden"===t(e).css("overflow"))return!1;var s=i&&"left"===i?"scrollLeft":"scrollTop",n=!1;return e[s]>0?!0:(e[s]=1,n=e[s]>0,e[s]=0,n)},_create:function(){var e,i=this.options,s=this;this._addClass("ui-resizable"),t.extend(this,{_aspectRatio:!!i.aspectRatio,aspectRatio:i.aspectRatio,originalElement:this.element,_proportionallyResizeElements:[],_helper:i.helper||i.ghost||i.animate?i.helper||"ui-resizable-helper":null}),this.element[0].nodeName.match(/^(canvas|textarea|input|select|button|img)$/i)&&(this.element.wrap(t("<div class='ui-wrapper' style='overflow: hidden;'></div>").css({position:this.element.css("position"),width:this.element.outerWidth(),height:this.element.outerHeight(),top:this.element.css("top"),left:this.element.css("left")})),this.element=this.element.parent().data("ui-resizable",this.element.resizable("instance")),this.elementIsWrapper=!0,e={marginTop:this.originalElement.css("marginTop"),marginRight:this.originalElement.css("marginRight"),marginBottom:this.originalElement.css("marginBottom"),marginLeft:this.originalElement.css("marginLeft")},this.element.css(e),this.originalElement.css("margin",0),this.originalResizeStyle=this.originalElement.css("resize"),this.originalElement.css("resize","none"),this._proportionallyResizeElements.push(this.originalElement.css({position:"static",zoom:1,display:"block"})),this.originalElement.css(e),this._proportionallyResize()),this._setupHandles(),i.autoHide&&t(this.element).on("mouseenter",function(){i.disabled||(s._removeClass("ui-resizable-autohide"),s._handles.show())}).on("mouseleave",function(){i.disabled||s.resizing||(s._addClass("ui-resizable-autohide"),s._handles.hide())}),this._mouseInit()},_destroy:function(){this._mouseDestroy();var e,i=function(e){t(e).removeData("resizable").removeData("ui-resizable").off(".resizable").find(".ui-resizable-handle").remove()};return this.elementIsWrapper&&(i(this.element),e=this.element,this.originalElement.css({position:e.css("position"),width:e.outerWidth(),height:e.outerHeight(),top:e.css("top"),left:e.css("left")}).insertAfter(e),e.remove()),this.originalElement.css("resize",this.originalResizeStyle),i(this.originalElement),this},_setOption:function(t,e){switch(this._super(t,e),t){case"handles":this._removeHandles(),this._setupHandles();break;default:}},_setupHandles:function(){var e,i,s,n,o,a=this.options,r=this;if(this.handles=a.handles||(t(".ui-resizable-handle",this.element).length?{n:".ui-resizable-n",e:".ui-resizable-e",s:".ui-resizable-s",w:".ui-resizable-w",se:".ui-resizable-se",sw:".ui-resizable-sw",ne:".ui-resizable-ne",nw:".ui-resizable-nw"}:"e,s,se"),this._handles=t(),this.handles.constructor===String)for("all"===this.handles&&(this.handles="n,e,s,w,se,sw,ne,nw"),s=this.handles.split(","),this.handles={},i=0;s.length>i;i++)e=t.trim(s[i]),n="ui-resizable-"+e,o=t("<div>"),this._addClass(o,"ui-resizable-handle "+n),o.css({zIndex:a.zIndex}),this.handles[e]=".ui-resizable-"+e,this.element.append(o);this._renderAxis=function(e){var i,s,n,o;e=e||this.element;for(i in this.handles)this.handles[i].constructor===String?this.handles[i]=this.element.children(this.handles[i]).first().show():(this.handles[i].jquery||this.handles[i].nodeType)&&(this.handles[i]=t(this.handles[i]),this._on(this.handles[i],{mousedown:r._mouseDown})),this.elementIsWrapper&&this.originalElement[0].nodeName.match(/^(textarea|input|select|button)$/i)&&(s=t(this.handles[i],this.element),o=/sw|ne|nw|se|n|s/.test(i)?s.outerHeight():s.outerWidth(),n=["padding",/ne|nw|n/.test(i)?"Top":/se|sw|s/.test(i)?"Bottom":/^e$/.test(i)?"Right":"Left"].join(""),e.css(n,o),this._proportionallyResize()),this._handles=this._handles.add(this.handles[i])},this._renderAxis(this.element),this._handles=this._handles.add(this.element.find(".ui-resizable-handle")),this._handles.disableSelection(),this._handles.on("mouseover",function(){r.resizing||(this.className&&(o=this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i)),r.axis=o&&o[1]?o[1]:"se")}),a.autoHide&&(this._handles.hide(),this._addClass("ui-resizable-autohide"))},_removeHandles:function(){this._handles.remove()},_mouseCapture:function(e){var i,s,n=!1;for(i in this.handles)s=t(this.handles[i])[0],(s===e.target||t.contains(s,e.target))&&(n=!0);return!this.options.disabled&&n},_mouseStart:function(e){var i,s,n,o=this.options,a=this.element;return this.resizing=!0,this._renderProxy(),i=this._num(this.helper.css("left")),s=this._num(this.helper.css("top")),o.containment&&(i+=t(o.containment).scrollLeft()||0,s+=t(o.containment).scrollTop()||0),this.offset=this.helper.offset(),this.position={left:i,top:s},this.size=this._helper?{width:this.helper.width(),height:this.helper.height()}:{width:a.width(),height:a.height()},this.originalSize=this._helper?{width:a.outerWidth(),height:a.outerHeight()}:{width:a.width(),height:a.height()},this.sizeDiff={width:a.outerWidth()-a.width(),height:a.outerHeight()-a.height()},this.originalPosition={left:i,top:s},this.originalMousePosition={left:e.pageX,top:e.pageY},this.aspectRatio="number"==typeof o.aspectRatio?o.aspectRatio:this.originalSize.width/this.originalSize.height||1,n=t(".ui-resizable-"+this.axis).css("cursor"),t("body").css("cursor","auto"===n?this.axis+"-resize":n),this._addClass("ui-resizable-resizing"),this._propagate("start",e),!0},_mouseDrag:function(e){var i,s,n=this.originalMousePosition,o=this.axis,a=e.pageX-n.left||0,r=e.pageY-n.top||0,h=this._change[o];return this._updatePrevProperties(),h?(i=h.apply(this,[e,a,r]),this._updateVirtualBoundaries(e.shiftKey),(this._aspectRatio||e.shiftKey)&&(i=this._updateRatio(i,e)),i=this._respectSize(i,e),this._updateCache(i),this._propagate("resize",e),s=this._applyChanges(),!this._helper&&this._proportionallyResizeElements.length&&this._proportionallyResize(),t.isEmptyObject(s)||(this._updatePrevProperties(),this._trigger("resize",e,this.ui()),this._applyChanges()),!1):!1},_mouseStop:function(e){this.resizing=!1;var i,s,n,o,a,r,h,l=this.options,c=this;return this._helper&&(i=this._proportionallyResizeElements,s=i.length&&/textarea/i.test(i[0].nodeName),n=s&&this._hasScroll(i[0],"left")?0:c.sizeDiff.height,o=s?0:c.sizeDiff.width,a={width:c.helper.width()-o,height:c.helper.height()-n},r=parseFloat(c.element.css("left"))+(c.position.left-c.originalPosition.left)||null,h=parseFloat(c.element.css("top"))+(c.position.top-c.originalPosition.top)||null,l.animate||this.element.css(t.extend(a,{top:h,left:r})),c.helper.height(c.size.height),c.helper.width(c.size.width),this._helper&&!l.animate&&this._proportionallyResize()),t("body").css("cursor","auto"),this._removeClass("ui-resizable-resizing"),this._propagate("stop",e),this._helper&&this.helper.remove(),!1},_updatePrevProperties:function(){this.prevPosition={top:this.position.top,left:this.position.left},this.prevSize={width:this.size.width,height:this.size.height}},_applyChanges:function(){var t={};return this.position.top!==this.prevPosition.top&&(t.top=this.position.top+"px"),this.position.left!==this.prevPosition.left&&(t.left=this.position.left+"px"),this.size.width!==this.prevSize.width&&(t.width=this.size.width+"px"),this.size.height!==this.prevSize.height&&(t.height=this.size.height+"px"),this.helper.css(t),t},_updateVirtualBoundaries:function(t){var e,i,s,n,o,a=this.options;o={minWidth:this._isNumber(a.minWidth)?a.minWidth:0,maxWidth:this._isNumber(a.maxWidth)?a.maxWidth:1/0,minHeight:this._isNumber(a.minHeight)?a.minHeight:0,maxHeight:this._isNumber(a.maxHeight)?a.maxHeight:1/0},(this._aspectRatio||t)&&(e=o.minHeight*this.aspectRatio,s=o.minWidth/this.aspectRatio,i=o.maxHeight*this.aspectRatio,n=o.maxWidth/this.aspectRatio,e>o.minWidth&&(o.minWidth=e),s>o.minHeight&&(o.minHeight=s),o.maxWidth>i&&(o.maxWidth=i),o.maxHeight>n&&(o.maxHeight=n)),this._vBoundaries=o},_updateCache:function(t){this.offset=this.helper.offset(),this._isNumber(t.left)&&(this.position.left=t.left),this._isNumber(t.top)&&(this.position.top=t.top),this._isNumber(t.height)&&(this.size.height=t.height),this._isNumber(t.width)&&(this.size.width=t.width)},_updateRatio:function(t){var e=this.position,i=this.size,s=this.axis;return this._isNumber(t.height)?t.width=t.height*this.aspectRatio:this._isNumber(t.width)&&(t.height=t.width/this.aspectRatio),"sw"===s&&(t.left=e.left+(i.width-t.width),t.top=null),"nw"===s&&(t.top=e.top+(i.height-t.height),t.left=e.left+(i.width-t.width)),t},_respectSize:function(t){var e=this._vBoundaries,i=this.axis,s=this._isNumber(t.width)&&e.maxWidth&&e.maxWidth<t.width,n=this._isNumber(t.height)&&e.maxHeight&&e.maxHeight<t.height,o=this._isNumber(t.width)&&e.minWidth&&e.minWidth>t.width,a=this._isNumber(t.height)&&e.minHeight&&e.minHeight>t.height,r=this.originalPosition.left+this.originalSize.width,h=this.originalPosition.top+this.originalSize.height,l=/sw|nw|w/.test(i),c=/nw|ne|n/.test(i);return o&&(t.width=e.minWidth),a&&(t.height=e.minHeight),s&&(t.width=e.maxWidth),n&&(t.height=e.maxHeight),o&&l&&(t.left=r-e.minWidth),s&&l&&(t.left=r-e.maxWidth),a&&c&&(t.top=h-e.minHeight),n&&c&&(t.top=h-e.maxHeight),t.width||t.height||t.left||!t.top?t.width||t.height||t.top||!t.left||(t.left=null):t.top=null,t},_getPaddingPlusBorderDimensions:function(t){for(var e=0,i=[],s=[t.css("borderTopWidth"),t.css("borderRightWidth"),t.css("borderBottomWidth"),t.css("borderLeftWidth")],n=[t.css("paddingTop"),t.css("paddingRight"),t.css("paddingBottom"),t.css("paddingLeft")];4>e;e++)i[e]=parseFloat(s[e])||0,i[e]+=parseFloat(n[e])||0;return{height:i[0]+i[2],width:i[1]+i[3]}},_proportionallyResize:function(){if(this._proportionallyResizeElements.length)for(var t,e=0,i=this.helper||this.element;this._proportionallyResizeElements.length>e;e++)t=this._proportionallyResizeElements[e],this.outerDimensions||(this.outerDimensions=this._getPaddingPlusBorderDimensions(t)),t.css({height:i.height()-this.outerDimensions.height||0,width:i.width()-this.outerDimensions.width||0})},_renderProxy:function(){var e=this.element,i=this.options;this.elementOffset=e.offset(),this._helper?(this.helper=this.helper||t("<div style='overflow:hidden;'></div>"),this._addClass(this.helper,this._helper),this.helper.css({width:this.element.outerWidth(),height:this.element.outerHeight(),position:"absolute",left:this.elementOffset.left+"px",top:this.elementOffset.top+"px",zIndex:++i.zIndex}),this.helper.appendTo("body").disableSelection()):this.helper=this.element},_change:{e:function(t,e){return{width:this.originalSize.width+e}},w:function(t,e){var i=this.originalSize,s=this.originalPosition;return{left:s.left+e,width:i.width-e}},n:function(t,e,i){var s=this.originalSize,n=this.originalPosition;return{top:n.top+i,height:s.height-i}},s:function(t,e,i){return{height:this.originalSize.height+i}},se:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},sw:function(e,i,s){return t.extend(this._change.s.apply(this,arguments),this._change.w.apply(this,[e,i,s]))},ne:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.e.apply(this,[e,i,s]))},nw:function(e,i,s){return t.extend(this._change.n.apply(this,arguments),this._change.w.apply(this,[e,i,s]))}},_propagate:function(e,i){t.ui.plugin.call(this,e,[i,this.ui()]),"resize"!==e&&this._trigger(e,i,this.ui())},plugins:{},ui:function(){return{originalElement:this.originalElement,element:this.element,helper:this.helper,position:this.position,size:this.size,originalSize:this.originalSize,originalPosition:this.originalPosition}}}),t.ui.plugin.add("resizable","animate",{stop:function(e){var i=t(this).resizable("instance"),s=i.options,n=i._proportionallyResizeElements,o=n.length&&/textarea/i.test(n[0].nodeName),a=o&&i._hasScroll(n[0],"left")?0:i.sizeDiff.height,r=o?0:i.sizeDiff.width,h={width:i.size.width-r,height:i.size.height-a},l=parseFloat(i.element.css("left"))+(i.position.left-i.originalPosition.left)||null,c=parseFloat(i.element.css("top"))+(i.position.top-i.originalPosition.top)||null;i.element.animate(t.extend(h,c&&l?{top:c,left:l}:{}),{duration:s.animateDuration,easing:s.animateEasing,step:function(){var s={width:parseFloat(i.element.css("width")),height:parseFloat(i.element.css("height")),top:parseFloat(i.element.css("top")),left:parseFloat(i.element.css("left"))};n&&n.length&&t(n[0]).css({width:s.width,height:s.height}),i._updateCache(s),i._propagate("resize",e)}})}}),t.ui.plugin.add("resizable","containment",{start:function(){var e,i,s,n,o,a,r,h=t(this).resizable("instance"),l=h.options,c=h.element,u=l.containment,d=u instanceof t?u.get(0):/parent/.test(u)?c.parent().get(0):u;d&&(h.containerElement=t(d),/document/.test(u)||u===document?(h.containerOffset={left:0,top:0},h.containerPosition={left:0,top:0},h.parentData={element:t(document),left:0,top:0,width:t(document).width(),height:t(document).height()||document.body.parentNode.scrollHeight}):(e=t(d),i=[],t(["Top","Right","Left","Bottom"]).each(function(t,s){i[t]=h._num(e.css("padding"+s))}),h.containerOffset=e.offset(),h.containerPosition=e.position(),h.containerSize={height:e.innerHeight()-i[3],width:e.innerWidth()-i[1]},s=h.containerOffset,n=h.containerSize.height,o=h.containerSize.width,a=h._hasScroll(d,"left")?d.scrollWidth:o,r=h._hasScroll(d)?d.scrollHeight:n,h.parentData={element:d,left:s.left,top:s.top,width:a,height:r}))},resize:function(e){var i,s,n,o,a=t(this).resizable("instance"),r=a.options,h=a.containerOffset,l=a.position,c=a._aspectRatio||e.shiftKey,u={top:0,left:0},d=a.containerElement,p=!0;d[0]!==document&&/static/.test(d.css("position"))&&(u=h),l.left<(a._helper?h.left:0)&&(a.size.width=a.size.width+(a._helper?a.position.left-h.left:a.position.left-u.left),c&&(a.size.height=a.size.width/a.aspectRatio,p=!1),a.position.left=r.helper?h.left:0),l.top<(a._helper?h.top:0)&&(a.size.height=a.size.height+(a._helper?a.position.top-h.top:a.position.top),c&&(a.size.width=a.size.height*a.aspectRatio,p=!1),a.position.top=a._helper?h.top:0),n=a.containerElement.get(0)===a.element.parent().get(0),o=/relative|absolute/.test(a.containerElement.css("position")),n&&o?(a.offset.left=a.parentData.left+a.position.left,a.offset.top=a.parentData.top+a.position.top):(a.offset.left=a.element.offset().left,a.offset.top=a.element.offset().top),i=Math.abs(a.sizeDiff.width+(a._helper?a.offset.left-u.left:a.offset.left-h.left)),s=Math.abs(a.sizeDiff.height+(a._helper?a.offset.top-u.top:a.offset.top-h.top)),i+a.size.width>=a.parentData.width&&(a.size.width=a.parentData.width-i,c&&(a.size.height=a.size.width/a.aspectRatio,p=!1)),s+a.size.height>=a.parentData.height&&(a.size.height=a.parentData.height-s,c&&(a.size.width=a.size.height*a.aspectRatio,p=!1)),p||(a.position.left=a.prevPosition.left,a.position.top=a.prevPosition.top,a.size.width=a.prevSize.width,a.size.height=a.prevSize.height)},stop:function(){var e=t(this).resizable("instance"),i=e.options,s=e.containerOffset,n=e.containerPosition,o=e.containerElement,a=t(e.helper),r=a.offset(),h=a.outerWidth()-e.sizeDiff.width,l=a.outerHeight()-e.sizeDiff.height;e._helper&&!i.animate&&/relative/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l}),e._helper&&!i.animate&&/static/.test(o.css("position"))&&t(this).css({left:r.left-n.left-s.left,width:h,height:l})}}),t.ui.plugin.add("resizable","alsoResize",{start:function(){var e=t(this).resizable("instance"),i=e.options;t(i.alsoResize).each(function(){var e=t(this);e.data("ui-resizable-alsoresize",{width:parseFloat(e.width()),height:parseFloat(e.height()),left:parseFloat(e.css("left")),top:parseFloat(e.css("top"))})})},resize:function(e,i){var s=t(this).resizable("instance"),n=s.options,o=s.originalSize,a=s.originalPosition,r={height:s.size.height-o.height||0,width:s.size.width-o.width||0,top:s.position.top-a.top||0,left:s.position.left-a.left||0};t(n.alsoResize).each(function(){var e=t(this),s=t(this).data("ui-resizable-alsoresize"),n={},o=e.parents(i.originalElement[0]).length?["width","height"]:["width","height","top","left"];t.each(o,function(t,e){var i=(s[e]||0)+(r[e]||0);i&&i>=0&&(n[e]=i||null)}),e.css(n)})},stop:function(){t(this).removeData("ui-resizable-alsoresize")}}),t.ui.plugin.add("resizable","ghost",{start:function(){var e=t(this).resizable("instance"),i=e.size;e.ghost=e.originalElement.clone(),e.ghost.css({opacity:.25,display:"block",position:"relative",height:i.height,width:i.width,margin:0,left:0,top:0}),e._addClass(e.ghost,"ui-resizable-ghost"),t.uiBackCompat!==!1&&"string"==typeof e.options.ghost&&e.ghost.addClass(this.options.ghost),e.ghost.appendTo(e.helper)},resize:function(){var e=t(this).resizable("instance");e.ghost&&e.ghost.css({position:"relative",height:e.size.height,width:e.size.width})},stop:function(){var e=t(this).resizable("instance");e.ghost&&e.helper&&e.helper.get(0).removeChild(e.ghost.get(0))}}),t.ui.plugin.add("resizable","grid",{resize:function(){var e,i=t(this).resizable("instance"),s=i.options,n=i.size,o=i.originalSize,a=i.originalPosition,r=i.axis,h="number"==typeof s.grid?[s.grid,s.grid]:s.grid,l=h[0]||1,c=h[1]||1,u=Math.round((n.width-o.width)/l)*l,d=Math.round((n.height-o.height)/c)*c,p=o.width+u,f=o.height+d,g=s.maxWidth&&p>s.maxWidth,m=s.maxHeight&&f>s.maxHeight,_=s.minWidth&&s.minWidth>p,v=s.minHeight&&s.minHeight>f;s.grid=h,_&&(p+=l),v&&(f+=c),g&&(p-=l),m&&(f-=c),/^(se|s|e)$/.test(r)?(i.size.width=p,i.size.height=f):/^(ne)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.top=a.top-d):/^(sw)$/.test(r)?(i.size.width=p,i.size.height=f,i.position.left=a.left-u):((0>=f-c||0>=p-l)&&(e=i._getPaddingPlusBorderDimensions(this)),f-c>0?(i.size.height=f,i.position.top=a.top-d):(f=c-e.height,i.size.height=f,i.position.top=a.top+o.height-f),p-l>0?(i.size.width=p,i.position.left=a.left-u):(p=l-e.width,i.size.width=p,i.position.left=a.left+o.width-p))}}),t.ui.resizable,t.widget("ui.dialog",{version:"1.12.1",options:{appendTo:"body",autoOpen:!0,buttons:[],classes:{"ui-dialog":"ui-corner-all","ui-dialog-titlebar":"ui-corner-all"},closeOnEscape:!0,closeText:"Close",draggable:!0,hide:null,height:"auto",maxHeight:null,maxWidth:null,minHeight:150,minWidth:150,modal:!1,position:{my:"center",at:"center",of:window,collision:"fit",using:function(e){var i=t(this).css(e).offset().top;0>i&&t(this).css("top",e.top-i)}},resizable:!0,show:null,title:null,width:300,beforeClose:null,close:null,drag:null,dragStart:null,dragStop:null,focus:null,open:null,resize:null,resizeStart:null,resizeStop:null},sizeRelatedOptions:{buttons:!0,height:!0,maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0,width:!0},resizableRelatedOptions:{maxHeight:!0,maxWidth:!0,minHeight:!0,minWidth:!0},_create:function(){this.originalCss={display:this.element[0].style.display,width:this.element[0].style.width,minHeight:this.element[0].style.minHeight,maxHeight:this.element[0].style.maxHeight,height:this.element[0].style.height},this.originalPosition={parent:this.element.parent(),index:this.element.parent().children().index(this.element)},this.originalTitle=this.element.attr("title"),null==this.options.title&&null!=this.originalTitle&&(this.options.title=this.originalTitle),this.options.disabled&&(this.options.disabled=!1),this._createWrapper(),this.element.show().removeAttr("title").appendTo(this.uiDialog),this._addClass("ui-dialog-content","ui-widget-content"),this._createTitlebar(),this._createButtonPane(),this.options.draggable&&t.fn.draggable&&this._makeDraggable(),this.options.resizable&&t.fn.resizable&&this._makeResizable(),this._isOpen=!1,this._trackFocus()},_init:function(){this.options.autoOpen&&this.open()},_appendTo:function(){var e=this.options.appendTo;return e&&(e.jquery||e.nodeType)?t(e):this.document.find(e||"body").eq(0)},_destroy:function(){var t,e=this.originalPosition;this._untrackInstance(),this._destroyOverlay(),this.element.removeUniqueId().css(this.originalCss).detach(),this.uiDialog.remove(),this.originalTitle&&this.element.attr("title",this.originalTitle),t=e.parent.children().eq(e.index),t.length&&t[0]!==this.element[0]?t.before(this.element):e.parent.append(this.element)},widget:function(){return this.uiDialog
},disable:t.noop,enable:t.noop,close:function(e){var i=this;this._isOpen&&this._trigger("beforeClose",e)!==!1&&(this._isOpen=!1,this._focusedElement=null,this._destroyOverlay(),this._untrackInstance(),this.opener.filter(":focusable").trigger("focus").length||t.ui.safeBlur(t.ui.safeActiveElement(this.document[0])),this._hide(this.uiDialog,this.options.hide,function(){i._trigger("close",e)}))},isOpen:function(){return this._isOpen},moveToTop:function(){this._moveToTop()},_moveToTop:function(e,i){var s=!1,n=this.uiDialog.siblings(".ui-front:visible").map(function(){return+t(this).css("z-index")}).get(),o=Math.max.apply(null,n);return o>=+this.uiDialog.css("z-index")&&(this.uiDialog.css("z-index",o+1),s=!0),s&&!i&&this._trigger("focus",e),s},open:function(){var e=this;return this._isOpen?(this._moveToTop()&&this._focusTabbable(),void 0):(this._isOpen=!0,this.opener=t(t.ui.safeActiveElement(this.document[0])),this._size(),this._position(),this._createOverlay(),this._moveToTop(null,!0),this.overlay&&this.overlay.css("z-index",this.uiDialog.css("z-index")-1),this._show(this.uiDialog,this.options.show,function(){e._focusTabbable(),e._trigger("focus")}),this._makeFocusTarget(),this._trigger("open"),void 0)},_focusTabbable:function(){var t=this._focusedElement;t||(t=this.element.find("[autofocus]")),t.length||(t=this.element.find(":tabbable")),t.length||(t=this.uiDialogButtonPane.find(":tabbable")),t.length||(t=this.uiDialogTitlebarClose.filter(":tabbable")),t.length||(t=this.uiDialog),t.eq(0).trigger("focus")},_keepFocus:function(e){function i(){var e=t.ui.safeActiveElement(this.document[0]),i=this.uiDialog[0]===e||t.contains(this.uiDialog[0],e);i||this._focusTabbable()}e.preventDefault(),i.call(this),this._delay(i)},_createWrapper:function(){this.uiDialog=t("<div>").hide().attr({tabIndex:-1,role:"dialog"}).appendTo(this._appendTo()),this._addClass(this.uiDialog,"ui-dialog","ui-widget ui-widget-content ui-front"),this._on(this.uiDialog,{keydown:function(e){if(this.options.closeOnEscape&&!e.isDefaultPrevented()&&e.keyCode&&e.keyCode===t.ui.keyCode.ESCAPE)return e.preventDefault(),this.close(e),void 0;if(e.keyCode===t.ui.keyCode.TAB&&!e.isDefaultPrevented()){var i=this.uiDialog.find(":tabbable"),s=i.filter(":first"),n=i.filter(":last");e.target!==n[0]&&e.target!==this.uiDialog[0]||e.shiftKey?e.target!==s[0]&&e.target!==this.uiDialog[0]||!e.shiftKey||(this._delay(function(){n.trigger("focus")}),e.preventDefault()):(this._delay(function(){s.trigger("focus")}),e.preventDefault())}},mousedown:function(t){this._moveToTop(t)&&this._focusTabbable()}}),this.element.find("[aria-describedby]").length||this.uiDialog.attr({"aria-describedby":this.element.uniqueId().attr("id")})},_createTitlebar:function(){var e;this.uiDialogTitlebar=t("<div>"),this._addClass(this.uiDialogTitlebar,"ui-dialog-titlebar","ui-widget-header ui-helper-clearfix"),this._on(this.uiDialogTitlebar,{mousedown:function(e){t(e.target).closest(".ui-dialog-titlebar-close")||this.uiDialog.trigger("focus")}}),this.uiDialogTitlebarClose=t("<button type='button'></button>").button({label:t("<a>").text(this.options.closeText).html(),icon:"ui-icon-closethick",showLabel:!1}).appendTo(this.uiDialogTitlebar),this._addClass(this.uiDialogTitlebarClose,"ui-dialog-titlebar-close"),this._on(this.uiDialogTitlebarClose,{click:function(t){t.preventDefault(),this.close(t)}}),e=t("<span>").uniqueId().prependTo(this.uiDialogTitlebar),this._addClass(e,"ui-dialog-title"),this._title(e),this.uiDialogTitlebar.prependTo(this.uiDialog),this.uiDialog.attr({"aria-labelledby":e.attr("id")})},_title:function(t){this.options.title?t.text(this.options.title):t.html("&#160;")},_createButtonPane:function(){this.uiDialogButtonPane=t("<div>"),this._addClass(this.uiDialogButtonPane,"ui-dialog-buttonpane","ui-widget-content ui-helper-clearfix"),this.uiButtonSet=t("<div>").appendTo(this.uiDialogButtonPane),this._addClass(this.uiButtonSet,"ui-dialog-buttonset"),this._createButtons()},_createButtons:function(){var e=this,i=this.options.buttons;return this.uiDialogButtonPane.remove(),this.uiButtonSet.empty(),t.isEmptyObject(i)||t.isArray(i)&&!i.length?(this._removeClass(this.uiDialog,"ui-dialog-buttons"),void 0):(t.each(i,function(i,s){var n,o;s=t.isFunction(s)?{click:s,text:i}:s,s=t.extend({type:"button"},s),n=s.click,o={icon:s.icon,iconPosition:s.iconPosition,showLabel:s.showLabel,icons:s.icons,text:s.text},delete s.click,delete s.icon,delete s.iconPosition,delete s.showLabel,delete s.icons,"boolean"==typeof s.text&&delete s.text,t("<button></button>",s).button(o).appendTo(e.uiButtonSet).on("click",function(){n.apply(e.element[0],arguments)})}),this._addClass(this.uiDialog,"ui-dialog-buttons"),this.uiDialogButtonPane.appendTo(this.uiDialog),void 0)},_makeDraggable:function(){function e(t){return{position:t.position,offset:t.offset}}var i=this,s=this.options;this.uiDialog.draggable({cancel:".ui-dialog-content, .ui-dialog-titlebar-close",handle:".ui-dialog-titlebar",containment:"document",start:function(s,n){i._addClass(t(this),"ui-dialog-dragging"),i._blockFrames(),i._trigger("dragStart",s,e(n))},drag:function(t,s){i._trigger("drag",t,e(s))},stop:function(n,o){var a=o.offset.left-i.document.scrollLeft(),r=o.offset.top-i.document.scrollTop();s.position={my:"left top",at:"left"+(a>=0?"+":"")+a+" "+"top"+(r>=0?"+":"")+r,of:i.window},i._removeClass(t(this),"ui-dialog-dragging"),i._unblockFrames(),i._trigger("dragStop",n,e(o))}})},_makeResizable:function(){function e(t){return{originalPosition:t.originalPosition,originalSize:t.originalSize,position:t.position,size:t.size}}var i=this,s=this.options,n=s.resizable,o=this.uiDialog.css("position"),a="string"==typeof n?n:"n,e,s,w,se,sw,ne,nw";this.uiDialog.resizable({cancel:".ui-dialog-content",containment:"document",alsoResize:this.element,maxWidth:s.maxWidth,maxHeight:s.maxHeight,minWidth:s.minWidth,minHeight:this._minHeight(),handles:a,start:function(s,n){i._addClass(t(this),"ui-dialog-resizing"),i._blockFrames(),i._trigger("resizeStart",s,e(n))},resize:function(t,s){i._trigger("resize",t,e(s))},stop:function(n,o){var a=i.uiDialog.offset(),r=a.left-i.document.scrollLeft(),h=a.top-i.document.scrollTop();s.height=i.uiDialog.height(),s.width=i.uiDialog.width(),s.position={my:"left top",at:"left"+(r>=0?"+":"")+r+" "+"top"+(h>=0?"+":"")+h,of:i.window},i._removeClass(t(this),"ui-dialog-resizing"),i._unblockFrames(),i._trigger("resizeStop",n,e(o))}}).css("position",o)},_trackFocus:function(){this._on(this.widget(),{focusin:function(e){this._makeFocusTarget(),this._focusedElement=t(e.target)}})},_makeFocusTarget:function(){this._untrackInstance(),this._trackingInstances().unshift(this)},_untrackInstance:function(){var e=this._trackingInstances(),i=t.inArray(this,e);-1!==i&&e.splice(i,1)},_trackingInstances:function(){var t=this.document.data("ui-dialog-instances");return t||(t=[],this.document.data("ui-dialog-instances",t)),t},_minHeight:function(){var t=this.options;return"auto"===t.height?t.minHeight:Math.min(t.minHeight,t.height)},_position:function(){var t=this.uiDialog.is(":visible");t||this.uiDialog.show(),this.uiDialog.position(this.options.position),t||this.uiDialog.hide()},_setOptions:function(e){var i=this,s=!1,n={};t.each(e,function(t,e){i._setOption(t,e),t in i.sizeRelatedOptions&&(s=!0),t in i.resizableRelatedOptions&&(n[t]=e)}),s&&(this._size(),this._position()),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option",n)},_setOption:function(e,i){var s,n,o=this.uiDialog;"disabled"!==e&&(this._super(e,i),"appendTo"===e&&this.uiDialog.appendTo(this._appendTo()),"buttons"===e&&this._createButtons(),"closeText"===e&&this.uiDialogTitlebarClose.button({label:t("<a>").text(""+this.options.closeText).html()}),"draggable"===e&&(s=o.is(":data(ui-draggable)"),s&&!i&&o.draggable("destroy"),!s&&i&&this._makeDraggable()),"position"===e&&this._position(),"resizable"===e&&(n=o.is(":data(ui-resizable)"),n&&!i&&o.resizable("destroy"),n&&"string"==typeof i&&o.resizable("option","handles",i),n||i===!1||this._makeResizable()),"title"===e&&this._title(this.uiDialogTitlebar.find(".ui-dialog-title")))},_size:function(){var t,e,i,s=this.options;this.element.show().css({width:"auto",minHeight:0,maxHeight:"none",height:0}),s.minWidth>s.width&&(s.width=s.minWidth),t=this.uiDialog.css({height:"auto",width:s.width}).outerHeight(),e=Math.max(0,s.minHeight-t),i="number"==typeof s.maxHeight?Math.max(0,s.maxHeight-t):"none","auto"===s.height?this.element.css({minHeight:e,maxHeight:i,height:"auto"}):this.element.height(Math.max(0,s.height-t)),this.uiDialog.is(":data(ui-resizable)")&&this.uiDialog.resizable("option","minHeight",this._minHeight())},_blockFrames:function(){this.iframeBlocks=this.document.find("iframe").map(function(){var e=t(this);return t("<div>").css({position:"absolute",width:e.outerWidth(),height:e.outerHeight()}).appendTo(e.parent()).offset(e.offset())[0]})},_unblockFrames:function(){this.iframeBlocks&&(this.iframeBlocks.remove(),delete this.iframeBlocks)},_allowInteraction:function(e){return t(e.target).closest(".ui-dialog").length?!0:!!t(e.target).closest(".ui-datepicker").length},_createOverlay:function(){if(this.options.modal){var e=!0;this._delay(function(){e=!1}),this.document.data("ui-dialog-overlays")||this._on(this.document,{focusin:function(t){e||this._allowInteraction(t)||(t.preventDefault(),this._trackingInstances()[0]._focusTabbable())}}),this.overlay=t("<div>").appendTo(this._appendTo()),this._addClass(this.overlay,null,"ui-widget-overlay ui-front"),this._on(this.overlay,{mousedown:"_keepFocus"}),this.document.data("ui-dialog-overlays",(this.document.data("ui-dialog-overlays")||0)+1)}},_destroyOverlay:function(){if(this.options.modal&&this.overlay){var t=this.document.data("ui-dialog-overlays")-1;t?this.document.data("ui-dialog-overlays",t):(this._off(this.document,"focusin"),this.document.removeData("ui-dialog-overlays")),this.overlay.remove(),this.overlay=null}}}),t.uiBackCompat!==!1&&t.widget("ui.dialog",t.ui.dialog,{options:{dialogClass:""},_createWrapper:function(){this._super(),this.uiDialog.addClass(this.options.dialogClass)},_setOption:function(t,e){"dialogClass"===t&&this.uiDialog.removeClass(this.options.dialogClass).addClass(e),this._superApply(arguments)}}),t.ui.dialog,t.widget("ui.droppable",{version:"1.12.1",widgetEventPrefix:"drop",options:{accept:"*",addClasses:!0,greedy:!1,scope:"default",tolerance:"intersect",activate:null,deactivate:null,drop:null,out:null,over:null},_create:function(){var e,i=this.options,s=i.accept;this.isover=!1,this.isout=!0,this.accept=t.isFunction(s)?s:function(t){return t.is(s)},this.proportions=function(){return arguments.length?(e=arguments[0],void 0):e?e:e={width:this.element[0].offsetWidth,height:this.element[0].offsetHeight}},this._addToManager(i.scope),i.addClasses&&this._addClass("ui-droppable")},_addToManager:function(e){t.ui.ddmanager.droppables[e]=t.ui.ddmanager.droppables[e]||[],t.ui.ddmanager.droppables[e].push(this)},_splice:function(t){for(var e=0;t.length>e;e++)t[e]===this&&t.splice(e,1)},_destroy:function(){var e=t.ui.ddmanager.droppables[this.options.scope];this._splice(e)},_setOption:function(e,i){if("accept"===e)this.accept=t.isFunction(i)?i:function(t){return t.is(i)};else if("scope"===e){var s=t.ui.ddmanager.droppables[this.options.scope];this._splice(s),this._addToManager(i)}this._super(e,i)},_activate:function(e){var i=t.ui.ddmanager.current;this._addActiveClass(),i&&this._trigger("activate",e,this.ui(i))},_deactivate:function(e){var i=t.ui.ddmanager.current;this._removeActiveClass(),i&&this._trigger("deactivate",e,this.ui(i))},_over:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._addHoverClass(),this._trigger("over",e,this.ui(i)))},_out:function(e){var i=t.ui.ddmanager.current;i&&(i.currentItem||i.element)[0]!==this.element[0]&&this.accept.call(this.element[0],i.currentItem||i.element)&&(this._removeHoverClass(),this._trigger("out",e,this.ui(i)))},_drop:function(e,i){var s=i||t.ui.ddmanager.current,n=!1;return s&&(s.currentItem||s.element)[0]!==this.element[0]?(this.element.find(":data(ui-droppable)").not(".ui-draggable-dragging").each(function(){var i=t(this).droppable("instance");return i.options.greedy&&!i.options.disabled&&i.options.scope===s.options.scope&&i.accept.call(i.element[0],s.currentItem||s.element)&&v(s,t.extend(i,{offset:i.element.offset()}),i.options.tolerance,e)?(n=!0,!1):void 0}),n?!1:this.accept.call(this.element[0],s.currentItem||s.element)?(this._removeActiveClass(),this._removeHoverClass(),this._trigger("drop",e,this.ui(s)),this.element):!1):!1},ui:function(t){return{draggable:t.currentItem||t.element,helper:t.helper,position:t.position,offset:t.positionAbs}},_addHoverClass:function(){this._addClass("ui-droppable-hover")},_removeHoverClass:function(){this._removeClass("ui-droppable-hover")},_addActiveClass:function(){this._addClass("ui-droppable-active")},_removeActiveClass:function(){this._removeClass("ui-droppable-active")}});var v=t.ui.intersect=function(){function t(t,e,i){return t>=e&&e+i>t}return function(e,i,s,n){if(!i.offset)return!1;var o=(e.positionAbs||e.position.absolute).left+e.margins.left,a=(e.positionAbs||e.position.absolute).top+e.margins.top,r=o+e.helperProportions.width,h=a+e.helperProportions.height,l=i.offset.left,c=i.offset.top,u=l+i.proportions().width,d=c+i.proportions().height;switch(s){case"fit":return o>=l&&u>=r&&a>=c&&d>=h;case"intersect":return o+e.helperProportions.width/2>l&&u>r-e.helperProportions.width/2&&a+e.helperProportions.height/2>c&&d>h-e.helperProportions.height/2;case"pointer":return t(n.pageY,c,i.proportions().height)&&t(n.pageX,l,i.proportions().width);case"touch":return(a>=c&&d>=a||h>=c&&d>=h||c>a&&h>d)&&(o>=l&&u>=o||r>=l&&u>=r||l>o&&r>u);default:return!1}}}();t.ui.ddmanager={current:null,droppables:{"default":[]},prepareOffsets:function(e,i){var s,n,o=t.ui.ddmanager.droppables[e.options.scope]||[],a=i?i.type:null,r=(e.currentItem||e.element).find(":data(ui-droppable)").addBack();t:for(s=0;o.length>s;s++)if(!(o[s].options.disabled||e&&!o[s].accept.call(o[s].element[0],e.currentItem||e.element))){for(n=0;r.length>n;n++)if(r[n]===o[s].element[0]){o[s].proportions().height=0;continue t}o[s].visible="none"!==o[s].element.css("display"),o[s].visible&&("mousedown"===a&&o[s]._activate.call(o[s],i),o[s].offset=o[s].element.offset(),o[s].proportions({width:o[s].element[0].offsetWidth,height:o[s].element[0].offsetHeight}))}},drop:function(e,i){var s=!1;return t.each((t.ui.ddmanager.droppables[e.options.scope]||[]).slice(),function(){this.options&&(!this.options.disabled&&this.visible&&v(e,this,this.options.tolerance,i)&&(s=this._drop.call(this,i)||s),!this.options.disabled&&this.visible&&this.accept.call(this.element[0],e.currentItem||e.element)&&(this.isout=!0,this.isover=!1,this._deactivate.call(this,i)))}),s},dragStart:function(e,i){e.element.parentsUntil("body").on("scroll.droppable",function(){e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)})},drag:function(e,i){e.options.refreshPositions&&t.ui.ddmanager.prepareOffsets(e,i),t.each(t.ui.ddmanager.droppables[e.options.scope]||[],function(){if(!this.options.disabled&&!this.greedyChild&&this.visible){var s,n,o,a=v(e,this,this.options.tolerance,i),r=!a&&this.isover?"isout":a&&!this.isover?"isover":null;r&&(this.options.greedy&&(n=this.options.scope,o=this.element.parents(":data(ui-droppable)").filter(function(){return t(this).droppable("instance").options.scope===n}),o.length&&(s=t(o[0]).droppable("instance"),s.greedyChild="isover"===r)),s&&"isover"===r&&(s.isover=!1,s.isout=!0,s._out.call(s,i)),this[r]=!0,this["isout"===r?"isover":"isout"]=!1,this["isover"===r?"_over":"_out"].call(this,i),s&&"isout"===r&&(s.isout=!1,s.isover=!0,s._over.call(s,i)))}})},dragStop:function(e,i){e.element.parentsUntil("body").off("scroll.droppable"),e.options.refreshPositions||t.ui.ddmanager.prepareOffsets(e,i)}},t.uiBackCompat!==!1&&t.widget("ui.droppable",t.ui.droppable,{options:{hoverClass:!1,activeClass:!1},_addActiveClass:function(){this._super(),this.options.activeClass&&this.element.addClass(this.options.activeClass)},_removeActiveClass:function(){this._super(),this.options.activeClass&&this.element.removeClass(this.options.activeClass)},_addHoverClass:function(){this._super(),this.options.hoverClass&&this.element.addClass(this.options.hoverClass)},_removeHoverClass:function(){this._super(),this.options.hoverClass&&this.element.removeClass(this.options.hoverClass)}}),t.ui.droppable,t.widget("ui.progressbar",{version:"1.12.1",options:{classes:{"ui-progressbar":"ui-corner-all","ui-progressbar-value":"ui-corner-left","ui-progressbar-complete":"ui-corner-right"},max:100,value:0,change:null,complete:null},min:0,_create:function(){this.oldValue=this.options.value=this._constrainedValue(),this.element.attr({role:"progressbar","aria-valuemin":this.min}),this._addClass("ui-progressbar","ui-widget ui-widget-content"),this.valueDiv=t("<div>").appendTo(this.element),this._addClass(this.valueDiv,"ui-progressbar-value","ui-widget-header"),this._refreshValue()},_destroy:function(){this.element.removeAttr("role aria-valuemin aria-valuemax aria-valuenow"),this.valueDiv.remove()},value:function(t){return void 0===t?this.options.value:(this.options.value=this._constrainedValue(t),this._refreshValue(),void 0)},_constrainedValue:function(t){return void 0===t&&(t=this.options.value),this.indeterminate=t===!1,"number"!=typeof t&&(t=0),this.indeterminate?!1:Math.min(this.options.max,Math.max(this.min,t))},_setOptions:function(t){var e=t.value;delete t.value,this._super(t),this.options.value=this._constrainedValue(e),this._refreshValue()},_setOption:function(t,e){"max"===t&&(e=Math.max(this.min,e)),this._super(t,e)},_setOptionDisabled:function(t){this._super(t),this.element.attr("aria-disabled",t),this._toggleClass(null,"ui-state-disabled",!!t)},_percentage:function(){return this.indeterminate?100:100*(this.options.value-this.min)/(this.options.max-this.min)},_refreshValue:function(){var e=this.options.value,i=this._percentage();this.valueDiv.toggle(this.indeterminate||e>this.min).width(i.toFixed(0)+"%"),this._toggleClass(this.valueDiv,"ui-progressbar-complete",null,e===this.options.max)._toggleClass("ui-progressbar-indeterminate",null,this.indeterminate),this.indeterminate?(this.element.removeAttr("aria-valuenow"),this.overlayDiv||(this.overlayDiv=t("<div>").appendTo(this.valueDiv),this._addClass(this.overlayDiv,"ui-progressbar-overlay"))):(this.element.attr({"aria-valuemax":this.options.max,"aria-valuenow":e}),this.overlayDiv&&(this.overlayDiv.remove(),this.overlayDiv=null)),this.oldValue!==e&&(this.oldValue=e,this._trigger("change")),e===this.options.max&&this._trigger("complete")}}),t.widget("ui.selectable",t.ui.mouse,{version:"1.12.1",options:{appendTo:"body",autoRefresh:!0,distance:0,filter:"*",tolerance:"touch",selected:null,selecting:null,start:null,stop:null,unselected:null,unselecting:null},_create:function(){var e=this;this._addClass("ui-selectable"),this.dragged=!1,this.refresh=function(){e.elementPos=t(e.element[0]).offset(),e.selectees=t(e.options.filter,e.element[0]),e._addClass(e.selectees,"ui-selectee"),e.selectees.each(function(){var i=t(this),s=i.offset(),n={left:s.left-e.elementPos.left,top:s.top-e.elementPos.top};t.data(this,"selectable-item",{element:this,$element:i,left:n.left,top:n.top,right:n.left+i.outerWidth(),bottom:n.top+i.outerHeight(),startselected:!1,selected:i.hasClass("ui-selected"),selecting:i.hasClass("ui-selecting"),unselecting:i.hasClass("ui-unselecting")})})},this.refresh(),this._mouseInit(),this.helper=t("<div>"),this._addClass(this.helper,"ui-selectable-helper")},_destroy:function(){this.selectees.removeData("selectable-item"),this._mouseDestroy()},_mouseStart:function(e){var i=this,s=this.options;this.opos=[e.pageX,e.pageY],this.elementPos=t(this.element[0]).offset(),this.options.disabled||(this.selectees=t(s.filter,this.element[0]),this._trigger("start",e),t(s.appendTo).append(this.helper),this.helper.css({left:e.pageX,top:e.pageY,width:0,height:0}),s.autoRefresh&&this.refresh(),this.selectees.filter(".ui-selected").each(function(){var s=t.data(this,"selectable-item");s.startselected=!0,e.metaKey||e.ctrlKey||(i._removeClass(s.$element,"ui-selected"),s.selected=!1,i._addClass(s.$element,"ui-unselecting"),s.unselecting=!0,i._trigger("unselecting",e,{unselecting:s.element}))}),t(e.target).parents().addBack().each(function(){var s,n=t.data(this,"selectable-item");return n?(s=!e.metaKey&&!e.ctrlKey||!n.$element.hasClass("ui-selected"),i._removeClass(n.$element,s?"ui-unselecting":"ui-selected")._addClass(n.$element,s?"ui-selecting":"ui-unselecting"),n.unselecting=!s,n.selecting=s,n.selected=s,s?i._trigger("selecting",e,{selecting:n.element}):i._trigger("unselecting",e,{unselecting:n.element}),!1):void 0}))},_mouseDrag:function(e){if(this.dragged=!0,!this.options.disabled){var i,s=this,n=this.options,o=this.opos[0],a=this.opos[1],r=e.pageX,h=e.pageY;return o>r&&(i=r,r=o,o=i),a>h&&(i=h,h=a,a=i),this.helper.css({left:o,top:a,width:r-o,height:h-a}),this.selectees.each(function(){var i=t.data(this,"selectable-item"),l=!1,c={};i&&i.element!==s.element[0]&&(c.left=i.left+s.elementPos.left,c.right=i.right+s.elementPos.left,c.top=i.top+s.elementPos.top,c.bottom=i.bottom+s.elementPos.top,"touch"===n.tolerance?l=!(c.left>r||o>c.right||c.top>h||a>c.bottom):"fit"===n.tolerance&&(l=c.left>o&&r>c.right&&c.top>a&&h>c.bottom),l?(i.selected&&(s._removeClass(i.$element,"ui-selected"),i.selected=!1),i.unselecting&&(s._removeClass(i.$element,"ui-unselecting"),i.unselecting=!1),i.selecting||(s._addClass(i.$element,"ui-selecting"),i.selecting=!0,s._trigger("selecting",e,{selecting:i.element}))):(i.selecting&&((e.metaKey||e.ctrlKey)&&i.startselected?(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,s._addClass(i.$element,"ui-selected"),i.selected=!0):(s._removeClass(i.$element,"ui-selecting"),i.selecting=!1,i.startselected&&(s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0),s._trigger("unselecting",e,{unselecting:i.element}))),i.selected&&(e.metaKey||e.ctrlKey||i.startselected||(s._removeClass(i.$element,"ui-selected"),i.selected=!1,s._addClass(i.$element,"ui-unselecting"),i.unselecting=!0,s._trigger("unselecting",e,{unselecting:i.element})))))}),!1}},_mouseStop:function(e){var i=this;return this.dragged=!1,t(".ui-unselecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-unselecting"),s.unselecting=!1,s.startselected=!1,i._trigger("unselected",e,{unselected:s.element})}),t(".ui-selecting",this.element[0]).each(function(){var s=t.data(this,"selectable-item");i._removeClass(s.$element,"ui-selecting")._addClass(s.$element,"ui-selected"),s.selecting=!1,s.selected=!0,s.startselected=!0,i._trigger("selected",e,{selected:s.element})}),this._trigger("stop",e),this.helper.remove(),!1}}),t.widget("ui.selectmenu",[t.ui.formResetMixin,{version:"1.12.1",defaultElement:"<select>",options:{appendTo:null,classes:{"ui-selectmenu-button-open":"ui-corner-top","ui-selectmenu-button-closed":"ui-corner-all"},disabled:null,icons:{button:"ui-icon-triangle-1-s"},position:{my:"left top",at:"left bottom",collision:"none"},width:!1,change:null,close:null,focus:null,open:null,select:null},_create:function(){var e=this.element.uniqueId().attr("id");this.ids={element:e,button:e+"-button",menu:e+"-menu"},this._drawButton(),this._drawMenu(),this._bindFormResetHandler(),this._rendered=!1,this.menuItems=t()},_drawButton:function(){var e,i=this,s=this._parseOption(this.element.find("option:selected"),this.element[0].selectedIndex);this.labels=this.element.labels().attr("for",this.ids.button),this._on(this.labels,{click:function(t){this.button.focus(),t.preventDefault()}}),this.element.hide(),this.button=t("<span>",{tabindex:this.options.disabled?-1:0,id:this.ids.button,role:"combobox","aria-expanded":"false","aria-autocomplete":"list","aria-owns":this.ids.menu,"aria-haspopup":"true",title:this.element.attr("title")}).insertAfter(this.element),this._addClass(this.button,"ui-selectmenu-button ui-selectmenu-button-closed","ui-button ui-widget"),e=t("<span>").appendTo(this.button),this._addClass(e,"ui-selectmenu-icon","ui-icon "+this.options.icons.button),this.buttonItem=this._renderButtonItem(s).appendTo(this.button),this.options.width!==!1&&this._resizeButton(),this._on(this.button,this._buttonEvents),this.button.one("focusin",function(){i._rendered||i._refreshMenu()})},_drawMenu:function(){var e=this;this.menu=t("<ul>",{"aria-hidden":"true","aria-labelledby":this.ids.button,id:this.ids.menu}),this.menuWrap=t("<div>").append(this.menu),this._addClass(this.menuWrap,"ui-selectmenu-menu","ui-front"),this.menuWrap.appendTo(this._appendTo()),this.menuInstance=this.menu.menu({classes:{"ui-menu":"ui-corner-bottom"},role:"listbox",select:function(t,i){t.preventDefault(),e._setSelection(),e._select(i.item.data("ui-selectmenu-item"),t)},focus:function(t,i){var s=i.item.data("ui-selectmenu-item");null!=e.focusIndex&&s.index!==e.focusIndex&&(e._trigger("focus",t,{item:s}),e.isOpen||e._select(s,t)),e.focusIndex=s.index,e.button.attr("aria-activedescendant",e.menuItems.eq(s.index).attr("id"))}}).menu("instance"),this.menuInstance._off(this.menu,"mouseleave"),this.menuInstance._closeOnDocumentClick=function(){return!1},this.menuInstance._isDivider=function(){return!1}},refresh:function(){this._refreshMenu(),this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(this._getSelectedItem().data("ui-selectmenu-item")||{})),null===this.options.width&&this._resizeButton()},_refreshMenu:function(){var t,e=this.element.find("option");this.menu.empty(),this._parseOptions(e),this._renderMenu(this.menu,this.items),this.menuInstance.refresh(),this.menuItems=this.menu.find("li").not(".ui-selectmenu-optgroup").find(".ui-menu-item-wrapper"),this._rendered=!0,e.length&&(t=this._getSelectedItem(),this.menuInstance.focus(null,t),this._setAria(t.data("ui-selectmenu-item")),this._setOption("disabled",this.element.prop("disabled")))},open:function(t){this.options.disabled||(this._rendered?(this._removeClass(this.menu.find(".ui-state-active"),null,"ui-state-active"),this.menuInstance.focus(null,this._getSelectedItem())):this._refreshMenu(),this.menuItems.length&&(this.isOpen=!0,this._toggleAttr(),this._resizeMenu(),this._position(),this._on(this.document,this._documentClick),this._trigger("open",t)))},_position:function(){this.menuWrap.position(t.extend({of:this.button},this.options.position))},close:function(t){this.isOpen&&(this.isOpen=!1,this._toggleAttr(),this.range=null,this._off(this.document),this._trigger("close",t))},widget:function(){return this.button},menuWidget:function(){return this.menu},_renderButtonItem:function(e){var i=t("<span>");return this._setText(i,e.label),this._addClass(i,"ui-selectmenu-text"),i},_renderMenu:function(e,i){var s=this,n="";t.each(i,function(i,o){var a;o.optgroup!==n&&(a=t("<li>",{text:o.optgroup}),s._addClass(a,"ui-selectmenu-optgroup","ui-menu-divider"+(o.element.parent("optgroup").prop("disabled")?" ui-state-disabled":"")),a.appendTo(e),n=o.optgroup),s._renderItemData(e,o)})},_renderItemData:function(t,e){return this._renderItem(t,e).data("ui-selectmenu-item",e)},_renderItem:function(e,i){var s=t("<li>"),n=t("<div>",{title:i.element.attr("title")});return i.disabled&&this._addClass(s,null,"ui-state-disabled"),this._setText(n,i.label),s.append(n).appendTo(e)},_setText:function(t,e){e?t.text(e):t.html("&#160;")},_move:function(t,e){var i,s,n=".ui-menu-item";this.isOpen?i=this.menuItems.eq(this.focusIndex).parent("li"):(i=this.menuItems.eq(this.element[0].selectedIndex).parent("li"),n+=":not(.ui-state-disabled)"),s="first"===t||"last"===t?i["first"===t?"prevAll":"nextAll"](n).eq(-1):i[t+"All"](n).eq(0),s.length&&this.menuInstance.focus(e,s)},_getSelectedItem:function(){return this.menuItems.eq(this.element[0].selectedIndex).parent("li")},_toggle:function(t){this[this.isOpen?"close":"open"](t)},_setSelection:function(){var t;this.range&&(window.getSelection?(t=window.getSelection(),t.removeAllRanges(),t.addRange(this.range)):this.range.select(),this.button.focus())},_documentClick:{mousedown:function(e){this.isOpen&&(t(e.target).closest(".ui-selectmenu-menu, #"+t.ui.escapeSelector(this.ids.button)).length||this.close(e))}},_buttonEvents:{mousedown:function(){var t;window.getSelection?(t=window.getSelection(),t.rangeCount&&(this.range=t.getRangeAt(0))):this.range=document.selection.createRange()},click:function(t){this._setSelection(),this._toggle(t)},keydown:function(e){var i=!0;switch(e.keyCode){case t.ui.keyCode.TAB:case t.ui.keyCode.ESCAPE:this.close(e),i=!1;break;case t.ui.keyCode.ENTER:this.isOpen&&this._selectFocusedItem(e);break;case t.ui.keyCode.UP:e.altKey?this._toggle(e):this._move("prev",e);break;case t.ui.keyCode.DOWN:e.altKey?this._toggle(e):this._move("next",e);break;case t.ui.keyCode.SPACE:this.isOpen?this._selectFocusedItem(e):this._toggle(e);break;case t.ui.keyCode.LEFT:this._move("prev",e);break;case t.ui.keyCode.RIGHT:this._move("next",e);break;case t.ui.keyCode.HOME:case t.ui.keyCode.PAGE_UP:this._move("first",e);break;case t.ui.keyCode.END:case t.ui.keyCode.PAGE_DOWN:this._move("last",e);break;default:this.menu.trigger(e),i=!1}i&&e.preventDefault()}},_selectFocusedItem:function(t){var e=this.menuItems.eq(this.focusIndex).parent("li");e.hasClass("ui-state-disabled")||this._select(e.data("ui-selectmenu-item"),t)},_select:function(t,e){var i=this.element[0].selectedIndex;this.element[0].selectedIndex=t.index,this.buttonItem.replaceWith(this.buttonItem=this._renderButtonItem(t)),this._setAria(t),this._trigger("select",e,{item:t}),t.index!==i&&this._trigger("change",e,{item:t}),this.close(e)},_setAria:function(t){var e=this.menuItems.eq(t.index).attr("id");this.button.attr({"aria-labelledby":e,"aria-activedescendant":e}),this.menu.attr("aria-activedescendant",e)},_setOption:function(t,e){if("icons"===t){var i=this.button.find("span.ui-icon");this._removeClass(i,null,this.options.icons.button)._addClass(i,null,e.button)}this._super(t,e),"appendTo"===t&&this.menuWrap.appendTo(this._appendTo()),"width"===t&&this._resizeButton()},_setOptionDisabled:function(t){this._super(t),this.menuInstance.option("disabled",t),this.button.attr("aria-disabled",t),this._toggleClass(this.button,null,"ui-state-disabled",t),this.element.prop("disabled",t),t?(this.button.attr("tabindex",-1),this.close()):this.button.attr("tabindex",0)},_appendTo:function(){var e=this.options.appendTo;return e&&(e=e.jquery||e.nodeType?t(e):this.document.find(e).eq(0)),e&&e[0]||(e=this.element.closest(".ui-front, dialog")),e.length||(e=this.document[0].body),e},_toggleAttr:function(){this.button.attr("aria-expanded",this.isOpen),this._removeClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"closed":"open"))._addClass(this.button,"ui-selectmenu-button-"+(this.isOpen?"open":"closed"))._toggleClass(this.menuWrap,"ui-selectmenu-open",null,this.isOpen),this.menu.attr("aria-hidden",!this.isOpen)},_resizeButton:function(){var t=this.options.width;return t===!1?(this.button.css("width",""),void 0):(null===t&&(t=this.element.show().outerWidth(),this.element.hide()),this.button.outerWidth(t),void 0)},_resizeMenu:function(){this.menu.outerWidth(Math.max(this.button.outerWidth(),this.menu.width("").outerWidth()+1))},_getCreateOptions:function(){var t=this._super();return t.disabled=this.element.prop("disabled"),t},_parseOptions:function(e){var i=this,s=[];e.each(function(e,n){s.push(i._parseOption(t(n),e))}),this.items=s},_parseOption:function(t,e){var i=t.parent("optgroup");return{element:t,index:e,value:t.val(),label:t.text(),optgroup:i.attr("label")||"",disabled:i.prop("disabled")||t.prop("disabled")}},_destroy:function(){this._unbindFormResetHandler(),this.menuWrap.remove(),this.button.remove(),this.element.show(),this.element.removeUniqueId(),this.labels.attr("for",this.ids.element)}}]),t.widget("ui.slider",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"slide",options:{animate:!1,classes:{"ui-slider":"ui-corner-all","ui-slider-handle":"ui-corner-all","ui-slider-range":"ui-corner-all ui-widget-header"},distance:0,max:100,min:0,orientation:"horizontal",range:!1,step:1,value:0,values:null,change:null,slide:null,start:null,stop:null},numPages:5,_create:function(){this._keySliding=!1,this._mouseSliding=!1,this._animateOff=!0,this._handleIndex=null,this._detectOrientation(),this._mouseInit(),this._calculateNewMax(),this._addClass("ui-slider ui-slider-"+this.orientation,"ui-widget ui-widget-content"),this._refresh(),this._animateOff=!1
},_refresh:function(){this._createRange(),this._createHandles(),this._setupEvents(),this._refreshValue()},_createHandles:function(){var e,i,s=this.options,n=this.element.find(".ui-slider-handle"),o="<span tabindex='0'></span>",a=[];for(i=s.values&&s.values.length||1,n.length>i&&(n.slice(i).remove(),n=n.slice(0,i)),e=n.length;i>e;e++)a.push(o);this.handles=n.add(t(a.join("")).appendTo(this.element)),this._addClass(this.handles,"ui-slider-handle","ui-state-default"),this.handle=this.handles.eq(0),this.handles.each(function(e){t(this).data("ui-slider-handle-index",e).attr("tabIndex",0)})},_createRange:function(){var e=this.options;e.range?(e.range===!0&&(e.values?e.values.length&&2!==e.values.length?e.values=[e.values[0],e.values[0]]:t.isArray(e.values)&&(e.values=e.values.slice(0)):e.values=[this._valueMin(),this._valueMin()]),this.range&&this.range.length?(this._removeClass(this.range,"ui-slider-range-min ui-slider-range-max"),this.range.css({left:"",bottom:""})):(this.range=t("<div>").appendTo(this.element),this._addClass(this.range,"ui-slider-range")),("min"===e.range||"max"===e.range)&&this._addClass(this.range,"ui-slider-range-"+e.range)):(this.range&&this.range.remove(),this.range=null)},_setupEvents:function(){this._off(this.handles),this._on(this.handles,this._handleEvents),this._hoverable(this.handles),this._focusable(this.handles)},_destroy:function(){this.handles.remove(),this.range&&this.range.remove(),this._mouseDestroy()},_mouseCapture:function(e){var i,s,n,o,a,r,h,l,c=this,u=this.options;return u.disabled?!1:(this.elementSize={width:this.element.outerWidth(),height:this.element.outerHeight()},this.elementOffset=this.element.offset(),i={x:e.pageX,y:e.pageY},s=this._normValueFromMouse(i),n=this._valueMax()-this._valueMin()+1,this.handles.each(function(e){var i=Math.abs(s-c.values(e));(n>i||n===i&&(e===c._lastChangedValue||c.values(e)===u.min))&&(n=i,o=t(this),a=e)}),r=this._start(e,a),r===!1?!1:(this._mouseSliding=!0,this._handleIndex=a,this._addClass(o,null,"ui-state-active"),o.trigger("focus"),h=o.offset(),l=!t(e.target).parents().addBack().is(".ui-slider-handle"),this._clickOffset=l?{left:0,top:0}:{left:e.pageX-h.left-o.width()/2,top:e.pageY-h.top-o.height()/2-(parseInt(o.css("borderTopWidth"),10)||0)-(parseInt(o.css("borderBottomWidth"),10)||0)+(parseInt(o.css("marginTop"),10)||0)},this.handles.hasClass("ui-state-hover")||this._slide(e,a,s),this._animateOff=!0,!0))},_mouseStart:function(){return!0},_mouseDrag:function(t){var e={x:t.pageX,y:t.pageY},i=this._normValueFromMouse(e);return this._slide(t,this._handleIndex,i),!1},_mouseStop:function(t){return this._removeClass(this.handles,null,"ui-state-active"),this._mouseSliding=!1,this._stop(t,this._handleIndex),this._change(t,this._handleIndex),this._handleIndex=null,this._clickOffset=null,this._animateOff=!1,!1},_detectOrientation:function(){this.orientation="vertical"===this.options.orientation?"vertical":"horizontal"},_normValueFromMouse:function(t){var e,i,s,n,o;return"horizontal"===this.orientation?(e=this.elementSize.width,i=t.x-this.elementOffset.left-(this._clickOffset?this._clickOffset.left:0)):(e=this.elementSize.height,i=t.y-this.elementOffset.top-(this._clickOffset?this._clickOffset.top:0)),s=i/e,s>1&&(s=1),0>s&&(s=0),"vertical"===this.orientation&&(s=1-s),n=this._valueMax()-this._valueMin(),o=this._valueMin()+s*n,this._trimAlignValue(o)},_uiHash:function(t,e,i){var s={handle:this.handles[t],handleIndex:t,value:void 0!==e?e:this.value()};return this._hasMultipleValues()&&(s.value=void 0!==e?e:this.values(t),s.values=i||this.values()),s},_hasMultipleValues:function(){return this.options.values&&this.options.values.length},_start:function(t,e){return this._trigger("start",t,this._uiHash(e))},_slide:function(t,e,i){var s,n,o=this.value(),a=this.values();this._hasMultipleValues()&&(n=this.values(e?0:1),o=this.values(e),2===this.options.values.length&&this.options.range===!0&&(i=0===e?Math.min(n,i):Math.max(n,i)),a[e]=i),i!==o&&(s=this._trigger("slide",t,this._uiHash(e,i,a)),s!==!1&&(this._hasMultipleValues()?this.values(e,i):this.value(i)))},_stop:function(t,e){this._trigger("stop",t,this._uiHash(e))},_change:function(t,e){this._keySliding||this._mouseSliding||(this._lastChangedValue=e,this._trigger("change",t,this._uiHash(e)))},value:function(t){return arguments.length?(this.options.value=this._trimAlignValue(t),this._refreshValue(),this._change(null,0),void 0):this._value()},values:function(e,i){var s,n,o;if(arguments.length>1)return this.options.values[e]=this._trimAlignValue(i),this._refreshValue(),this._change(null,e),void 0;if(!arguments.length)return this._values();if(!t.isArray(arguments[0]))return this._hasMultipleValues()?this._values(e):this.value();for(s=this.options.values,n=arguments[0],o=0;s.length>o;o+=1)s[o]=this._trimAlignValue(n[o]),this._change(null,o);this._refreshValue()},_setOption:function(e,i){var s,n=0;switch("range"===e&&this.options.range===!0&&("min"===i?(this.options.value=this._values(0),this.options.values=null):"max"===i&&(this.options.value=this._values(this.options.values.length-1),this.options.values=null)),t.isArray(this.options.values)&&(n=this.options.values.length),this._super(e,i),e){case"orientation":this._detectOrientation(),this._removeClass("ui-slider-horizontal ui-slider-vertical")._addClass("ui-slider-"+this.orientation),this._refreshValue(),this.options.range&&this._refreshRange(i),this.handles.css("horizontal"===i?"bottom":"left","");break;case"value":this._animateOff=!0,this._refreshValue(),this._change(null,0),this._animateOff=!1;break;case"values":for(this._animateOff=!0,this._refreshValue(),s=n-1;s>=0;s--)this._change(null,s);this._animateOff=!1;break;case"step":case"min":case"max":this._animateOff=!0,this._calculateNewMax(),this._refreshValue(),this._animateOff=!1;break;case"range":this._animateOff=!0,this._refresh(),this._animateOff=!1}},_setOptionDisabled:function(t){this._super(t),this._toggleClass(null,"ui-state-disabled",!!t)},_value:function(){var t=this.options.value;return t=this._trimAlignValue(t)},_values:function(t){var e,i,s;if(arguments.length)return e=this.options.values[t],e=this._trimAlignValue(e);if(this._hasMultipleValues()){for(i=this.options.values.slice(),s=0;i.length>s;s+=1)i[s]=this._trimAlignValue(i[s]);return i}return[]},_trimAlignValue:function(t){if(this._valueMin()>=t)return this._valueMin();if(t>=this._valueMax())return this._valueMax();var e=this.options.step>0?this.options.step:1,i=(t-this._valueMin())%e,s=t-i;return 2*Math.abs(i)>=e&&(s+=i>0?e:-e),parseFloat(s.toFixed(5))},_calculateNewMax:function(){var t=this.options.max,e=this._valueMin(),i=this.options.step,s=Math.round((t-e)/i)*i;t=s+e,t>this.options.max&&(t-=i),this.max=parseFloat(t.toFixed(this._precision()))},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_valueMin:function(){return this.options.min},_valueMax:function(){return this.max},_refreshRange:function(t){"vertical"===t&&this.range.css({width:"",left:""}),"horizontal"===t&&this.range.css({height:"",bottom:""})},_refreshValue:function(){var e,i,s,n,o,a=this.options.range,r=this.options,h=this,l=this._animateOff?!1:r.animate,c={};this._hasMultipleValues()?this.handles.each(function(s){i=100*((h.values(s)-h._valueMin())/(h._valueMax()-h._valueMin())),c["horizontal"===h.orientation?"left":"bottom"]=i+"%",t(this).stop(1,1)[l?"animate":"css"](c,r.animate),h.options.range===!0&&("horizontal"===h.orientation?(0===s&&h.range.stop(1,1)[l?"animate":"css"]({left:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({width:i-e+"%"},{queue:!1,duration:r.animate})):(0===s&&h.range.stop(1,1)[l?"animate":"css"]({bottom:i+"%"},r.animate),1===s&&h.range[l?"animate":"css"]({height:i-e+"%"},{queue:!1,duration:r.animate}))),e=i}):(s=this.value(),n=this._valueMin(),o=this._valueMax(),i=o!==n?100*((s-n)/(o-n)):0,c["horizontal"===this.orientation?"left":"bottom"]=i+"%",this.handle.stop(1,1)[l?"animate":"css"](c,r.animate),"min"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:i+"%"},r.animate),"max"===a&&"horizontal"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({width:100-i+"%"},r.animate),"min"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:i+"%"},r.animate),"max"===a&&"vertical"===this.orientation&&this.range.stop(1,1)[l?"animate":"css"]({height:100-i+"%"},r.animate))},_handleEvents:{keydown:function(e){var i,s,n,o,a=t(e.target).data("ui-slider-handle-index");switch(e.keyCode){case t.ui.keyCode.HOME:case t.ui.keyCode.END:case t.ui.keyCode.PAGE_UP:case t.ui.keyCode.PAGE_DOWN:case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(e.preventDefault(),!this._keySliding&&(this._keySliding=!0,this._addClass(t(e.target),null,"ui-state-active"),i=this._start(e,a),i===!1))return}switch(o=this.options.step,s=n=this._hasMultipleValues()?this.values(a):this.value(),e.keyCode){case t.ui.keyCode.HOME:n=this._valueMin();break;case t.ui.keyCode.END:n=this._valueMax();break;case t.ui.keyCode.PAGE_UP:n=this._trimAlignValue(s+(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.PAGE_DOWN:n=this._trimAlignValue(s-(this._valueMax()-this._valueMin())/this.numPages);break;case t.ui.keyCode.UP:case t.ui.keyCode.RIGHT:if(s===this._valueMax())return;n=this._trimAlignValue(s+o);break;case t.ui.keyCode.DOWN:case t.ui.keyCode.LEFT:if(s===this._valueMin())return;n=this._trimAlignValue(s-o)}this._slide(e,a,n)},keyup:function(e){var i=t(e.target).data("ui-slider-handle-index");this._keySliding&&(this._keySliding=!1,this._stop(e,i),this._change(e,i),this._removeClass(t(e.target),null,"ui-state-active"))}}}),t.widget("ui.sortable",t.ui.mouse,{version:"1.12.1",widgetEventPrefix:"sort",ready:!1,options:{appendTo:"parent",axis:!1,connectWith:!1,containment:!1,cursor:"auto",cursorAt:!1,dropOnEmpty:!0,forcePlaceholderSize:!1,forceHelperSize:!1,grid:!1,handle:!1,helper:"original",items:"> *",opacity:!1,placeholder:!1,revert:!1,scroll:!0,scrollSensitivity:20,scrollSpeed:20,scope:"default",tolerance:"intersect",zIndex:1e3,activate:null,beforeStop:null,change:null,deactivate:null,out:null,over:null,receive:null,remove:null,sort:null,start:null,stop:null,update:null},_isOverAxis:function(t,e,i){return t>=e&&e+i>t},_isFloating:function(t){return/left|right/.test(t.css("float"))||/inline|table-cell/.test(t.css("display"))},_create:function(){this.containerCache={},this._addClass("ui-sortable"),this.refresh(),this.offset=this.element.offset(),this._mouseInit(),this._setHandleClassName(),this.ready=!0},_setOption:function(t,e){this._super(t,e),"handle"===t&&this._setHandleClassName()},_setHandleClassName:function(){var e=this;this._removeClass(this.element.find(".ui-sortable-handle"),"ui-sortable-handle"),t.each(this.items,function(){e._addClass(this.instance.options.handle?this.item.find(this.instance.options.handle):this.item,"ui-sortable-handle")})},_destroy:function(){this._mouseDestroy();for(var t=this.items.length-1;t>=0;t--)this.items[t].item.removeData(this.widgetName+"-item");return this},_mouseCapture:function(e,i){var s=null,n=!1,o=this;return this.reverting?!1:this.options.disabled||"static"===this.options.type?!1:(this._refreshItems(e),t(e.target).parents().each(function(){return t.data(this,o.widgetName+"-item")===o?(s=t(this),!1):void 0}),t.data(e.target,o.widgetName+"-item")===o&&(s=t(e.target)),s?!this.options.handle||i||(t(this.options.handle,s).find("*").addBack().each(function(){this===e.target&&(n=!0)}),n)?(this.currentItem=s,this._removeCurrentsFromItems(),!0):!1:!1)},_mouseStart:function(e,i,s){var n,o,a=this.options;if(this.currentContainer=this,this.refreshPositions(),this.helper=this._createHelper(e),this._cacheHelperProportions(),this._cacheMargins(),this.scrollParent=this.helper.scrollParent(),this.offset=this.currentItem.offset(),this.offset={top:this.offset.top-this.margins.top,left:this.offset.left-this.margins.left},t.extend(this.offset,{click:{left:e.pageX-this.offset.left,top:e.pageY-this.offset.top},parent:this._getParentOffset(),relative:this._getRelativeOffset()}),this.helper.css("position","absolute"),this.cssPosition=this.helper.css("position"),this.originalPosition=this._generatePosition(e),this.originalPageX=e.pageX,this.originalPageY=e.pageY,a.cursorAt&&this._adjustOffsetFromHelper(a.cursorAt),this.domPosition={prev:this.currentItem.prev()[0],parent:this.currentItem.parent()[0]},this.helper[0]!==this.currentItem[0]&&this.currentItem.hide(),this._createPlaceholder(),a.containment&&this._setContainment(),a.cursor&&"auto"!==a.cursor&&(o=this.document.find("body"),this.storedCursor=o.css("cursor"),o.css("cursor",a.cursor),this.storedStylesheet=t("<style>*{ cursor: "+a.cursor+" !important; }</style>").appendTo(o)),a.opacity&&(this.helper.css("opacity")&&(this._storedOpacity=this.helper.css("opacity")),this.helper.css("opacity",a.opacity)),a.zIndex&&(this.helper.css("zIndex")&&(this._storedZIndex=this.helper.css("zIndex")),this.helper.css("zIndex",a.zIndex)),this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName&&(this.overflowOffset=this.scrollParent.offset()),this._trigger("start",e,this._uiHash()),this._preserveHelperProportions||this._cacheHelperProportions(),!s)for(n=this.containers.length-1;n>=0;n--)this.containers[n]._trigger("activate",e,this._uiHash(this));return t.ui.ddmanager&&(t.ui.ddmanager.current=this),t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e),this.dragging=!0,this._addClass(this.helper,"ui-sortable-helper"),this._mouseDrag(e),!0},_mouseDrag:function(e){var i,s,n,o,a=this.options,r=!1;for(this.position=this._generatePosition(e),this.positionAbs=this._convertPositionTo("absolute"),this.lastPositionAbs||(this.lastPositionAbs=this.positionAbs),this.options.scroll&&(this.scrollParent[0]!==this.document[0]&&"HTML"!==this.scrollParent[0].tagName?(this.overflowOffset.top+this.scrollParent[0].offsetHeight-e.pageY<a.scrollSensitivity?this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop+a.scrollSpeed:e.pageY-this.overflowOffset.top<a.scrollSensitivity&&(this.scrollParent[0].scrollTop=r=this.scrollParent[0].scrollTop-a.scrollSpeed),this.overflowOffset.left+this.scrollParent[0].offsetWidth-e.pageX<a.scrollSensitivity?this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft+a.scrollSpeed:e.pageX-this.overflowOffset.left<a.scrollSensitivity&&(this.scrollParent[0].scrollLeft=r=this.scrollParent[0].scrollLeft-a.scrollSpeed)):(e.pageY-this.document.scrollTop()<a.scrollSensitivity?r=this.document.scrollTop(this.document.scrollTop()-a.scrollSpeed):this.window.height()-(e.pageY-this.document.scrollTop())<a.scrollSensitivity&&(r=this.document.scrollTop(this.document.scrollTop()+a.scrollSpeed)),e.pageX-this.document.scrollLeft()<a.scrollSensitivity?r=this.document.scrollLeft(this.document.scrollLeft()-a.scrollSpeed):this.window.width()-(e.pageX-this.document.scrollLeft())<a.scrollSensitivity&&(r=this.document.scrollLeft(this.document.scrollLeft()+a.scrollSpeed))),r!==!1&&t.ui.ddmanager&&!a.dropBehaviour&&t.ui.ddmanager.prepareOffsets(this,e)),this.positionAbs=this._convertPositionTo("absolute"),this.options.axis&&"y"===this.options.axis||(this.helper[0].style.left=this.position.left+"px"),this.options.axis&&"x"===this.options.axis||(this.helper[0].style.top=this.position.top+"px"),i=this.items.length-1;i>=0;i--)if(s=this.items[i],n=s.item[0],o=this._intersectsWithPointer(s),o&&s.instance===this.currentContainer&&n!==this.currentItem[0]&&this.placeholder[1===o?"next":"prev"]()[0]!==n&&!t.contains(this.placeholder[0],n)&&("semi-dynamic"===this.options.type?!t.contains(this.element[0],n):!0)){if(this.direction=1===o?"down":"up","pointer"!==this.options.tolerance&&!this._intersectsWithSides(s))break;this._rearrange(e,s),this._trigger("change",e,this._uiHash());break}return this._contactContainers(e),t.ui.ddmanager&&t.ui.ddmanager.drag(this,e),this._trigger("sort",e,this._uiHash()),this.lastPositionAbs=this.positionAbs,!1},_mouseStop:function(e,i){if(e){if(t.ui.ddmanager&&!this.options.dropBehaviour&&t.ui.ddmanager.drop(this,e),this.options.revert){var s=this,n=this.placeholder.offset(),o=this.options.axis,a={};o&&"x"!==o||(a.left=n.left-this.offset.parent.left-this.margins.left+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollLeft)),o&&"y"!==o||(a.top=n.top-this.offset.parent.top-this.margins.top+(this.offsetParent[0]===this.document[0].body?0:this.offsetParent[0].scrollTop)),this.reverting=!0,t(this.helper).animate(a,parseInt(this.options.revert,10)||500,function(){s._clear(e)})}else this._clear(e,i);return!1}},cancel:function(){if(this.dragging){this._mouseUp(new t.Event("mouseup",{target:null})),"original"===this.options.helper?(this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")):this.currentItem.show();for(var e=this.containers.length-1;e>=0;e--)this.containers[e]._trigger("deactivate",null,this._uiHash(this)),this.containers[e].containerCache.over&&(this.containers[e]._trigger("out",null,this._uiHash(this)),this.containers[e].containerCache.over=0)}return this.placeholder&&(this.placeholder[0].parentNode&&this.placeholder[0].parentNode.removeChild(this.placeholder[0]),"original"!==this.options.helper&&this.helper&&this.helper[0].parentNode&&this.helper.remove(),t.extend(this,{helper:null,dragging:!1,reverting:!1,_noFinalSort:null}),this.domPosition.prev?t(this.domPosition.prev).after(this.currentItem):t(this.domPosition.parent).prepend(this.currentItem)),this},serialize:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},t(i).each(function(){var i=(t(e.item||this).attr(e.attribute||"id")||"").match(e.expression||/(.+)[\-=_](.+)/);i&&s.push((e.key||i[1]+"[]")+"="+(e.key&&e.expression?i[1]:i[2]))}),!s.length&&e.key&&s.push(e.key+"="),s.join("&")},toArray:function(e){var i=this._getItemsAsjQuery(e&&e.connected),s=[];return e=e||{},i.each(function(){s.push(t(e.item||this).attr(e.attribute||"id")||"")}),s},_intersectsWith:function(t){var e=this.positionAbs.left,i=e+this.helperProportions.width,s=this.positionAbs.top,n=s+this.helperProportions.height,o=t.left,a=o+t.width,r=t.top,h=r+t.height,l=this.offset.click.top,c=this.offset.click.left,u="x"===this.options.axis||s+l>r&&h>s+l,d="y"===this.options.axis||e+c>o&&a>e+c,p=u&&d;return"pointer"===this.options.tolerance||this.options.forcePointerForContainers||"pointer"!==this.options.tolerance&&this.helperProportions[this.floating?"width":"height"]>t[this.floating?"width":"height"]?p:e+this.helperProportions.width/2>o&&a>i-this.helperProportions.width/2&&s+this.helperProportions.height/2>r&&h>n-this.helperProportions.height/2},_intersectsWithPointer:function(t){var e,i,s="x"===this.options.axis||this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top,t.height),n="y"===this.options.axis||this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left,t.width),o=s&&n;return o?(e=this._getDragVerticalDirection(),i=this._getDragHorizontalDirection(),this.floating?"right"===i||"down"===e?2:1:e&&("down"===e?2:1)):!1},_intersectsWithSides:function(t){var e=this._isOverAxis(this.positionAbs.top+this.offset.click.top,t.top+t.height/2,t.height),i=this._isOverAxis(this.positionAbs.left+this.offset.click.left,t.left+t.width/2,t.width),s=this._getDragVerticalDirection(),n=this._getDragHorizontalDirection();return this.floating&&n?"right"===n&&i||"left"===n&&!i:s&&("down"===s&&e||"up"===s&&!e)},_getDragVerticalDirection:function(){var t=this.positionAbs.top-this.lastPositionAbs.top;return 0!==t&&(t>0?"down":"up")},_getDragHorizontalDirection:function(){var t=this.positionAbs.left-this.lastPositionAbs.left;return 0!==t&&(t>0?"right":"left")},refresh:function(t){return this._refreshItems(t),this._setHandleClassName(),this.refreshPositions(),this},_connectWith:function(){var t=this.options;return t.connectWith.constructor===String?[t.connectWith]:t.connectWith},_getItemsAsjQuery:function(e){function i(){r.push(this)}var s,n,o,a,r=[],h=[],l=this._connectWith();if(l&&e)for(s=l.length-1;s>=0;s--)for(o=t(l[s],this.document[0]),n=o.length-1;n>=0;n--)a=t.data(o[n],this.widgetFullName),a&&a!==this&&!a.options.disabled&&h.push([t.isFunction(a.options.items)?a.options.items.call(a.element):t(a.options.items,a.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),a]);for(h.push([t.isFunction(this.options.items)?this.options.items.call(this.element,null,{options:this.options,item:this.currentItem}):t(this.options.items,this.element).not(".ui-sortable-helper").not(".ui-sortable-placeholder"),this]),s=h.length-1;s>=0;s--)h[s][0].each(i);return t(r)},_removeCurrentsFromItems:function(){var e=this.currentItem.find(":data("+this.widgetName+"-item)");this.items=t.grep(this.items,function(t){for(var i=0;e.length>i;i++)if(e[i]===t.item[0])return!1;return!0})},_refreshItems:function(e){this.items=[],this.containers=[this];var i,s,n,o,a,r,h,l,c=this.items,u=[[t.isFunction(this.options.items)?this.options.items.call(this.element[0],e,{item:this.currentItem}):t(this.options.items,this.element),this]],d=this._connectWith();if(d&&this.ready)for(i=d.length-1;i>=0;i--)for(n=t(d[i],this.document[0]),s=n.length-1;s>=0;s--)o=t.data(n[s],this.widgetFullName),o&&o!==this&&!o.options.disabled&&(u.push([t.isFunction(o.options.items)?o.options.items.call(o.element[0],e,{item:this.currentItem}):t(o.options.items,o.element),o]),this.containers.push(o));for(i=u.length-1;i>=0;i--)for(a=u[i][1],r=u[i][0],s=0,l=r.length;l>s;s++)h=t(r[s]),h.data(this.widgetName+"-item",a),c.push({item:h,instance:a,width:0,height:0,left:0,top:0})},refreshPositions:function(e){this.floating=this.items.length?"x"===this.options.axis||this._isFloating(this.items[0].item):!1,this.offsetParent&&this.helper&&(this.offset.parent=this._getParentOffset());var i,s,n,o;for(i=this.items.length-1;i>=0;i--)s=this.items[i],s.instance!==this.currentContainer&&this.currentContainer&&s.item[0]!==this.currentItem[0]||(n=this.options.toleranceElement?t(this.options.toleranceElement,s.item):s.item,e||(s.width=n.outerWidth(),s.height=n.outerHeight()),o=n.offset(),s.left=o.left,s.top=o.top);if(this.options.custom&&this.options.custom.refreshContainers)this.options.custom.refreshContainers.call(this);else for(i=this.containers.length-1;i>=0;i--)o=this.containers[i].element.offset(),this.containers[i].containerCache.left=o.left,this.containers[i].containerCache.top=o.top,this.containers[i].containerCache.width=this.containers[i].element.outerWidth(),this.containers[i].containerCache.height=this.containers[i].element.outerHeight();return this},_createPlaceholder:function(e){e=e||this;var i,s=e.options;s.placeholder&&s.placeholder.constructor!==String||(i=s.placeholder,s.placeholder={element:function(){var s=e.currentItem[0].nodeName.toLowerCase(),n=t("<"+s+">",e.document[0]);return e._addClass(n,"ui-sortable-placeholder",i||e.currentItem[0].className)._removeClass(n,"ui-sortable-helper"),"tbody"===s?e._createTrPlaceholder(e.currentItem.find("tr").eq(0),t("<tr>",e.document[0]).appendTo(n)):"tr"===s?e._createTrPlaceholder(e.currentItem,n):"img"===s&&n.attr("src",e.currentItem.attr("src")),i||n.css("visibility","hidden"),n},update:function(t,n){(!i||s.forcePlaceholderSize)&&(n.height()||n.height(e.currentItem.innerHeight()-parseInt(e.currentItem.css("paddingTop")||0,10)-parseInt(e.currentItem.css("paddingBottom")||0,10)),n.width()||n.width(e.currentItem.innerWidth()-parseInt(e.currentItem.css("paddingLeft")||0,10)-parseInt(e.currentItem.css("paddingRight")||0,10)))}}),e.placeholder=t(s.placeholder.element.call(e.element,e.currentItem)),e.currentItem.after(e.placeholder),s.placeholder.update(e,e.placeholder)},_createTrPlaceholder:function(e,i){var s=this;e.children().each(function(){t("<td>&#160;</td>",s.document[0]).attr("colspan",t(this).attr("colspan")||1).appendTo(i)})},_contactContainers:function(e){var i,s,n,o,a,r,h,l,c,u,d=null,p=null;for(i=this.containers.length-1;i>=0;i--)if(!t.contains(this.currentItem[0],this.containers[i].element[0]))if(this._intersectsWith(this.containers[i].containerCache)){if(d&&t.contains(this.containers[i].element[0],d.element[0]))continue;d=this.containers[i],p=i}else this.containers[i].containerCache.over&&(this.containers[i]._trigger("out",e,this._uiHash(this)),this.containers[i].containerCache.over=0);if(d)if(1===this.containers.length)this.containers[p].containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1);else{for(n=1e4,o=null,c=d.floating||this._isFloating(this.currentItem),a=c?"left":"top",r=c?"width":"height",u=c?"pageX":"pageY",s=this.items.length-1;s>=0;s--)t.contains(this.containers[p].element[0],this.items[s].item[0])&&this.items[s].item[0]!==this.currentItem[0]&&(h=this.items[s].item.offset()[a],l=!1,e[u]-h>this.items[s][r]/2&&(l=!0),n>Math.abs(e[u]-h)&&(n=Math.abs(e[u]-h),o=this.items[s],this.direction=l?"up":"down"));if(!o&&!this.options.dropOnEmpty)return;if(this.currentContainer===this.containers[p])return this.currentContainer.containerCache.over||(this.containers[p]._trigger("over",e,this._uiHash()),this.currentContainer.containerCache.over=1),void 0;o?this._rearrange(e,o,null,!0):this._rearrange(e,null,this.containers[p].element,!0),this._trigger("change",e,this._uiHash()),this.containers[p]._trigger("change",e,this._uiHash(this)),this.currentContainer=this.containers[p],this.options.placeholder.update(this.currentContainer,this.placeholder),this.containers[p]._trigger("over",e,this._uiHash(this)),this.containers[p].containerCache.over=1}},_createHelper:function(e){var i=this.options,s=t.isFunction(i.helper)?t(i.helper.apply(this.element[0],[e,this.currentItem])):"clone"===i.helper?this.currentItem.clone():this.currentItem;return s.parents("body").length||t("parent"!==i.appendTo?i.appendTo:this.currentItem[0].parentNode)[0].appendChild(s[0]),s[0]===this.currentItem[0]&&(this._storedCSS={width:this.currentItem[0].style.width,height:this.currentItem[0].style.height,position:this.currentItem.css("position"),top:this.currentItem.css("top"),left:this.currentItem.css("left")}),(!s[0].style.width||i.forceHelperSize)&&s.width(this.currentItem.width()),(!s[0].style.height||i.forceHelperSize)&&s.height(this.currentItem.height()),s},_adjustOffsetFromHelper:function(e){"string"==typeof e&&(e=e.split(" ")),t.isArray(e)&&(e={left:+e[0],top:+e[1]||0}),"left"in e&&(this.offset.click.left=e.left+this.margins.left),"right"in e&&(this.offset.click.left=this.helperProportions.width-e.right+this.margins.left),"top"in e&&(this.offset.click.top=e.top+this.margins.top),"bottom"in e&&(this.offset.click.top=this.helperProportions.height-e.bottom+this.margins.top)},_getParentOffset:function(){this.offsetParent=this.helper.offsetParent();var e=this.offsetParent.offset();return"absolute"===this.cssPosition&&this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])&&(e.left+=this.scrollParent.scrollLeft(),e.top+=this.scrollParent.scrollTop()),(this.offsetParent[0]===this.document[0].body||this.offsetParent[0].tagName&&"html"===this.offsetParent[0].tagName.toLowerCase()&&t.ui.ie)&&(e={top:0,left:0}),{top:e.top+(parseInt(this.offsetParent.css("borderTopWidth"),10)||0),left:e.left+(parseInt(this.offsetParent.css("borderLeftWidth"),10)||0)}},_getRelativeOffset:function(){if("relative"===this.cssPosition){var t=this.currentItem.position();return{top:t.top-(parseInt(this.helper.css("top"),10)||0)+this.scrollParent.scrollTop(),left:t.left-(parseInt(this.helper.css("left"),10)||0)+this.scrollParent.scrollLeft()}}return{top:0,left:0}},_cacheMargins:function(){this.margins={left:parseInt(this.currentItem.css("marginLeft"),10)||0,top:parseInt(this.currentItem.css("marginTop"),10)||0}},_cacheHelperProportions:function(){this.helperProportions={width:this.helper.outerWidth(),height:this.helper.outerHeight()}},_setContainment:function(){var e,i,s,n=this.options;"parent"===n.containment&&(n.containment=this.helper[0].parentNode),("document"===n.containment||"window"===n.containment)&&(this.containment=[0-this.offset.relative.left-this.offset.parent.left,0-this.offset.relative.top-this.offset.parent.top,"document"===n.containment?this.document.width():this.window.width()-this.helperProportions.width-this.margins.left,("document"===n.containment?this.document.height()||document.body.parentNode.scrollHeight:this.window.height()||this.document[0].body.parentNode.scrollHeight)-this.helperProportions.height-this.margins.top]),/^(document|window|parent)$/.test(n.containment)||(e=t(n.containment)[0],i=t(n.containment).offset(),s="hidden"!==t(e).css("overflow"),this.containment=[i.left+(parseInt(t(e).css("borderLeftWidth"),10)||0)+(parseInt(t(e).css("paddingLeft"),10)||0)-this.margins.left,i.top+(parseInt(t(e).css("borderTopWidth"),10)||0)+(parseInt(t(e).css("paddingTop"),10)||0)-this.margins.top,i.left+(s?Math.max(e.scrollWidth,e.offsetWidth):e.offsetWidth)-(parseInt(t(e).css("borderLeftWidth"),10)||0)-(parseInt(t(e).css("paddingRight"),10)||0)-this.helperProportions.width-this.margins.left,i.top+(s?Math.max(e.scrollHeight,e.offsetHeight):e.offsetHeight)-(parseInt(t(e).css("borderTopWidth"),10)||0)-(parseInt(t(e).css("paddingBottom"),10)||0)-this.helperProportions.height-this.margins.top])},_convertPositionTo:function(e,i){i||(i=this.position);var s="absolute"===e?1:-1,n="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,o=/(html|body)/i.test(n[0].tagName);return{top:i.top+this.offset.relative.top*s+this.offset.parent.top*s-("fixed"===this.cssPosition?-this.scrollParent.scrollTop():o?0:n.scrollTop())*s,left:i.left+this.offset.relative.left*s+this.offset.parent.left*s-("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():o?0:n.scrollLeft())*s}},_generatePosition:function(e){var i,s,n=this.options,o=e.pageX,a=e.pageY,r="absolute"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&t.contains(this.scrollParent[0],this.offsetParent[0])?this.scrollParent:this.offsetParent,h=/(html|body)/i.test(r[0].tagName);return"relative"!==this.cssPosition||this.scrollParent[0]!==this.document[0]&&this.scrollParent[0]!==this.offsetParent[0]||(this.offset.relative=this._getRelativeOffset()),this.originalPosition&&(this.containment&&(e.pageX-this.offset.click.left<this.containment[0]&&(o=this.containment[0]+this.offset.click.left),e.pageY-this.offset.click.top<this.containment[1]&&(a=this.containment[1]+this.offset.click.top),e.pageX-this.offset.click.left>this.containment[2]&&(o=this.containment[2]+this.offset.click.left),e.pageY-this.offset.click.top>this.containment[3]&&(a=this.containment[3]+this.offset.click.top)),n.grid&&(i=this.originalPageY+Math.round((a-this.originalPageY)/n.grid[1])*n.grid[1],a=this.containment?i-this.offset.click.top>=this.containment[1]&&i-this.offset.click.top<=this.containment[3]?i:i-this.offset.click.top>=this.containment[1]?i-n.grid[1]:i+n.grid[1]:i,s=this.originalPageX+Math.round((o-this.originalPageX)/n.grid[0])*n.grid[0],o=this.containment?s-this.offset.click.left>=this.containment[0]&&s-this.offset.click.left<=this.containment[2]?s:s-this.offset.click.left>=this.containment[0]?s-n.grid[0]:s+n.grid[0]:s)),{top:a-this.offset.click.top-this.offset.relative.top-this.offset.parent.top+("fixed"===this.cssPosition?-this.scrollParent.scrollTop():h?0:r.scrollTop()),left:o-this.offset.click.left-this.offset.relative.left-this.offset.parent.left+("fixed"===this.cssPosition?-this.scrollParent.scrollLeft():h?0:r.scrollLeft())}},_rearrange:function(t,e,i,s){i?i[0].appendChild(this.placeholder[0]):e.item[0].parentNode.insertBefore(this.placeholder[0],"down"===this.direction?e.item[0]:e.item[0].nextSibling),this.counter=this.counter?++this.counter:1;var n=this.counter;
this._delay(function(){n===this.counter&&this.refreshPositions(!s)})},_clear:function(t,e){function i(t,e,i){return function(s){i._trigger(t,s,e._uiHash(e))}}this.reverting=!1;var s,n=[];if(!this._noFinalSort&&this.currentItem.parent().length&&this.placeholder.before(this.currentItem),this._noFinalSort=null,this.helper[0]===this.currentItem[0]){for(s in this._storedCSS)("auto"===this._storedCSS[s]||"static"===this._storedCSS[s])&&(this._storedCSS[s]="");this.currentItem.css(this._storedCSS),this._removeClass(this.currentItem,"ui-sortable-helper")}else this.currentItem.show();for(this.fromOutside&&!e&&n.push(function(t){this._trigger("receive",t,this._uiHash(this.fromOutside))}),!this.fromOutside&&this.domPosition.prev===this.currentItem.prev().not(".ui-sortable-helper")[0]&&this.domPosition.parent===this.currentItem.parent()[0]||e||n.push(function(t){this._trigger("update",t,this._uiHash())}),this!==this.currentContainer&&(e||(n.push(function(t){this._trigger("remove",t,this._uiHash())}),n.push(function(t){return function(e){t._trigger("receive",e,this._uiHash(this))}}.call(this,this.currentContainer)),n.push(function(t){return function(e){t._trigger("update",e,this._uiHash(this))}}.call(this,this.currentContainer)))),s=this.containers.length-1;s>=0;s--)e||n.push(i("deactivate",this,this.containers[s])),this.containers[s].containerCache.over&&(n.push(i("out",this,this.containers[s])),this.containers[s].containerCache.over=0);if(this.storedCursor&&(this.document.find("body").css("cursor",this.storedCursor),this.storedStylesheet.remove()),this._storedOpacity&&this.helper.css("opacity",this._storedOpacity),this._storedZIndex&&this.helper.css("zIndex","auto"===this._storedZIndex?"":this._storedZIndex),this.dragging=!1,e||this._trigger("beforeStop",t,this._uiHash()),this.placeholder[0].parentNode.removeChild(this.placeholder[0]),this.cancelHelperRemoval||(this.helper[0]!==this.currentItem[0]&&this.helper.remove(),this.helper=null),!e){for(s=0;n.length>s;s++)n[s].call(this,t);this._trigger("stop",t,this._uiHash())}return this.fromOutside=!1,!this.cancelHelperRemoval},_trigger:function(){t.Widget.prototype._trigger.apply(this,arguments)===!1&&this.cancel()},_uiHash:function(e){var i=e||this;return{helper:i.helper,placeholder:i.placeholder||t([]),position:i.position,originalPosition:i.originalPosition,offset:i.positionAbs,item:i.currentItem,sender:e?e.element:null}}}),t.widget("ui.spinner",{version:"1.12.1",defaultElement:"<input>",widgetEventPrefix:"spin",options:{classes:{"ui-spinner":"ui-corner-all","ui-spinner-down":"ui-corner-br","ui-spinner-up":"ui-corner-tr"},culture:null,icons:{down:"ui-icon-triangle-1-s",up:"ui-icon-triangle-1-n"},incremental:!0,max:null,min:null,numberFormat:null,page:10,step:1,change:null,spin:null,start:null,stop:null},_create:function(){this._setOption("max",this.options.max),this._setOption("min",this.options.min),this._setOption("step",this.options.step),""!==this.value()&&this._value(this.element.val(),!0),this._draw(),this._on(this._events),this._refresh(),this._on(this.window,{beforeunload:function(){this.element.removeAttr("autocomplete")}})},_getCreateOptions:function(){var e=this._super(),i=this.element;return t.each(["min","max","step"],function(t,s){var n=i.attr(s);null!=n&&n.length&&(e[s]=n)}),e},_events:{keydown:function(t){this._start(t)&&this._keydown(t)&&t.preventDefault()},keyup:"_stop",focus:function(){this.previous=this.element.val()},blur:function(t){return this.cancelBlur?(delete this.cancelBlur,void 0):(this._stop(),this._refresh(),this.previous!==this.element.val()&&this._trigger("change",t),void 0)},mousewheel:function(t,e){if(e){if(!this.spinning&&!this._start(t))return!1;this._spin((e>0?1:-1)*this.options.step,t),clearTimeout(this.mousewheelTimer),this.mousewheelTimer=this._delay(function(){this.spinning&&this._stop(t)},100),t.preventDefault()}},"mousedown .ui-spinner-button":function(e){function i(){var e=this.element[0]===t.ui.safeActiveElement(this.document[0]);e||(this.element.trigger("focus"),this.previous=s,this._delay(function(){this.previous=s}))}var s;s=this.element[0]===t.ui.safeActiveElement(this.document[0])?this.previous:this.element.val(),e.preventDefault(),i.call(this),this.cancelBlur=!0,this._delay(function(){delete this.cancelBlur,i.call(this)}),this._start(e)!==!1&&this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e)},"mouseup .ui-spinner-button":"_stop","mouseenter .ui-spinner-button":function(e){return t(e.currentTarget).hasClass("ui-state-active")?this._start(e)===!1?!1:(this._repeat(null,t(e.currentTarget).hasClass("ui-spinner-up")?1:-1,e),void 0):void 0},"mouseleave .ui-spinner-button":"_stop"},_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap("<span>").parent().append("<a></a><a></a>")},_draw:function(){this._enhance(),this._addClass(this.uiSpinner,"ui-spinner","ui-widget ui-widget-content"),this._addClass("ui-spinner-input"),this.element.attr("role","spinbutton"),this.buttons=this.uiSpinner.children("a").attr("tabIndex",-1).attr("aria-hidden",!0).button({classes:{"ui-button":""}}),this._removeClass(this.buttons,"ui-corner-all"),this._addClass(this.buttons.first(),"ui-spinner-button ui-spinner-up"),this._addClass(this.buttons.last(),"ui-spinner-button ui-spinner-down"),this.buttons.first().button({icon:this.options.icons.up,showLabel:!1}),this.buttons.last().button({icon:this.options.icons.down,showLabel:!1}),this.buttons.height()>Math.ceil(.5*this.uiSpinner.height())&&this.uiSpinner.height()>0&&this.uiSpinner.height(this.uiSpinner.height())},_keydown:function(e){var i=this.options,s=t.ui.keyCode;switch(e.keyCode){case s.UP:return this._repeat(null,1,e),!0;case s.DOWN:return this._repeat(null,-1,e),!0;case s.PAGE_UP:return this._repeat(null,i.page,e),!0;case s.PAGE_DOWN:return this._repeat(null,-i.page,e),!0}return!1},_start:function(t){return this.spinning||this._trigger("start",t)!==!1?(this.counter||(this.counter=1),this.spinning=!0,!0):!1},_repeat:function(t,e,i){t=t||500,clearTimeout(this.timer),this.timer=this._delay(function(){this._repeat(40,e,i)},t),this._spin(e*this.options.step,i)},_spin:function(t,e){var i=this.value()||0;this.counter||(this.counter=1),i=this._adjustValue(i+t*this._increment(this.counter)),this.spinning&&this._trigger("spin",e,{value:i})===!1||(this._value(i),this.counter++)},_increment:function(e){var i=this.options.incremental;return i?t.isFunction(i)?i(e):Math.floor(e*e*e/5e4-e*e/500+17*e/200+1):1},_precision:function(){var t=this._precisionOf(this.options.step);return null!==this.options.min&&(t=Math.max(t,this._precisionOf(this.options.min))),t},_precisionOf:function(t){var e=""+t,i=e.indexOf(".");return-1===i?0:e.length-i-1},_adjustValue:function(t){var e,i,s=this.options;return e=null!==s.min?s.min:0,i=t-e,i=Math.round(i/s.step)*s.step,t=e+i,t=parseFloat(t.toFixed(this._precision())),null!==s.max&&t>s.max?s.max:null!==s.min&&s.min>t?s.min:t},_stop:function(t){this.spinning&&(clearTimeout(this.timer),clearTimeout(this.mousewheelTimer),this.counter=0,this.spinning=!1,this._trigger("stop",t))},_setOption:function(t,e){var i,s,n;return"culture"===t||"numberFormat"===t?(i=this._parse(this.element.val()),this.options[t]=e,this.element.val(this._format(i)),void 0):(("max"===t||"min"===t||"step"===t)&&"string"==typeof e&&(e=this._parse(e)),"icons"===t&&(s=this.buttons.first().find(".ui-icon"),this._removeClass(s,null,this.options.icons.up),this._addClass(s,null,e.up),n=this.buttons.last().find(".ui-icon"),this._removeClass(n,null,this.options.icons.down),this._addClass(n,null,e.down)),this._super(t,e),void 0)},_setOptionDisabled:function(t){this._super(t),this._toggleClass(this.uiSpinner,null,"ui-state-disabled",!!t),this.element.prop("disabled",!!t),this.buttons.button(t?"disable":"enable")},_setOptions:r(function(t){this._super(t)}),_parse:function(t){return"string"==typeof t&&""!==t&&(t=window.Globalize&&this.options.numberFormat?Globalize.parseFloat(t,10,this.options.culture):+t),""===t||isNaN(t)?null:t},_format:function(t){return""===t?"":window.Globalize&&this.options.numberFormat?Globalize.format(t,this.options.numberFormat,this.options.culture):t},_refresh:function(){this.element.attr({"aria-valuemin":this.options.min,"aria-valuemax":this.options.max,"aria-valuenow":this._parse(this.element.val())})},isValid:function(){var t=this.value();return null===t?!1:t===this._adjustValue(t)},_value:function(t,e){var i;""!==t&&(i=this._parse(t),null!==i&&(e||(i=this._adjustValue(i)),t=this._format(i))),this.element.val(t),this._refresh()},_destroy:function(){this.element.prop("disabled",!1).removeAttr("autocomplete role aria-valuemin aria-valuemax aria-valuenow"),this.uiSpinner.replaceWith(this.element)},stepUp:r(function(t){this._stepUp(t)}),_stepUp:function(t){this._start()&&(this._spin((t||1)*this.options.step),this._stop())},stepDown:r(function(t){this._stepDown(t)}),_stepDown:function(t){this._start()&&(this._spin((t||1)*-this.options.step),this._stop())},pageUp:r(function(t){this._stepUp((t||1)*this.options.page)}),pageDown:r(function(t){this._stepDown((t||1)*this.options.page)}),value:function(t){return arguments.length?(r(this._value).call(this,t),void 0):this._parse(this.element.val())},widget:function(){return this.uiSpinner}}),t.uiBackCompat!==!1&&t.widget("ui.spinner",t.ui.spinner,{_enhance:function(){this.uiSpinner=this.element.attr("autocomplete","off").wrap(this._uiSpinnerHtml()).parent().append(this._buttonHtml())},_uiSpinnerHtml:function(){return"<span>"},_buttonHtml:function(){return"<a></a><a></a>"}}),t.ui.spinner,t.widget("ui.tabs",{version:"1.12.1",delay:300,options:{active:null,classes:{"ui-tabs":"ui-corner-all","ui-tabs-nav":"ui-corner-all","ui-tabs-panel":"ui-corner-bottom","ui-tabs-tab":"ui-corner-top"},collapsible:!1,event:"click",heightStyle:"content",hide:null,show:null,activate:null,beforeActivate:null,beforeLoad:null,load:null},_isLocal:function(){var t=/#.*$/;return function(e){var i,s;i=e.href.replace(t,""),s=location.href.replace(t,"");try{i=decodeURIComponent(i)}catch(n){}try{s=decodeURIComponent(s)}catch(n){}return e.hash.length>1&&i===s}}(),_create:function(){var e=this,i=this.options;this.running=!1,this._addClass("ui-tabs","ui-widget ui-widget-content"),this._toggleClass("ui-tabs-collapsible",null,i.collapsible),this._processTabs(),i.active=this._initialActive(),t.isArray(i.disabled)&&(i.disabled=t.unique(i.disabled.concat(t.map(this.tabs.filter(".ui-state-disabled"),function(t){return e.tabs.index(t)}))).sort()),this.active=this.options.active!==!1&&this.anchors.length?this._findActive(i.active):t(),this._refresh(),this.active.length&&this.load(i.active)},_initialActive:function(){var e=this.options.active,i=this.options.collapsible,s=location.hash.substring(1);return null===e&&(s&&this.tabs.each(function(i,n){return t(n).attr("aria-controls")===s?(e=i,!1):void 0}),null===e&&(e=this.tabs.index(this.tabs.filter(".ui-tabs-active"))),(null===e||-1===e)&&(e=this.tabs.length?0:!1)),e!==!1&&(e=this.tabs.index(this.tabs.eq(e)),-1===e&&(e=i?!1:0)),!i&&e===!1&&this.anchors.length&&(e=0),e},_getCreateEventData:function(){return{tab:this.active,panel:this.active.length?this._getPanelForTab(this.active):t()}},_tabKeydown:function(e){var i=t(t.ui.safeActiveElement(this.document[0])).closest("li"),s=this.tabs.index(i),n=!0;if(!this._handlePageNav(e)){switch(e.keyCode){case t.ui.keyCode.RIGHT:case t.ui.keyCode.DOWN:s++;break;case t.ui.keyCode.UP:case t.ui.keyCode.LEFT:n=!1,s--;break;case t.ui.keyCode.END:s=this.anchors.length-1;break;case t.ui.keyCode.HOME:s=0;break;case t.ui.keyCode.SPACE:return e.preventDefault(),clearTimeout(this.activating),this._activate(s),void 0;case t.ui.keyCode.ENTER:return e.preventDefault(),clearTimeout(this.activating),this._activate(s===this.options.active?!1:s),void 0;default:return}e.preventDefault(),clearTimeout(this.activating),s=this._focusNextTab(s,n),e.ctrlKey||e.metaKey||(i.attr("aria-selected","false"),this.tabs.eq(s).attr("aria-selected","true"),this.activating=this._delay(function(){this.option("active",s)},this.delay))}},_panelKeydown:function(e){this._handlePageNav(e)||e.ctrlKey&&e.keyCode===t.ui.keyCode.UP&&(e.preventDefault(),this.active.trigger("focus"))},_handlePageNav:function(e){return e.altKey&&e.keyCode===t.ui.keyCode.PAGE_UP?(this._activate(this._focusNextTab(this.options.active-1,!1)),!0):e.altKey&&e.keyCode===t.ui.keyCode.PAGE_DOWN?(this._activate(this._focusNextTab(this.options.active+1,!0)),!0):void 0},_findNextTab:function(e,i){function s(){return e>n&&(e=0),0>e&&(e=n),e}for(var n=this.tabs.length-1;-1!==t.inArray(s(),this.options.disabled);)e=i?e+1:e-1;return e},_focusNextTab:function(t,e){return t=this._findNextTab(t,e),this.tabs.eq(t).trigger("focus"),t},_setOption:function(t,e){return"active"===t?(this._activate(e),void 0):(this._super(t,e),"collapsible"===t&&(this._toggleClass("ui-tabs-collapsible",null,e),e||this.options.active!==!1||this._activate(0)),"event"===t&&this._setupEvents(e),"heightStyle"===t&&this._setupHeightStyle(e),void 0)},_sanitizeSelector:function(t){return t?t.replace(/[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g,"\\$&"):""},refresh:function(){var e=this.options,i=this.tablist.children(":has(a[href])");e.disabled=t.map(i.filter(".ui-state-disabled"),function(t){return i.index(t)}),this._processTabs(),e.active!==!1&&this.anchors.length?this.active.length&&!t.contains(this.tablist[0],this.active[0])?this.tabs.length===e.disabled.length?(e.active=!1,this.active=t()):this._activate(this._findNextTab(Math.max(0,e.active-1),!1)):e.active=this.tabs.index(this.active):(e.active=!1,this.active=t()),this._refresh()},_refresh:function(){this._setOptionDisabled(this.options.disabled),this._setupEvents(this.options.event),this._setupHeightStyle(this.options.heightStyle),this.tabs.not(this.active).attr({"aria-selected":"false","aria-expanded":"false",tabIndex:-1}),this.panels.not(this._getPanelForTab(this.active)).hide().attr({"aria-hidden":"true"}),this.active.length?(this.active.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0}),this._addClass(this.active,"ui-tabs-active","ui-state-active"),this._getPanelForTab(this.active).show().attr({"aria-hidden":"false"})):this.tabs.eq(0).attr("tabIndex",0)},_processTabs:function(){var e=this,i=this.tabs,s=this.anchors,n=this.panels;this.tablist=this._getList().attr("role","tablist"),this._addClass(this.tablist,"ui-tabs-nav","ui-helper-reset ui-helper-clearfix ui-widget-header"),this.tablist.on("mousedown"+this.eventNamespace,"> li",function(e){t(this).is(".ui-state-disabled")&&e.preventDefault()}).on("focus"+this.eventNamespace,".ui-tabs-anchor",function(){t(this).closest("li").is(".ui-state-disabled")&&this.blur()}),this.tabs=this.tablist.find("> li:has(a[href])").attr({role:"tab",tabIndex:-1}),this._addClass(this.tabs,"ui-tabs-tab","ui-state-default"),this.anchors=this.tabs.map(function(){return t("a",this)[0]}).attr({role:"presentation",tabIndex:-1}),this._addClass(this.anchors,"ui-tabs-anchor"),this.panels=t(),this.anchors.each(function(i,s){var n,o,a,r=t(s).uniqueId().attr("id"),h=t(s).closest("li"),l=h.attr("aria-controls");e._isLocal(s)?(n=s.hash,a=n.substring(1),o=e.element.find(e._sanitizeSelector(n))):(a=h.attr("aria-controls")||t({}).uniqueId()[0].id,n="#"+a,o=e.element.find(n),o.length||(o=e._createPanel(a),o.insertAfter(e.panels[i-1]||e.tablist)),o.attr("aria-live","polite")),o.length&&(e.panels=e.panels.add(o)),l&&h.data("ui-tabs-aria-controls",l),h.attr({"aria-controls":a,"aria-labelledby":r}),o.attr("aria-labelledby",r)}),this.panels.attr("role","tabpanel"),this._addClass(this.panels,"ui-tabs-panel","ui-widget-content"),i&&(this._off(i.not(this.tabs)),this._off(s.not(this.anchors)),this._off(n.not(this.panels)))},_getList:function(){return this.tablist||this.element.find("ol, ul").eq(0)},_createPanel:function(e){return t("<div>").attr("id",e).data("ui-tabs-destroy",!0)},_setOptionDisabled:function(e){var i,s,n;for(t.isArray(e)&&(e.length?e.length===this.anchors.length&&(e=!0):e=!1),n=0;s=this.tabs[n];n++)i=t(s),e===!0||-1!==t.inArray(n,e)?(i.attr("aria-disabled","true"),this._addClass(i,null,"ui-state-disabled")):(i.removeAttr("aria-disabled"),this._removeClass(i,null,"ui-state-disabled"));this.options.disabled=e,this._toggleClass(this.widget(),this.widgetFullName+"-disabled",null,e===!0)},_setupEvents:function(e){var i={};e&&t.each(e.split(" "),function(t,e){i[e]="_eventHandler"}),this._off(this.anchors.add(this.tabs).add(this.panels)),this._on(!0,this.anchors,{click:function(t){t.preventDefault()}}),this._on(this.anchors,i),this._on(this.tabs,{keydown:"_tabKeydown"}),this._on(this.panels,{keydown:"_panelKeydown"}),this._focusable(this.tabs),this._hoverable(this.tabs)},_setupHeightStyle:function(e){var i,s=this.element.parent();"fill"===e?(i=s.height(),i-=this.element.outerHeight()-this.element.height(),this.element.siblings(":visible").each(function(){var e=t(this),s=e.css("position");"absolute"!==s&&"fixed"!==s&&(i-=e.outerHeight(!0))}),this.element.children().not(this.panels).each(function(){i-=t(this).outerHeight(!0)}),this.panels.each(function(){t(this).height(Math.max(0,i-t(this).innerHeight()+t(this).height()))}).css("overflow","auto")):"auto"===e&&(i=0,this.panels.each(function(){i=Math.max(i,t(this).height("").height())}).height(i))},_eventHandler:function(e){var i=this.options,s=this.active,n=t(e.currentTarget),o=n.closest("li"),a=o[0]===s[0],r=a&&i.collapsible,h=r?t():this._getPanelForTab(o),l=s.length?this._getPanelForTab(s):t(),c={oldTab:s,oldPanel:l,newTab:r?t():o,newPanel:h};e.preventDefault(),o.hasClass("ui-state-disabled")||o.hasClass("ui-tabs-loading")||this.running||a&&!i.collapsible||this._trigger("beforeActivate",e,c)===!1||(i.active=r?!1:this.tabs.index(o),this.active=a?t():o,this.xhr&&this.xhr.abort(),l.length||h.length||t.error("jQuery UI Tabs: Mismatching fragment identifier."),h.length&&this.load(this.tabs.index(o),e),this._toggle(e,c))},_toggle:function(e,i){function s(){o.running=!1,o._trigger("activate",e,i)}function n(){o._addClass(i.newTab.closest("li"),"ui-tabs-active","ui-state-active"),a.length&&o.options.show?o._show(a,o.options.show,s):(a.show(),s())}var o=this,a=i.newPanel,r=i.oldPanel;this.running=!0,r.length&&this.options.hide?this._hide(r,this.options.hide,function(){o._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),n()}):(this._removeClass(i.oldTab.closest("li"),"ui-tabs-active","ui-state-active"),r.hide(),n()),r.attr("aria-hidden","true"),i.oldTab.attr({"aria-selected":"false","aria-expanded":"false"}),a.length&&r.length?i.oldTab.attr("tabIndex",-1):a.length&&this.tabs.filter(function(){return 0===t(this).attr("tabIndex")}).attr("tabIndex",-1),a.attr("aria-hidden","false"),i.newTab.attr({"aria-selected":"true","aria-expanded":"true",tabIndex:0})},_activate:function(e){var i,s=this._findActive(e);s[0]!==this.active[0]&&(s.length||(s=this.active),i=s.find(".ui-tabs-anchor")[0],this._eventHandler({target:i,currentTarget:i,preventDefault:t.noop}))},_findActive:function(e){return e===!1?t():this.tabs.eq(e)},_getIndex:function(e){return"string"==typeof e&&(e=this.anchors.index(this.anchors.filter("[href$='"+t.ui.escapeSelector(e)+"']"))),e},_destroy:function(){this.xhr&&this.xhr.abort(),this.tablist.removeAttr("role").off(this.eventNamespace),this.anchors.removeAttr("role tabIndex").removeUniqueId(),this.tabs.add(this.panels).each(function(){t.data(this,"ui-tabs-destroy")?t(this).remove():t(this).removeAttr("role tabIndex aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded")}),this.tabs.each(function(){var e=t(this),i=e.data("ui-tabs-aria-controls");i?e.attr("aria-controls",i).removeData("ui-tabs-aria-controls"):e.removeAttr("aria-controls")}),this.panels.show(),"content"!==this.options.heightStyle&&this.panels.css("height","")},enable:function(e){var i=this.options.disabled;i!==!1&&(void 0===e?i=!1:(e=this._getIndex(e),i=t.isArray(i)?t.map(i,function(t){return t!==e?t:null}):t.map(this.tabs,function(t,i){return i!==e?i:null})),this._setOptionDisabled(i))},disable:function(e){var i=this.options.disabled;if(i!==!0){if(void 0===e)i=!0;else{if(e=this._getIndex(e),-1!==t.inArray(e,i))return;i=t.isArray(i)?t.merge([e],i).sort():[e]}this._setOptionDisabled(i)}},load:function(e,i){e=this._getIndex(e);var s=this,n=this.tabs.eq(e),o=n.find(".ui-tabs-anchor"),a=this._getPanelForTab(n),r={tab:n,panel:a},h=function(t,e){"abort"===e&&s.panels.stop(!1,!0),s._removeClass(n,"ui-tabs-loading"),a.removeAttr("aria-busy"),t===s.xhr&&delete s.xhr};this._isLocal(o[0])||(this.xhr=t.ajax(this._ajaxSettings(o,i,r)),this.xhr&&"canceled"!==this.xhr.statusText&&(this._addClass(n,"ui-tabs-loading"),a.attr("aria-busy","true"),this.xhr.done(function(t,e,n){setTimeout(function(){a.html(t),s._trigger("load",i,r),h(n,e)},1)}).fail(function(t,e){setTimeout(function(){h(t,e)},1)})))},_ajaxSettings:function(e,i,s){var n=this;return{url:e.attr("href").replace(/#.*$/,""),beforeSend:function(e,o){return n._trigger("beforeLoad",i,t.extend({jqXHR:e,ajaxSettings:o},s))}}},_getPanelForTab:function(e){var i=t(e).attr("aria-controls");return this.element.find(this._sanitizeSelector("#"+i))}}),t.uiBackCompat!==!1&&t.widget("ui.tabs",t.ui.tabs,{_processTabs:function(){this._superApply(arguments),this._addClass(this.tabs,"ui-tab")}}),t.ui.tabs,t.widget("ui.tooltip",{version:"1.12.1",options:{classes:{"ui-tooltip":"ui-corner-all ui-widget-shadow"},content:function(){var e=t(this).attr("title")||"";return t("<a>").text(e).html()},hide:!0,items:"[title]:not([disabled])",position:{my:"left top+15",at:"left bottom",collision:"flipfit flip"},show:!0,track:!1,close:null,open:null},_addDescribedBy:function(e,i){var s=(e.attr("aria-describedby")||"").split(/\s+/);s.push(i),e.data("ui-tooltip-id",i).attr("aria-describedby",t.trim(s.join(" ")))},_removeDescribedBy:function(e){var i=e.data("ui-tooltip-id"),s=(e.attr("aria-describedby")||"").split(/\s+/),n=t.inArray(i,s);-1!==n&&s.splice(n,1),e.removeData("ui-tooltip-id"),s=t.trim(s.join(" ")),s?e.attr("aria-describedby",s):e.removeAttr("aria-describedby")},_create:function(){this._on({mouseover:"open",focusin:"open"}),this.tooltips={},this.parents={},this.liveRegion=t("<div>").attr({role:"log","aria-live":"assertive","aria-relevant":"additions"}).appendTo(this.document[0].body),this._addClass(this.liveRegion,null,"ui-helper-hidden-accessible"),this.disabledTitles=t([])},_setOption:function(e,i){var s=this;this._super(e,i),"content"===e&&t.each(this.tooltips,function(t,e){s._updateContent(e.element)})},_setOptionDisabled:function(t){this[t?"_disable":"_enable"]()},_disable:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur");n.target=n.currentTarget=s.element[0],e.close(n,!0)}),this.disabledTitles=this.disabledTitles.add(this.element.find(this.options.items).addBack().filter(function(){var e=t(this);return e.is("[title]")?e.data("ui-tooltip-title",e.attr("title")).removeAttr("title"):void 0}))},_enable:function(){this.disabledTitles.each(function(){var e=t(this);e.data("ui-tooltip-title")&&e.attr("title",e.data("ui-tooltip-title"))}),this.disabledTitles=t([])},open:function(e){var i=this,s=t(e?e.target:this.element).closest(this.options.items);s.length&&!s.data("ui-tooltip-id")&&(s.attr("title")&&s.data("ui-tooltip-title",s.attr("title")),s.data("ui-tooltip-open",!0),e&&"mouseover"===e.type&&s.parents().each(function(){var e,s=t(this);s.data("ui-tooltip-open")&&(e=t.Event("blur"),e.target=e.currentTarget=this,i.close(e,!0)),s.attr("title")&&(s.uniqueId(),i.parents[this.id]={element:this,title:s.attr("title")},s.attr("title",""))}),this._registerCloseHandlers(e,s),this._updateContent(s,e))},_updateContent:function(t,e){var i,s=this.options.content,n=this,o=e?e.type:null;return"string"==typeof s||s.nodeType||s.jquery?this._open(e,t,s):(i=s.call(t[0],function(i){n._delay(function(){t.data("ui-tooltip-open")&&(e&&(e.type=o),this._open(e,t,i))})}),i&&this._open(e,t,i),void 0)},_open:function(e,i,s){function n(t){l.of=t,a.is(":hidden")||a.position(l)}var o,a,r,h,l=t.extend({},this.options.position);if(s){if(o=this._find(i))return o.tooltip.find(".ui-tooltip-content").html(s),void 0;i.is("[title]")&&(e&&"mouseover"===e.type?i.attr("title",""):i.removeAttr("title")),o=this._tooltip(i),a=o.tooltip,this._addDescribedBy(i,a.attr("id")),a.find(".ui-tooltip-content").html(s),this.liveRegion.children().hide(),h=t("<div>").html(a.find(".ui-tooltip-content").html()),h.removeAttr("name").find("[name]").removeAttr("name"),h.removeAttr("id").find("[id]").removeAttr("id"),h.appendTo(this.liveRegion),this.options.track&&e&&/^mouse/.test(e.type)?(this._on(this.document,{mousemove:n}),n(e)):a.position(t.extend({of:i},this.options.position)),a.hide(),this._show(a,this.options.show),this.options.track&&this.options.show&&this.options.show.delay&&(r=this.delayedShow=setInterval(function(){a.is(":visible")&&(n(l.of),clearInterval(r))},t.fx.interval)),this._trigger("open",e,{tooltip:a})}},_registerCloseHandlers:function(e,i){var s={keyup:function(e){if(e.keyCode===t.ui.keyCode.ESCAPE){var s=t.Event(e);s.currentTarget=i[0],this.close(s,!0)}}};i[0]!==this.element[0]&&(s.remove=function(){this._removeTooltip(this._find(i).tooltip)}),e&&"mouseover"!==e.type||(s.mouseleave="close"),e&&"focusin"!==e.type||(s.focusout="close"),this._on(!0,i,s)},close:function(e){var i,s=this,n=t(e?e.currentTarget:this.element),o=this._find(n);return o?(i=o.tooltip,o.closing||(clearInterval(this.delayedShow),n.data("ui-tooltip-title")&&!n.attr("title")&&n.attr("title",n.data("ui-tooltip-title")),this._removeDescribedBy(n),o.hiding=!0,i.stop(!0),this._hide(i,this.options.hide,function(){s._removeTooltip(t(this))}),n.removeData("ui-tooltip-open"),this._off(n,"mouseleave focusout keyup"),n[0]!==this.element[0]&&this._off(n,"remove"),this._off(this.document,"mousemove"),e&&"mouseleave"===e.type&&t.each(this.parents,function(e,i){t(i.element).attr("title",i.title),delete s.parents[e]}),o.closing=!0,this._trigger("close",e,{tooltip:i}),o.hiding||(o.closing=!1)),void 0):(n.removeData("ui-tooltip-open"),void 0)},_tooltip:function(e){var i=t("<div>").attr("role","tooltip"),s=t("<div>").appendTo(i),n=i.uniqueId().attr("id");return this._addClass(s,"ui-tooltip-content"),this._addClass(i,"ui-tooltip","ui-widget ui-widget-content"),i.appendTo(this._appendTo(e)),this.tooltips[n]={element:e,tooltip:i}},_find:function(t){var e=t.data("ui-tooltip-id");return e?this.tooltips[e]:null},_removeTooltip:function(t){t.remove(),delete this.tooltips[t.attr("id")]},_appendTo:function(t){var e=t.closest(".ui-front, dialog");return e.length||(e=this.document[0].body),e},_destroy:function(){var e=this;t.each(this.tooltips,function(i,s){var n=t.Event("blur"),o=s.element;n.target=n.currentTarget=o[0],e.close(n,!0),t("#"+i).remove(),o.data("ui-tooltip-title")&&(o.attr("title")||o.attr("title",o.data("ui-tooltip-title")),o.removeData("ui-tooltip-title"))}),this.liveRegion.remove()}}),t.uiBackCompat!==!1&&t.widget("ui.tooltip",t.ui.tooltip,{options:{tooltipClass:null},_tooltip:function(){var t=this._superApply(arguments);return this.options.tooltipClass&&t.tooltip.addClass(this.options.tooltipClass),t}}),t.ui.tooltip});
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    ImageProcessing module
 */
define('Services/ImageProcessingCore',["jquery", "../Renderer/FeatureStyle", "jquery.ui"],
    function ($, FeatureStyle) {

        /**************************************************************************************************************/

        var feature;
        var layer;
        var disable;
        var unselect;
        var $dialog;
        var histogramElement;
        var cutOutElement;

        /**************************************************************************************************************/

        /**
         *    Toggle visibility of dialog
         */
        function toggle() {
            if ($dialog.dialog("isOpen")) {
                $dialog.dialog("close");
            }
            else {
                $dialog.dialog("open");
            }
        }

        /**************************************************************************************************************/

        /**
         *    Remove view
         */
        function remove() {
            if (unselect) {
                unselect();
            }

            if (disable) {
                disable();
            }

            if (histogramElement) {
                histogramElement.remove();
            }

            $dialog.remove();
        }

        /**************************************************************************************************************/

        /**
         *    Set data to process
         *
         *    @param selectedData Object containing feature and layer extracted by <PickingManager>
         */
        function setData(selectedData) {
            if (feature && feature.properties.identifier === selectedData.feature.properties.identifier) {
                this.toggle();
            }
            else {
                if (!$dialog.dialog("isOpen")) {
                    this.toggle();
                }
            }

            feature = selectedData.feature;
            layer = selectedData.layer;

            if (selectedData.feature.services) {
                cutOutElement.setUrl(selectedData.feature.services.download.url);
            }/** else {
                // TODO : disable cutOutElement if feature's url isn't defined
            }*/

            var image = selectedData.feature.properties.style.uniformValues;
            if (!image) {
                $dialog.find('.histogramContent').children('div').fadeOut(function () {
                    $(this).siblings('p').fadeIn();
                });
            }
            else {
                this.setImage(image);
            }
        }

        /**************************************************************************************************************/

        /**
         * Remove passed feature
         *
         * @param {Feature} data
         */
        function removeData(data) {
            if (feature && data.feature.properties.identifier === feature.properties.identifier) {
                if (this.isOpened()) {
                    this.toggle();
                }
                $dialog.find('.histogramContent').children('div').fadeOut(function () {
                    $(this).siblings('p').fadeIn();
                });
                feature = null;
                layer = null;
            }
        }

        /**************************************************************************************************************/

        /**
         * Set image on the Histogram element
         *
         * @param image
         */
        function setImage(image) {
            histogramElement.setImage(image);
            if (image.url) {
                cutOutElement.setUrl(image.url);
            }

            $dialog.find('.histogramContent').children('p').fadeOut(function () {
                $(this).siblings('div').fadeIn();
            });
        }

        /**************************************************************************************************************/

        /**
         * Change shader callback
         *
         * @param contrast
         */
        function changeShaderCallback(contrast) {
            var targetStyle;
            if (contrast === "raw") {
                targetStyle = new FeatureStyle(feature.properties.style);
                targetStyle.fillShader = {
                    fragmentCode: null,
                    updateUniforms: null
                };
                layer.modifyFeatureStyle(feature, targetStyle);
            }
            else {
                targetStyle = new FeatureStyle(feature.properties.style);
                targetStyle.fillShader = {
                    fragmentCode: this.image.fragmentCode,
                    updateUniforms: this.image.updateUniforms
                };
                layer.modifyFeatureStyle(feature, targetStyle);
            }
        }

        /**************************************************************************************************************/

        /**
         * Check if ImageProcessing is opened
         */
        function isOpened() {
            return $dialog.dialog("isOpen");
        }

        /**************************************************************************************************************/

        return {

            /**
             *    Init ImageProcessingCore
             *
             *    @param options
             *        <ul>
             *            <li>feature: The feature to process
             *            <li>layer: The layer to which the feature belongs to
             *            <li>disable: Disable callback</li>
             *            <li>unselect: Unselect callback</li>
             *        </ul>
             *    @param {HTMLElement} $dl dialogElement
             *    @param {HTMLElement} $histoElmt histogramElement
             *    @param {HTMLElement} $cutOutElmt cutOutElement
             *
             */
            init: function (options, $dl, histoElmt, cutOutElmt) {
                if (options) {
                    //this.id = options.id;
                    feature = options.feature || null;
                    layer = options.layer || null;

                    // Callbacks
                    disable = options.disable || null;
                    unselect = options.unselect || null;
                }

                $dialog = $dl;
                histogramElement = histoElmt;
                cutOutElement = cutOutElmt;
            },

            setData: setData,
            setImage: setImage,
            toggle: toggle
        };
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('Services/MeasureToolPlanetCore',["jquery", "underscore-min", "../Utils/Constants",
        "../Layer/VectorLayer", "../Renderer/Ray", "../Utils/Numeric", "../Renderer/FeatureStyle", "../Renderer/glMatrix"],
    function ($, _, Constants,
              VectorLayer, Ray, Numeric, FeatureStyle) {

        var navigation, mizarAPI, onselect, scale, measureLayer, self, dragging;

        /**********************************************************************************************/

        /**
         * Get first Geo pick point in terms of cursor position
         * @param event
         * @returns {Array} geoPickPoint geo position on the planet
         */
        function _handleMouseDown(event) {
            event.preventDefault();
            if (!self.activated) {
                return;
            }

            navigation.stop();

            dragging = true;
            self.elevations = [];

            if (event.type.search("touch") >= 0) {
                self.pickPoint = [event.changedTouches[0].clientX, event.changedTouches[0].clientY];
            }
            else {
                self.pickPoint = [event.layerX, event.layerY];
            }
            var geo = mizarAPI.getActivatedContext().getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
            if (geo !== null) {
                self.geoPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);
            } else {
                return null;
            }
            return self.geoPickPoint;
        }

        /**
         * Close the measure with the last point
         * @param event
         */
        function _handleMouseUp(event) {
            event.preventDefault();

            // Compute geo radius
            var stopPickPoint;
            if (event.type.search("touch") >= 0) {
                stopPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
            }
            else {

                stopPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(event.layerX, event.layerY);
            }

            // No point found, picking was not on planet but sky
            if (!_.isEmpty(stopPickPoint)) {
                // Find angle between start and stop vectors which is in fact the radius
                var dotProduct = vec3.dot(vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)), vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)));
                var theta = Math.acos(dotProduct);
                self.geoDistance = Numeric.toDegree(theta);

                if (onselect) {
                    onselect();
                }
            }
            navigation.start();
            dragging = false;
        }

        /**
         * Update drawing and label in terms of current point
         * @param event
         */
        function _handleMouseMove(event) {
            event.preventDefault();
            if (!self.activated || !dragging) {
                return;
            }
            if (event.type.search("touch") >= 0) {
                self.secondPickPoint = [event.changedTouches[0].clientX, event.changedTouches[0].clientY];
            }
            else {
                self.secondPickPoint = [event.layerX, event.layerY];
            }

            var geo = mizarAPI.getActivatedContext().getLonLatFromPixel(self.secondPickPoint[0], self.secondPickPoint[1]);
            if (geo !== null) {
                self.secondGeoPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(self.secondPickPoint[0], self.secondPickPoint[1]);
            } else {
                return;
            }
            //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

            // Update radius
            self.distance = Math.sqrt(Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) + Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2));
            var dotProduct;
            if (self.secondGeoPickPoint === undefined) {
                dotProduct = vec3.dot(vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.secondPickPoint)), vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)));
            }
            else {
                dotProduct = vec3.dot(vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)), vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)));
            }
            var theta = Math.acos(dotProduct);
            self.geoDistance = Numeric.toDegree(theta);

            updateMeasure();
        }

        /**************************************************************************************************************/

        /**
         * Transform coordinates to the right world space dimension
         * @param points
         * @returns {Array} points  points transformed
         */
        function computeIntersection(points) {
            var rc = self.renderContext;
            var tmpMat = mat4.create();

            // Computes eye in world space
            mat4.inverse(rc.viewMatrix, tmpMat);
            var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

            // Computes the inverse of view/proj matrix
            mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
            mat4.inverse(tmpMat);

            // Transforms the four corners of measured shape into world space
            // and then for each corner computes the intersection of ray starting from the eye to the sphere
            var worldCenter = [0, 0, 0];
            for (var i = 0; i < points.length; i++) {
                mat4.multiplyVec4(tmpMat, points[i]);
                vec3.scale(points[i], 1.0 / points[i][3]);
                vec3.subtract(points[i], eye, points[i]);
                vec3.normalize(points[i]);
                var ray = new Ray(eye, points[i]);
                var pos3d = ray.computePoint(ray.sphereIntersect(worldCenter, mizarAPI.getCrs().getGeoide().getRadius()));
                points[i] = mizarAPI.getCrs().getWorldFrom3D(pos3d);
            }

            return points;
        }

        /**********************************************************************************************/

        function rotateVector2D(vec, theta) {
            theta = theta * Math.PI / 180;
            var cs = Math.cos(theta);
            var sn = Math.sin(theta);

            return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
        }

        function normalize2D(vec, dest) {
            if (!dest) {
                dest = vec;
            }

            var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
            dest[0] = vec[0] / length;
            dest[1] = vec[1] / length;
            return dest;
        }

        /**********************************************************************************************/

        /**
         * Computes the measure for the given pick point depending on the second point (used to draw)
         * @returns {Array} points to draw
         */
        function computeMeasure() {

            var rc = self.renderContext;

            var widthScale = 2 / rc.canvas.width;
            var heightScale = 2 / rc.canvas.height;

            var points;
            if (mizarAPI.getActivatedContext().getNavigation().getType() === Constants.NAVIGATION.FlatNavigation) {
                points = [
                    [self.geoPickPoint[0], self.geoPickPoint[1], 1],
                    [self.secondGeoPickPoint[0], self.secondGeoPickPoint[1], 1]
                ];
                return points;
            }

            var diff = [self.secondPickPoint[0] - self.pickPoint[0], self.secondPickPoint[1] - self.pickPoint[1]];
            normalize2D(diff);

            // First arrow
            var arrow = rotateVector2D(diff, 30);
            var arrow2 = rotateVector2D(diff, -30);
            arrow = [self.pickPoint[0] + 10 * arrow[0], self.pickPoint[1] + 10 * arrow[1]];
            arrow2 = [self.pickPoint[0] + 10 * arrow2[0], self.pickPoint[1] + 10 * arrow2[1]];

            var diff2 = [-diff[0], -diff[1]];
            var arrow3 = rotateVector2D(diff2, 30);
            var arrow4 = rotateVector2D(diff2, -30);
            arrow3 = [self.secondPickPoint[0] + 10 * arrow3[0], self.secondPickPoint[1] + 10 * arrow3[1]];
            arrow4 = [self.secondPickPoint[0] + 10 * arrow4[0], self.secondPickPoint[1] + 10 * arrow4[1]];

            points = [
                [arrow[0] * widthScale - 1, (rc.canvas.height - arrow[1]) * heightScale - 1, 1, 1],
                [self.pickPoint[0] * widthScale - 1, (rc.canvas.height - self.pickPoint[1]) * heightScale - 1, 1, 1],
                [arrow2[0] * widthScale - 1, (rc.canvas.height - arrow2[1]) * heightScale - 1, 1, 1],
                [self.pickPoint[0] * widthScale - 1, (rc.canvas.height - self.pickPoint[1]) * heightScale - 1, 1, 1]
            ];

            ////calcul des points intermédiaires
            //var distance = 1;
            //var x = this.pickPoint[0], y = this.pickPoint[1];
            //while (x < this.secondPickPoint[0] && y < this.secondPickPoint[1]) {
            //    x += distance * diff[0];
            //    y += distance * diff[1];
            //    points.push([x * widthScale - 1, (rc.canvas.height - y) * heightScale - 1, 1, 1]);
            //}

            //ajout du dernier point
            points.push(
                [self.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1, 1, 1],
                [arrow3[0] * widthScale - 1, (rc.canvas.height - arrow3[1]) * heightScale - 1, 1, 1],
                [self.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1, 1, 1],
                [arrow4[0] * widthScale - 1, (rc.canvas.height - arrow4[1]) * heightScale - 1, 1, 1]
            );
            self.computeIntersection(points);
            return points;
        }

        /**********************************************************************************************/

        function remove() {
            self.clear();
            mizarAPI.getPlanetContext().removeDraw(measureLayer);
        }

        /**
         *    Updates measure coordinates
         */
        function updateMeasure() {
            self.clear();
            var coordinates = self.computeMeasure();

            // Get dem scale of elevation layer
            var mntScale;
            if (
               (mizarAPI.getActivatedContext().elevationTracker !== null) &&
               (mizarAPI.getActivatedContext().elevationTracker.options !== null) &&
               (mizarAPI.getActivatedContext().elevationTracker.options.elevationLayer !== undefined) &&
               (mizarAPI.getActivatedContext().elevationTracker.options.elevationLayer.scale !== null) ) {
                mntScale = mizarAPI.getActivatedContext().elevationTracker.options.elevationLayer.scale;
            } else {
                mntScale = 1;
            }
            var firstPoint = self.geoPickPoint;
            var secondPoint = self.secondGeoPickPoint;
            var maxElevation = 0;
            // Get maximum elevation along the segment
            if ((firstPoint !== null) && (secondPoint !== null)) {
              var intermediatesPoints = calculateIntermediateElevationPoint({},firstPoint,secondPoint);
              // For each point, get elevation
              for (var i=0;i<intermediatesPoints.length;i++) {
                  var pt = intermediatesPoints[i];
                  var elevation = mizarAPI.getActivatedContext().getElevation(pt[0], pt[1]);
                  elevation = Numeric.roundNumber(elevation / scale, 0)
                  if (elevation > maxElevation) {
                    maxElevation = elevation;
                  }
              }
              // Apply dem scale
              maxElevation = maxElevation * mntScale;

              // Add 10% to avoid collision display
              maxElevation = maxElevation * 1.1;
            }

            // Apply elevation to all point of displayed arrow
            for (var i=0;i<coordinates.length;i++) {
              coordinates[i][2] = maxElevation;
            }

            self.measureFeature = {
                geometry: {
                    gid: "measureShape",
                    coordinates: coordinates,
                    type: Constants.GEOMETRY.LineString,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                properties: {
                    style: new FeatureStyle({
                        fillColor: [1, 0, 0, 1]
                    })
                },
                type: "Feature"
            };



            var center = [(self.secondPickPoint[0] + self.pickPoint[0]) / 2, (self.secondPickPoint[1] + self.pickPoint[1]) / 2];
            var geoCenter = mizarAPI.getActivatedContext().getLonLatFromPixel(center[0],center[1]);

            // Apply elevation to label
            geoCenter[2] = maxElevation;

            var distance = self.calculateDistanceElevation(self.geoPickPoint, self.secondGeoPickPoint);

            distance = Numeric.roundNumber(distance.toFixed(3), 2);

            self.measureLabel = {
                geometry: {
                    type: Constants.GEOMETRY.Point,
                    gid: "measureShape",
                    coordinates: geoCenter,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                properties: {
                    style: new FeatureStyle({
                        label: distance + " km",
                        fillColor: [1, 1, 1, 1],
                        pointMaxSize : 600,
                        extrusionScale: -100000
                    })
                }
            };
            measureLayer.addFeature(self.measureFeature);
            measureLayer.addFeature(self.measureLabel);
        }

        /**************************************************************************************************************/

        /**
         *    Clear measureFeature and measureLabel
         */
        function clear() {
            if (self.measureFeature) {
                measureLayer.removeFeature(self.measureFeature);
            }
            if (self.measureLabel) {
                measureLayer.removeFeature(self.measureLabel);
            }
        }

        /**************************************************************************************************************/

        /**
         * Calculate intermediaries elevation points to increase drawing precision
         *
         * @param {Object} options
         *              <ul>
         *                  <li>scale : number of intermediary points to compute</li>
         *              </ul>
         * @param {Array} firstPoint
         * @param {Array} secondPoint
         * @return {Array} intermediatePoints
         */
        function calculateIntermediateElevationPoint(options, firstPoint, secondPoint) {
            var scale = options.scale | 50;
            var deltaX = firstPoint[0] - secondPoint[0];
            var intervalX;
            if(deltaX >180.0) {
                deltaX = 360.0 - deltaX;
                intervalX = -deltaX / scale;
            } else if(deltaX < -180.0) {
                deltaX = 360.0 + deltaX;
                intervalX = deltaX / scale;
            } else {
                intervalX = deltaX / scale;
            }
            var intervalY = (firstPoint[1] - secondPoint[1]) / scale;

            var intermediatePoints = [];
            intermediatePoints[0] = firstPoint;
            for (var i = 1; i < scale; i++) {

                var x = (intermediatePoints[i - 1][0] - intervalX);
                if (x > 180.0) {
                    x = x - 360;
                } else if (x < -180.0) {
                    x = x + 360;
                }
                var y = (intermediatePoints[i - 1][1] - intervalY);
                intermediatePoints[i] = [x, y];
            }
            intermediatePoints[scale] = secondPoint;
            return intermediatePoints;
        }

        /**
         * Calculate distance elevation from a point
         *
         * url calcul distance : http://www.movable-type.co.uk/scripts/latlong.html
         *
         * @param {Array} firstPoint
         * @param {Array} secondPoint
         * @returns {number} distance elevation in meters
         */
        function calculateDistanceElevation(firstPoint, secondPoint) {
            var R = mizarAPI.getCrs().getGeoide().getRealPlanetRadius();
            var φ1 = Numeric.toRadian(firstPoint[1]);
            var φ2 = Numeric.toRadian(secondPoint[1]);
            var Δφ = Numeric.toRadian(secondPoint[1] - firstPoint[1]);
            var Δλ = Numeric.toRadian(secondPoint[0] - firstPoint[0]);

            var a = Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
                Math.cos(φ1) * Math.cos(φ2) *
                Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
            var c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            var distance = R * c;

            return distance / 1000;

        }

        /**
         * Calculate distance and elevation for a given point and store it
         * @param {Array} firstPoint
         * @param {Array} secondPoint
         */
        function storeDistanceAndElevation(firstPoint, secondPoint) {
            var distance = self.calculateDistanceElevation(firstPoint, secondPoint);
            distance = Numeric.roundNumber(distance.toFixed(3), 2);

            var elevation = mizarAPI.getActivatedContext().getElevation(secondPoint[0], secondPoint[1]);
            elevation = Numeric.roundNumber(elevation / scale, 0);
            var pointElevation = [distance, elevation];

            self.elevations.push(pointElevation);
        }

        function updateContext(mizar) {
            mizarAPI = mizar;
            navigation = mizarAPI.getActivatedContext().getNavigation();
            var elevationLayer = _.find(mizarAPI.getActivatedContext().getLayers(),  function(obj) { return obj.type ===  Constants.LAYER.WCSElevation ||  obj.type ===  Constants.LAYER.WMSElevation});
            scale = elevationLayer.scale;
            dragging = false;

            // Layer containing measure feature
            if (!measureLayer) {
                measureLayer = new VectorLayer();
            }
            mizarAPI.getPlanetContext().addDraw(measureLayer);

            this.activated = false;
            this.renderContext = mizarAPI.getRenderContext();

            this.elevations = [];
            this.measureFeature = null;

        }

        return {
            init: function (options) {
                mizarAPI = options.mizar;
                navigation = mizarAPI.getActivatedContext().getNavigation();
                onselect = options.onselect;
                var elevationLayer = _.find(mizarAPI.getActivatedContext().getLayers(),  function(obj) { return obj.type ===  Constants.LAYER.WCSElevation ||  obj.type ===  Constants.LAYER.WMSElevation});
                if(elevationLayer !== undefined) {
                    scale = elevationLayer.scale;
                } else {
                    scale = 1;
                }
                self = this;
                dragging = false;

                // Layer containing measure feature
                measureLayer = mizarAPI.LayerFactory.create({type:Constants.LAYER.Vector, visible:true});
                mizarAPI.getPlanetContext().addDraw(measureLayer);

                this.activated = false;
                this.renderContext = mizarAPI.getRenderContext();

                this.elevations = [];
                this.measureFeature = null;
            },
            _handleMouseDown: _handleMouseDown,
            _handleMouseUp: _handleMouseUp,
            _handleMouseMove: _handleMouseMove,
            clear: clear,
            remove:remove,
            updateContext: updateContext,
            calculateIntermediateElevationPoint: calculateIntermediateElevationPoint,
            calculateDistanceElevation: calculateDistanceElevation,
            computeMeasure: computeMeasure,
            computeIntersection: computeIntersection,
            storeDistanceAndElevation: storeDistanceAndElevation
        };
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to measure the distance between two points in planet mode
 */

define('Services/MeasureToolSkyCore',["jquery", "underscore-min", "../Utils/Numeric", "../Utils/Constants",
        "../Layer/VectorLayer", "../Renderer/Ray", "../Renderer/FeatureStyle", "../Renderer/glMatrix"],
    function ($, _, Numeric, Constants,
              VectorLayer, Ray, FeatureStyle) {

        var mizarAPI, navigation, onselect, measureLayer, self, dragging;

        /**********************************************************************************************/

        /**
         * Get first Geo pick point in terms of cursor position
         * @param event
         * @returns {Array} geoPickPoint geo position on the planet
         */
        function _handleMouseDown(event) {
            event.preventDefault();
            if (!self.activated) {
                return;
            }

            self.distance = 0;
            // Disable standard navigation events
            navigation.stop();

            dragging = true;
            self.elevations = [];

            if (event.type.search("touch") >= 0) {
                self.pickPoint = [event.changedTouches[0].clientX, event.changedTouches[0].clientY];
            }
            else {
                self.pickPoint = [event.layerX, event.layerY];
            }
            self.geoPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(self.pickPoint[0], self.pickPoint[1]);

        }

        /**
         * Close the measure with the last point
         * @param event
         */
        function _handleMouseUp(event) {
            event.preventDefault();
            if (!self.activated) {
                return;
            }

            // Compute geo radius
            var stopPickPoint;
            if (event.type.search("touch") >= 0) {
                stopPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(event.changedTouches[0].clientX, event.changedTouches[0].clientY);
            }
            else {
                stopPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(event.layerX, event.layerY);
            }

            // Find angle between start and stop vectors which is in fact the radius
            var dotProduct = vec3.dot(vec3.normalize(mizarAPI.getCrs().get3DFromWorld(stopPickPoint)), vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)));
            var theta = Math.acos(dotProduct);
            self.geoDistance = Numeric.toDegree(theta);

            if (onselect) {
                onselect();
            }

            // Enable standard navigation events
            navigation.start();
            dragging = false;
        }

        /**
         * Update drawing and label in terms of current point
         * @param event
         */
        function _handleMouseMove(event) {
            event.preventDefault();
            if (!self.activated || !dragging) {
                return;
            }
            if (event.type.search("touch") >= 0) {
                self.secondPickPoint = [event.changedTouches[0].clientX, event.changedTouches[0].clientY];
            }
            else {
                self.secondPickPoint = [event.layerX, event.layerY];
            }

            self.secondGeoPickPoint = mizarAPI.getActivatedContext().getLonLatFromPixel(self.secondPickPoint[0], self.secondPickPoint[1]);

            //self.storeDistanceAndElevation(self.geoPickPoint, self.secondGeoPickPoint);

            // Update radius
            self.distance = Math.sqrt(Math.pow(self.secondPickPoint[0] - self.pickPoint[0], 2) + Math.pow(self.secondPickPoint[1] - self.pickPoint[1], 2));
            var dotProduct = vec3.dot(vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.secondGeoPickPoint)), vec3.normalize(mizarAPI.getCrs().get3DFromWorld(self.geoPickPoint)));

            var theta = Math.acos(dotProduct);
            self.geoDistance = Numeric.toDegree(theta);

            self.updateMeasure();
        }

        /**************************************************************************************************************/

        /**
         * Transform coordinates to the right world space dimension
         * @param points
         * @returns {Array} points  points transformed
         */
        function computeIntersection(points) {
            var rc = self.renderContext;
            var tmpMat = mat4.create();

            // Computes eye in world space
            mat4.inverse(rc.viewMatrix, tmpMat);
            var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

            // Computes the inverse of view/proj matrix
            mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
            mat4.inverse(tmpMat);

            // Transforms the four corners of measured shape into world space
            // and then for each corner computes the intersection of ray starting from the eye to the sphere
            var worldCenter = [0, 0, 0];
            for (var i = 0; i < points.length; i++) {
                mat4.multiplyVec4(tmpMat, points[i]);
                vec3.scale(points[i], 1.0 / points[i][3]);
                vec3.subtract(points[i], eye, points[i]);
                vec3.normalize(points[i]);

                var ray = new Ray(eye, points[i]);
                var pos3d = ray.computePoint(ray.sphereIntersect(worldCenter, mizarAPI.getCrs().getGeoide().getRadius()));
                points[i] = mizarAPI.getCrs().getWorldFrom3D(pos3d);
            }

            return points;
        }

        /**********************************************************************************************/

        function rotateVector2D(vec, theta) {
            theta = theta * Math.PI / 180;
            var cs = Math.cos(theta);
            var sn = Math.sin(theta);

            return [vec[0] * cs - vec[1] * sn, vec[0] * sn + vec[1] * cs];
        }

        function normalize2D(vec, dest) {
            if (!dest) {
                dest = vec;
            }

            var length = Math.sqrt(vec[0] * vec[0] + vec[1] * vec[1]);
            dest[0] = vec[0] / length;
            dest[1] = vec[1] / length;
            return dest;
        }

        /**********************************************************************************************/

        /**
         * Computes the measure for the given pick point depending on the second point (used to draw)
         * @returns {Array} points to draw
         */
        function computeMeasure() {
            var rc = self.renderContext;
            // Scale to [-1,1]
            var widthScale = 2 / rc.canvas.width;
            var heightScale = 2 / rc.canvas.height;

            var diff = [self.secondPickPoint[0] - self.pickPoint[0], self.secondPickPoint[1] - self.pickPoint[1]];
            normalize2D(diff);

            // First arrow
            var arrow = rotateVector2D(diff, 30);
            var arrow2 = rotateVector2D(diff, -30);
            arrow = [self.pickPoint[0] + 10 * arrow[0], self.pickPoint[1] + 10 * arrow[1]];
            arrow2 = [self.pickPoint[0] + 10 * arrow2[0], self.pickPoint[1] + 10 * arrow2[1]];

            var diff2 = [-diff[0], -diff[1]];
            var arrow3 = rotateVector2D(diff2, 30);
            var arrow4 = rotateVector2D(diff2, -30);
            arrow3 = [self.secondPickPoint[0] + 10 * arrow3[0], self.secondPickPoint[1] + 10 * arrow3[1]];
            arrow4 = [self.secondPickPoint[0] + 10 * arrow4[0], self.secondPickPoint[1] + 10 * arrow4[1]];

            var points = [
                [self.pickPoint[0] * widthScale - 1, (rc.canvas.height - self.pickPoint[1]) * heightScale - 1, 1, 1],
                [arrow[0] * widthScale - 1, (rc.canvas.height - arrow[1]) * heightScale - 1, 1, 1],
                [self.pickPoint[0] * widthScale - 1, (rc.canvas.height - self.pickPoint[1]) * heightScale - 1, 1, 1],
                [arrow2[0] * widthScale - 1, (rc.canvas.height - arrow2[1]) * heightScale - 1, 1, 1],
                [self.pickPoint[0] * widthScale - 1, (rc.canvas.height - self.pickPoint[1]) * heightScale - 1, 1, 1],
                [self.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1, 1, 1],
                [arrow3[0] * widthScale - 1, (rc.canvas.height - arrow3[1]) * heightScale - 1, 1, 1],
                [self.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1, 1, 1],
                [arrow4[0] * widthScale - 1, (rc.canvas.height - arrow4[1]) * heightScale - 1, 1, 1],
                [self.secondPickPoint[0] * widthScale - 1, (rc.canvas.height - self.secondPickPoint[1]) * heightScale - 1, 1, 1]
            ];

            this.computeIntersection(points);
            return points;
        }

        /**********************************************************************************************/

        /**
         *    Updates measure coordinates
         */
        function updateMeasure() {
            self.clear();

            var coordinates = self.computeMeasure();

            // Close the polygon
            coordinates.push(coordinates[0]);

            self.measureFeature = {
                geometry: {
                    gid: "measureShape",
                    coordinates: [coordinates],
                    type: Constants.GEOMETRY.Polygon,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                properties: {
                    style: new FeatureStyle({
                        zIndex: 2,
                        fillColor: [1, 0, 0, 1]
                    })
                },
                type: "Feature"
            };

            var center = [(self.secondPickPoint[0] + self.pickPoint[0]) / 2, (self.secondPickPoint[1] + self.pickPoint[1]) / 2];
            var geoCenter = mizarAPI.getActivatedContext().getLonLatFromPixel(center[0],center[1]);
            self.measureLabel = {
                geometry: {
                    type: Constants.GEOMETRY.Point,
                    gid: "measureShape",
                    coordinates:geoCenter,
                    crs: {
                        type: "name",
                        properties: {
                            name: mizarAPI.getCrs().getGeoideName()
                        }
                    }
                },
                properties: {
                    style: new FeatureStyle({
                        label: mizarAPI.getCrs().fromDegreesToDMS(self.geoDistance),
                        fillColor: [1, 1, 1, 1],
                        zIndex: 2
                    })
                }
            };
            var msg = "Distance :"+self.geoDistance+" at "+coordinates[0][0]+","+coordinates[0][1]+","+coordinates[0][2];
            console.log("MSG:"+msg);
            measureLayer.addFeature(self.measureFeature);
            measureLayer.addFeature(self.measureLabel);
        }

        /**************************************************************************************************************/

        /**
         *    Clear measureFeature and measureLabel
         */
        function clear() {
            if (self.measureFeature) {
                measureLayer.removeFeature(self.measureFeature);
            }
            if (self.measureLabel) {
                measureLayer.removeFeature(self.measureLabel);
            }
        }

        function remove() {
            self.clear();
            mizarAPI.getSkyContext().removeDraw(measureLayer);
        }

        return {
            init: function (options) {
                mizarAPI = options.mizar;
                navigation = mizarAPI.getActivatedContext().getNavigation();
                onselect = options.onselect;
                self = this;
                dragging = false;

                // Layer containing measure feature
                measureLayer = mizarAPI.LayerFactory.create({type:Constants.LAYER.Vector, visible:true});
                mizarAPI.getSkyContext().addDraw(measureLayer);

                this.activated = false;
                this.renderContext = mizarAPI.getRenderContext();

                // Measure attributes
                /*this.pickPoint; // Window pick point
                this.secondPickPoint; // Window second pick point
                this.geoPickPoint; // Pick point in geographic reference
                this.secondGeoPickPoint; // Pick point in geographic reference
                this.measureLabel;
                */
                this.elevations = [];
                this.measureFeature = null;
            },
            _handleMouseDown: _handleMouseDown,
            _handleMouseUp: _handleMouseUp,
            _handleMouseMove: _handleMouseMove,
            updateMeasure : updateMeasure,
            clear: clear,
            remove: remove,
            computeMeasure: computeMeasure,
            computeIntersection: computeIntersection
        };

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 *    Moc base module
 */
define('Services/MocBase',["jquery", "../Renderer/FeatureStyle", "../Layer/MocLayer", "../Utils/Numeric", "../Layer/FitsLoader", "../Tiling/HEALPixBase"],
    function ($, FeatureStyle, MocLayer, Numeric, FitsLoader, HEALPixBase) {
        var mizarAPI;
        var coverageServiceUrl;

        /**************************************************************************************************************/

        /**
         *    Request moc description for the given layer
         */
        function requestMocDesc(layer, successCallback, errorCallback) {
            // Get moc template

            // case moc url service return a fits file
            if (layer.serviceUrl && layer.serviceUrl.search(/[/.fits]+$/g) !== 1) {
                layer.describeUrl = layer.serviceUrl;
                successCallback(layer);
            } else {
                $.ajax({
                    type: "GET",
                    url: layer.serviceUrl,
                    //dataType: "xml",
                    success: function (xml) {
                        var mocdesc = $(xml).find('Url[rel="mocdesc"]');
                        var describeUrl = $(mocdesc).attr("template");
                        if (describeUrl) {
                            // Cut request parameters if exists
                            var splitIndex = describeUrl.indexOf("?q=");
                            if (splitIndex !== -1) {
                                describeUrl = describeUrl.substring(0, splitIndex);
                            }
                            layer.describeUrl = describeUrl;
                            successCallback(layer);

                        }
                        else {
                            layer.describeUrl = "Not available";
                            layer.coverage = "Not available";
                            if (errorCallback) {
                                errorCallback(layer);
                            }
                        }
                    },
                    error: function (xhr) {
                        layer.describeUrl = "Not available";
                        layer.coverage = "Not available";
                        if (errorCallback) {
                            errorCallback(layer);
                        }
                    }
                });
            }
        }

        /**************************************************************************************************************/

        /**
         * Request moc layer for the given layer
         * @param {Layer} layer
         * @param {Function} callback
         */
        function requestMoc(layer, callback) {
            var mocLayer = this.findMocSublayer(layer);
            layer.globe = this.scene;

            // Create if doesn't exist
            if (!mocLayer) {
                MocBase.createMocSublayer(layer, function (layer) {
                    callback(this.findMocSublayer(layer));
                }, function (layer) {
                    callback(this.findMocSublayer(layer));
                });
            } else {
                callback(mocLayer);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Get moc sky coverage information
         */
        function getSkyCoverage(layer, successCallback, errorCallback) {
            if (layer.coverage !== "Not available") {
                var media = "?media=txt";
                if (!layer.describeUrl) {
                    requestMocDesc(layer, function (layer) {
                        if (layer.describeUrl.lastIndexOf("?") > 0) {
                            media = "&media=txt";
                        }
                        requestSkyCoverage(layer, layer.describeUrl + media, successCallback);
                    }, errorCallback);
                }
                else {
                    if (layer.describeUrl.lastIndexOf("?") > 0) {
                        media = "&media=txt";
                    }
                    requestSkyCoverage(layer, layer.describeUrl + media, successCallback);
                }
            }
            else {
                errorCallback(layer);
            }
        }

        /**************************************************************************************************************/

        /**
         * Request sky coverage based on moc
         * @param layer
         * @param callback
         */
       function requestSkyCoverage (layer, callback) {
            this.getSkyCoverage(layer, function (layer) {
                callback(layer.coverage);
            }, function (layer) {
                callback(layer.coverage);
            });
        }

        /**************************************************************************************************************/

        /**
         *    Create moc sublayer
         *
         *    @param layer Parent layer
         */
        function createMocSublayer(layer, successCallback, errorCallback) {
            if (layer.describeUrl !== "Not available") {
                if (!layer.describeUrl) {
                    requestMocDesc(layer, function (layer) {
                        handleMocLayer(layer, layer.describeUrl);
                        var url = layer.describeUrl;
                        if (!String(url).endsWith(".fits")) {
                            url+="?media=txt"
                        }
                        requestSkyCoverage(layer, url, successCallback);
                    }, errorCallback);
                }
                else {
                    handleMocLayer(layer, layer.describeUrl);
                    var url = layer.describeUrl;
                    if (!String(url).endsWith(".fits")) {
                        url+="?media=txt"
                    }
                    requestSkyCoverage(layer, url, successCallback);
                }
            }
            else {
                errorCallback(layer);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Requesting moc sky coverage information and stock it as layer parameter
         */
        function requestSkyCoverage(layer, mocServiceUrl, successCallback) {
            if(layer.hasOwnProperty("properties") && layer.properties.hasOwnProperty("mocCoverage")){
                layer.coverage = Numeric.roundNumber(parseFloat(layer.properties.mocCoverage) * 100, 5) + "%";
            }

            if (!layer.coverage) {

                if (String(mocServiceUrl).endsWith(".fits")) {
                    FitsLoader.loadFits(mocServiceUrl, function (fits) {
                        var healpixMoc = {};
                        var binaryTable = fits.getHDU(1).data;

                        // setting startOrder with first order in dataTable
                        //self.startOrder = uniq2hpix(binaryTable.getRow(0)[binaryTable.columns[0]])[0];

                        for(var i = 0; i < binaryTable.rows; i++) {
                            var uniq = binaryTable.getRow(i);
                            var hpix = HEALPixBase.uniq2hpix(uniq[binaryTable.columns[0]]);

                            var order = hpix[0];
                            if (healpixMoc[order] === undefined) {
                                healpixMoc[order] = [];
                            }
                            healpixMoc[order].push(hpix[1]);
                        }

                        var maxOrder;
                        _.each(healpixMoc, function(pixels, order) {
                           maxOrder = parseInt(order, 10);
                        });
                        var nOrder = maxOrder + 1;

                        if (_.isNumber(response)) {
                            layer.coverage = Numeric.roundNumber(getCoverage(nOrder, healpixMoc) * 100, 5) + "%";
                        }
                        else {
                            layer.coverage = "Not available";
                        }
                        if (successCallback) {
                            successCallback(layer);
                        }
                    });

                } else {
                    // Request MOC space coverage
                    $.ajax({
                        type: "GET",
                        url: mocServiceUrl,
                        success: function (response) {
                            if (_.isNumber(response)) {
                                layer.coverage = Numeric.roundNumber(parseFloat(response), 5) + "%";
                            }
                            else {
                                layer.coverage = "Not available";
                            }
                            if (successCallback) {
                                successCallback(layer);
                            }
                        }
                    });
                }
            }
            else {
                successCallback(layer);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Handle moc layer as a sublayer
         *
         *    @param layer Parent layer
         *    @param mocServiceUrl Url to moc service
         */
        function handleMocLayer(layer, mocServiceUrl) {
            var style = layer.style;
            var serviceLayer = new MocLayer({
                serviceUrl: mocServiceUrl,
                style: layer.style,
                visible: false
            });

            serviceLayer.style.fill = true;
            serviceLayer.style.fillColor[3] = 0.3;
            // TODO: think about attachement of moc layer
            // if ( layer.globe && layer.isVisible() )
            // {
            // Add sublayer to engine
            layer.globe.addLayer(serviceLayer);
            // }

            if (!layer.subLayers) {
                layer.subLayers = [];
            }

            layer.subLayers.push(serviceLayer);
        }

        /**************************************************************************************************************/

        /**
         *    Search moc sublayer
         *    @return    Moc layer if found, null otherwise
         */
        function findMocSublayer(layer) {
            if (layer.subLayers) {
                for (var j = 0; j < layer.subLayers.length; j++) {
                    if (layer.subLayers[j] instanceof MocLayer) {
                        return layer.subLayers[j];
                    }
                }
            }
            return null;
        }

        /**************************************************************************************************************/

        /**
         *    Intersect layers
         */
        function intersectLayers(layersToIntersect) {
            // Construct url & layerNames
            var url = coverageServiceUrl;
            var layerNames = "";
            for (var i = 0; i < layersToIntersect.length; i++) {
                var layer = layersToIntersect[i];

                layerNames += layer.name;
                url += layer.describeUrl;
                if (i !== layersToIntersect.length - 1) {
                    url += ';';
                    layerNames += ' x ';
                }
            }

            // Create intersection MOC layer
            intersectionLayer = new MocLayer({
                name: "Intersection( " + layerNames + " )",
                serviceUrl: url + "&media=json",
                style: new FeatureStyle({
                    rendererHint: "Basic",
                    fill: true,
                    fillColor: [1.0, 0.0, 0.0, 0.3]
                }),
                visible: false
            });
            mizarAPI.getSkyContext().globe.addLayer(intersectionLayer);

            intersectionLayer.describeUrl = url;

            return intersectionLayer;
        }

        /** Return the fraction of the sky covered by the Moc [0..1] */
        function getCoverage(nOrder, healpixMoc) {
            var area = getArea(nOrder);
            if( area === 0 ) {
              return 0.0;
            }
            return getUsedArea(nOrder, healpixMoc) / area;
        }

        /** Return the number of low level pixels of the Moc  */
        function getUsedArea(nOrder, healpixMoc) {
            var n=0;
            var sizeCell = 1;
            for( var order=nOrder-1; order>=0; order--, sizeCell*=4) {
              n += getSize(order, healpixMoc)*sizeCell;
            }
            return n;
        }

        /** return the area of the Moc computed in pixels at the most low level */
        function getArea(nOrder) {
            if( nOrder === 0 ) {
              return 0;
            }
            var nside = pow2(nOrder-1);
            return 12*nside*nside;
        }

        /** Provide the number of Healpix pixels for a dedicated order */
        function getSize(order, healpixMoc) {
            if(healpixMoc[order]) {
                return healpixMoc[order].length;
            }
            else {
                return 0;
            }
        }

        function pow2(order) {
           return 1 << order;
        }

        /**************************************************************************************************************/

        return {
            init: function (m, options) {
                mizarAPI = m;
                coverageServiceUrl = "TODO must use AbstractLayer to get info";//options.coverageService.baseUrl;
                //TODO must use AbstractLayer to get this information
            },
            createMocSublayer: createMocSublayer,
            findMocSublayer: findMocSublayer,
            getSkyCoverage: getSkyCoverage,
            requestSkyCoverage: requestSkyCoverage,
            intersectLayers: intersectLayers
        }

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Mollweider viewer module : Sky representation in mollweide coordinate system
 */
define('Services/MollweideViewerCore',["jquery", "../Utils/Numeric", "../Renderer/Ray","../Renderer/glMatrix"],
    function ($, Numeric, Ray) {

    var mizarAPI;
    var mizarBaseUrl;
    var navigation;
    var halfPaddingX;
    var halfPaddingY;
    var halfHeight;
    var halfWidth;
    var tesselation;
    var center3d;
    var canvas;
    var context;
    var self;
    var imageObj;

    /**
     *  Newton-Raphson method to find auxiliary theta needed for mollweide x/y computation
     *  @param lat latitude
     *  @see https://en.wikipedia.org/wiki/Mollweide_projection
     *  @return theta
     */
    function _findTheta(lat) {
        // Avoid divide by zero
        if (Math.abs(lat) === Math.PI / 2) {
            return lat;
        }

        var epsilon = 0.001;
        var thetaN;  // n
        var thetaN1; // n+1

        do
        {
            thetaN = thetaN1;
            if (!thetaN) {
                thetaN = lat;
            }
            var twoThetaN = 2 * thetaN;
            thetaN1 = twoThetaN / 2 - (twoThetaN + Math.sin(twoThetaN) - Math.PI * Math.sin(lat)) / (2 + 2 * Math.cos(twoThetaN));
        } while (Math.abs(thetaN1 - thetaN) >= epsilon);

        return thetaN1;
    }

    /**********************************************************************************************/

    /**
     *  Canvas 2D point
     *  @param {Object} options
     *      <ul>
     *          <li>options : x,y, color, size</li>
     */
    var Point = function (options) {
        this.x = options.x | 0;
        this.y = options.y | 0;
        this.color = options.color | "rgb(255,0,0)";
        this.size = options.size | 2;
        for (var x in options) {
            if(options.hasOwnProperty(x)) {
                this[x] = options[x];
            }
        }
    };

    /**********************************************************************************************/

    /**
     *  Compute mollweide position for given 3D position
     *  @param {Array} pos position
     *  @return {Array} x,y coordinates
     */
    function computeMollweidePosition(pos) {
        var coordinateSystem = mizarAPI.getCrs();
        var geoPos = coordinateSystem.getWorldFrom3D(pos);
        if(geoPos[0] > 180)
            geoPos[0]-=360;
        //var geoPos = coordinateSystem.from3DToEquatorial(pos, null, false);
        //geoPos = coordinateSystem.convert(geoPos, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());
        //geoPos = coordinateSystem.fromEquatorialToGeo(geoPos, null, false);

        var lambda = geoPos[0] * Math.PI / 180; // longitude
        var theta0 = geoPos[1] * Math.PI / 180;  // latitude

        var auxTheta = _findTheta(theta0);

        // Transfrom to Mollweide coordinate system
        var mollX = 2 * Math.sqrt(2) / Math.PI * lambda * Math.cos(auxTheta);
        var mollY = Math.sqrt(2) * Math.sin(auxTheta);

        // Transform to image space
        //    2.8: max x value in Mollweide projection
        //    1.38: max y value in Mollweide projection
        var x = -mollX * halfWidth / 2.8 + halfWidth + halfPaddingX;
        var y = -mollY * halfHeight / 1.38 + halfHeight + halfPaddingY;

        return [x, y];
    }

    /**********************************************************************************************/

    /**
     *  Update navigation eye for the given mouse coordinates
     *  @param {Array} moll
     */
    function updateNavigation(moll) {
        // Transform to Mollweide space
        center3d.x = -( moll[0] - halfWidth - halfPaddingX ) * 2.8 / halfWidth;
        center3d.y = -( moll[1] - halfHeight - halfPaddingY ) * 1.38 / halfHeight;

        // Transform to geographic coordinate system
        // http://mathworld.wolfram.com/MollweideProjection.html
        var auxTheta = Math.asin(center3d.y / Math.sqrt(2));

        var phi = Math.asin((2 * auxTheta + Math.sin(2 * auxTheta)) / Math.PI);
        var lambda = (Math.PI * center3d.x) / ( 2 * Math.sqrt(2) * Math.cos(auxTheta));

        var geo = [lambda * 180 / Math.PI, phi * 180 / Math.PI];

        // Update navigation
        mizarAPI.getCrs().get3DFromWorld(geo, navigation.center3d);

        navigation.computeViewMatrix();
    }

    /**********************************************************************************************/

    /**
     *  Function updating the position of center of camera on mollweide element
     */
    function updateMollweideFov() {
        // Reinit canvas
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
        context.drawImage(imageObj, 0, 0);

        // Draw fov
        context.fillStyle = "rgb(255,0,0)";
        var stepX = mizarAPI.getRenderContext().canvas.clientWidth / (tesselation - 1);
        var stepY = mizarAPI.getRenderContext().canvas.clientHeight / (tesselation - 1);

        var ray;
        var pos3d;
        var mPos;
        for (var i = 0; i < tesselation; i++) {
            // Width
            for (var j = 0; j < tesselation; j++) {
                // Height
                ray = Ray.createFromPixel(mizarAPI.getRenderContext(), i * stepX, j * stepY);
                pos3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], mizarAPI.getCrs().getGeoide().getRadius()));

                mPos = computeMollweidePosition(pos3d);

                // Draw on canvas 2d
                context.fillRect(mPos[0], mPos[1], 2, 2);
            }
        }

        // Draw center
        context.fillStyle = center3d.color;
        mPos = computeMollweidePosition(navigation.center3d);
        center3d.x = mPos[0] - center3d.size / 2;
        center3d.y = mPos[1] - center3d.size / 2;

        // Draw on canvas 2d
        context.fillRect(mPos[0] - center3d.size / 2, mPos[1] - center3d.size / 2, center3d.size, center3d.size);

        // Update fov degrees
        var fov = navigation.getFov();
        var fovx = Numeric.roundNumber(fov[0], 2);
        fovx = mizarAPI.getCrs().fromDegreesToDMS(fovx);
        var fovy = Numeric.roundNumber(fov[1], 2);
        fovy = mizarAPI.getCrs().fromDegreesToDMS(fovy);
        $('#fov').html("Fov : " + fovx + " x " + fovy);
    }

    function updateGalaxyProjection(ctx) {
        $(self.getImageObj()).attr("src", mizarBaseUrl + "css/images/MollweideSky_" + ctx.getCoordinateSystem().getGeoideName() + ".png");
    }

    /**********************************************************************************************/

    return {
        init: function (options) {
            mizarAPI = options.mizar;
            mizarBaseUrl = options.mizarBaseUrl;

            // Init options
            navigation = mizarAPI.getActivatedContext().getNavigation();
            halfPaddingX = 16;
            halfPaddingY = 8;

            // Grid background dimensions
            halfHeight = 50;
            halfWidth = 100;

            // Level of tesselation to represent fov
            tesselation = 9; // Must be >= 2

            // Center of fov
            center3d = new Point({
                size: 5,
                color: "rgb(255,255,0)"
            });

            // Init image background
            canvas = document.getElementById('mollweideCanvas');
            context = canvas.getContext('2d');
            self = this;

            imageObj = new Image();
            imageObj.onload = function () {
                context.drawImage(imageObj, 0, 0);
                updateMollweideFov(imageObj);
            };
        },
        getImageObj: function () {
            return imageObj;
        },
        _findTheta: _findTheta,
        computeMollweidePosition: computeMollweidePosition,
        updateNavigation: updateNavigation,
        updateMollweideFov: updateMollweideFov,
        updateGalaxyProjection: updateGalaxyProjection
    };

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Services/PickingManagerCore',["../Renderer/FeatureStyle", "../Layer/OpenSearchLayer", "../Utils/Utils","../Utils/UtilsIntersection","../Utils/Constants"],
    function (FeatureStyle, OpenSearchLayer, Utils, UtilsIntersection, Constants) {

        var ctx;
        var globe;

        var pickableLayers = [];
        var selection = [];
        var stackSelectionIndex = -1;

        var selectedStyle = new FeatureStyle({
            strokeColor: [1.0, 1.0, 0.0, 1.0],
            fillColor: [1.0, 1.0, 0.0, 1.0],
            zIndex: 1
        });

        /**************************************************************************************************************/

        /**
         *    Add pickable layer to the pickableLayers list
         *    @function addPickableLayer
         *    @param {AbstractLayer} layer
         */
        function addPickableLayer(layer) {
            if (pickableLayers.indexOf(layer) === -1) {
                pickableLayers.push(layer);
            }
            else {
                console.log("WARN:" + layer.name + " has been already added");
            }
        }

        /**************************************************************************************************************/

        /**
         *    Remove pickable layers
         *    @param {AbstractLayer} layer
         */
        function removePickableLayer(layer) {
            for (var i = 0; i < pickableLayers.length; i++) {
                if (layer.id === pickableLayers[i].id) {
                    pickableLayers.splice(i, 1);
                }
            }
        }

        /**************************************************************************************************************/

        /**
         * Get the list of pickable layers
         * @returns {Array} pickableLayers
         */
        function getPickableLayers() {
            return pickableLayers;
        }

        /**************************************************************************************************************/

        /**
         *    Revert style of selected feature
         */
        function blurSelectedFeature() {
            var selectedData = this.getSelection()[this.stackSelectionIndex];
            if (selectedData) {
                var style = new FeatureStyle(selectedData.feature.properties.style);
                switch (selectedData.feature.geometry.type) {
                    case Constants.GEOMETRY.LineString:
                    case Constants.GEOMETRY.MultiLineString:
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:
                        style.strokeColor = selectedData.layer.style.strokeColor;
                        break;
                    case Constants.GEOMETRY.Point:
                        // Use stroke color while reverting
                        style.fillColor = selectedData.feature.properties.style.strokeColor;
                        break;
                    default:
                        break;
                }
                style.zIndex = selectedData.layer.style.zIndex;
                selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Apply selected style to the feature by the given index in selection array
         *
         *    @param index Index of feature in selection array
         *    @param options
         *        <li>isExclusive : Boolean indicating if the focus is exclusive</li>
         *        <li>color : Highlight color</li>
         */
        function focusFeatureByIndex(index, options) {
            if (options && options.isExclusive) {
                blurSelection();
            }

            // Update highlight color
            var strokeColor = options.color ? FeatureStyle.fromStringToColor(options.color) : this.selectedStyle.strokeColor;
            var fillColor = options.color ? FeatureStyle.fromStringToColor(options.color) : this.selectedStyle.fillColor;

            var selectedData = this.getSelection()[index];
            if (selectedData) {
                this.stackSelectionIndex = index;
                var style = new FeatureStyle(selectedData.feature.properties.style);
                switch (selectedData.feature.geometry.type) {
                    case Constants.GEOMETRY.LineString:
                    case Constants.GEOMETRY.MultiLineString:
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:
                        style.strokeColor = strokeColor;
                        break;
                    case Constants.GEOMETRY.Point:
                        style.fillColor = fillColor;
                        break;
                    default:
                        break;
                }
                style.zIndex = this.selectedStyle.zIndex;
                selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
            }
            globe.refresh();
        }

        /**************************************************************************************************************/

        /**
         * Get the current selection
         * @returns {Array}
         */
        function getSelection() {
            return selection;
        }

        /**************************************************************************************************************/

        /**
         *    Revert style of selection
         */
        function blurSelection() {
            for (var i = 0; i < this.getSelection().length; i++) {
                var selectedData = this.getSelection()[i];
                var style = new FeatureStyle(selectedData.feature.properties.style);
                switch (selectedData.feature.geometry.type) {
                    case Constants.GEOMETRY.LineString:
                    case Constants.GEOMETRY.MultiLineString:
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:
                        style.strokeColor = selectedData.layer.style.strokeColor;
                        break;
                    case Constants.GEOMETRY.Point:
                        // Use stroke color while reverting
                        style.fillColor = selectedData.feature.properties.style.strokeColor;
                        break;
                    default:
                        break;
                }
                style.zIndex = selectedData.layer.style.zIndex;

                if (selectedData.layer.globe) {
                    // Layer is still attached to globe
                    selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
                }
            }
        }

        /**************************************************************************************************************/

        /**
         *    Apply style to selection
         *    @param {Array} newSelection selection of data
         */
        function focusSelection(newSelection) {
            var style;
            for (var i = 0; i < newSelection.length; i++) {
                var selectedData = newSelection[i];

                if (selectedData.feature.properties.style) {
                    style = new FeatureStyle(selectedData.feature.properties.style);
                }
                else {
                    style = new FeatureStyle(selectedData.layer.style);
                }

                switch (selectedData.feature.geometry.type) {
                    case Constants.GEOMETRY.LineString:
                    case Constants.GEOMETRY.MultiLineString:
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:
                        style.strokeColor = this.selectedStyle.strokeColor;
                        break;
                    case Constants.GEOMETRY.Point:
                        style.fillColor = this.selectedStyle.fillColor;
                        break;
                    default:
                        break;
                }
                style.zIndex = this.selectedStyle.zIndex;
                selectedData.layer.modifyFeatureStyle(selectedData.feature, style);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Clear selection
         */
        function clearSelection() {
            this.blurSelection();
            this.setSelection([]);
        }

        /**************************************************************************************************************/

        /**
         * Check if a geometry crosses the date line
         * @param {Array} pickPoint
         * @param {Array}coords
         * @returns {Array} coords
         */
        function fixDateLine(pickPoint, coords) {
            var crossDateLine = false;
            var startLon = coords[0][0];
            for (var i = 1; i < coords.length && !crossDateLine; i++) {
                var deltaLon = Math.abs(coords[i][0] - startLon);
                if (deltaLon > 180) {
                    // DateLine!
                    crossDateLine = true;
                }
            }
            var n;
            if (crossDateLine) {
                var fixCoords = [];

                if (pickPoint[0] < 0.0) {
                    // Ensure coordinates are always negative
                    for (n = 0; n < coords.length; n++) {
                        if (coords[n][0] > 0) {
                            fixCoords[n] = [coords[n][0] - 360, coords[n][1]];
                        } else {
                            fixCoords[n] = [coords[n][0], coords[n][1]];
                        }
                    }
                }
                else {
                    // Ensure coordinates are always positive
                    for (n = 0; n < coords.length; n++) {
                        if (coords[n][0] < 0) {
                            fixCoords[n] = [coords[n][0] + 360, coords[n][1]];
                        } else {
                            fixCoords[n] = [coords[n][0], coords[n][1]];
                        }
                    }
                }

                return fixCoords;
            }
            else {
                return coords;
            }
        }

        /**************************************************************************************************************/

        /**
         * Picking test for feature depending on its geometry type
         * @param {Object} feature
         * @param {Array} pickPoint
         * @returns {Boolean} isPicked
         */
        function featureIsPicked(feature, pickPoint) {
            var i,j,p;
            var feat,featNext,ring;
            switch (feature.geometry.type) {
                case Constants.GEOMETRY.LineString:
                    for (i = 0; i < feature.geometry.coordinates.length - 1; i++) {
                        feat = feature.geometry.coordinates[i];
                        featNext = feature.geometry.coordinates[i + 1];
                        if (UtilsIntersection.pointInLine(pickPoint, feat, featNext)) {
                            return true;
                        }
                    }
                    //var ring = this.fixDateLine(pickPoint, feature['geometry']['coordinates'][0]);
                    break;
                case Constants.GEOMETRY.MultiLineString:
                    for (i = 0; i < feature.geometry.coordinates.length; i++) {
                        for (j = 0; j < feature.geometry.coordinates[i].length - 1; j++) {
                            feat = feature.geometry.coordinates[i][j];
                            featNext = feature.geometry.coordinates[i][j + 1];
                            if (UtilsIntersection.pointInLine(pickPoint, feat, featNext)) {
                                return true;
                            }
                        }
                    }
                    break;
                case Constants.GEOMETRY.Polygon:
                    ring = this.fixDateLine(pickPoint, feature.geometry.coordinates[0]);
                    return UtilsIntersection.pointInRing(pickPoint, ring);
                case Constants.GEOMETRY.MultiPolygon:
                    for (p = 0; p < feature.geometry.coordinates.length; p++) {
                        ring = this.fixDateLine(pickPoint, feature.geometry.coordinates[p][0]);
                        if (UtilsIntersection.pointInRing(pickPoint, ring)) {
                            return true;
                        }
                    }
                    return false;
                case Constants.GEOMETRY.Point:
                    var point = feature.geometry.coordinates;
                    // Do not pick the labeled features
                    var isLabel = feature.properties.style && feature.properties.style.label;
                    return UtilsIntersection.pointInSphere(ctx, pickPoint, point, feature.geometry._bucket.textureHeight) && !isLabel;
                default:
                    console.log("Picking for " + feature.geometry.type + " is not implemented yet");
                    return false;
            }
        }

        /**************************************************************************************************************/

        /**
         * Compute the selection at the picking point
         * @param {Array} pickPoint
         * @return {Array} newSelection
         */
        function computePickSelection(pickPoint) {

            if (!pickPoint) {
                return [];
            }
            var i,j,feature;
            var newSelection = [];
            for (i = 0; i < this.getPickableLayers().length; i++) {
                var selectedTile = globe.tileManager.getVisibleTile(pickPoint[0], pickPoint[1]);
                var pickableLayer = this.getPickableLayers()[i];
                if (pickableLayer.isVisible() && pickableLayer.globe === globe) {
                    if (pickableLayer instanceof OpenSearchLayer) {
                        // Extension using layer
                        // Search for features in each tile
                        var tile = selectedTile;
                        var tileData = tile.extension[pickableLayer.extId];

                        if (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED) {
                            while (tile.parent && (!tileData || tileData.state !== OpenSearchLayer.TileState.LOADED)) {
                                tile = tile.parent;
                                tileData = tile.extension[pickableLayer.extId];
                            }
                        }

                        if (tileData) {
                            for (j = 0; j < tileData.featureIds.length; j++) {
                                feature = pickableLayer.features[pickableLayer.featuresSet[tileData.featureIds[j]].index];
                                if (this.featureIsPicked(feature, pickPoint)) {
                                    newSelection.push({feature: feature, layer: pickableLayer});
                                }
                            }
                        }
                    }
                    else {
                        // Vector layer
                        // Search for picked features
                        for (j = 0; j < pickableLayer.features.length; j++) {
                            feature = pickableLayer.features[j];
                            if (this.featureIsPicked(feature, pickPoint)) {
                                newSelection.push({feature: feature, layer: pickableLayer});
                            }
                        }
                    }
                }

                // Add selected tile to selection to be able to make the requests by tile
                // (actually used for asteroids search)
                newSelection.selectedTile = selectedTile;
            }

            return newSelection;
        }

        /**************************************************************************************************************/

        /**
         * Set selection list with passed selection
         * @param {Array} sel selection
         */
        function setSelection(sel) {
            selection = sel;
            return selection;
        }

        /**************************************************************************************************************/

        /**
         *    Highlight the given feature
         *
         *    @param featureData
         *        Feature data is an object composed by feature and its layer
         *    @param options
         *        Focus feature options(isExclusive and color)
         *
         *    // TODO : maybe it's more intelligent to store layer reference on feature ?
         */
        function highlightObservation(featureData, options) {
            selection.push(featureData);
            focusFeatureByIndex(selection - 1, options);
        }

        function updateContext(context) {
            ctx = context;
            globe = context.globe;
        }

        /**************************************************************************************************************/

        return {
            selectedStyle: selectedStyle,
            stackSelectionIndex: stackSelectionIndex,
            init: function (context) {
                ctx = context;
                globe = context.globe;
            },
            addPickableLayer: addPickableLayer,
            removePickableLayer: removePickableLayer,
            getPickableLayers: getPickableLayers,
            blurSelectedFeature: blurSelectedFeature,
            focusFeatureByIndex: focusFeatureByIndex,
            getSelection: getSelection,
            blurSelection: blurSelection,
            focusSelection: focusSelection,
            clearSelection: clearSelection,
            fixDateLine: fixDateLine,
            featureIsPicked: featureIsPicked,
            computePickSelection: computePickSelection,
            setSelection: setSelection,
            highlightObservation: highlightObservation,
            updateContext: updateContext
        };
    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/*global define: false */

/**
 *    JSON processor module
 *
 *    Module processing feature collection
 *
 */
define('Parser/JsonProcessor',["../Layer/HipsGraphicLayer", "../Utils/Constants", "../Crs/CoordinateSystemFactory"], function (HipsLayer, Constants, CoordinateSystemFactory) {
    var gid = 0;

    /**
     *    Handle services of feature
     */
    function handleServices(gwLayer, feature) {
        console.log("hop", gwLayer);
        for (var x in feature.services) {
            var service = feature.services[x];
            if (!gwLayer.subLayers) {
                gwLayer.subLayers = [];
            }
            switch (service.type) {
                case Constants.LAYER.Hips:
                    service.layer = new HipsLayer({
                        format: service.format,
                        baseUrl: service.url,
                        name: service.name,
                        visible: false,
                        coordinates: feature.geometry.coordinates[0]
                    });
                    gwLayer.subLayers.push(service.layer);
                    if (gwLayer.planet && gwLayer.visible()) {
                        // Add sublayer to engine
                        gwLayer.planet.addLayer(service.layer);
                    }
                    break;
                default:
                    break;
            }
        }
    }

    return {
        /**
         *    Handles feature collection
         *    Recompute geometry from equatorial coordinates to geo for each feature
         *    Handle feature services
         *    Add gid
         *
         *    @param gwLayer Layer of feature
         *    @param featureCollection GeoJSON FeatureCollection
         *
         */
        handleFeatureCollection: function (gwLayer, featureCollection) {
            // Default CRS according to GeoJSON specification
            var defaultCrs = {
                type: "name",
                properties: {
                    name: Constants.CRS.WGS84
                }
            };

            if ((featureCollection === null) || (featureCollection === undefined)) {
                throw new ReferenceError("Error, featureCollection is null", "JsonProcessor.js");
            }
            
            //check if crs is global at the featureCollection
            var crs = (featureCollection.crs) ? featureCollection.crs : defaultCrs;

            gwLayer.coordinateSystem = CoordinateSystemFactory.create({geoideName:crs.properties.name});

            var features = featureCollection.features;
            if ((features === null) || (features === undefined)) {
                console.log("Error, no feature in featureCollection : ", featureCollection);
                return;
            }
            var i, j, r;

            for (i = 0; i < features.length; i++) {
                var currentFeature = features[i];

                switch (currentFeature.geometry.type) {
                    case Constants.GEOMETRY.Point:
                        if (!gwLayer.dataType) {
                            gwLayer.dataType = "point";
                        } else {
                            if (gwLayer.dataType !== 'point') {
                                gwLayer.dataType = "none";
                            }
                        }
                        break;
                    case Constants.GEOMETRY.Polygon:
                    case Constants.GEOMETRY.MultiPolygon:

                        if (!gwLayer.dataType) {
                            gwLayer.dataType = "line";
                        } else {
                            if (gwLayer.dataType !== 'line') {
                                gwLayer.dataType = "none";
                            }
                        }

                        if (currentFeature.properties._imageCoordinates) {
                            // Set _imageCoordinates as geometry's property (may be modified later)
                            currentFeature.geometry._imageCoordinates = currentFeature.properties._imageCoordinates;
                        }

                        break;
                    default:
                        break;
                }
                if (!currentFeature.geometry.crs) {
                    currentFeature.geometry.crs = crs;
                }
                currentFeature.geometry.gid = "jsonProc_" + gid;
                gid++;

                if (currentFeature.services) {
                    handleServices(gwLayer, currentFeature);
                }
            }
        }
    };

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('Gui/dialog/ErrorDialog',["jquery", "jquery.ui"], function ($) {

// The main div for error
    var errorDiv = '<div id="errorDiv" style="text-align: left" title="Error"></div>';

// Create the div, use jQuery UI dialog

    var $text = "";
    var $buttonName = "";

    var $errorDiv = $(errorDiv)
        .appendTo('body')
        .dialog({
            autoOpen: false,
            width: 700,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: 'errorBox'
            //beforeClose: function( event, ui ) { $text = ""; }
        });
    var $active = false;
    var $displayWarning = false;
    var $displayDebug = false;

    _recordError = function(html) {
        $text += html + "<br/>";
        if ($('#warningContainer')) {
            $('#warningContainer').show();
            $errorDiv.on('dialogclose', function (event) {
                if($buttonName) {
                    $buttonName.hide();
                }
            });
        }
        if ($active === true) {
            $errorDiv
                .html($text)
                .dialog("open");
            $errorDiv.scrollTop(5000);
        }
    };

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function (html, debug) {
            if(debug != null) {
                debug = false;
            }
            if (debug && $displayDebug) {
                // debug mode for developers
                _recordError(html);
            } else if (!debug && $displayWarning === true) {
                //user mode : user needs to known when a problem happens with data
                _recordError(html)
            }
        },
        view: function () {
            $errorDiv
                .html($text)
                .dialog("open");

            $errorDiv.scrollTop(5000);
            $active = true;
        },
        hide: function () {
            $errorDiv.dialog("close");
            $active = false;
        },
        isActive: function () {
            return $active;
        },
        setDisplayWarning: function (value) {
            $displayWarning = value;
        },
        setDisplayDebug: function (value) {
            $displayDebug = value;
        },
        setIcon : function(buttonName) {
            $buttonName = $(buttonName);
        }
    };

});

// samp
// ----
// Provides capabilities for using the SAMP Web Profile from JavaScript.
// Exported tokens are in the samp.* namespace.
// Inline documentation is somewhat patchy (partly because I don't know
// what javascript documentation is supposed to look like) - it is
// suggested to use it conjunction with the provided examples,
// currently visible at http://astrojs.github.com/sampjs/
// (gh-pages branch of github sources).

var samp = (function() {

    // Constants defining well-known location of SAMP Web Profile hub etc.
    var WEBSAMP_PORT = 21012;
    var WEBSAMP_PATH = "/";
    var WEBSAMP_PREFIX = "samp.webhub.";
    var WEBSAMP_CLIENT_PREFIX = "";

    // Tokens representing permissible types in a SAMP object (e.g. a message)
    TYPE_STRING = "string";
    TYPE_LIST = "list";
    TYPE_MAP = "map";

    var heir = function(proto) {
        function F() {};
        F.prototype = proto;
        return new F();
    };

    // Utility functions for navigating DOM etc.
    // -----------------------------------------

    var getSampType = function(obj) {
        if (typeof obj === "string") {
            return TYPE_STRING;
        }
        else if (obj instanceof Array) {
            return TYPE_LIST;
        }
        else if (obj instanceof Object && obj !== null) {
            return TYPE_MAP;
        }
        else {
            throw new Error("Not legal SAMP object type: " + obj);
        }
    };
    var getChildElements = function(el, childTagName) {
        var children = el.childNodes;
        var child;
        var childEls = [];
        var i;
        for (i = 0; i < children.length; i++) {
            child = children[i];
            if (child.nodeType === 1) {  // Element
                if (childTagName && (child.tagName !== childTagName)) {
                    throw new Error("Child <" + children[i].tagName + ">"
                                  + " of <" + el.tagName + ">"
                                  + " is not a <" + childTagName + ">");
                }
                childEls.push(child);
            }
        }
        return childEls;
    };
    var getSoleChild = function(el, childTagName) {
        var children = getChildElements(el, childTagName);
        if (children.length === 1 ) {
            return children[0];
        }
        else {
            throw new Error("No sole child of <" + el.tagName + ">");
        }
    };
    var getTextContent = function(el) {
        var txt = "";
        var i;
        var child;
        for (i = 0; i < el.childNodes.length; i++ ) {
            child = el.childNodes[i];
            if (child.nodeType === 1) {           // Element 
                throw new Error("Element found in text content");
            }
            else if (child.nodeType === 3 ||      // Text
                     child.nodeType === 4 ) {     // CDATASection
                txt += child.nodeValue;
            }
        }
        return txt;
    };
    var stringify = function(obj) {
        return typeof JSON === "undefined" ? "..." : JSON.stringify(obj);
    };

    // XmlRpc class:
    // Utilities for packing and unpacking XML-RPC messages.
    // See xml-rpc.com.

    var XmlRpc = {};

    // Takes text and turns it into something suitable for use as the content
    // of an XML-RPC string - special characters are escaped.
    XmlRpc.escapeXml = function(s) {
        return s.replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;");
    };

    // Asserts that the elements of paramList match the types given by typeList.
    // TypeList must be an array containing only TYPE_STRING, TYPE_LIST
    // and TYPE_MAP objects in some combination.  paramList must be the
    // same length.
    // In case of mismatch an error is thrown.
    XmlRpc.checkParams = function(paramList, typeList) {
        var i;
        for (i = 0; i < typeList.length; i++) {
            if (typeList[i] !== TYPE_STRING &&
                typeList[i] !== TYPE_LIST &&
                typeList[i] !== TYPE_MAP) {
                throw new Error("Unknown type " + typeList[i]
                              + " in check list");
            }
        }
        var npar = paramList.length;
        var actualTypeList = [];
        var ok = true;
        for (i = 0; i < npar; i++) {
            actualTypeList.push(getSampType(paramList[i]));
        }
        ok = ok && (typeList.length === npar);
        for (i = 0; ok && i < npar; i++ ) {
            ok = ok && typeList[i] === actualTypeList[i];
        }
        if (!ok) {
            throw new Error("Param type list mismatch: " 
                          + "[" + typeList + "] != "
                          + "[" + actualTypeList + "]");
        }
    };

    // Turns a SAMP object (structure of strings, lists, maps) into an
    // XML string suitable for use with XML-RPC.
    XmlRpc.valueToXml = function v2x(obj, prefix) {
        prefix = prefix || "";
        var a;
        var i;
        var result;
        var type = getSampType(obj);
        if (type === TYPE_STRING) {
            return prefix
                 + "<value><string>"
                 + XmlRpc.escapeXml(obj)
                 + "</string></value>";
        }
        else if (type === TYPE_LIST) {
            result = [];
            result.push(prefix + "<value>",
                        prefix + "  <array>",
                        prefix + "    <data>");
            for (i = 0; i < obj.length; i++) {
                result.push(v2x(obj[i], prefix + "      "));
            }
            result.push(prefix + "    </data>",
                        prefix + "  </array>",
                        prefix + "</value>");
          
            return result.join("\n");
        }
        else if (type === TYPE_MAP) {
            result = [];
            result.push(prefix + "<value>");
            result.push(prefix + "  <struct>");
            for (i in obj) {
                result.push(prefix + "    <member>");
                result.push(prefix + "      <name>"
                          + XmlRpc.escapeXml(i)
                          + "</name>");
                result.push(v2x(obj[i], prefix + "      "));
                result.push(prefix + "    </member>");
            }
            result.push(prefix + "  </struct>");
            result.push(prefix + "</value>");
            return result.join("\n");
        }
        else {
            throw new Error("bad type");  // shouldn't get here
        }
    };

    // Turns an XML string from and XML-RPC message into a SAMP object
    // (structure of strings, lists, maps).
    XmlRpc.xmlToValue = function x2v(valueEl, allowInt) {
        var childEls = getChildElements(valueEl);
        var i;
        var j;
        var txt;
        var node;
        var childEl;
        var elName;
        if (childEls.length === 0) {
            return getTextContent(valueEl);
        }
        else if (childEls.length === 1) {
            childEl = childEls[0];
            elName = childEl.tagName;
            if (elName === "string") {
                return getTextContent(childEl);
            }
            else if (elName === "array") {
                var valueEls =
                    getChildElements(getSoleChild(childEl, "data"), "value");
                var list = [];
                for (i = 0; i < valueEls.length; i++) {
                    list.push(x2v(valueEls[i], allowInt));
                }
                return list;
            }
            else if (elName === "struct") {
                var memberEls = getChildElements(childEl, "member");
                var map = {};
                var s_name;
                var s_value;
                var jc;
                for (i = 0; i < memberEls.length; i++) {
                    s_name = undefined;
                    s_value = undefined;
                    for (j = 0; j < memberEls[i].childNodes.length; j++) {
                        jc = memberEls[i].childNodes[j];
                        if (jc.nodeType == 1) {
                            if (jc.tagName === "name") {
                                s_name = getTextContent(jc);
                            }
                            else if (jc.tagName === "value") {
                                s_value = x2v(jc, allowInt);
                            }
                        }
                    }
                    if (s_name !== undefined && s_value !== undefined) {
                        map[s_name] = s_value;
                    }
                    else {
                        throw new Error("No <name> and/or <value> "
                                      + "in <member>?");
                    }
                }
                return map;
            }
            else if (allowInt && (elName === "int" || elName === "i4")) {
                return getTextContent(childEl);
            }
            else {
                throw new Error("Non SAMP-friendly value content: "
                              + "<" + elName + ">");
            }
        }
        else {
            throw new Error("Bad XML-RPC <value> content - multiple elements");
        }
    };

    // Turns the content of an XML-RPC <params> element into an array of
    // SAMP objects.
    XmlRpc.decodeParams = function(paramsEl) {
        var paramEls = getChildElements(paramsEl, "param");
        var i;
        var results = [];
        for (i = 0; i < paramEls.length; i++) {
            results.push(XmlRpc.xmlToValue(getSoleChild(paramEls[i], "value")));
        }
        return results;
    };

    // Turns the content of an XML-RPC <fault> element into an XmlRpc.Fault
    // object.
    XmlRpc.decodeFault = function(faultEl) {
        var faultObj = XmlRpc.xmlToValue(getSoleChild(faultEl, "value"), true);
        return new XmlRpc.Fault(faultObj.faultString, faultObj.faultCode);
    };

    // Turns an XML-RPC response element (should be <methodResponse>) into
    // either a SAMP response object or an XmlRpc.Fault object.
    // Note that a fault response does not throw an error, so check for
    // the type of the result if you want to know whether a fault occurred.
    // An error will however be thrown if the supplied XML does not
    // correspond to a legal XML-RPC response.
    XmlRpc.decodeResponse = function(xml) {
        var mrEl = xml.documentElement;
        if (mrEl.tagName !== "methodResponse") {
            throw new Error("Response element is not <methodResponse>");
        }
        var contentEl = getSoleChild(mrEl);
        if (contentEl.tagName === "fault") {
            return XmlRpc.decodeFault(contentEl);
        }
        else if (contentEl.tagName === "params") {
            return XmlRpc.decodeParams(contentEl)[0];
        }
        else {
            throw new Error("Bad XML-RPC response - unknown element"
                          + " <" + contentEl.tagName + ">");
        }
    };

    // XmlRpc.Fault class:
    // Represents an XML-RPC Fault response.
    XmlRpc.Fault = function(faultString, faultCode) {
        this.faultString = faultString;
        this.faultCode = faultCode;
    };
    XmlRpc.Fault.prototype.toString = function() {
        return "XML-RPC Fault (" + this.faultCode + "): " + this.faultString;
    };

    // XmlRpcRequest class:
    // Represents an call which can be sent to an XML-RPC server.
    var XmlRpcRequest = function(methodName, params) {
        this.methodName = methodName;
        this.params = params || [];
    }
    XmlRpcRequest.prototype.toString = function() {
        return this.methodName + "(" + stringify(this.params) + ")";
    };
    XmlRpcRequest.prototype.addParam = function(param) {
        this.params.push(param);
        return this;
    };
    XmlRpcRequest.prototype.addParams = function(params) {
        var i;
        for (i = 0; i < params.length; i++) {
            this.params.push(params[i]);
        }
        return this;
    };
    XmlRpcRequest.prototype.checkParams = function(typeList) {
        XmlRpc.checkParams(this.params, typeList);
    };
    XmlRpcRequest.prototype.toXml = function() {
        var lines = [];
        lines.push(
           "<?xml version='1.0'?>",
           "<methodCall>",
           "  <methodName>" + this.methodName + "</methodName>",
           "  <params>");
        for (var i = 0; i < this.params.length; i++) {
            lines.push("    <param>",
                       XmlRpc.valueToXml(this.params[i], "      "),
                       "    </param>");
        }
        lines.push(
           "  </params>",
           "</methodCall>");
        return lines.join("\n");
    };

    // XmlRpcClient class:
    // Object capable of sending XML-RPC calls to an XML-RPC server.
    // That server will typically reside on the host on which the
    // javascript is running; it is not likely to reside on the host
    // which served the javascript.  That means that sandboxing restrictions
    // will be in effect.  Much of the work done here is therefore to
    // do the client-side work required to potentially escape the sandbox.
    // The endpoint parameter, if supplied, is the URL of the XML-RPC server.
    // If absent, the default SAMP Web Profile server is used.
    var XmlRpcClient = function(endpoint) {
        this.endpoint = endpoint ||
                        "http://localhost:" + WEBSAMP_PORT + WEBSAMP_PATH;
    };

    // Creates an XHR facade - an object that presents an interface
    // resembling that of an XMLHttpRequest Level 2.
    // This facade may be based on an actual XMLHttpRequest Level 2 object
    // (on browsers that support it), or it may fake one using other
    // available technology.
    //
    // The created facade in any case presents the following interface:
    //
    //    open(method, url)
    //    send(body)
    //    abort()
    //    setContentType()
    //    responseText
    //    responseXML
    //    onload
    //    onerror(err)  - includes timeout; abort is ignored
    //
    // See the documentation at http://www.w3.org/TR/XMLHttpRequest/
    // for semantics.
    //
    // XMLHttpRequest Level 2 supports Cross-Origin Resource Sharing (CORS)
    // which makes sandbox evasion possible.  Faked XHRL2s returned by
    // this method may use CORS or some other technology to evade the
    // sandbox.  The SAMP hub itself may selectively allow some of these
    // technologies and not others, according to configuration.
    XmlRpcClient.createXHR = function() {

        // Creates an XHR facade based on a genuine XMLHttpRequest Level 2.
        var XhrL2 = function(xhr) {
            this.xhr = xhr;
            xhr.onreadystatechange = (function(l2) {
                return function() {
                    if (xhr.readyState !== 4) {
                        return;
                    }
                    else if (!l2.completed) {
                        if (+xhr.status === 200) {
                            l2.completed = true;
                            l2.responseText = xhr.responseText;
                            l2.responseXML = xhr.responseXML;
                            if (l2.onload) {
                                l2.onload();
                            }
                        }
                    }
                };
            })(this);
            xhr.onerror = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            if (event) {
                                event.toString = function() {return "No hub?";};
                            }
                            else {
                                event = "No hub?";
                            }
                            l2.onerror(event);
                        }
                    }
                };
            })(this);
            xhr.ontimeout = (function(l2) {
                return function(event) {
                    if (!l2.completed) {
                        l2.completed = true;
                        if (l2.onerror) {
                            l2.onerror("timeout");
                        }
                    }
                };
            })(this);
        };
        XhrL2.prototype.open = function(method, url) {
            this.xhr.open(method, url);
        };
        XhrL2.prototype.send = function(body) {
            this.xhr.send(body);
        };
        XhrL2.prototype.abort = function() {
            this.xhr.abort();
        }
        XhrL2.prototype.setContentType = function(mimeType) {
            if ("setRequestHeader" in this.xhr) {
                this.xhr.setRequestHeader("Content-Type", mimeType);
            }
        }

        // Creates an XHR facade based on an XDomainRequest (IE8+ only).
        var XdrL2 = function(xdr) {
            this.xdr = xdr;
            xdr.onload = (function(l2) {
                return function() {
                    var e;
                    l2.responseText = xdr.responseText;
                    if (xdr.contentType === "text/xml" ||
                        xdr.contentType === "application/xml" ||
                        /\/x-/.test(xdr.contentType)) {
                        try {
                            var xdoc = new ActiveXObject("Microsoft.XMLDOM");
                            xdoc.loadXML(xdr.responseText);
                            l2.responseXML = xdoc;
                        }
                        catch (e) {
                            l2.responseXML = e;
                        }
                    }
                    if (l2.onload) {
                        l2.onload();
                    }
                };
            })(this);
            xdr.onerror = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
            xdr.ontimeout = (function(l2) {
                return function(event) {
                    if (l2.onerror) {
                        l2.onerror(event);
                    }
                };
            })(this);
        };
        XdrL2.prototype.open = function(method, url) {
            this.xdr.open(method, url);
        };
        XdrL2.prototype.send = function(body) {
            this.xdr.send(body);
        };
        XdrL2.prototype.abort = function() {
            this.xdr.abort();
        };
        XdrL2.prototype.setContentType = function(mimeType) {
            // can't do it.
        };

        // Creates an XHR Facade based on available XMLHttpRequest-type
        // capabilibities.
        // If an actual XMLHttpRequest Level 2 is available, use that.
        if (typeof XMLHttpRequest !== "undefined") {
            var xhr = new XMLHttpRequest();
            if ("withCredentials" in xhr) {
                return new XhrL2(xhr);
            }
        }

        // Else if an XDomainRequest is available, use that.
        if (typeof XDomainRequest !== "undefined") {
            return new XdrL2(new XDomainRequest());
        }

        // Else fake an XMLHttpRequest using Flash/flXHR, if available
        // and use that.
        if (typeof flensed.flXHR !== "undefined") {
            return new XhrL2(new flensed.flXHR({instancePooling: true}));
        }

        // No luck.
        throw new Error("no cross-origin mechanism available");
    };

    // Executes a request by passing it to the XML-RPC server.
    // On success, the result is passed to the resultHandler.
    // On failure, the errHandler is called with one of two possible
    // arguments: an XmlRpc.Fault object, or an Error object.
    XmlRpcClient.prototype.execute = function(req, resultHandler, errHandler) {
        (function(xClient) {
            var xhr;
            var e;
            try {
                xhr = XmlRpcClient.createXHR();
                xhr.open("POST", xClient.endpoint);
                xhr.setContentType("text/xml");
            }
            catch (e) {
                errHandler(e);
                throw e;
            }
            xhr.onload = function() {
                var xml = xhr.responseXML;
                var result;
                var e;
                if (xml) {
                    try {
                        result = XmlRpc.decodeResponse(xml);
                    }
                    catch (e) {
                        if (errHandler) {
                            errHandler(e);
                        }
                        return;
                    }
                }
                else {
                    if (errHandler) {
                        errHandler("no XML response");
                    }
                    return;
                }
                if (result instanceof XmlRpc.Fault) {
                    if (errHandler) {
                        errHandler(result);
                    }
                }
                else {
                    if (resultHandler) {
                        resultHandler(result);
                    }
                }
            };
            xhr.onerror = function(event) {
                if (event) {
                    event.toString = function() {return "No hub?";}
                }
                else {
                    event = "No hub";
                }
                if (errHandler) {
                    errHandler(event);
                }
            };
            xhr.send(req.toXml());
            return xhr;
        })(this);
    };

    // Message class:
    // Aggregates an MType string and a params map.
    var Message = function(mtype, params) {
        this["samp.mtype"] = mtype;
        this["samp.params"] = params;
    };

    // Connection class:
    // this is what clients use to communicate with the hub.
    //
    // All the methods from the Hub Abstract API as described in the
    // SAMP standard are available as methods of a Connection object.
    // The initial private-key argument required by the Web Profile is
    // handled internally by this object - you do not need to supply it
    // when calling one of the methods.
    //
    // All these calls have the same form:
    //
    //    connection.method([method-args], resultHandler, errorHandler)
    //
    // the first argument is an array of the arguments (as per the SAMP
    // abstract hub API), the second argument is a function which is
    // called on successful completion with the result of the SAMP call
    // as its argument, and the third argument is a function which is
    // called on unsuccessful completion with an error object as its
    // argument.  The resultHandler and errorHandler arguments are optional.
    //
    // So for instance if you have a Connection object conn,
    // you can send a notify message to all other clients by doing, e.g.:
    //
    //    conn.notifyAll([new samp.Message(mtype, params)])
    //
    // Connection has other methods as well as the hub API ones
    // as documented below.
    var Connection = function(regInfo) {
        this.regInfo = regInfo;
        this.privateKey = regInfo["samp.private-key"];
        if (! typeof(this.privateKey) === "string") {
            throw new Error("Bad registration object");
        }
        this.xClient = new XmlRpcClient();
    };
    (function() {
        var connMethods = {
            call: [TYPE_STRING, TYPE_STRING, TYPE_MAP],
            callAll: [TYPE_STRING, TYPE_MAP],
            callAndWait: [TYPE_STRING, TYPE_MAP, TYPE_STRING],
            declareMetadata: [TYPE_MAP],
            declareSubscriptions: [TYPE_MAP],
            getMetadata: [TYPE_STRING],
            getRegisteredClients: [],
            getSubscribedClients: [TYPE_STRING],
            getSubscriptions: [TYPE_STRING],
            notify: [TYPE_STRING, TYPE_MAP],
            notifyAll: [TYPE_MAP],
            ping: [],
            reply: [TYPE_STRING, TYPE_MAP]
        };
        var fn;
        var types;
        for (fn in connMethods) {
            (function(fname, types) {
                // errHandler may be passed an XmlRpc.Fault or a thrown Error.
                Connection.prototype[fname] =
                        function(sampArgs, resultHandler, errHandler) {
                    var closer =
                        (function(c) {return function() {c.close()}})(this);
                    errHandler = errHandler || closer
                    XmlRpc.checkParams(sampArgs, types);
                    var request = new XmlRpcRequest(WEBSAMP_PREFIX + fname);
                    request.addParam(this.privateKey);
                    request.addParams(sampArgs);
                    return this.xClient.
                           execute(request, resultHandler, errHandler);
                };
            })(fn, connMethods[fn]);
        }
    })();
    Connection.prototype.unregister = function() {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
        }
        var request = new XmlRpcRequest(WEBSAMP_PREFIX + "unregister");
        request.addParam(this.privateKey);
        try {
            this.xClient.execute(request);
        }
        catch (e) {
            // log unregister failed
        }
        delete this.regInfo;
        delete this.privateKey;
    };

    // Closes this connection.  It unregisters from the hub if still
    // registered, but may harmlessly be called multiple times.
    Connection.prototype.close = function() {
        var e;
        if (this.closed) {
            return;
        }
        this.closed = true;
        try {
            if (this.regInfo) {
                this.unregister();
            }
        }
        catch (e) {
        }
        if (this.onclose) {
            oc = this.onclose;
            delete this.onclose;
            try {
                oc();
            }
            catch (e) {
            }
        }
    };

    // Arranges for this connection to receive callbacks.
    //
    // The callableClient argument must be an object implementing the
    // SAMP callable client API, i.e. it must have the following methods:
    //
    //     receiveNotification(string sender-id, map message)
    //     receiveCall(string sender-id, string msg-id, map message)
    //     receiveResponse(string responder-id, string msg-tag, map response)
    // 
    // The successHandler argument will be called with no arguments if the
    // allowCallbacks hub method completes successfully - it is a suitable
    // hook to use for declaring subscriptions.
    //
    // The CallableClient class provides a suitable implementation, see below.
    Connection.prototype.setCallable = function(callableClient,
                                                successHandler) {
        var e;
        if (this.callbackRequest) {
            try {
                this.callbackRequest.abort();
            }
            catch (e) {
            }
            finally {
                delete this.callbackRequest;
            }
        }
        if (!callableClient && !this.regInfo) {
            return;
        }
        var request =
            new XmlRpcRequest(WEBSAMP_PREFIX + "allowReverseCallbacks");
        request.addParam(this.privateKey);
        request.addParam(callableClient ? "1" : "0");
        var closer = (function(c) {return function() {c.close()}})(this);
        if (callableClient) {
            (function(connection) {
                var invokeCallback = function(callback) {
                    var methodName = callback["samp.methodName"];
                    var methodParams = callback["samp.params"];
                    var handlerFunc = undefined;
                    if (methodName === WEBSAMP_CLIENT_PREFIX
                                     + "receiveNotification") {
                        handlerFunc = callableClient.receiveNotification;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveCall") {
                        handlerFunc = callableClient.receiveCall;
                    }
                    else if (methodName === WEBSAMP_CLIENT_PREFIX
                                          + "receiveResponse") {
                        handlerFunc = callableClient.receiveResponse;
                    }
                    else {
                        // unknown callback??
                    }
                    if (handlerFunc) {
                        handlerFunc.apply(callableClient, methodParams);
                    }
                };
                var startTime;
                var resultHandler = function(result) {
                    if (getSampType(result) != TYPE_LIST) {
                        errHandler(new Error("pullCallbacks result not List"));
                        return;
                    }
                    var i;
                    var e;
                    for (i = 0; i < result.length; i++) {
                        try {
                            invokeCallback(result[i]);
                        }
                        catch (e) {
                            // log here?
                        }
                    }
                    callWaiter();
                };
                var errHandler = function(error) {
                    var elapsed = new Date().getTime() - startTime;
                    if (elapsed < 1000) {
                        connection.close()
                    }
                    else {
                        // probably a timeout
                        callWaiter();
                    }
                };
                var callWaiter = function() {
                    if (!connection.regInfo) {
                        return;
                    }
                    var request =
                        new XmlRpcRequest(WEBSAMP_PREFIX + "pullCallbacks");
                    request.addParam(connection.privateKey);
                    request.addParam("600");
                    startTime = new Date().getTime();
                    connection.callbackRequest =
                        connection.xClient.
                                   execute(request, resultHandler, errHandler);
                };
                var sHandler = function() {
                    callWaiter();
                    successHandler();
                };
                connection.xClient.execute(request, sHandler, closer);
            })(this);
        }
        else {
            this.xClient.execute(request, successHandler, closer);
        }
    };

    // Takes a public URL and returns a URL that can be used from within
    // this javascript context.  Some translation may be required, since
    // a URL sent by an external application may be cross-domain, in which
    // case browser sandboxing would typically disallow access to it.
    Connection.prototype.translateUrl = function(url) {
        var translator = this.regInfo["samp.url-translator"] || "";
        return translator + url;
    };
    Connection.Action = function(actName, actArgs, resultKey) {
        this.actName = actName;
        this.actArgs = actArgs;
        this.resultKey = resultKey;
    };

    // Suitable implementation for a callable client object which can
    // be supplied to Connection.setCallable().
    // Its callHandler and replyHandler members are string->function maps
    // which can be used to provide handler functions for MTypes and
    // message tags respectively.
    //
    // In more detail:
    // The callHandler member maps a string representing an MType to
    // a function with arguments (senderId, message, isCall).
    // The replyHandler member maps a string representing a message tag to
    // a function with arguments (responderId, msgTag, response).
    var CallableClient = function(connection) {
        this.callHandler = {};
        this.replyHandler = {};
    };
    CallableClient.prototype.init = function(connection) {
    };
    CallableClient.prototype.receiveNotification = function(senderId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var e;
        if (mtype in this.callHandler) {
            try {
                this.callHandler[mtype](senderId, message, false);
            }
            catch (e) {
            }
            handled = true;
        }
        return handled;
    };
    CallableClient.prototype.receiveCall = function(senderId, msgId, message) {
        var mtype = message["samp.mtype"];
        var handled = false;
        var response;
        var result;
        var e;
        if (mtype in this.callHandler) {
            try {
                result = this.callHandler[mtype](senderId, message, true) || {};
                response = {"samp.status": "samp.ok",
                            "samp.result": result};
                handled = true;
            }
            catch (e) {
                response = {"samp.status": "samp.error",
                            "samp.error": {"samp.errortxt": e.toString()}};
            }
        }
        else {
            response = {"samp.status": "samp.warning",
                        "samp.result": {},
                        "samp.error": {"samp.errortxt": "no action"}};
        }
        this.connection.reply([msgId, response]);
        return handled;
    };
    CallableClient.prototype.receiveResponse = function(responderId, msgTag,
                                                        response) {
        var handled = false;
        var e;
        if (msgTag in this.replyHandler) {
            try {
                this.replyHandler[msgTag](responderId, msgTag, response);
                handled = true;
            }
            catch (e) {
            }
        }
        return handled;
    };
    CallableClient.prototype.calculateSubscriptions = function() {
        var subs = {};
        var mt;
        for (mt in this.callHandler) {
            subs[mt] = {};
        }
        return subs;
    };

    // ClientTracker is a CallableClient which also provides tracking of
    // registered clients.
    //
    // Its onchange member, if defined, will be called with arguments
    // (client-id, change-type, associated-data) whenever the list or
    // characteristics of registered clients has changed.
    var ClientTracker = function() {
        var tracker = this;
        this.ids = {};
        this.metas = {};
        this.subs = {};
        this.replyHandler = {};
        this.callHandler = {
            "samp.hub.event.shutdown": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.disconnect": function(senderId, message) {
                tracker.connection.close();
            },
            "samp.hub.event.register": function(senderId, message) {
                var id = message["samp.params"]["id"];
                tracker.ids[id] = true;
                tracker.changed(id, "register", null);
            },
            "samp.hub.event.unregister": function(senderId, message) {
                var id = message["samp.params"]["id"];
                delete tracker.ids[id];
                delete tracker.metas[id];
                delete tracker.subs[id];
                tracker.changed(id, "unregister", null);
            },
            "samp.hub.event.metadata": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var meta = message["samp.params"]["metadata"];
                tracker.metas[id] = meta;
                tracker.changed(id, "meta", meta);
            },
            "samp.hub.event.subscriptions": function(senderId, message) {
                var id = message["samp.params"]["id"];
                var subs = message["samp.params"]["subscriptions"];
                tracker.subs[id] = subs;
                tracker.changed(id, "subs", subs);
            }
        };
    };
    ClientTracker.prototype = heir(CallableClient.prototype);
    ClientTracker.prototype.changed = function(id, type, data) {
        if (this.onchange) {
            this.onchange(id, type, data);
        }
    };
    ClientTracker.prototype.init = function(connection) {
        var tracker = this;
        this.connection = connection;
        var retrieveInfo = function(id, type, infoFuncName, infoArray) {
            connection[infoFuncName]([id], function(info) {
                infoArray[id] = info;
                tracker.changed(id, type, info);
            });
        };
        connection.getRegisteredClients([], function(idlist) {
            var i;
            var id;
            tracker.ids = {};
            for (i = 0; i < idlist.length; i++) {
                id = idlist[i];
                tracker.ids[id] = true;
                retrieveInfo(id, "meta", "getMetadata", tracker.metas);
                retrieveInfo(id, "subs", "getSubscriptions", tracker.subs);
            }
            tracker.changed(null, "ids", null);
        });
    };
    ClientTracker.prototype.getName = function(id) {
        var meta = this.metas[id];
        return (meta && meta["samp.name"]) ? meta["samp.name"] : "[" + id + "]";
    };

    // Connector class:
    // A higher level class which can manage transparent hub
    // registration/unregistration and client tracking.
    //
    // On construction, the name argument is mandatory, and corresponds
    // to the samp.name item submitted at registration time.
    // The other arguments are optional.
    // meta is a metadata map (if absent, no metadata is declared)
    // callableClient is a callable client object for receiving callbacks
    // (if absent, the client is not callable).
    // subs is a subscriptions map (if absent, no subscriptions are declared)
    var Connector = function(name, meta, callableClient, subs) {
        this.name = name;
        this.meta = meta;
        this.callableClient = callableClient;
        this.subs = subs;
        this.regTextNodes = [];
        this.whenRegs = [];
        this.whenUnregs = [];
        this.connection = undefined;
        this.onreg = undefined;
        this.onunreg = undefined;
    };
    var setRegText = function(connector, txt) {
        var i;
        var nodes = connector.regTextNodes;
        var node;
        for (i = 0; i < nodes.length; i++) {
            node = nodes[i];
            node.innerHTML = "";
            node.appendChild(document.createTextNode(txt));
        }
    };
    Connector.prototype.setConnection = function(conn) {
        var connector = this;
        var e;
        if (this.connection) {
            this.connection.close();
            if (this.onunreg) {
                try {
                    this.onunreg();
                }
                catch (e) {
                }
            }
        }
        this.connection = conn;
        if (conn) {
            conn.onclose = function() {
                connector.connection = null;
                if (connector.onunreg) {
                    try {
                        connector.onunreg();
                    }
                    catch (e) {
                    }
                }
                connector.update();
            };
            if (this.meta) {
                conn.declareMetadata([this.meta]);
            }
            if (this.callableClient) {
                if (this.callableClient.init) {
                    this.callableClient.init(conn);
                }
                conn.setCallable(this.callableClient, function() {
                    conn.declareSubscriptions([connector.subs]);
                });
            }
            if (this.onreg) {
                try {
                    this.onreg(conn);
                }
                catch (e) {
                }
            }
        }
        this.update();
    };
    Connector.prototype.register = function() {
        var connector = this;
        var regErrHandler = function(err) {
            setRegText(connector, "no (" + err.toString() + ")");
        };
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            setRegText(connector, conn ? "Yes" : "No");
        };
        register(this.name, regSuccessHandler, regErrHandler);
    };
    Connector.prototype.unregister = function() {
        if (this.connection) {
            this.connection.unregister([]);
            this.setConnection(null);
        }
    };

    // Returns a document fragment which contains Register/Unregister
    // buttons for use by the user to attempt to connect/disconnect
    // with the hub.  This is useful for models where explicit
    // user registration is encouraged or required, but when using
    // the register-on-demand model such buttons are not necessary.
    Connector.prototype.createRegButtons = function() {
        var connector = this;
        var regButt = document.createElement("button");
        regButt.setAttribute("type", "button");
        regButt.appendChild(document.createTextNode("Register"));
        regButt.onclick = function() {connector.register();};
        this.whenUnregs.push(regButt);
        var unregButt = document.createElement("button");
        unregButt.setAttribute("type", "button");
        unregButt.appendChild(document.createTextNode("Unregister"));
        unregButt.onclick = function() {connector.unregister();};
        this.whenRegs.push(unregButt);
        var regText = document.createElement("span");
        this.regTextNodes.push(regText);
        var node = document.createDocumentFragment();
        node.appendChild(regButt);
        node.appendChild(document.createTextNode(" "));
        node.appendChild(unregButt);
        var label = document.createElement("span");
        label.innerHTML = " <strong>Registered: </strong>";
        node.appendChild(label);
        node.appendChild(regText);
        this.update();
        return node;
    };

    Connector.prototype.update = function() {
        var i;
        var isConnected = !! this.connection;
        var enableds = isConnected ? this.whenRegs : this.whenUnregs;
        var disableds = isConnected ? this.whenUnregs : this.whenRegs;
        for (i = 0; i < enableds.length; i++) {
            enableds[i].removeAttribute("disabled");
        }
        for (i = 0; i < disableds.length; i++) {
            disableds[i].setAttribute("disabled", "disabled");
        }
        setRegText(this, "No");
    };

    // Provides execution of a SAMP operation with register-on-demand.
    // You can use this method to provide lightweight registration/use
    // of web SAMP.  Simply provide a connHandler function which
    // does something with a connection (e.g. sends a message) and
    // Connector.runWithConnection on it.  This will connect if not
    // already connected, and call the connHandler on with the connection.
    // No explicit registration action is then required from the user.
    //
    // If the regErrorHandler argument is supplied, it is a function of
    // one (error) argument called in the case that registration-on-demand
    // fails.
    //
    // This is a more-or-less complete sampjs page:
    //   <script>
    //     var connector = new samp.Connector("pinger", {"samp.name": "Pinger"})
    //     var pingFunc = function(connection) {
    //       connection.notifyAll([new samp.Message("samp.app.ping", {})])
    //     }
    //   </script>
    //   <button onclick="connector.runWithConnection(pingFunc)">Ping</button>
    Connector.prototype.runWithConnection =
            function(connHandler, regErrorHandler) {
        var connector = this;
        var regSuccessHandler = function(conn) {
            connector.setConnection(conn);
            connHandler(conn);
        };
        var regFailureHandler = function(e) {
            connector.setConnection(undefined);
            regErrorHandler(e);
        };
        var pingResultHandler = function(result) {
            connHandler(connector.connection);
        };
        var pingErrorHandler = function(err) {
            register(this.name, regSuccessHandler, regFailureHandler);
        };
        if (this.connection) {
            // Use getRegisteredClients as the most lightweight check
            // I can think of that this connection is still OK.
            // Ping doesn't work because the server replies even if the
            // private-key is incorrect/invalid.  Is that a bug or not?
            this.connection.
                 getRegisteredClients([], pingResultHandler, pingErrorHandler);
        }
        else {
            register(this.name, regSuccessHandler, regFailureHandler);
        }
    };

    // Sets up an interval timer to run at intervals and notify a callback
    // about whether a hub is currently running.
    // Every millis milliseconds, the supplied availHandler function is
    // called with a boolean argument: true if a (web profile) hub is
    // running, false if not.
    // Returns the interval timer (can be passed to clearInterval()).
    Connector.prototype.onHubAvailability = function(availHandler, millis) {
        samp.ping(availHandler);

        // Could use the W3C Page Visibility API to avoid making these
        // checks when the page is not visible.
        return setInterval(function() {samp.ping(availHandler);}, millis);
    };

    // Determines whether a given subscriptions map indicates subscription
    // to a given mtype.
    var isSubscribed = function(subs, mtype) {
        var matching = function(pattern, mtype) {
            if (pattern == mtype) {
                return true;
            }
            else if (pattern === "*") {
                return true;
            }
            else {
                var prefix;
                var split = /^(.*)\.\*$/.exec(pat);
                if (split) {
                    prefix = split[1];
                    if (prefix === mtype.substring(0, prefix.length)) {
                        return true;
                    }
                }
            }
            return false;
        };
        var pat;
        for (pat in subs) {
            if (matching(pat, mtype)) {
                return true;
            }
        }
        return false;
    }

    // Attempts registration with a SAMP hub.
    // On success the supplied connectionHandler function is called
    // with the connection as an argument, on failure the supplied
    // errorHandler is called with an argument that may be an Error
    // or an XmlRpc.Fault.
    var register = function(appName, connectionHandler, errorHandler) {
        var xClient = new XmlRpcClient();
        var regRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "register");
        var securityInfo = {"samp.name": appName};
        regRequest.addParam(securityInfo);
        regRequest.checkParams([TYPE_MAP]);
        var resultHandler = function(result) {
            var conn;
            var e;
            try {
                conn = new Connection(result);
            }
            catch (e) {
                errorHandler(e);
                return;
            }
            connectionHandler(conn);
        };
        xClient.execute(regRequest, resultHandler, errorHandler);
    };

    // Calls the hub ping method once.  It is not necessary to be
    // registered to do this.
    // The supplied pingHandler function is called with a boolean argument:
    // true if a (web profile) hub is running, false if not.
    var ping = function(pingHandler) {
        var xClient = new XmlRpcClient();
        var pingRequest = new XmlRpcRequest(WEBSAMP_PREFIX + "ping");
        var resultHandler = function(result) {
            pingHandler(true);
        };
        var errorHandler = function(error) {
            pingHandler(false);
        };
        xClient.execute(pingRequest, resultHandler, errorHandler);
    };


    /* Exports. */
    var jss = {};
    jss.XmlRpcRequest = XmlRpcRequest;
    jss.XmlRpcClient = XmlRpcClient;
    jss.Message = Message;
    jss.TYPE_STRING = TYPE_STRING;
    jss.TYPE_LIST = TYPE_LIST;
    jss.TYPE_MAP = TYPE_MAP;
    jss.register = register;
    jss.ping = ping;
    jss.isSubscribed = isSubscribed;
    jss.Connector = Connector;
    jss.CallableClient = CallableClient;
    jss.ClientTracker = ClientTracker;

    return jss;
})();

define("samp", function(){});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * SampCore Module : containing core methods
 */
define('Services/SampCore',["jquery", "underscore-min", "../Parser/JsonProcessor", "../Gui/dialog/ErrorDialog", "samp", "jquery.ui"],
    function ($, _, JsonProcessor, ErrorDialog) {

        var mizar;
        var sky;
        var navigation;
        var imageManager;

        var connector;	// SAMP connector
        var sampLayer;	// SAMP vector layer containing all incoming fits images
        var pointAtReceived = false; // Parameter avoiding looping while receiving coord.pointAt.sky SAMP event
        var votable2geojsonBaseUrl;
        var sitoolsBaseUrl;

        /**************************************************************************************************************/

        /**
         *    Create SAMP ClientTracker object which handles incoming messages
         */
        function createClientTracker() {
            // Initialize client tracker
            var clientTracker = new samp.ClientTracker();

            // Init available samp income message handlers(as ping, load.votable..)
            var callHandler = clientTracker.callHandler;
            callHandler["samp.app.ping"] = function (senderId, message, isCall) {
                if (isCall) {
                    return {text: "ping to you, " + clientTracker.getName(senderId)};
                }
            };

            callHandler["table.load.votable"] = function (senderId, message, isCall) {

                if (votable2geojsonBaseUrl) {
                    //var params = message["samp.params"];
                    //var origUrl = params.url;
                    //var proxyUrl = clientTracker.connection.translateUrl(origUrl);
                    //Utils.convertVotable2JsonFromURL(proxyUrl, function (response) {
                        // Add feature collection
                    //    JsonProcessor.handleFeatureCollection(sampLayer, response);
                    //    sampLayer.addFeatureCollection(response);
                    //});
                }
                else {
                    ErrorDialog.open('votable2geojson plugin base url isn\'t defined');
                }
            };

            // callHandler["table.highlight.row"] = function(senderId, message, isCall) {
            // 	var params = message["samp.params"];
            // 	var url = params['url'];
            // 	var row = params['row'];

            // 	if ( highlightedData )
            // 	{
            // 		highlightedData.layer.modifyFeatureStyle( highlightedData.feature, highlightedData.layer.style );
            // 	}

            // 	if ( tables[url] )
            // 	{
            // 		var layer = tables[url].layer;
            // 		var feature = tables[url].features[parseInt(row)];

            // 		layer.modifyFeatureStyle( feature, highlightStyle );
            // 		highlightedData = {
            // 			layer: layer,
            // 			feature: feature
            // 		}

            // 		var barycenter = Utils.computeGeometryBarycenter( feature.geometry );
            // 		navigation.zoomTo( barycenter, (navigation.renderContext.fov < 1. ? navigation.renderContext.fov : 1.), 300. );
            // 	}
            // };

            callHandler["image.load.fits"] = function (senderId, message, isCall) {
                // var params = message["samp.params"];
                //
                // // Create feature
                // var feature = {
                //     "geometry": {
                //         "gid": params.name,
                //         "coordinates": [],
                //         "type": "Polygon"
                //     },
                //     "properties": {
                //         "identifier": params.name
                //     },
                //     "services": {
                //         "download": {
                //             "mimetype": "image/fits",
                //             "url": params['image-id']
                //         }
                //     },
                //     "type": "Feature"
                // };
                //
                // // Get fits texture from url
                // var featureData = {
                //     layer: sampLayer,
                //     feature: feature,
                //     isFits: true
                // };
                // var url = sitoolsBaseUrl + "/proxy?external_url=" + encodeURIComponent(params['image-id']);
                // mizar.publish("image:add", featureData);
                // imageManager.computeFits(featureData, url, function (featureData, fits) {
                //     // Update feature coordinates according to Fits header
                //     var coords = Utils.getPolygonCoordinatesFromFits(fits);
                //     featureData.feature.geometry.coordinates = [coords];
                //     sampLayer.addFeature(featureData.feature);
                // });
            };

            callHandler["coord.pointAt.sky"] = function (senderId, message, isCall) {
                pointAtReceived = true;
                var params = message["samp.params"];
                var ra = parseFloat(params.ra);
                var dec = parseFloat(params.dec);
                // var proxyUrl = clientTracker.connection.translateUrl(origUrl);
                var geoPick = [ra, dec];
                var center3d = [];
                sky.getCoordinateSystem().get3DFromWorld(geoPick, center3d);
                navigation.center3d = center3d;
                navigation.computeViewMatrix();
                sky.getRenderContext().requestFrame();
            };

            callHandler["samp.hub.event.unregister"] = function (senderId, message, isCall) {
                // Update jQuery UI buttons
                $('#registerSamp').removeAttr('disabled').button("refresh");
                $("#unregisterSamp").attr('disabled', 'disabled').button("refresh");
                $('#sampInvoker').toggleClass('selected');
            };

            return clientTracker;
        }

        /**************************************************************************************************************/

        /**
         *    Init SAMP connector
         */
        function initSamp() {
            var clientTracker = createClientTracker();

            // Samp event callbacks
            var logCc = {
                receiveNotification: function (senderId, message) {
                    var handled = clientTracker.receiveNotification(senderId, message);
                    if (message["samp.mtype"] === "samp.hub.event.subscriptions") {
                        // Update jQuery UI buttons
                        $('#unregisterSamp').removeAttr('disabled').button("refresh");
                        $('#registerSamp').attr('disabled', 'disabled').button("refresh");
                        $('#sampInvoker').addClass('selected');
                    }
                },
                receiveCall: function (senderId, msgId, message) {
                    var handled = clientTracker.receiveCall(senderId, msgId, message);
                },
                receiveResponse: function (responderId, msgTag, response) {
                    var handled = clientTracker.receiveResponse(responderId, msgTag, response);
                },
                init: function (connection) {
                    clientTracker.init(connection);
                }
            };

            // Meta-data
            var meta = {
                "samp.name": "Mizar",
                "samp.description.text": "Module for Interactive visualiZation from Astronomical Repositories",
                "mizar.version": "v0.1",
                "author.affiliation": "CNES/TPZ",
                "home.page": "http://github.com/TPZF/RTWeb3D"
            };

            // Generate subscriptions map
            var subs = clientTracker.calculateSubscriptions();

            connector = new samp.Connector("Mizar", meta, logCc, subs);

            // Uncomment for automatic registration(check every 2 sec if Hub is available)
            // Adjusts page content depending on whether the hub exists or not.
            // var configureSampEnabled = function(isHubRunning) {
            //     // TODO
            // };
            // connector.onHubAvailability(configureSampEnabled, 2000);

            // Registration status element is updated by samp.js
            connector.regTextNodes.push($('#sampResult')[0]);

            return connector;
        }

        /**************************************************************************************************************/

        return {
            initSamp: initSamp,
            sendImage: function (url) {
                if (this.isConnected()) {
                    // Send message
                    var msg = new samp.Message("image.load.fits", {url: url});
                    connector.connection.notifyAll([msg]);
                    return "Image has been sent";
                }
                else {
                    return "Connect to SAMP Hub first";
                }
            },

            sendVOTable: function (layer, url) {
                if (this.isConnected()) {
                    // Send message
                    var msg = new samp.Message("table.load.votable", {url: url + "&media=votable"});
                    connector.connection.notifyAll([msg]);

                    // Part used to highlighting
                    // $.ajax({
                    // 	type: "GET",
                    // 	url: url,
                    // 	success: function(response) {

                    // 		if ( response.totalResults > 0 )
                    // 		{
                    // 			// Store table to be able to highlight features later
                    // 			tables[ url+'&media=votable' ] = {
                    // 				layer: layer,
                    // 				features: []
                    // 			};
                    // 			for ( var i=0; i<response.features.length; i++ )
                    // 			{
                    // 				var feature = response.features[i];
                    // 				tables[url+'&media=votable'].features.push(feature);
                    // 			}
                    // 		}
                    // 		// Send message
                    // 		var msg = new samp.Message("table.load.votable", {url: url+"&media=votable"});
                    // 		connector.connection.notifyAll([msg]);
                    // 	},
                    // 	error: function(thrownError)
                    // 	{
                    // 		console.error(thrownError);
                    // 	}
                    // });
                    return "VOTable has been sent";
                }
                else {
                    return "Connect to SAMP Hub first";
                }
            },

            // Commented part is used for highlighting feature which wasn't implemented due to
            // difficulty of SAMP protocol (client doesn't know the feature from row)
            highlightFeature: function (layer, feature) {
                /**if (this.isConnected()) {
                    // for ( var url in tables )
                    // {
                    // 	var table = tables[url];
                    // 	if ( layer == table.layer )
                    // 	{
                    // 		var featureToHighlight = _.filter( table.features, function(x){ return(feature.properties.identifier == x.properties.identifier) } );
                    // 		if ( featureToHighlight.length )
                    // 		{
                    // var featureRow = table.features.indexOf(featureToHighlight[0]);
                    // var msg = new samp.Message("table.highlight.row", {url: url, row: featureRow.toString()});
                    // connector.connection.notifyAll([msg]);
                    // 		}
                    // 	}
                    // }
                }
                */
            },
            isConnected: function () {
                return connector.connection;
            }
        }

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('Services/SelectionToolCore',["jquery", "../Utils/UtilsIntersection", "../Utils/Numeric", "../Layer/VectorLayer", "../Renderer/FeatureStyle", "../Renderer/Ray", "../Renderer/glMatrix"],
    function ($, UtilsIntersection, Numeric, VectorLayer, FeatureStyle, Ray) {

        var ctx, navigation, onselect;
        /**
         *    @constructor
         *    @param options Configuration options
         *        <ul>
         *            <li>planet: planet</li>
         *            <li>navigation: Navigation</li>
         *            <li>onselect: On selection callback</li>
         *            <li>style: Selection tool style</li>
         *        </ul>
         */
        var SelectionToolCore = function (options) {
            // Required options
            ctx = options.ctx;
            navigation = ctx.getNavigation();
            onselect = options.onselect;

            this.activated = options.activated || false;
            this.renderContext = ctx.getRenderContext();
            this.coordinateSystem = ctx.getCoordinateSystem();

            // Set style
            var style;
            if (options && options.style) {
                style = options.style;
            }
            else {
                style = new FeatureStyle();
            }
            style.zIndex = 2;

            // Layer containing selection feature
            this.selectionLayer = new VectorLayer({
                style: style,
                visible:true
            });
            ctx.addDraw(this.selectionLayer);

            this.selectionFeature = null;

            // Selection attributes
            this.radius = null;	// Window radius
            this.pickPoint = null; // Window pick point
            this.geoRadius = null; // Radius in geographic reference
            this.geoPickPoint = null; // Pick point in geographic reference

            var self = this;
            var dragging = false;
            var state;

            this.renderContext.canvas.addEventListener("mousedown", function (event) {

                var pickPoint = [event.layerX, event.layerY];
                var geoPickPoint = ctx.getLonLatFromPixel(event.layerX, event.layerY);

                if (!self.activated && !self.selectionFeature) {
                    return;
                }

                // Dragging : moving/resizing OR drawing selection
                if (self.activated) {
                    // Draw
                    navigation.stop();
                    dragging = true;
                    self.pickPoint = pickPoint;
                    self.geoPickPoint = geoPickPoint;
                    self.radius = 0.0;
                    state = "resize";
                }
                else {
                    var pickIsInside = UtilsIntersection.pointInRing(geoPickPoint, self.selectionFeature.geometry.coordinates[0]);
                    if (!pickIsInside) {
                        return;
                    }
                    navigation.stop();
                    dragging = true;
                    // Resize/move
                    var inside = false;
                    // Check if user clicked on one of control points
                    for (var i = 0; i < self.selectionFeature.geometry.coordinates[0].length; i++) {
                        var controlPoint = self.selectionFeature.geometry.coordinates[0][i];
                        inside |= UtilsIntersection.pointInSphere(ctx, geoPickPoint, controlPoint, 20);
                    }

                    if (inside) {
                        state = "resize";
                    }
                    else {
                        state = "move";
                    }
                }
            });

            this.renderContext.canvas.addEventListener("mousemove", function (event) {
                if (!dragging) {
                    return;
                }

                var geoPickPoint = ctx.getLonLatFromPixel(event.layerX, event.layerY);
                if (state === "resize") {
                    // Update radius
                    self.radius = Math.sqrt(Math.pow(event.layerX - self.pickPoint[0], 2) + Math.pow(event.layerY - self.pickPoint[1], 2));
                    self.computeGeoRadius(geoPickPoint);
                }
                else if (state === "move") {
                    // Update pick point position
                    self.pickPoint = [event.layerX, event.layerY];
                    self.geoPickPoint = ctx.getLonLatFromPixel(event.layerX, event.layerY);

                    // TODO: scale radius of selection shape if fov has been changed(or not?)
                }
                self.updateSelection();
            });

            this.renderContext.canvas.addEventListener("mouseup", function (event) {
                if (!dragging) {
                    return;
                }

                // Compute geo radius
                var stopPickPoint = ctx.getLonLatFromPixel(event.layerX, event.layerY);

                var coordinates = self.computeSelection();
                if (self.activated && onselect) {
                    onselect(coordinates);
                }

                // Reactivate standard navigation events
                navigation.start();
                dragging = false;
            });
        };

        /**********************************************************************************************/

        /**
         *    Compute selection tool radius between pickPoint and the given point
         *    @param {Array} pt point
         */
        SelectionToolCore.prototype.computeGeoRadius = function (pt) {
            // Find angle between start and stop vectors which is in fact the radius
            var dotProduct = vec3.dot(vec3.normalize(this.coordinateSystem.get3DFromWorld(pt)), vec3.normalize(this.coordinateSystem.get3DFromWorld(this.geoPickPoint)));
            var theta = Math.acos(dotProduct);
            this.geoRadius = Numeric.toDegree(theta);
        };

        /**********************************************************************************************/

        /**
         *    Compute selection for the given pick point depending on radius
         *    @return {Array} points
         */
        SelectionToolCore.prototype.computeSelection = function () {
            var rc = this.renderContext;
            var tmpMat = mat4.create();

            // Compute eye in world space
            mat4.inverse(rc.viewMatrix, tmpMat);
            var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

            // Compute the inverse of view/proj matrix
            mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
            mat4.inverse(tmpMat);

            // Scale to [-1,1]
            var widthScale = 2 / rc.canvas.width;
            var heightScale = 2 / rc.canvas.height;
            var points = [
                [(this.pickPoint[0] - this.radius) * widthScale - 1.0, ((rc.canvas.height - this.pickPoint[1]) - this.radius) * heightScale - 1.0, 1, 1],
                [(this.pickPoint[0] - this.radius) * widthScale - 1.0, ((rc.canvas.height - this.pickPoint[1]) + this.radius) * heightScale - 1.0, 1, 1],
                [(this.pickPoint[0] + this.radius) * widthScale - 1.0, ((rc.canvas.height - this.pickPoint[1]) + this.radius) * heightScale - 1.0, 1, 1],
                [(this.pickPoint[0] + this.radius) * widthScale - 1.0, ((rc.canvas.height - this.pickPoint[1]) - this.radius) * heightScale - 1.0, 1, 1]
            ];

            // Transform the four corners of selection shape into world space
            // and then for each corner compute the intersection of ray starting from the eye with the sphere
            var worldCenter = [0, 0, 0];
            for (var i = 0; i < 4; i++) {
                mat4.multiplyVec4(tmpMat, points[i]);
                vec3.scale(points[i], 1.0 / points[i][3]);
                vec3.subtract(points[i], eye, points[i]);
                vec3.normalize(points[i]);

                var ray = new Ray(eye, points[i]);
                var pos3d = ray.computePoint(ray.sphereIntersect(worldCenter, this.coordinateSystem.getGeoide().getRadius()));
                points[i] = this.coordinateSystem.getWorldFrom3D(pos3d);
            }

            return points;
        };

        /**************************************************************************************************************/

        /**
         *    Update selection coordinates
         */
        SelectionToolCore.prototype.updateSelection = function () {
            if (this.selectionFeature) {
                this.selectionLayer.removeFeature(this.selectionFeature);
            }

            var coordinates = this.computeSelection();
            // Close the polygon
            coordinates.push(coordinates[0]);

            this.selectionFeature = {
                geometry: {
                    gid: "selectionShape",
                    coordinates: [coordinates],
                    type: "Polygon",
                    crs: {
                        type: "name",
                        properties: {
                            name: ctx.getCoordinateSystem().getGeoideName()
                        }
                    }
                },
                type: "Feature"
            };

            this.selectionLayer.addFeature(this.selectionFeature);
        };

        /**************************************************************************************************************/

        /**
         *    Activate/desactivate the tool
         */
        SelectionToolCore.prototype.toggle = function () {
            this.activated = !this.activated;
            if (this.activated) {
                // TODO : Find more sexy image for cursor
                $(this.renderContext.canvas).css('cursor', 'url(css/images/selectionCursor.png)');
            }
            else {
                $(this.renderContext.canvas).css('cursor', 'default');
            }
        };

        /**************************************************************************************************************/

        /**
         *    Clear selection
         */
        SelectionToolCore.prototype.clear = function () {
            if (this.selectionFeature) {
                this.selectionLayer.removeFeature(this.selectionFeature);
            }

            this.pickPoint = null;
            this.radius = null;
            this.geoPickPoint = null;
            this.geoRadius = null;
        };

        /**************************************************************************************************************/

        return SelectionToolCore;

    });

/*!

JSZip v3.1.5 - A JavaScript class for generating and reading zip files
<http://stuartk.com/jszip>

(c) 2009-2016 Stuart Knightley <stuart [at] stuartk.com>
Dual licenced under the MIT license or GPLv3. See https://raw.github.com/Stuk/jszip/master/LICENSE.markdown.

JSZip uses the library pako released under the MIT license :
https://github.com/nodeca/pako/blob/master/LICENSE
*/
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define('jszip',[],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.JSZip=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){"use strict";var d=a("./utils"),e=a("./support"),f="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";c.encode=function(a){for(var b,c,e,g,h,i,j,k=[],l=0,m=a.length,n=m,o="string"!==d.getTypeOf(a);l<a.length;)n=m-l,o?(b=a[l++],c=l<m?a[l++]:0,e=l<m?a[l++]:0):(b=a.charCodeAt(l++),c=l<m?a.charCodeAt(l++):0,e=l<m?a.charCodeAt(l++):0),g=b>>2,h=(3&b)<<4|c>>4,i=n>1?(15&c)<<2|e>>6:64,j=n>2?63&e:64,k.push(f.charAt(g)+f.charAt(h)+f.charAt(i)+f.charAt(j));return k.join("")},c.decode=function(a){var b,c,d,g,h,i,j,k=0,l=0,m="data:";if(a.substr(0,m.length)===m)throw new Error("Invalid base64 input, it looks like a data url.");a=a.replace(/[^A-Za-z0-9\+\/\=]/g,"");var n=3*a.length/4;if(a.charAt(a.length-1)===f.charAt(64)&&n--,a.charAt(a.length-2)===f.charAt(64)&&n--,n%1!==0)throw new Error("Invalid base64 input, bad content length.");var o;for(o=e.uint8array?new Uint8Array(0|n):new Array(0|n);k<a.length;)g=f.indexOf(a.charAt(k++)),h=f.indexOf(a.charAt(k++)),i=f.indexOf(a.charAt(k++)),j=f.indexOf(a.charAt(k++)),b=g<<2|h>>4,c=(15&h)<<4|i>>2,d=(3&i)<<6|j,o[l++]=b,64!==i&&(o[l++]=c),64!==j&&(o[l++]=d);return o}},{"./support":30,"./utils":32}],2:[function(a,b,c){"use strict";function d(a,b,c,d,e){this.compressedSize=a,this.uncompressedSize=b,this.crc32=c,this.compression=d,this.compressedContent=e}var e=a("./external"),f=a("./stream/DataWorker"),g=a("./stream/DataLengthProbe"),h=a("./stream/Crc32Probe"),g=a("./stream/DataLengthProbe");d.prototype={getContentWorker:function(){var a=new f(e.Promise.resolve(this.compressedContent)).pipe(this.compression.uncompressWorker()).pipe(new g("data_length")),b=this;return a.on("end",function(){if(this.streamInfo.data_length!==b.uncompressedSize)throw new Error("Bug : uncompressed data size mismatch")}),a},getCompressedWorker:function(){return new f(e.Promise.resolve(this.compressedContent)).withStreamInfo("compressedSize",this.compressedSize).withStreamInfo("uncompressedSize",this.uncompressedSize).withStreamInfo("crc32",this.crc32).withStreamInfo("compression",this.compression)}},d.createWorkerFrom=function(a,b,c){return a.pipe(new h).pipe(new g("uncompressedSize")).pipe(b.compressWorker(c)).pipe(new g("compressedSize")).withStreamInfo("compression",b)},b.exports=d},{"./external":6,"./stream/Crc32Probe":25,"./stream/DataLengthProbe":26,"./stream/DataWorker":27}],3:[function(a,b,c){"use strict";var d=a("./stream/GenericWorker");c.STORE={magic:"\0\0",compressWorker:function(a){return new d("STORE compression")},uncompressWorker:function(){return new d("STORE decompression")}},c.DEFLATE=a("./flate")},{"./flate":7,"./stream/GenericWorker":28}],4:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b[g])];return a^-1}function f(a,b,c,d){var e=h,f=d+c;a^=-1;for(var g=d;g<f;g++)a=a>>>8^e[255&(a^b.charCodeAt(g))];return a^-1}var g=a("./utils"),h=d();b.exports=function(a,b){if("undefined"==typeof a||!a.length)return 0;var c="string"!==g.getTypeOf(a);return c?e(0|b,a,a.length,0):f(0|b,a,a.length,0)}},{"./utils":32}],5:[function(a,b,c){"use strict";c.base64=!1,c.binary=!1,c.dir=!1,c.createFolders=!0,c.date=null,c.compression=null,c.compressionOptions=null,c.comment=null,c.unixPermissions=null,c.dosPermissions=null},{}],6:[function(a,b,c){"use strict";var d=null;d="undefined"!=typeof Promise?Promise:a("lie"),b.exports={Promise:d}},{lie:58}],7:[function(a,b,c){"use strict";function d(a,b){h.call(this,"FlateWorker/"+a),this._pako=null,this._pakoAction=a,this._pakoOptions=b,this.meta={}}var e="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Uint32Array,f=a("pako"),g=a("./utils"),h=a("./stream/GenericWorker"),i=e?"uint8array":"array";c.magic="\b\0",g.inherits(d,h),d.prototype.processChunk=function(a){this.meta=a.meta,null===this._pako&&this._createPako(),this._pako.push(g.transformTo(i,a.data),!1)},d.prototype.flush=function(){h.prototype.flush.call(this),null===this._pako&&this._createPako(),this._pako.push([],!0)},d.prototype.cleanUp=function(){h.prototype.cleanUp.call(this),this._pako=null},d.prototype._createPako=function(){this._pako=new f[this._pakoAction]({raw:!0,level:this._pakoOptions.level||-1});var a=this;this._pako.onData=function(b){a.push({data:b,meta:a.meta})}},c.compressWorker=function(a){return new d("Deflate",a)},c.uncompressWorker=function(){return new d("Inflate",{})}},{"./stream/GenericWorker":28,"./utils":32,pako:59}],8:[function(a,b,c){"use strict";function d(a,b,c,d){f.call(this,"ZipFileWorker"),this.bytesWritten=0,this.zipComment=b,this.zipPlatform=c,this.encodeFileName=d,this.streamFiles=a,this.accumulate=!1,this.contentBuffer=[],this.dirRecords=[],this.currentSourceOffset=0,this.entriesCount=0,this.currentFile=null,this._sources=[]}var e=a("../utils"),f=a("../stream/GenericWorker"),g=a("../utf8"),h=a("../crc32"),i=a("../signature"),j=function(a,b){var c,d="";for(c=0;c<b;c++)d+=String.fromCharCode(255&a),a>>>=8;return d},k=function(a,b){var c=a;return a||(c=b?16893:33204),(65535&c)<<16},l=function(a,b){return 63&(a||0)},m=function(a,b,c,d,f,m){var n,o,p=a.file,q=a.compression,r=m!==g.utf8encode,s=e.transformTo("string",m(p.name)),t=e.transformTo("string",g.utf8encode(p.name)),u=p.comment,v=e.transformTo("string",m(u)),w=e.transformTo("string",g.utf8encode(u)),x=t.length!==p.name.length,y=w.length!==u.length,z="",A="",B="",C=p.dir,D=p.date,E={crc32:0,compressedSize:0,uncompressedSize:0};b&&!c||(E.crc32=a.crc32,E.compressedSize=a.compressedSize,E.uncompressedSize=a.uncompressedSize);var F=0;b&&(F|=8),r||!x&&!y||(F|=2048);var G=0,H=0;C&&(G|=16),"UNIX"===f?(H=798,G|=k(p.unixPermissions,C)):(H=20,G|=l(p.dosPermissions,C)),n=D.getUTCHours(),n<<=6,n|=D.getUTCMinutes(),n<<=5,n|=D.getUTCSeconds()/2,o=D.getUTCFullYear()-1980,o<<=4,o|=D.getUTCMonth()+1,o<<=5,o|=D.getUTCDate(),x&&(A=j(1,1)+j(h(s),4)+t,z+="up"+j(A.length,2)+A),y&&(B=j(1,1)+j(h(v),4)+w,z+="uc"+j(B.length,2)+B);var I="";I+="\n\0",I+=j(F,2),I+=q.magic,I+=j(n,2),I+=j(o,2),I+=j(E.crc32,4),I+=j(E.compressedSize,4),I+=j(E.uncompressedSize,4),I+=j(s.length,2),I+=j(z.length,2);var J=i.LOCAL_FILE_HEADER+I+s+z,K=i.CENTRAL_FILE_HEADER+j(H,2)+I+j(v.length,2)+"\0\0\0\0"+j(G,4)+j(d,4)+s+z+v;return{fileRecord:J,dirRecord:K}},n=function(a,b,c,d,f){var g="",h=e.transformTo("string",f(d));return g=i.CENTRAL_DIRECTORY_END+"\0\0\0\0"+j(a,2)+j(a,2)+j(b,4)+j(c,4)+j(h.length,2)+h},o=function(a){var b="";return b=i.DATA_DESCRIPTOR+j(a.crc32,4)+j(a.compressedSize,4)+j(a.uncompressedSize,4)};e.inherits(d,f),d.prototype.push=function(a){var b=a.meta.percent||0,c=this.entriesCount,d=this._sources.length;this.accumulate?this.contentBuffer.push(a):(this.bytesWritten+=a.data.length,f.prototype.push.call(this,{data:a.data,meta:{currentFile:this.currentFile,percent:c?(b+100*(c-d-1))/c:100}}))},d.prototype.openedSource=function(a){this.currentSourceOffset=this.bytesWritten,this.currentFile=a.file.name;var b=this.streamFiles&&!a.file.dir;if(b){var c=m(a,b,!1,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);this.push({data:c.fileRecord,meta:{percent:0}})}else this.accumulate=!0},d.prototype.closedSource=function(a){this.accumulate=!1;var b=this.streamFiles&&!a.file.dir,c=m(a,b,!0,this.currentSourceOffset,this.zipPlatform,this.encodeFileName);if(this.dirRecords.push(c.dirRecord),b)this.push({data:o(a),meta:{percent:100}});else for(this.push({data:c.fileRecord,meta:{percent:0}});this.contentBuffer.length;)this.push(this.contentBuffer.shift());this.currentFile=null},d.prototype.flush=function(){for(var a=this.bytesWritten,b=0;b<this.dirRecords.length;b++)this.push({data:this.dirRecords[b],meta:{percent:100}});var c=this.bytesWritten-a,d=n(this.dirRecords.length,c,a,this.zipComment,this.encodeFileName);this.push({data:d,meta:{percent:100}})},d.prototype.prepareNextSource=function(){this.previous=this._sources.shift(),this.openedSource(this.previous.streamInfo),this.isPaused?this.previous.pause():this.previous.resume()},d.prototype.registerPrevious=function(a){this._sources.push(a);var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.closedSource(b.previous.streamInfo),b._sources.length?b.prepareNextSource():b.end()}),a.on("error",function(a){b.error(a)}),this},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this.previous&&this._sources.length?(this.prepareNextSource(),!0):this.previous||this._sources.length||this.generatedError?void 0:(this.end(),!0))},d.prototype.error=function(a){var b=this._sources;if(!f.prototype.error.call(this,a))return!1;for(var c=0;c<b.length;c++)try{b[c].error(a)}catch(a){}return!0},d.prototype.lock=function(){f.prototype.lock.call(this);for(var a=this._sources,b=0;b<a.length;b++)a[b].lock()},b.exports=d},{"../crc32":4,"../signature":23,"../stream/GenericWorker":28,"../utf8":31,"../utils":32}],9:[function(a,b,c){"use strict";var d=a("../compressions"),e=a("./ZipFileWorker"),f=function(a,b){var c=a||b,e=d[c];if(!e)throw new Error(c+" is not a valid compression method !");return e};c.generateWorker=function(a,b,c){var d=new e(b.streamFiles,c,b.platform,b.encodeFileName),g=0;try{a.forEach(function(a,c){g++;var e=f(c.options.compression,b.compression),h=c.options.compressionOptions||b.compressionOptions||{},i=c.dir,j=c.date;c._compressWorker(e,h).withStreamInfo("file",{name:a,dir:i,date:j,comment:c.comment||"",unixPermissions:c.unixPermissions,dosPermissions:c.dosPermissions}).pipe(d)}),d.entriesCount=g}catch(h){d.error(h)}return d}},{"../compressions":3,"./ZipFileWorker":8}],10:[function(a,b,c){"use strict";function d(){if(!(this instanceof d))return new d;if(arguments.length)throw new Error("The constructor with parameters has been removed in JSZip 3.0, please check the upgrade guide.");this.files={},this.comment=null,this.root="",this.clone=function(){var a=new d;for(var b in this)"function"!=typeof this[b]&&(a[b]=this[b]);return a}}d.prototype=a("./object"),d.prototype.loadAsync=a("./load"),d.support=a("./support"),d.defaults=a("./defaults"),d.version="3.1.5",d.loadAsync=function(a,b){return(new d).loadAsync(a,b)},d.external=a("./external"),b.exports=d},{"./defaults":5,"./external":6,"./load":11,"./object":15,"./support":30}],11:[function(a,b,c){"use strict";function d(a){return new f.Promise(function(b,c){var d=a.decompressed.getContentWorker().pipe(new i);d.on("error",function(a){c(a)}).on("end",function(){d.streamInfo.crc32!==a.decompressed.crc32?c(new Error("Corrupted zip : CRC32 mismatch")):b()}).resume()})}var e=a("./utils"),f=a("./external"),g=a("./utf8"),e=a("./utils"),h=a("./zipEntries"),i=a("./stream/Crc32Probe"),j=a("./nodejsUtils");b.exports=function(a,b){var c=this;return b=e.extend(b||{},{base64:!1,checkCRC32:!1,optimizedBinaryString:!1,createFolders:!1,decodeFileName:g.utf8decode}),j.isNode&&j.isStream(a)?f.Promise.reject(new Error("JSZip can't accept a stream when loading a zip file.")):e.prepareContent("the loaded zip file",a,!0,b.optimizedBinaryString,b.base64).then(function(a){var c=new h(b);return c.load(a),c}).then(function(a){var c=[f.Promise.resolve(a)],e=a.files;if(b.checkCRC32)for(var g=0;g<e.length;g++)c.push(d(e[g]));return f.Promise.all(c)}).then(function(a){for(var d=a.shift(),e=d.files,f=0;f<e.length;f++){var g=e[f];c.file(g.fileNameStr,g.decompressed,{binary:!0,optimizedBinaryString:!0,date:g.date,dir:g.dir,comment:g.fileCommentStr.length?g.fileCommentStr:null,unixPermissions:g.unixPermissions,dosPermissions:g.dosPermissions,createFolders:b.createFolders})}return d.zipComment.length&&(c.comment=d.zipComment),c})}},{"./external":6,"./nodejsUtils":14,"./stream/Crc32Probe":25,"./utf8":31,"./utils":32,"./zipEntries":33}],12:[function(a,b,c){"use strict";function d(a,b){f.call(this,"Nodejs stream input adapter for "+a),this._upstreamEnded=!1,this._bindStream(b)}var e=a("../utils"),f=a("../stream/GenericWorker");e.inherits(d,f),d.prototype._bindStream=function(a){var b=this;this._stream=a,a.pause(),a.on("data",function(a){b.push({data:a,meta:{percent:0}})}).on("error",function(a){b.isPaused?this.generatedError=a:b.error(a)}).on("end",function(){b.isPaused?b._upstreamEnded=!0:b.end()})},d.prototype.pause=function(){return!!f.prototype.pause.call(this)&&(this._stream.pause(),!0)},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(this._upstreamEnded?this.end():this._stream.resume(),!0)},b.exports=d},{"../stream/GenericWorker":28,"../utils":32}],13:[function(a,b,c){"use strict";function d(a,b,c){e.call(this,b),this._helper=a;var d=this;a.on("data",function(a,b){d.push(a)||d._helper.pause(),c&&c(b)}).on("error",function(a){d.emit("error",a)}).on("end",function(){d.push(null)})}var e=a("readable-stream").Readable,f=a("../utils");f.inherits(d,e),d.prototype._read=function(){this._helper.resume()},b.exports=d},{"../utils":32,"readable-stream":16}],14:[function(a,b,c){"use strict";b.exports={isNode:"undefined"!=typeof Buffer,newBufferFrom:function(a,b){return new Buffer(a,b)},allocBuffer:function(a){return Buffer.alloc?Buffer.alloc(a):new Buffer(a)},isBuffer:function(a){return Buffer.isBuffer(a)},isStream:function(a){return a&&"function"==typeof a.on&&"function"==typeof a.pause&&"function"==typeof a.resume}}},{}],15:[function(a,b,c){"use strict";function d(a){return"[object RegExp]"===Object.prototype.toString.call(a)}var e=a("./utf8"),f=a("./utils"),g=a("./stream/GenericWorker"),h=a("./stream/StreamHelper"),i=a("./defaults"),j=a("./compressedObject"),k=a("./zipObject"),l=a("./generate"),m=a("./nodejsUtils"),n=a("./nodejs/NodejsStreamInputAdapter"),o=function(a,b,c){var d,e=f.getTypeOf(b),h=f.extend(c||{},i);h.date=h.date||new Date,null!==h.compression&&(h.compression=h.compression.toUpperCase()),"string"==typeof h.unixPermissions&&(h.unixPermissions=parseInt(h.unixPermissions,8)),h.unixPermissions&&16384&h.unixPermissions&&(h.dir=!0),h.dosPermissions&&16&h.dosPermissions&&(h.dir=!0),h.dir&&(a=q(a)),h.createFolders&&(d=p(a))&&r.call(this,d,!0);var l="string"===e&&h.binary===!1&&h.base64===!1;c&&"undefined"!=typeof c.binary||(h.binary=!l);var o=b instanceof j&&0===b.uncompressedSize;(o||h.dir||!b||0===b.length)&&(h.base64=!1,h.binary=!0,b="",h.compression="STORE",e="string");var s=null;s=b instanceof j||b instanceof g?b:m.isNode&&m.isStream(b)?new n(a,b):f.prepareContent(a,b,h.binary,h.optimizedBinaryString,h.base64);var t=new k(a,s,h);this.files[a]=t},p=function(a){"/"===a.slice(-1)&&(a=a.substring(0,a.length-1));var b=a.lastIndexOf("/");return b>0?a.substring(0,b):""},q=function(a){return"/"!==a.slice(-1)&&(a+="/"),a},r=function(a,b){return b="undefined"!=typeof b?b:i.createFolders,a=q(a),this.files[a]||o.call(this,a,null,{dir:!0,createFolders:b}),this.files[a]},s={load:function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},forEach:function(a){var b,c,d;for(b in this.files)this.files.hasOwnProperty(b)&&(d=this.files[b],c=b.slice(this.root.length,b.length),c&&b.slice(0,this.root.length)===this.root&&a(c,d))},filter:function(a){var b=[];return this.forEach(function(c,d){a(c,d)&&b.push(d)}),b},file:function(a,b,c){if(1===arguments.length){if(d(a)){var e=a;return this.filter(function(a,b){return!b.dir&&e.test(a)})}var f=this.files[this.root+a];return f&&!f.dir?f:null}return a=this.root+a,o.call(this,a,b,c),this},folder:function(a){if(!a)return this;if(d(a))return this.filter(function(b,c){return c.dir&&a.test(b)});var b=this.root+a,c=r.call(this,b),e=this.clone();return e.root=c.name,e},remove:function(a){a=this.root+a;var b=this.files[a];if(b||("/"!==a.slice(-1)&&(a+="/"),b=this.files[a]),b&&!b.dir)delete this.files[a];else for(var c=this.filter(function(b,c){return c.name.slice(0,a.length)===a}),d=0;d<c.length;d++)delete this.files[c[d].name];return this},generate:function(a){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},generateInternalStream:function(a){var b,c={};try{if(c=f.extend(a||{},{streamFiles:!1,compression:"STORE",compressionOptions:null,type:"",platform:"DOS",comment:null,mimeType:"application/zip",encodeFileName:e.utf8encode}),c.type=c.type.toLowerCase(),c.compression=c.compression.toUpperCase(),"binarystring"===c.type&&(c.type="string"),!c.type)throw new Error("No output type specified.");f.checkSupport(c.type),"darwin"!==c.platform&&"freebsd"!==c.platform&&"linux"!==c.platform&&"sunos"!==c.platform||(c.platform="UNIX"),"win32"===c.platform&&(c.platform="DOS");var d=c.comment||this.comment||"";b=l.generateWorker(this,c,d)}catch(i){b=new g("error"),b.error(i)}return new h(b,c.type||"string",c.mimeType)},generateAsync:function(a,b){return this.generateInternalStream(a).accumulate(b)},generateNodeStream:function(a,b){return a=a||{},a.type||(a.type="nodebuffer"),this.generateInternalStream(a).toNodejsStream(b)}};b.exports=s},{"./compressedObject":2,"./defaults":5,"./generate":9,"./nodejs/NodejsStreamInputAdapter":12,"./nodejsUtils":14,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31,"./utils":32,"./zipObject":35}],16:[function(a,b,c){b.exports=a("stream")},{stream:void 0}],17:[function(a,b,c){"use strict";function d(a){e.call(this,a);for(var b=0;b<this.data.length;b++)a[b]=255&a[b]}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data[this.zero+a]},d.prototype.lastIndexOfSignature=function(a){for(var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.length-4;f>=0;--f)if(this.data[f]===b&&this.data[f+1]===c&&this.data[f+2]===d&&this.data[f+3]===e)return f-this.zero;return-1},d.prototype.readAndCheckSignature=function(a){var b=a.charCodeAt(0),c=a.charCodeAt(1),d=a.charCodeAt(2),e=a.charCodeAt(3),f=this.readData(4);return b===f[0]&&c===f[1]&&d===f[2]&&e===f[3]},d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return[];var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],18:[function(a,b,c){"use strict";function d(a){this.data=a,this.length=a.length,this.index=0,this.zero=0}var e=a("../utils");d.prototype={checkOffset:function(a){this.checkIndex(this.index+a)},checkIndex:function(a){if(this.length<this.zero+a||a<0)throw new Error("End of data reached (data length = "+this.length+", asked index = "+a+"). Corrupted zip ?")},setIndex:function(a){this.checkIndex(a),this.index=a},skip:function(a){this.setIndex(this.index+a)},byteAt:function(a){},readInt:function(a){var b,c=0;for(this.checkOffset(a),b=this.index+a-1;b>=this.index;b--)c=(c<<8)+this.byteAt(b);return this.index+=a,c},readString:function(a){return e.transformTo("string",this.readData(a))},readData:function(a){},lastIndexOfSignature:function(a){},readAndCheckSignature:function(a){},readDate:function(){var a=this.readInt(4);return new Date(Date.UTC((a>>25&127)+1980,(a>>21&15)-1,a>>16&31,a>>11&31,a>>5&63,(31&a)<<1))}},b.exports=d},{"../utils":32}],19:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./Uint8ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./Uint8ArrayReader":21}],20:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./DataReader"),f=a("../utils");f.inherits(d,e),d.prototype.byteAt=function(a){return this.data.charCodeAt(this.zero+a)},d.prototype.lastIndexOfSignature=function(a){return this.data.lastIndexOf(a)-this.zero},d.prototype.readAndCheckSignature=function(a){var b=this.readData(4);return a===b},d.prototype.readData=function(a){this.checkOffset(a);var b=this.data.slice(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./DataReader":18}],21:[function(a,b,c){"use strict";function d(a){e.call(this,a)}var e=a("./ArrayReader"),f=a("../utils");f.inherits(d,e),d.prototype.readData=function(a){if(this.checkOffset(a),0===a)return new Uint8Array(0);var b=this.data.subarray(this.zero+this.index,this.zero+this.index+a);return this.index+=a,b},b.exports=d},{"../utils":32,"./ArrayReader":17}],22:[function(a,b,c){"use strict";var d=a("../utils"),e=a("../support"),f=a("./ArrayReader"),g=a("./StringReader"),h=a("./NodeBufferReader"),i=a("./Uint8ArrayReader");b.exports=function(a){var b=d.getTypeOf(a);return d.checkSupport(b),"string"!==b||e.uint8array?"nodebuffer"===b?new h(a):e.uint8array?new i(d.transformTo("uint8array",a)):new f(d.transformTo("array",a)):new g(a)}},{"../support":30,"../utils":32,"./ArrayReader":17,"./NodeBufferReader":19,"./StringReader":20,"./Uint8ArrayReader":21}],23:[function(a,b,c){"use strict";c.LOCAL_FILE_HEADER="PK",c.CENTRAL_FILE_HEADER="PK",c.CENTRAL_DIRECTORY_END="PK",c.ZIP64_CENTRAL_DIRECTORY_LOCATOR="PK",c.ZIP64_CENTRAL_DIRECTORY_END="PK",c.DATA_DESCRIPTOR="PK\b"},{}],24:[function(a,b,c){"use strict";function d(a){e.call(this,"ConvertWorker to "+a),this.destType=a}var e=a("./GenericWorker"),f=a("../utils");f.inherits(d,e),d.prototype.processChunk=function(a){this.push({data:f.transformTo(this.destType,a.data),meta:a.meta})},b.exports=d},{"../utils":32,"./GenericWorker":28}],25:[function(a,b,c){"use strict";function d(){e.call(this,"Crc32Probe"),this.withStreamInfo("crc32",0)}var e=a("./GenericWorker"),f=a("../crc32"),g=a("../utils");g.inherits(d,e),d.prototype.processChunk=function(a){this.streamInfo.crc32=f(a.data,this.streamInfo.crc32||0),this.push(a)},b.exports=d},{"../crc32":4,"../utils":32,"./GenericWorker":28}],26:[function(a,b,c){"use strict";function d(a){f.call(this,"DataLengthProbe for "+a),this.propName=a,this.withStreamInfo(a,0)}var e=a("../utils"),f=a("./GenericWorker");e.inherits(d,f),d.prototype.processChunk=function(a){if(a){var b=this.streamInfo[this.propName]||0;this.streamInfo[this.propName]=b+a.data.length}f.prototype.processChunk.call(this,a)},b.exports=d},{"../utils":32,"./GenericWorker":28}],27:[function(a,b,c){"use strict";function d(a){f.call(this,"DataWorker");var b=this;this.dataIsReady=!1,this.index=0,this.max=0,this.data=null,this.type="",this._tickScheduled=!1,a.then(function(a){b.dataIsReady=!0,b.data=a,b.max=a&&a.length||0,b.type=e.getTypeOf(a),b.isPaused||b._tickAndRepeat()},function(a){b.error(a)})}var e=a("../utils"),f=a("./GenericWorker"),g=16384;e.inherits(d,f),d.prototype.cleanUp=function(){f.prototype.cleanUp.call(this),this.data=null},d.prototype.resume=function(){return!!f.prototype.resume.call(this)&&(!this._tickScheduled&&this.dataIsReady&&(this._tickScheduled=!0,e.delay(this._tickAndRepeat,[],this)),!0)},d.prototype._tickAndRepeat=function(){this._tickScheduled=!1,this.isPaused||this.isFinished||(this._tick(),this.isFinished||(e.delay(this._tickAndRepeat,[],this),this._tickScheduled=!0))},d.prototype._tick=function(){if(this.isPaused||this.isFinished)return!1;var a=g,b=null,c=Math.min(this.max,this.index+a);if(this.index>=this.max)return this.end();switch(this.type){case"string":b=this.data.substring(this.index,c);break;case"uint8array":b=this.data.subarray(this.index,c);break;case"array":case"nodebuffer":b=this.data.slice(this.index,c)}return this.index=c,this.push({data:b,meta:{percent:this.max?this.index/this.max*100:0}})},b.exports=d},{"../utils":32,"./GenericWorker":28}],28:[function(a,b,c){"use strict";function d(a){this.name=a||"default",this.streamInfo={},this.generatedError=null,this.extraStreamInfo={},this.isPaused=!0,this.isFinished=!1,this.isLocked=!1,this._listeners={data:[],end:[],error:[]},this.previous=null}d.prototype={push:function(a){this.emit("data",a)},end:function(){if(this.isFinished)return!1;this.flush();try{this.emit("end"),this.cleanUp(),this.isFinished=!0}catch(a){this.emit("error",a)}return!0},error:function(a){return!this.isFinished&&(this.isPaused?this.generatedError=a:(this.isFinished=!0,this.emit("error",a),this.previous&&this.previous.error(a),this.cleanUp()),!0)},on:function(a,b){return this._listeners[a].push(b),this},cleanUp:function(){this.streamInfo=this.generatedError=this.extraStreamInfo=null,this._listeners=[]},emit:function(a,b){if(this._listeners[a])for(var c=0;c<this._listeners[a].length;c++)this._listeners[a][c].call(this,b)},pipe:function(a){return a.registerPrevious(this)},registerPrevious:function(a){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.streamInfo=a.streamInfo,this.mergeStreamInfo(),this.previous=a;var b=this;return a.on("data",function(a){b.processChunk(a)}),a.on("end",function(){b.end()}),a.on("error",function(a){b.error(a)}),this},pause:function(){return!this.isPaused&&!this.isFinished&&(this.isPaused=!0,this.previous&&this.previous.pause(),!0)},resume:function(){if(!this.isPaused||this.isFinished)return!1;this.isPaused=!1;var a=!1;return this.generatedError&&(this.error(this.generatedError),a=!0),this.previous&&this.previous.resume(),!a},flush:function(){},processChunk:function(a){this.push(a)},withStreamInfo:function(a,b){return this.extraStreamInfo[a]=b,this.mergeStreamInfo(),this},mergeStreamInfo:function(){for(var a in this.extraStreamInfo)this.extraStreamInfo.hasOwnProperty(a)&&(this.streamInfo[a]=this.extraStreamInfo[a])},lock:function(){if(this.isLocked)throw new Error("The stream '"+this+"' has already been used.");this.isLocked=!0,this.previous&&this.previous.lock()},toString:function(){var a="Worker "+this.name;return this.previous?this.previous+" -> "+a:a}},b.exports=d},{}],29:[function(a,b,c){"use strict";function d(a,b,c){switch(a){case"blob":return h.newBlob(h.transformTo("arraybuffer",b),c);case"base64":return k.encode(b);default:return h.transformTo(a,b)}}function e(a,b){var c,d=0,e=null,f=0;for(c=0;c<b.length;c++)f+=b[c].length;switch(a){case"string":return b.join("");case"array":return Array.prototype.concat.apply([],b);case"uint8array":for(e=new Uint8Array(f),c=0;c<b.length;c++)e.set(b[c],d),d+=b[c].length;return e;case"nodebuffer":return Buffer.concat(b);default:throw new Error("concat : unsupported type '"+a+"'")}}function f(a,b){return new m.Promise(function(c,f){var g=[],h=a._internalType,i=a._outputType,j=a._mimeType;a.on("data",function(a,c){g.push(a),b&&b(c)}).on("error",function(a){g=[],f(a)}).on("end",function(){try{var a=d(i,e(h,g),j);c(a)}catch(b){f(b)}g=[]}).resume()})}function g(a,b,c){var d=b;switch(b){case"blob":case"arraybuffer":d="uint8array";break;case"base64":d="string"}try{this._internalType=d,this._outputType=b,this._mimeType=c,h.checkSupport(d),this._worker=a.pipe(new i(d)),a.lock()}catch(e){this._worker=new j("error"),this._worker.error(e)}}var h=a("../utils"),i=a("./ConvertWorker"),j=a("./GenericWorker"),k=a("../base64"),l=a("../support"),m=a("../external"),n=null;if(l.nodestream)try{n=a("../nodejs/NodejsStreamOutputAdapter")}catch(o){}g.prototype={accumulate:function(a){return f(this,a)},on:function(a,b){var c=this;return"data"===a?this._worker.on(a,function(a){b.call(c,a.data,a.meta)}):this._worker.on(a,function(){h.delay(b,arguments,c)}),this},resume:function(){return h.delay(this._worker.resume,[],this._worker),this},pause:function(){return this._worker.pause(),this},toNodejsStream:function(a){if(h.checkSupport("nodestream"),"nodebuffer"!==this._outputType)throw new Error(this._outputType+" is not supported by this method");return new n(this,{objectMode:"nodebuffer"!==this._outputType},a)}},b.exports=g},{"../base64":1,"../external":6,"../nodejs/NodejsStreamOutputAdapter":13,"../support":30,"../utils":32,"./ConvertWorker":24,"./GenericWorker":28}],30:[function(a,b,c){"use strict";if(c.base64=!0,c.array=!0,c.string=!0,c.arraybuffer="undefined"!=typeof ArrayBuffer&&"undefined"!=typeof Uint8Array,c.nodebuffer="undefined"!=typeof Buffer,c.uint8array="undefined"!=typeof Uint8Array,"undefined"==typeof ArrayBuffer)c.blob=!1;else{var d=new ArrayBuffer(0);try{c.blob=0===new Blob([d],{type:"application/zip"}).size}catch(e){try{var f=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,g=new f;g.append(d),c.blob=0===g.getBlob("application/zip").size}catch(e){c.blob=!1}}}try{c.nodestream=!!a("readable-stream").Readable}catch(e){c.nodestream=!1}},{"readable-stream":16}],31:[function(a,b,c){"use strict";function d(){i.call(this,"utf-8 decode"),this.leftOver=null}function e(){i.call(this,"utf-8 encode")}for(var f=a("./utils"),g=a("./support"),h=a("./nodejsUtils"),i=a("./stream/GenericWorker"),j=new Array(256),k=0;k<256;k++)j[k]=k>=252?6:k>=248?5:k>=240?4:k>=224?3:k>=192?2:1;j[254]=j[254]=1;var l=function(a){var b,c,d,e,f,h=a.length,i=0;for(e=0;e<h;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=g.uint8array?new Uint8Array(i):new Array(i),f=0,e=0;f<i;e++)c=a.charCodeAt(e),55296===(64512&c)&&e+1<h&&(d=a.charCodeAt(e+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),e++)),c<128?b[f++]=c:c<2048?(b[f++]=192|c>>>6,b[f++]=128|63&c):c<65536?(b[f++]=224|c>>>12,b[f++]=128|c>>>6&63,b[f++]=128|63&c):(b[f++]=240|c>>>18,b[f++]=128|c>>>12&63,b[f++]=128|c>>>6&63,b[f++]=128|63&c);return b},m=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+j[a[c]]>b?c:b},n=function(a){var b,c,d,e,g=a.length,h=new Array(2*g);for(c=0,b=0;b<g;)if(d=a[b++],d<128)h[c++]=d;else if(e=j[d],e>4)h[c++]=65533,b+=e-1;else{for(d&=2===e?31:3===e?15:7;e>1&&b<g;)d=d<<6|63&a[b++],e--;e>1?h[c++]=65533:d<65536?h[c++]=d:(d-=65536,h[c++]=55296|d>>10&1023,h[c++]=56320|1023&d)}return h.length!==c&&(h.subarray?h=h.subarray(0,c):h.length=c),f.applyFromCharCode(h)};c.utf8encode=function(a){return g.nodebuffer?h.newBufferFrom(a,"utf-8"):l(a)},c.utf8decode=function(a){return g.nodebuffer?f.transformTo("nodebuffer",a).toString("utf-8"):(a=f.transformTo(g.uint8array?"uint8array":"array",a),n(a))},f.inherits(d,i),d.prototype.processChunk=function(a){var b=f.transformTo(g.uint8array?"uint8array":"array",a.data);if(this.leftOver&&this.leftOver.length){if(g.uint8array){var d=b;b=new Uint8Array(d.length+this.leftOver.length),b.set(this.leftOver,0),b.set(d,this.leftOver.length)}else b=this.leftOver.concat(b);this.leftOver=null}var e=m(b),h=b;e!==b.length&&(g.uint8array?(h=b.subarray(0,e),this.leftOver=b.subarray(e,b.length)):(h=b.slice(0,e),this.leftOver=b.slice(e,b.length))),this.push({data:c.utf8decode(h),meta:a.meta})},d.prototype.flush=function(){this.leftOver&&this.leftOver.length&&(this.push({data:c.utf8decode(this.leftOver),meta:{}}),this.leftOver=null)},c.Utf8DecodeWorker=d,f.inherits(e,i),e.prototype.processChunk=function(a){this.push({data:c.utf8encode(a.data),meta:a.meta})},c.Utf8EncodeWorker=e},{"./nodejsUtils":14,"./stream/GenericWorker":28,"./support":30,"./utils":32}],32:[function(a,b,c){"use strict";function d(a){var b=null;return b=i.uint8array?new Uint8Array(a.length):new Array(a.length),f(a,b)}function e(a){return a}function f(a,b){for(var c=0;c<a.length;++c)b[c]=255&a.charCodeAt(c);return b}function g(a){var b=65536,d=c.getTypeOf(a),e=!0;if("uint8array"===d?e=n.applyCanBeUsed.uint8array:"nodebuffer"===d&&(e=n.applyCanBeUsed.nodebuffer),e)for(;b>1;)try{return n.stringifyByChunk(a,d,b)}catch(f){b=Math.floor(b/2)}return n.stringifyByChar(a)}function h(a,b){for(var c=0;c<a.length;c++)b[c]=a[c];
return b}var i=a("./support"),j=a("./base64"),k=a("./nodejsUtils"),l=a("core-js/library/fn/set-immediate"),m=a("./external");c.newBlob=function(a,b){c.checkSupport("blob");try{return new Blob([a],{type:b})}catch(d){try{var e=self.BlobBuilder||self.WebKitBlobBuilder||self.MozBlobBuilder||self.MSBlobBuilder,f=new e;return f.append(a),f.getBlob(b)}catch(d){throw new Error("Bug : can't construct the Blob.")}}};var n={stringifyByChunk:function(a,b,c){var d=[],e=0,f=a.length;if(f<=c)return String.fromCharCode.apply(null,a);for(;e<f;)"array"===b||"nodebuffer"===b?d.push(String.fromCharCode.apply(null,a.slice(e,Math.min(e+c,f)))):d.push(String.fromCharCode.apply(null,a.subarray(e,Math.min(e+c,f)))),e+=c;return d.join("")},stringifyByChar:function(a){for(var b="",c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b},applyCanBeUsed:{uint8array:function(){try{return i.uint8array&&1===String.fromCharCode.apply(null,new Uint8Array(1)).length}catch(a){return!1}}(),nodebuffer:function(){try{return i.nodebuffer&&1===String.fromCharCode.apply(null,k.allocBuffer(1)).length}catch(a){return!1}}()}};c.applyFromCharCode=g;var o={};o.string={string:e,array:function(a){return f(a,new Array(a.length))},arraybuffer:function(a){return o.string.uint8array(a).buffer},uint8array:function(a){return f(a,new Uint8Array(a.length))},nodebuffer:function(a){return f(a,k.allocBuffer(a.length))}},o.array={string:g,array:e,arraybuffer:function(a){return new Uint8Array(a).buffer},uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(a)}},o.arraybuffer={string:function(a){return g(new Uint8Array(a))},array:function(a){return h(new Uint8Array(a),new Array(a.byteLength))},arraybuffer:e,uint8array:function(a){return new Uint8Array(a)},nodebuffer:function(a){return k.newBufferFrom(new Uint8Array(a))}},o.uint8array={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return a.buffer},uint8array:e,nodebuffer:function(a){return k.newBufferFrom(a)}},o.nodebuffer={string:g,array:function(a){return h(a,new Array(a.length))},arraybuffer:function(a){return o.nodebuffer.uint8array(a).buffer},uint8array:function(a){return h(a,new Uint8Array(a.length))},nodebuffer:e},c.transformTo=function(a,b){if(b||(b=""),!a)return b;c.checkSupport(a);var d=c.getTypeOf(b),e=o[d][a](b);return e},c.getTypeOf=function(a){return"string"==typeof a?"string":"[object Array]"===Object.prototype.toString.call(a)?"array":i.nodebuffer&&k.isBuffer(a)?"nodebuffer":i.uint8array&&a instanceof Uint8Array?"uint8array":i.arraybuffer&&a instanceof ArrayBuffer?"arraybuffer":void 0},c.checkSupport=function(a){var b=i[a.toLowerCase()];if(!b)throw new Error(a+" is not supported by this platform")},c.MAX_VALUE_16BITS=65535,c.MAX_VALUE_32BITS=-1,c.pretty=function(a){var b,c,d="";for(c=0;c<(a||"").length;c++)b=a.charCodeAt(c),d+="\\x"+(b<16?"0":"")+b.toString(16).toUpperCase();return d},c.delay=function(a,b,c){l(function(){a.apply(c||null,b||[])})},c.inherits=function(a,b){var c=function(){};c.prototype=b.prototype,a.prototype=new c},c.extend=function(){var a,b,c={};for(a=0;a<arguments.length;a++)for(b in arguments[a])arguments[a].hasOwnProperty(b)&&"undefined"==typeof c[b]&&(c[b]=arguments[a][b]);return c},c.prepareContent=function(a,b,e,f,g){var h=m.Promise.resolve(b).then(function(a){var b=i.blob&&(a instanceof Blob||["[object File]","[object Blob]"].indexOf(Object.prototype.toString.call(a))!==-1);return b&&"undefined"!=typeof FileReader?new m.Promise(function(b,c){var d=new FileReader;d.onload=function(a){b(a.target.result)},d.onerror=function(a){c(a.target.error)},d.readAsArrayBuffer(a)}):a});return h.then(function(b){var h=c.getTypeOf(b);return h?("arraybuffer"===h?b=c.transformTo("uint8array",b):"string"===h&&(g?b=j.decode(b):e&&f!==!0&&(b=d(b))),b):m.Promise.reject(new Error("Can't read the data of '"+a+"'. Is it in a supported JavaScript type (String, Blob, ArrayBuffer, etc) ?"))})}},{"./base64":1,"./external":6,"./nodejsUtils":14,"./support":30,"core-js/library/fn/set-immediate":36}],33:[function(a,b,c){"use strict";function d(a){this.files=[],this.loadOptions=a}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./signature"),h=a("./zipEntry"),i=(a("./utf8"),a("./support"));d.prototype={checkSignature:function(a){if(!this.reader.readAndCheckSignature(a)){this.reader.index-=4;var b=this.reader.readString(4);throw new Error("Corrupted zip or bug: unexpected signature ("+f.pretty(b)+", expected "+f.pretty(a)+")")}},isSignature:function(a,b){var c=this.reader.index;this.reader.setIndex(a);var d=this.reader.readString(4),e=d===b;return this.reader.setIndex(c),e},readBlockEndOfCentral:function(){this.diskNumber=this.reader.readInt(2),this.diskWithCentralDirStart=this.reader.readInt(2),this.centralDirRecordsOnThisDisk=this.reader.readInt(2),this.centralDirRecords=this.reader.readInt(2),this.centralDirSize=this.reader.readInt(4),this.centralDirOffset=this.reader.readInt(4),this.zipCommentLength=this.reader.readInt(2);var a=this.reader.readData(this.zipCommentLength),b=i.uint8array?"uint8array":"array",c=f.transformTo(b,a);this.zipComment=this.loadOptions.decodeFileName(c)},readBlockZip64EndOfCentral:function(){this.zip64EndOfCentralSize=this.reader.readInt(8),this.reader.skip(4),this.diskNumber=this.reader.readInt(4),this.diskWithCentralDirStart=this.reader.readInt(4),this.centralDirRecordsOnThisDisk=this.reader.readInt(8),this.centralDirRecords=this.reader.readInt(8),this.centralDirSize=this.reader.readInt(8),this.centralDirOffset=this.reader.readInt(8),this.zip64ExtensibleData={};for(var a,b,c,d=this.zip64EndOfCentralSize-44,e=0;e<d;)a=this.reader.readInt(2),b=this.reader.readInt(4),c=this.reader.readData(b),this.zip64ExtensibleData[a]={id:a,length:b,value:c}},readBlockZip64EndOfCentralLocator:function(){if(this.diskWithZip64CentralDirStart=this.reader.readInt(4),this.relativeOffsetEndOfZip64CentralDir=this.reader.readInt(8),this.disksCount=this.reader.readInt(4),this.disksCount>1)throw new Error("Multi-volumes zip are not supported")},readLocalFiles:function(){var a,b;for(a=0;a<this.files.length;a++)b=this.files[a],this.reader.setIndex(b.localHeaderOffset),this.checkSignature(g.LOCAL_FILE_HEADER),b.readLocalPart(this.reader),b.handleUTF8(),b.processAttributes()},readCentralDir:function(){var a;for(this.reader.setIndex(this.centralDirOffset);this.reader.readAndCheckSignature(g.CENTRAL_FILE_HEADER);)a=new h({zip64:this.zip64},this.loadOptions),a.readCentralPart(this.reader),this.files.push(a);if(this.centralDirRecords!==this.files.length&&0!==this.centralDirRecords&&0===this.files.length)throw new Error("Corrupted zip or bug: expected "+this.centralDirRecords+" records in central dir, got "+this.files.length)},readEndOfCentral:function(){var a=this.reader.lastIndexOfSignature(g.CENTRAL_DIRECTORY_END);if(a<0){var b=!this.isSignature(0,g.LOCAL_FILE_HEADER);throw b?new Error("Can't find end of central directory : is this a zip file ? If it is, see https://stuk.github.io/jszip/documentation/howto/read_zip.html"):new Error("Corrupted zip: can't find end of central directory")}this.reader.setIndex(a);var c=a;if(this.checkSignature(g.CENTRAL_DIRECTORY_END),this.readBlockEndOfCentral(),this.diskNumber===f.MAX_VALUE_16BITS||this.diskWithCentralDirStart===f.MAX_VALUE_16BITS||this.centralDirRecordsOnThisDisk===f.MAX_VALUE_16BITS||this.centralDirRecords===f.MAX_VALUE_16BITS||this.centralDirSize===f.MAX_VALUE_32BITS||this.centralDirOffset===f.MAX_VALUE_32BITS){if(this.zip64=!0,a=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),a<0)throw new Error("Corrupted zip: can't find the ZIP64 end of central directory locator");if(this.reader.setIndex(a),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_LOCATOR),this.readBlockZip64EndOfCentralLocator(),!this.isSignature(this.relativeOffsetEndOfZip64CentralDir,g.ZIP64_CENTRAL_DIRECTORY_END)&&(this.relativeOffsetEndOfZip64CentralDir=this.reader.lastIndexOfSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.relativeOffsetEndOfZip64CentralDir<0))throw new Error("Corrupted zip: can't find the ZIP64 end of central directory");this.reader.setIndex(this.relativeOffsetEndOfZip64CentralDir),this.checkSignature(g.ZIP64_CENTRAL_DIRECTORY_END),this.readBlockZip64EndOfCentral()}var d=this.centralDirOffset+this.centralDirSize;this.zip64&&(d+=20,d+=12+this.zip64EndOfCentralSize);var e=c-d;if(e>0)this.isSignature(c,g.CENTRAL_FILE_HEADER)||(this.reader.zero=e);else if(e<0)throw new Error("Corrupted zip: missing "+Math.abs(e)+" bytes.")},prepareReader:function(a){this.reader=e(a)},load:function(a){this.prepareReader(a),this.readEndOfCentral(),this.readCentralDir(),this.readLocalFiles()}},b.exports=d},{"./reader/readerFor":22,"./signature":23,"./support":30,"./utf8":31,"./utils":32,"./zipEntry":34}],34:[function(a,b,c){"use strict";function d(a,b){this.options=a,this.loadOptions=b}var e=a("./reader/readerFor"),f=a("./utils"),g=a("./compressedObject"),h=a("./crc32"),i=a("./utf8"),j=a("./compressions"),k=a("./support"),l=0,m=3,n=function(a){for(var b in j)if(j.hasOwnProperty(b)&&j[b].magic===a)return j[b];return null};d.prototype={isEncrypted:function(){return 1===(1&this.bitFlag)},useUTF8:function(){return 2048===(2048&this.bitFlag)},readLocalPart:function(a){var b,c;if(a.skip(22),this.fileNameLength=a.readInt(2),c=a.readInt(2),this.fileName=a.readData(this.fileNameLength),a.skip(c),this.compressedSize===-1||this.uncompressedSize===-1)throw new Error("Bug or corrupted zip : didn't get enough informations from the central directory (compressedSize === -1 || uncompressedSize === -1)");if(b=n(this.compressionMethod),null===b)throw new Error("Corrupted zip : compression "+f.pretty(this.compressionMethod)+" unknown (inner file : "+f.transformTo("string",this.fileName)+")");this.decompressed=new g(this.compressedSize,this.uncompressedSize,this.crc32,b,a.readData(this.compressedSize))},readCentralPart:function(a){this.versionMadeBy=a.readInt(2),a.skip(2),this.bitFlag=a.readInt(2),this.compressionMethod=a.readString(2),this.date=a.readDate(),this.crc32=a.readInt(4),this.compressedSize=a.readInt(4),this.uncompressedSize=a.readInt(4);var b=a.readInt(2);if(this.extraFieldsLength=a.readInt(2),this.fileCommentLength=a.readInt(2),this.diskNumberStart=a.readInt(2),this.internalFileAttributes=a.readInt(2),this.externalFileAttributes=a.readInt(4),this.localHeaderOffset=a.readInt(4),this.isEncrypted())throw new Error("Encrypted zip are not supported");a.skip(b),this.readExtraFields(a),this.parseZIP64ExtraField(a),this.fileComment=a.readData(this.fileCommentLength)},processAttributes:function(){this.unixPermissions=null,this.dosPermissions=null;var a=this.versionMadeBy>>8;this.dir=!!(16&this.externalFileAttributes),a===l&&(this.dosPermissions=63&this.externalFileAttributes),a===m&&(this.unixPermissions=this.externalFileAttributes>>16&65535),this.dir||"/"!==this.fileNameStr.slice(-1)||(this.dir=!0)},parseZIP64ExtraField:function(a){if(this.extraFields[1]){var b=e(this.extraFields[1].value);this.uncompressedSize===f.MAX_VALUE_32BITS&&(this.uncompressedSize=b.readInt(8)),this.compressedSize===f.MAX_VALUE_32BITS&&(this.compressedSize=b.readInt(8)),this.localHeaderOffset===f.MAX_VALUE_32BITS&&(this.localHeaderOffset=b.readInt(8)),this.diskNumberStart===f.MAX_VALUE_32BITS&&(this.diskNumberStart=b.readInt(4))}},readExtraFields:function(a){var b,c,d,e=a.index+this.extraFieldsLength;for(this.extraFields||(this.extraFields={});a.index<e;)b=a.readInt(2),c=a.readInt(2),d=a.readData(c),this.extraFields[b]={id:b,length:c,value:d}},handleUTF8:function(){var a=k.uint8array?"uint8array":"array";if(this.useUTF8())this.fileNameStr=i.utf8decode(this.fileName),this.fileCommentStr=i.utf8decode(this.fileComment);else{var b=this.findExtraFieldUnicodePath();if(null!==b)this.fileNameStr=b;else{var c=f.transformTo(a,this.fileName);this.fileNameStr=this.loadOptions.decodeFileName(c)}var d=this.findExtraFieldUnicodeComment();if(null!==d)this.fileCommentStr=d;else{var e=f.transformTo(a,this.fileComment);this.fileCommentStr=this.loadOptions.decodeFileName(e)}}},findExtraFieldUnicodePath:function(){var a=this.extraFields[28789];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileName)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null},findExtraFieldUnicodeComment:function(){var a=this.extraFields[25461];if(a){var b=e(a.value);return 1!==b.readInt(1)?null:h(this.fileComment)!==b.readInt(4)?null:i.utf8decode(b.readData(a.length-5))}return null}},b.exports=d},{"./compressedObject":2,"./compressions":3,"./crc32":4,"./reader/readerFor":22,"./support":30,"./utf8":31,"./utils":32}],35:[function(a,b,c){"use strict";var d=a("./stream/StreamHelper"),e=a("./stream/DataWorker"),f=a("./utf8"),g=a("./compressedObject"),h=a("./stream/GenericWorker"),i=function(a,b,c){this.name=a,this.dir=c.dir,this.date=c.date,this.comment=c.comment,this.unixPermissions=c.unixPermissions,this.dosPermissions=c.dosPermissions,this._data=b,this._dataBinary=c.binary,this.options={compression:c.compression,compressionOptions:c.compressionOptions}};i.prototype={internalStream:function(a){var b=null,c="string";try{if(!a)throw new Error("No output type specified.");c=a.toLowerCase();var e="string"===c||"text"===c;"binarystring"!==c&&"text"!==c||(c="string"),b=this._decompressWorker();var g=!this._dataBinary;g&&!e&&(b=b.pipe(new f.Utf8EncodeWorker)),!g&&e&&(b=b.pipe(new f.Utf8DecodeWorker))}catch(i){b=new h("error"),b.error(i)}return new d(b,c,"")},async:function(a,b){return this.internalStream(a).accumulate(b)},nodeStream:function(a,b){return this.internalStream(a||"nodebuffer").toNodejsStream(b)},_compressWorker:function(a,b){if(this._data instanceof g&&this._data.compression.magic===a.magic)return this._data.getCompressedWorker();var c=this._decompressWorker();return this._dataBinary||(c=c.pipe(new f.Utf8EncodeWorker)),g.createWorkerFrom(c,a,b)},_decompressWorker:function(){return this._data instanceof g?this._data.getContentWorker():this._data instanceof h?this._data:new e(this._data)}};for(var j=["asText","asBinary","asNodeBuffer","asUint8Array","asArrayBuffer"],k=function(){throw new Error("This method has been removed in JSZip 3.0, please check the upgrade guide.")},l=0;l<j.length;l++)i.prototype[j[l]]=k;b.exports=i},{"./compressedObject":2,"./stream/DataWorker":27,"./stream/GenericWorker":28,"./stream/StreamHelper":29,"./utf8":31}],36:[function(a,b,c){a("../modules/web.immediate"),b.exports=a("../modules/_core").setImmediate},{"../modules/_core":40,"../modules/web.immediate":56}],37:[function(a,b,c){b.exports=function(a){if("function"!=typeof a)throw TypeError(a+" is not a function!");return a}},{}],38:[function(a,b,c){var d=a("./_is-object");b.exports=function(a){if(!d(a))throw TypeError(a+" is not an object!");return a}},{"./_is-object":51}],39:[function(a,b,c){var d={}.toString;b.exports=function(a){return d.call(a).slice(8,-1)}},{}],40:[function(a,b,c){var d=b.exports={version:"2.3.0"};"number"==typeof __e&&(__e=d)},{}],41:[function(a,b,c){var d=a("./_a-function");b.exports=function(a,b,c){if(d(a),void 0===b)return a;switch(c){case 1:return function(c){return a.call(b,c)};case 2:return function(c,d){return a.call(b,c,d)};case 3:return function(c,d,e){return a.call(b,c,d,e)}}return function(){return a.apply(b,arguments)}}},{"./_a-function":37}],42:[function(a,b,c){b.exports=!a("./_fails")(function(){return 7!=Object.defineProperty({},"a",{get:function(){return 7}}).a})},{"./_fails":45}],43:[function(a,b,c){var d=a("./_is-object"),e=a("./_global").document,f=d(e)&&d(e.createElement);b.exports=function(a){return f?e.createElement(a):{}}},{"./_global":46,"./_is-object":51}],44:[function(a,b,c){var d=a("./_global"),e=a("./_core"),f=a("./_ctx"),g=a("./_hide"),h="prototype",i=function(a,b,c){var j,k,l,m=a&i.F,n=a&i.G,o=a&i.S,p=a&i.P,q=a&i.B,r=a&i.W,s=n?e:e[b]||(e[b]={}),t=s[h],u=n?d:o?d[b]:(d[b]||{})[h];n&&(c=b);for(j in c)k=!m&&u&&void 0!==u[j],k&&j in s||(l=k?u[j]:c[j],s[j]=n&&"function"!=typeof u[j]?c[j]:q&&k?f(l,d):r&&u[j]==l?function(a){var b=function(b,c,d){if(this instanceof a){switch(arguments.length){case 0:return new a;case 1:return new a(b);case 2:return new a(b,c)}return new a(b,c,d)}return a.apply(this,arguments)};return b[h]=a[h],b}(l):p&&"function"==typeof l?f(Function.call,l):l,p&&((s.virtual||(s.virtual={}))[j]=l,a&i.R&&t&&!t[j]&&g(t,j,l)))};i.F=1,i.G=2,i.S=4,i.P=8,i.B=16,i.W=32,i.U=64,i.R=128,b.exports=i},{"./_core":40,"./_ctx":41,"./_global":46,"./_hide":47}],45:[function(a,b,c){b.exports=function(a){try{return!!a()}catch(b){return!0}}},{}],46:[function(a,b,c){var d=b.exports="undefined"!=typeof window&&window.Math==Math?window:"undefined"!=typeof self&&self.Math==Math?self:Function("return this")();"number"==typeof __g&&(__g=d)},{}],47:[function(a,b,c){var d=a("./_object-dp"),e=a("./_property-desc");b.exports=a("./_descriptors")?function(a,b,c){return d.f(a,b,e(1,c))}:function(a,b,c){return a[b]=c,a}},{"./_descriptors":42,"./_object-dp":52,"./_property-desc":53}],48:[function(a,b,c){b.exports=a("./_global").document&&document.documentElement},{"./_global":46}],49:[function(a,b,c){b.exports=!a("./_descriptors")&&!a("./_fails")(function(){return 7!=Object.defineProperty(a("./_dom-create")("div"),"a",{get:function(){return 7}}).a})},{"./_descriptors":42,"./_dom-create":43,"./_fails":45}],50:[function(a,b,c){b.exports=function(a,b,c){var d=void 0===c;switch(b.length){case 0:return d?a():a.call(c);case 1:return d?a(b[0]):a.call(c,b[0]);case 2:return d?a(b[0],b[1]):a.call(c,b[0],b[1]);case 3:return d?a(b[0],b[1],b[2]):a.call(c,b[0],b[1],b[2]);case 4:return d?a(b[0],b[1],b[2],b[3]):a.call(c,b[0],b[1],b[2],b[3])}return a.apply(c,b)}},{}],51:[function(a,b,c){b.exports=function(a){return"object"==typeof a?null!==a:"function"==typeof a}},{}],52:[function(a,b,c){var d=a("./_an-object"),e=a("./_ie8-dom-define"),f=a("./_to-primitive"),g=Object.defineProperty;c.f=a("./_descriptors")?Object.defineProperty:function(a,b,c){if(d(a),b=f(b,!0),d(c),e)try{return g(a,b,c)}catch(h){}if("get"in c||"set"in c)throw TypeError("Accessors not supported!");return"value"in c&&(a[b]=c.value),a}},{"./_an-object":38,"./_descriptors":42,"./_ie8-dom-define":49,"./_to-primitive":55}],53:[function(a,b,c){b.exports=function(a,b){return{enumerable:!(1&a),configurable:!(2&a),writable:!(4&a),value:b}}},{}],54:[function(a,b,c){var d,e,f,g=a("./_ctx"),h=a("./_invoke"),i=a("./_html"),j=a("./_dom-create"),k=a("./_global"),l=k.process,m=k.setImmediate,n=k.clearImmediate,o=k.MessageChannel,p=0,q={},r="onreadystatechange",s=function(){var a=+this;if(q.hasOwnProperty(a)){var b=q[a];delete q[a],b()}},t=function(a){s.call(a.data)};m&&n||(m=function(a){for(var b=[],c=1;arguments.length>c;)b.push(arguments[c++]);return q[++p]=function(){h("function"==typeof a?a:Function(a),b)},d(p),p},n=function(a){delete q[a]},"process"==a("./_cof")(l)?d=function(a){l.nextTick(g(s,a,1))}:o?(e=new o,f=e.port2,e.port1.onmessage=t,d=g(f.postMessage,f,1)):k.addEventListener&&"function"==typeof postMessage&&!k.importScripts?(d=function(a){k.postMessage(a+"","*")},k.addEventListener("message",t,!1)):d=r in j("script")?function(a){i.appendChild(j("script"))[r]=function(){i.removeChild(this),s.call(a)}}:function(a){setTimeout(g(s,a,1),0)}),b.exports={set:m,clear:n}},{"./_cof":39,"./_ctx":41,"./_dom-create":43,"./_global":46,"./_html":48,"./_invoke":50}],55:[function(a,b,c){var d=a("./_is-object");b.exports=function(a,b){if(!d(a))return a;var c,e;if(b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;if("function"==typeof(c=a.valueOf)&&!d(e=c.call(a)))return e;if(!b&&"function"==typeof(c=a.toString)&&!d(e=c.call(a)))return e;throw TypeError("Can't convert object to primitive value")}},{"./_is-object":51}],56:[function(a,b,c){var d=a("./_export"),e=a("./_task");d(d.G+d.B,{setImmediate:e.set,clearImmediate:e.clear})},{"./_export":44,"./_task":54}],57:[function(a,b,c){(function(a){"use strict";function c(){k=!0;for(var a,b,c=l.length;c;){for(b=l,l=[],a=-1;++a<c;)b[a]();c=l.length}k=!1}function d(a){1!==l.push(a)||k||e()}var e,f=a.MutationObserver||a.WebKitMutationObserver;if(f){var g=0,h=new f(c),i=a.document.createTextNode("");h.observe(i,{characterData:!0}),e=function(){i.data=g=++g%2}}else if(a.setImmediate||"undefined"==typeof a.MessageChannel)e="document"in a&&"onreadystatechange"in a.document.createElement("script")?function(){var b=a.document.createElement("script");b.onreadystatechange=function(){c(),b.onreadystatechange=null,b.parentNode.removeChild(b),b=null},a.document.documentElement.appendChild(b)}:function(){setTimeout(c,0)};else{var j=new a.MessageChannel;j.port1.onmessage=c,e=function(){j.port2.postMessage(0)}}var k,l=[];b.exports=d}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],58:[function(a,b,c){"use strict";function d(){}function e(a){if("function"!=typeof a)throw new TypeError("resolver must be a function");this.state=s,this.queue=[],this.outcome=void 0,a!==d&&i(this,a)}function f(a,b,c){this.promise=a,"function"==typeof b&&(this.onFulfilled=b,this.callFulfilled=this.otherCallFulfilled),"function"==typeof c&&(this.onRejected=c,this.callRejected=this.otherCallRejected)}function g(a,b,c){o(function(){var d;try{d=b(c)}catch(e){return p.reject(a,e)}d===a?p.reject(a,new TypeError("Cannot resolve promise with itself")):p.resolve(a,d)})}function h(a){var b=a&&a.then;if(a&&("object"==typeof a||"function"==typeof a)&&"function"==typeof b)return function(){b.apply(a,arguments)}}function i(a,b){function c(b){f||(f=!0,p.reject(a,b))}function d(b){f||(f=!0,p.resolve(a,b))}function e(){b(d,c)}var f=!1,g=j(e);"error"===g.status&&c(g.value)}function j(a,b){var c={};try{c.value=a(b),c.status="success"}catch(d){c.status="error",c.value=d}return c}function k(a){return a instanceof this?a:p.resolve(new this(d),a)}function l(a){var b=new this(d);return p.reject(b,a)}function m(a){function b(a,b){function d(a){g[b]=a,++h!==e||f||(f=!0,p.resolve(j,g))}c.resolve(a).then(d,function(a){f||(f=!0,p.reject(j,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=new Array(e),h=0,i=-1,j=new this(d);++i<e;)b(a[i],i);return j}function n(a){function b(a){c.resolve(a).then(function(a){f||(f=!0,p.resolve(h,a))},function(a){f||(f=!0,p.reject(h,a))})}var c=this;if("[object Array]"!==Object.prototype.toString.call(a))return this.reject(new TypeError("must be an array"));var e=a.length,f=!1;if(!e)return this.resolve([]);for(var g=-1,h=new this(d);++g<e;)b(a[g]);return h}var o=a("immediate"),p={},q=["REJECTED"],r=["FULFILLED"],s=["PENDING"];b.exports=e,e.prototype["catch"]=function(a){return this.then(null,a)},e.prototype.then=function(a,b){if("function"!=typeof a&&this.state===r||"function"!=typeof b&&this.state===q)return this;var c=new this.constructor(d);if(this.state!==s){var e=this.state===r?a:b;g(c,e,this.outcome)}else this.queue.push(new f(c,a,b));return c},f.prototype.callFulfilled=function(a){p.resolve(this.promise,a)},f.prototype.otherCallFulfilled=function(a){g(this.promise,this.onFulfilled,a)},f.prototype.callRejected=function(a){p.reject(this.promise,a)},f.prototype.otherCallRejected=function(a){g(this.promise,this.onRejected,a)},p.resolve=function(a,b){var c=j(h,b);if("error"===c.status)return p.reject(a,c.value);var d=c.value;if(d)i(a,d);else{a.state=r,a.outcome=b;for(var e=-1,f=a.queue.length;++e<f;)a.queue[e].callFulfilled(b)}return a},p.reject=function(a,b){a.state=q,a.outcome=b;for(var c=-1,d=a.queue.length;++c<d;)a.queue[c].callRejected(b);return a},e.resolve=k,e.reject=l,e.all=m,e.race=n},{immediate:57}],59:[function(a,b,c){"use strict";var d=a("./lib/utils/common").assign,e=a("./lib/deflate"),f=a("./lib/inflate"),g=a("./lib/zlib/constants"),h={};d(h,e,f,g),b.exports=h},{"./lib/deflate":60,"./lib/inflate":61,"./lib/utils/common":62,"./lib/zlib/constants":65}],60:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=i.assign({level:s,method:u,chunkSize:16384,windowBits:15,memLevel:8,strategy:t,to:""},a||{});var b=this.options;b.raw&&b.windowBits>0?b.windowBits=-b.windowBits:b.gzip&&b.windowBits>0&&b.windowBits<16&&(b.windowBits+=16),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=h.deflateInit2(this.strm,b.level,b.method,b.windowBits,b.memLevel,b.strategy);if(c!==p)throw new Error(k[c]);if(b.header&&h.deflateSetHeader(this.strm,b.header),b.dictionary){var e;if(e="string"==typeof b.dictionary?j.string2buf(b.dictionary):"[object ArrayBuffer]"===m.call(b.dictionary)?new Uint8Array(b.dictionary):b.dictionary,c=h.deflateSetDictionary(this.strm,e),c!==p)throw new Error(k[c]);this._dict_set=!0}}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}function g(a,b){return b=b||{},b.gzip=!0,e(a,b)}var h=a("./zlib/deflate"),i=a("./utils/common"),j=a("./utils/strings"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=Object.prototype.toString,n=0,o=4,p=0,q=1,r=2,s=-1,t=0,u=8;d.prototype.push=function(a,b){var c,d,e=this.strm,f=this.options.chunkSize;if(this.ended)return!1;d=b===~~b?b:b===!0?o:n,"string"==typeof a?e.input=j.string2buf(a):"[object ArrayBuffer]"===m.call(a)?e.input=new Uint8Array(a):e.input=a,e.next_in=0,e.avail_in=e.input.length;do{if(0===e.avail_out&&(e.output=new i.Buf8(f),e.next_out=0,e.avail_out=f),c=h.deflate(e,d),c!==q&&c!==p)return this.onEnd(c),this.ended=!0,!1;0!==e.avail_out&&(0!==e.avail_in||d!==o&&d!==r)||("string"===this.options.to?this.onData(j.buf2binstring(i.shrinkBuf(e.output,e.next_out))):this.onData(i.shrinkBuf(e.output,e.next_out)))}while((e.avail_in>0||0===e.avail_out)&&c!==q);return d===o?(c=h.deflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===p):d!==r||(this.onEnd(p),e.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===p&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=i.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Deflate=d,c.deflate=e,c.deflateRaw=f,c.gzip=g},{"./utils/common":62,"./utils/strings":63,"./zlib/deflate":67,"./zlib/messages":72,"./zlib/zstream":74}],61:[function(a,b,c){"use strict";function d(a){if(!(this instanceof d))return new d(a);this.options=h.assign({chunkSize:16384,windowBits:0,to:""},a||{});var b=this.options;b.raw&&b.windowBits>=0&&b.windowBits<16&&(b.windowBits=-b.windowBits,0===b.windowBits&&(b.windowBits=-15)),!(b.windowBits>=0&&b.windowBits<16)||a&&a.windowBits||(b.windowBits+=32),b.windowBits>15&&b.windowBits<48&&0===(15&b.windowBits)&&(b.windowBits|=15),this.err=0,this.msg="",this.ended=!1,this.chunks=[],this.strm=new l,this.strm.avail_out=0;var c=g.inflateInit2(this.strm,b.windowBits);if(c!==j.Z_OK)throw new Error(k[c]);this.header=new m,g.inflateGetHeader(this.strm,this.header)}function e(a,b){var c=new d(b);if(c.push(a,!0),c.err)throw c.msg||k[c.err];return c.result}function f(a,b){return b=b||{},b.raw=!0,e(a,b)}var g=a("./zlib/inflate"),h=a("./utils/common"),i=a("./utils/strings"),j=a("./zlib/constants"),k=a("./zlib/messages"),l=a("./zlib/zstream"),m=a("./zlib/gzheader"),n=Object.prototype.toString;d.prototype.push=function(a,b){var c,d,e,f,k,l,m=this.strm,o=this.options.chunkSize,p=this.options.dictionary,q=!1;if(this.ended)return!1;d=b===~~b?b:b===!0?j.Z_FINISH:j.Z_NO_FLUSH,"string"==typeof a?m.input=i.binstring2buf(a):"[object ArrayBuffer]"===n.call(a)?m.input=new Uint8Array(a):m.input=a,m.next_in=0,m.avail_in=m.input.length;do{if(0===m.avail_out&&(m.output=new h.Buf8(o),m.next_out=0,m.avail_out=o),c=g.inflate(m,j.Z_NO_FLUSH),c===j.Z_NEED_DICT&&p&&(l="string"==typeof p?i.string2buf(p):"[object ArrayBuffer]"===n.call(p)?new Uint8Array(p):p,c=g.inflateSetDictionary(this.strm,l)),c===j.Z_BUF_ERROR&&q===!0&&(c=j.Z_OK,q=!1),c!==j.Z_STREAM_END&&c!==j.Z_OK)return this.onEnd(c),this.ended=!0,!1;m.next_out&&(0!==m.avail_out&&c!==j.Z_STREAM_END&&(0!==m.avail_in||d!==j.Z_FINISH&&d!==j.Z_SYNC_FLUSH)||("string"===this.options.to?(e=i.utf8border(m.output,m.next_out),f=m.next_out-e,k=i.buf2string(m.output,e),m.next_out=f,m.avail_out=o-f,f&&h.arraySet(m.output,m.output,e,f,0),this.onData(k)):this.onData(h.shrinkBuf(m.output,m.next_out)))),0===m.avail_in&&0===m.avail_out&&(q=!0)}while((m.avail_in>0||0===m.avail_out)&&c!==j.Z_STREAM_END);return c===j.Z_STREAM_END&&(d=j.Z_FINISH),d===j.Z_FINISH?(c=g.inflateEnd(this.strm),this.onEnd(c),this.ended=!0,c===j.Z_OK):d!==j.Z_SYNC_FLUSH||(this.onEnd(j.Z_OK),m.avail_out=0,!0)},d.prototype.onData=function(a){this.chunks.push(a)},d.prototype.onEnd=function(a){a===j.Z_OK&&("string"===this.options.to?this.result=this.chunks.join(""):this.result=h.flattenChunks(this.chunks)),this.chunks=[],this.err=a,this.msg=this.strm.msg},c.Inflate=d,c.inflate=e,c.inflateRaw=f,c.ungzip=e},{"./utils/common":62,"./utils/strings":63,"./zlib/constants":65,"./zlib/gzheader":68,"./zlib/inflate":70,"./zlib/messages":72,"./zlib/zstream":74}],62:[function(a,b,c){"use strict";var d="undefined"!=typeof Uint8Array&&"undefined"!=typeof Uint16Array&&"undefined"!=typeof Int32Array;c.assign=function(a){for(var b=Array.prototype.slice.call(arguments,1);b.length;){var c=b.shift();if(c){if("object"!=typeof c)throw new TypeError(c+"must be non-object");for(var d in c)c.hasOwnProperty(d)&&(a[d]=c[d])}}return a},c.shrinkBuf=function(a,b){return a.length===b?a:a.subarray?a.subarray(0,b):(a.length=b,a)};var e={arraySet:function(a,b,c,d,e){if(b.subarray&&a.subarray)return void a.set(b.subarray(c,c+d),e);for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){var b,c,d,e,f,g;for(d=0,b=0,c=a.length;b<c;b++)d+=a[b].length;for(g=new Uint8Array(d),e=0,b=0,c=a.length;b<c;b++)f=a[b],g.set(f,e),e+=f.length;return g}},f={arraySet:function(a,b,c,d,e){for(var f=0;f<d;f++)a[e+f]=b[c+f]},flattenChunks:function(a){return[].concat.apply([],a)}};c.setTyped=function(a){a?(c.Buf8=Uint8Array,c.Buf16=Uint16Array,c.Buf32=Int32Array,c.assign(c,e)):(c.Buf8=Array,c.Buf16=Array,c.Buf32=Array,c.assign(c,f))},c.setTyped(d)},{}],63:[function(a,b,c){"use strict";function d(a,b){if(b<65537&&(a.subarray&&g||!a.subarray&&f))return String.fromCharCode.apply(null,e.shrinkBuf(a,b));for(var c="",d=0;d<b;d++)c+=String.fromCharCode(a[d]);return c}var e=a("./common"),f=!0,g=!0;try{String.fromCharCode.apply(null,[0])}catch(h){f=!1}try{String.fromCharCode.apply(null,new Uint8Array(1))}catch(h){g=!1}for(var i=new e.Buf8(256),j=0;j<256;j++)i[j]=j>=252?6:j>=248?5:j>=240?4:j>=224?3:j>=192?2:1;i[254]=i[254]=1,c.string2buf=function(a){var b,c,d,f,g,h=a.length,i=0;for(f=0;f<h;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),i+=c<128?1:c<2048?2:c<65536?3:4;for(b=new e.Buf8(i),g=0,f=0;g<i;f++)c=a.charCodeAt(f),55296===(64512&c)&&f+1<h&&(d=a.charCodeAt(f+1),56320===(64512&d)&&(c=65536+(c-55296<<10)+(d-56320),f++)),c<128?b[g++]=c:c<2048?(b[g++]=192|c>>>6,b[g++]=128|63&c):c<65536?(b[g++]=224|c>>>12,b[g++]=128|c>>>6&63,b[g++]=128|63&c):(b[g++]=240|c>>>18,b[g++]=128|c>>>12&63,b[g++]=128|c>>>6&63,b[g++]=128|63&c);return b},c.buf2binstring=function(a){return d(a,a.length)},c.binstring2buf=function(a){for(var b=new e.Buf8(a.length),c=0,d=b.length;c<d;c++)b[c]=a.charCodeAt(c);return b},c.buf2string=function(a,b){var c,e,f,g,h=b||a.length,j=new Array(2*h);for(e=0,c=0;c<h;)if(f=a[c++],f<128)j[e++]=f;else if(g=i[f],g>4)j[e++]=65533,c+=g-1;else{for(f&=2===g?31:3===g?15:7;g>1&&c<h;)f=f<<6|63&a[c++],g--;g>1?j[e++]=65533:f<65536?j[e++]=f:(f-=65536,j[e++]=55296|f>>10&1023,j[e++]=56320|1023&f)}return d(j,e)},c.utf8border=function(a,b){var c;for(b=b||a.length,b>a.length&&(b=a.length),c=b-1;c>=0&&128===(192&a[c]);)c--;return c<0?b:0===c?b:c+i[a[c]]>b?c:b}},{"./common":62}],64:[function(a,b,c){"use strict";function d(a,b,c,d){for(var e=65535&a|0,f=a>>>16&65535|0,g=0;0!==c;){g=c>2e3?2e3:c,c-=g;do e=e+b[d++]|0,f=f+e|0;while(--g);e%=65521,f%=65521}return e|f<<16|0;
}b.exports=d},{}],65:[function(a,b,c){"use strict";b.exports={Z_NO_FLUSH:0,Z_PARTIAL_FLUSH:1,Z_SYNC_FLUSH:2,Z_FULL_FLUSH:3,Z_FINISH:4,Z_BLOCK:5,Z_TREES:6,Z_OK:0,Z_STREAM_END:1,Z_NEED_DICT:2,Z_ERRNO:-1,Z_STREAM_ERROR:-2,Z_DATA_ERROR:-3,Z_BUF_ERROR:-5,Z_NO_COMPRESSION:0,Z_BEST_SPEED:1,Z_BEST_COMPRESSION:9,Z_DEFAULT_COMPRESSION:-1,Z_FILTERED:1,Z_HUFFMAN_ONLY:2,Z_RLE:3,Z_FIXED:4,Z_DEFAULT_STRATEGY:0,Z_BINARY:0,Z_TEXT:1,Z_UNKNOWN:2,Z_DEFLATED:8}},{}],66:[function(a,b,c){"use strict";function d(){for(var a,b=[],c=0;c<256;c++){a=c;for(var d=0;d<8;d++)a=1&a?3988292384^a>>>1:a>>>1;b[c]=a}return b}function e(a,b,c,d){var e=f,g=d+c;a^=-1;for(var h=d;h<g;h++)a=a>>>8^e[255&(a^b[h])];return a^-1}var f=d();b.exports=e},{}],67:[function(a,b,c){"use strict";function d(a,b){return a.msg=I[b],b}function e(a){return(a<<1)-(a>4?9:0)}function f(a){for(var b=a.length;--b>=0;)a[b]=0}function g(a){var b=a.state,c=b.pending;c>a.avail_out&&(c=a.avail_out),0!==c&&(E.arraySet(a.output,b.pending_buf,b.pending_out,c,a.next_out),a.next_out+=c,b.pending_out+=c,a.total_out+=c,a.avail_out-=c,b.pending-=c,0===b.pending&&(b.pending_out=0))}function h(a,b){F._tr_flush_block(a,a.block_start>=0?a.block_start:-1,a.strstart-a.block_start,b),a.block_start=a.strstart,g(a.strm)}function i(a,b){a.pending_buf[a.pending++]=b}function j(a,b){a.pending_buf[a.pending++]=b>>>8&255,a.pending_buf[a.pending++]=255&b}function k(a,b,c,d){var e=a.avail_in;return e>d&&(e=d),0===e?0:(a.avail_in-=e,E.arraySet(b,a.input,a.next_in,e,c),1===a.state.wrap?a.adler=G(a.adler,b,e,c):2===a.state.wrap&&(a.adler=H(a.adler,b,e,c)),a.next_in+=e,a.total_in+=e,e)}function l(a,b){var c,d,e=a.max_chain_length,f=a.strstart,g=a.prev_length,h=a.nice_match,i=a.strstart>a.w_size-la?a.strstart-(a.w_size-la):0,j=a.window,k=a.w_mask,l=a.prev,m=a.strstart+ka,n=j[f+g-1],o=j[f+g];a.prev_length>=a.good_match&&(e>>=2),h>a.lookahead&&(h=a.lookahead);do if(c=b,j[c+g]===o&&j[c+g-1]===n&&j[c]===j[f]&&j[++c]===j[f+1]){f+=2,c++;do;while(j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&j[++f]===j[++c]&&f<m);if(d=ka-(m-f),f=m-ka,d>g){if(a.match_start=b,g=d,d>=h)break;n=j[f+g-1],o=j[f+g]}}while((b=l[b&k])>i&&0!==--e);return g<=a.lookahead?g:a.lookahead}function m(a){var b,c,d,e,f,g=a.w_size;do{if(e=a.window_size-a.lookahead-a.strstart,a.strstart>=g+(g-la)){E.arraySet(a.window,a.window,g,g,0),a.match_start-=g,a.strstart-=g,a.block_start-=g,c=a.hash_size,b=c;do d=a.head[--b],a.head[b]=d>=g?d-g:0;while(--c);c=g,b=c;do d=a.prev[--b],a.prev[b]=d>=g?d-g:0;while(--c);e+=g}if(0===a.strm.avail_in)break;if(c=k(a.strm,a.window,a.strstart+a.lookahead,e),a.lookahead+=c,a.lookahead+a.insert>=ja)for(f=a.strstart-a.insert,a.ins_h=a.window[f],a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+1])&a.hash_mask;a.insert&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[f+ja-1])&a.hash_mask,a.prev[f&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=f,f++,a.insert--,!(a.lookahead+a.insert<ja)););}while(a.lookahead<la&&0!==a.strm.avail_in)}function n(a,b){var c=65535;for(c>a.pending_buf_size-5&&(c=a.pending_buf_size-5);;){if(a.lookahead<=1){if(m(a),0===a.lookahead&&b===J)return ua;if(0===a.lookahead)break}a.strstart+=a.lookahead,a.lookahead=0;var d=a.block_start+c;if((0===a.strstart||a.strstart>=d)&&(a.lookahead=a.strstart-d,a.strstart=d,h(a,!1),0===a.strm.avail_out))return ua;if(a.strstart-a.block_start>=a.w_size-la&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.strstart>a.block_start&&(h(a,!1),0===a.strm.avail_out)?ua:ua}function o(a,b){for(var c,d;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),0!==c&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c)),a.match_length>=ja)if(d=F._tr_tally(a,a.strstart-a.match_start,a.match_length-ja),a.lookahead-=a.match_length,a.match_length<=a.max_lazy_match&&a.lookahead>=ja){a.match_length--;do a.strstart++,a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart;while(0!==--a.match_length);a.strstart++}else a.strstart+=a.match_length,a.match_length=0,a.ins_h=a.window[a.strstart],a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+1])&a.hash_mask;else d=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++;if(d&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function p(a,b){for(var c,d,e;;){if(a.lookahead<la){if(m(a),a.lookahead<la&&b===J)return ua;if(0===a.lookahead)break}if(c=0,a.lookahead>=ja&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart),a.prev_length=a.match_length,a.prev_match=a.match_start,a.match_length=ja-1,0!==c&&a.prev_length<a.max_lazy_match&&a.strstart-c<=a.w_size-la&&(a.match_length=l(a,c),a.match_length<=5&&(a.strategy===U||a.match_length===ja&&a.strstart-a.match_start>4096)&&(a.match_length=ja-1)),a.prev_length>=ja&&a.match_length<=a.prev_length){e=a.strstart+a.lookahead-ja,d=F._tr_tally(a,a.strstart-1-a.prev_match,a.prev_length-ja),a.lookahead-=a.prev_length-1,a.prev_length-=2;do++a.strstart<=e&&(a.ins_h=(a.ins_h<<a.hash_shift^a.window[a.strstart+ja-1])&a.hash_mask,c=a.prev[a.strstart&a.w_mask]=a.head[a.ins_h],a.head[a.ins_h]=a.strstart);while(0!==--a.prev_length);if(a.match_available=0,a.match_length=ja-1,a.strstart++,d&&(h(a,!1),0===a.strm.avail_out))return ua}else if(a.match_available){if(d=F._tr_tally(a,0,a.window[a.strstart-1]),d&&h(a,!1),a.strstart++,a.lookahead--,0===a.strm.avail_out)return ua}else a.match_available=1,a.strstart++,a.lookahead--}return a.match_available&&(d=F._tr_tally(a,0,a.window[a.strstart-1]),a.match_available=0),a.insert=a.strstart<ja-1?a.strstart:ja-1,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function q(a,b){for(var c,d,e,f,g=a.window;;){if(a.lookahead<=ka){if(m(a),a.lookahead<=ka&&b===J)return ua;if(0===a.lookahead)break}if(a.match_length=0,a.lookahead>=ja&&a.strstart>0&&(e=a.strstart-1,d=g[e],d===g[++e]&&d===g[++e]&&d===g[++e])){f=a.strstart+ka;do;while(d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&d===g[++e]&&e<f);a.match_length=ka-(f-e),a.match_length>a.lookahead&&(a.match_length=a.lookahead)}if(a.match_length>=ja?(c=F._tr_tally(a,1,a.match_length-ja),a.lookahead-=a.match_length,a.strstart+=a.match_length,a.match_length=0):(c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++),c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function r(a,b){for(var c;;){if(0===a.lookahead&&(m(a),0===a.lookahead)){if(b===J)return ua;break}if(a.match_length=0,c=F._tr_tally(a,0,a.window[a.strstart]),a.lookahead--,a.strstart++,c&&(h(a,!1),0===a.strm.avail_out))return ua}return a.insert=0,b===M?(h(a,!0),0===a.strm.avail_out?wa:xa):a.last_lit&&(h(a,!1),0===a.strm.avail_out)?ua:va}function s(a,b,c,d,e){this.good_length=a,this.max_lazy=b,this.nice_length=c,this.max_chain=d,this.func=e}function t(a){a.window_size=2*a.w_size,f(a.head),a.max_lazy_match=D[a.level].max_lazy,a.good_match=D[a.level].good_length,a.nice_match=D[a.level].nice_length,a.max_chain_length=D[a.level].max_chain,a.strstart=0,a.block_start=0,a.lookahead=0,a.insert=0,a.match_length=a.prev_length=ja-1,a.match_available=0,a.ins_h=0}function u(){this.strm=null,this.status=0,this.pending_buf=null,this.pending_buf_size=0,this.pending_out=0,this.pending=0,this.wrap=0,this.gzhead=null,this.gzindex=0,this.method=$,this.last_flush=-1,this.w_size=0,this.w_bits=0,this.w_mask=0,this.window=null,this.window_size=0,this.prev=null,this.head=null,this.ins_h=0,this.hash_size=0,this.hash_bits=0,this.hash_mask=0,this.hash_shift=0,this.block_start=0,this.match_length=0,this.prev_match=0,this.match_available=0,this.strstart=0,this.match_start=0,this.lookahead=0,this.prev_length=0,this.max_chain_length=0,this.max_lazy_match=0,this.level=0,this.strategy=0,this.good_match=0,this.nice_match=0,this.dyn_ltree=new E.Buf16(2*ha),this.dyn_dtree=new E.Buf16(2*(2*fa+1)),this.bl_tree=new E.Buf16(2*(2*ga+1)),f(this.dyn_ltree),f(this.dyn_dtree),f(this.bl_tree),this.l_desc=null,this.d_desc=null,this.bl_desc=null,this.bl_count=new E.Buf16(ia+1),this.heap=new E.Buf16(2*ea+1),f(this.heap),this.heap_len=0,this.heap_max=0,this.depth=new E.Buf16(2*ea+1),f(this.depth),this.l_buf=0,this.lit_bufsize=0,this.last_lit=0,this.d_buf=0,this.opt_len=0,this.static_len=0,this.matches=0,this.insert=0,this.bi_buf=0,this.bi_valid=0}function v(a){var b;return a&&a.state?(a.total_in=a.total_out=0,a.data_type=Z,b=a.state,b.pending=0,b.pending_out=0,b.wrap<0&&(b.wrap=-b.wrap),b.status=b.wrap?na:sa,a.adler=2===b.wrap?0:1,b.last_flush=J,F._tr_init(b),O):d(a,Q)}function w(a){var b=v(a);return b===O&&t(a.state),b}function x(a,b){return a&&a.state?2!==a.state.wrap?Q:(a.state.gzhead=b,O):Q}function y(a,b,c,e,f,g){if(!a)return Q;var h=1;if(b===T&&(b=6),e<0?(h=0,e=-e):e>15&&(h=2,e-=16),f<1||f>_||c!==$||e<8||e>15||b<0||b>9||g<0||g>X)return d(a,Q);8===e&&(e=9);var i=new u;return a.state=i,i.strm=a,i.wrap=h,i.gzhead=null,i.w_bits=e,i.w_size=1<<i.w_bits,i.w_mask=i.w_size-1,i.hash_bits=f+7,i.hash_size=1<<i.hash_bits,i.hash_mask=i.hash_size-1,i.hash_shift=~~((i.hash_bits+ja-1)/ja),i.window=new E.Buf8(2*i.w_size),i.head=new E.Buf16(i.hash_size),i.prev=new E.Buf16(i.w_size),i.lit_bufsize=1<<f+6,i.pending_buf_size=4*i.lit_bufsize,i.pending_buf=new E.Buf8(i.pending_buf_size),i.d_buf=1*i.lit_bufsize,i.l_buf=3*i.lit_bufsize,i.level=b,i.strategy=g,i.method=c,w(a)}function z(a,b){return y(a,b,$,aa,ba,Y)}function A(a,b){var c,h,k,l;if(!a||!a.state||b>N||b<0)return a?d(a,Q):Q;if(h=a.state,!a.output||!a.input&&0!==a.avail_in||h.status===ta&&b!==M)return d(a,0===a.avail_out?S:Q);if(h.strm=a,c=h.last_flush,h.last_flush=b,h.status===na)if(2===h.wrap)a.adler=0,i(h,31),i(h,139),i(h,8),h.gzhead?(i(h,(h.gzhead.text?1:0)+(h.gzhead.hcrc?2:0)+(h.gzhead.extra?4:0)+(h.gzhead.name?8:0)+(h.gzhead.comment?16:0)),i(h,255&h.gzhead.time),i(h,h.gzhead.time>>8&255),i(h,h.gzhead.time>>16&255),i(h,h.gzhead.time>>24&255),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,255&h.gzhead.os),h.gzhead.extra&&h.gzhead.extra.length&&(i(h,255&h.gzhead.extra.length),i(h,h.gzhead.extra.length>>8&255)),h.gzhead.hcrc&&(a.adler=H(a.adler,h.pending_buf,h.pending,0)),h.gzindex=0,h.status=oa):(i(h,0),i(h,0),i(h,0),i(h,0),i(h,0),i(h,9===h.level?2:h.strategy>=V||h.level<2?4:0),i(h,ya),h.status=sa);else{var m=$+(h.w_bits-8<<4)<<8,n=-1;n=h.strategy>=V||h.level<2?0:h.level<6?1:6===h.level?2:3,m|=n<<6,0!==h.strstart&&(m|=ma),m+=31-m%31,h.status=sa,j(h,m),0!==h.strstart&&(j(h,a.adler>>>16),j(h,65535&a.adler)),a.adler=1}if(h.status===oa)if(h.gzhead.extra){for(k=h.pending;h.gzindex<(65535&h.gzhead.extra.length)&&(h.pending!==h.pending_buf_size||(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending!==h.pending_buf_size));)i(h,255&h.gzhead.extra[h.gzindex]),h.gzindex++;h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),h.gzindex===h.gzhead.extra.length&&(h.gzindex=0,h.status=pa)}else h.status=pa;if(h.status===pa)if(h.gzhead.name){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.name.length?255&h.gzhead.name.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.gzindex=0,h.status=qa)}else h.status=qa;if(h.status===qa)if(h.gzhead.comment){k=h.pending;do{if(h.pending===h.pending_buf_size&&(h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),g(a),k=h.pending,h.pending===h.pending_buf_size)){l=1;break}l=h.gzindex<h.gzhead.comment.length?255&h.gzhead.comment.charCodeAt(h.gzindex++):0,i(h,l)}while(0!==l);h.gzhead.hcrc&&h.pending>k&&(a.adler=H(a.adler,h.pending_buf,h.pending-k,k)),0===l&&(h.status=ra)}else h.status=ra;if(h.status===ra&&(h.gzhead.hcrc?(h.pending+2>h.pending_buf_size&&g(a),h.pending+2<=h.pending_buf_size&&(i(h,255&a.adler),i(h,a.adler>>8&255),a.adler=0,h.status=sa)):h.status=sa),0!==h.pending){if(g(a),0===a.avail_out)return h.last_flush=-1,O}else if(0===a.avail_in&&e(b)<=e(c)&&b!==M)return d(a,S);if(h.status===ta&&0!==a.avail_in)return d(a,S);if(0!==a.avail_in||0!==h.lookahead||b!==J&&h.status!==ta){var o=h.strategy===V?r(h,b):h.strategy===W?q(h,b):D[h.level].func(h,b);if(o!==wa&&o!==xa||(h.status=ta),o===ua||o===wa)return 0===a.avail_out&&(h.last_flush=-1),O;if(o===va&&(b===K?F._tr_align(h):b!==N&&(F._tr_stored_block(h,0,0,!1),b===L&&(f(h.head),0===h.lookahead&&(h.strstart=0,h.block_start=0,h.insert=0))),g(a),0===a.avail_out))return h.last_flush=-1,O}return b!==M?O:h.wrap<=0?P:(2===h.wrap?(i(h,255&a.adler),i(h,a.adler>>8&255),i(h,a.adler>>16&255),i(h,a.adler>>24&255),i(h,255&a.total_in),i(h,a.total_in>>8&255),i(h,a.total_in>>16&255),i(h,a.total_in>>24&255)):(j(h,a.adler>>>16),j(h,65535&a.adler)),g(a),h.wrap>0&&(h.wrap=-h.wrap),0!==h.pending?O:P)}function B(a){var b;return a&&a.state?(b=a.state.status,b!==na&&b!==oa&&b!==pa&&b!==qa&&b!==ra&&b!==sa&&b!==ta?d(a,Q):(a.state=null,b===sa?d(a,R):O)):Q}function C(a,b){var c,d,e,g,h,i,j,k,l=b.length;if(!a||!a.state)return Q;if(c=a.state,g=c.wrap,2===g||1===g&&c.status!==na||c.lookahead)return Q;for(1===g&&(a.adler=G(a.adler,b,l,0)),c.wrap=0,l>=c.w_size&&(0===g&&(f(c.head),c.strstart=0,c.block_start=0,c.insert=0),k=new E.Buf8(c.w_size),E.arraySet(k,b,l-c.w_size,c.w_size,0),b=k,l=c.w_size),h=a.avail_in,i=a.next_in,j=a.input,a.avail_in=l,a.next_in=0,a.input=b,m(c);c.lookahead>=ja;){d=c.strstart,e=c.lookahead-(ja-1);do c.ins_h=(c.ins_h<<c.hash_shift^c.window[d+ja-1])&c.hash_mask,c.prev[d&c.w_mask]=c.head[c.ins_h],c.head[c.ins_h]=d,d++;while(--e);c.strstart=d,c.lookahead=ja-1,m(c)}return c.strstart+=c.lookahead,c.block_start=c.strstart,c.insert=c.lookahead,c.lookahead=0,c.match_length=c.prev_length=ja-1,c.match_available=0,a.next_in=i,a.input=j,a.avail_in=h,c.wrap=g,O}var D,E=a("../utils/common"),F=a("./trees"),G=a("./adler32"),H=a("./crc32"),I=a("./messages"),J=0,K=1,L=3,M=4,N=5,O=0,P=1,Q=-2,R=-3,S=-5,T=-1,U=1,V=2,W=3,X=4,Y=0,Z=2,$=8,_=9,aa=15,ba=8,ca=29,da=256,ea=da+1+ca,fa=30,ga=19,ha=2*ea+1,ia=15,ja=3,ka=258,la=ka+ja+1,ma=32,na=42,oa=69,pa=73,qa=91,ra=103,sa=113,ta=666,ua=1,va=2,wa=3,xa=4,ya=3;D=[new s(0,0,0,0,n),new s(4,4,8,4,o),new s(4,5,16,8,o),new s(4,6,32,32,o),new s(4,4,16,16,p),new s(8,16,32,32,p),new s(8,16,128,128,p),new s(8,32,128,256,p),new s(32,128,258,1024,p),new s(32,258,258,4096,p)],c.deflateInit=z,c.deflateInit2=y,c.deflateReset=w,c.deflateResetKeep=v,c.deflateSetHeader=x,c.deflate=A,c.deflateEnd=B,c.deflateSetDictionary=C,c.deflateInfo="pako deflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./messages":72,"./trees":73}],68:[function(a,b,c){"use strict";function d(){this.text=0,this.time=0,this.xflags=0,this.os=0,this.extra=null,this.extra_len=0,this.name="",this.comment="",this.hcrc=0,this.done=!1}b.exports=d},{}],69:[function(a,b,c){"use strict";var d=30,e=12;b.exports=function(a,b){var c,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z,A,B,C;c=a.state,f=a.next_in,B=a.input,g=f+(a.avail_in-5),h=a.next_out,C=a.output,i=h-(b-a.avail_out),j=h+(a.avail_out-257),k=c.dmax,l=c.wsize,m=c.whave,n=c.wnext,o=c.window,p=c.hold,q=c.bits,r=c.lencode,s=c.distcode,t=(1<<c.lenbits)-1,u=(1<<c.distbits)-1;a:do{q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=r[p&t];b:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,0===w)C[h++]=65535&v;else{if(!(16&w)){if(0===(64&w)){v=r[(65535&v)+(p&(1<<w)-1)];continue b}if(32&w){c.mode=e;break a}a.msg="invalid literal/length code",c.mode=d;break a}x=65535&v,w&=15,w&&(q<w&&(p+=B[f++]<<q,q+=8),x+=p&(1<<w)-1,p>>>=w,q-=w),q<15&&(p+=B[f++]<<q,q+=8,p+=B[f++]<<q,q+=8),v=s[p&u];c:for(;;){if(w=v>>>24,p>>>=w,q-=w,w=v>>>16&255,!(16&w)){if(0===(64&w)){v=s[(65535&v)+(p&(1<<w)-1)];continue c}a.msg="invalid distance code",c.mode=d;break a}if(y=65535&v,w&=15,q<w&&(p+=B[f++]<<q,q+=8,q<w&&(p+=B[f++]<<q,q+=8)),y+=p&(1<<w)-1,y>k){a.msg="invalid distance too far back",c.mode=d;break a}if(p>>>=w,q-=w,w=h-i,y>w){if(w=y-w,w>m&&c.sane){a.msg="invalid distance too far back",c.mode=d;break a}if(z=0,A=o,0===n){if(z+=l-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}else if(n<w){if(z+=l+n-w,w-=n,w<x){x-=w;do C[h++]=o[z++];while(--w);if(z=0,n<x){w=n,x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}}}else if(z+=n-w,w<x){x-=w;do C[h++]=o[z++];while(--w);z=h-y,A=C}for(;x>2;)C[h++]=A[z++],C[h++]=A[z++],C[h++]=A[z++],x-=3;x&&(C[h++]=A[z++],x>1&&(C[h++]=A[z++]))}else{z=h-y;do C[h++]=C[z++],C[h++]=C[z++],C[h++]=C[z++],x-=3;while(x>2);x&&(C[h++]=C[z++],x>1&&(C[h++]=C[z++]))}break}}break}}while(f<g&&h<j);x=q>>3,f-=x,q-=x<<3,p&=(1<<q)-1,a.next_in=f,a.next_out=h,a.avail_in=f<g?5+(g-f):5-(f-g),a.avail_out=h<j?257+(j-h):257-(h-j),c.hold=p,c.bits=q}},{}],70:[function(a,b,c){"use strict";function d(a){return(a>>>24&255)+(a>>>8&65280)+((65280&a)<<8)+((255&a)<<24)}function e(){this.mode=0,this.last=!1,this.wrap=0,this.havedict=!1,this.flags=0,this.dmax=0,this.check=0,this.total=0,this.head=null,this.wbits=0,this.wsize=0,this.whave=0,this.wnext=0,this.window=null,this.hold=0,this.bits=0,this.length=0,this.offset=0,this.extra=0,this.lencode=null,this.distcode=null,this.lenbits=0,this.distbits=0,this.ncode=0,this.nlen=0,this.ndist=0,this.have=0,this.next=null,this.lens=new s.Buf16(320),this.work=new s.Buf16(288),this.lendyn=null,this.distdyn=null,this.sane=0,this.back=0,this.was=0}function f(a){var b;return a&&a.state?(b=a.state,a.total_in=a.total_out=b.total=0,a.msg="",b.wrap&&(a.adler=1&b.wrap),b.mode=L,b.last=0,b.havedict=0,b.dmax=32768,b.head=null,b.hold=0,b.bits=0,b.lencode=b.lendyn=new s.Buf32(pa),b.distcode=b.distdyn=new s.Buf32(qa),b.sane=1,b.back=-1,D):G}function g(a){var b;return a&&a.state?(b=a.state,b.wsize=0,b.whave=0,b.wnext=0,f(a)):G}function h(a,b){var c,d;return a&&a.state?(d=a.state,b<0?(c=0,b=-b):(c=(b>>4)+1,b<48&&(b&=15)),b&&(b<8||b>15)?G:(null!==d.window&&d.wbits!==b&&(d.window=null),d.wrap=c,d.wbits=b,g(a))):G}function i(a,b){var c,d;return a?(d=new e,a.state=d,d.window=null,c=h(a,b),c!==D&&(a.state=null),c):G}function j(a){return i(a,sa)}function k(a){if(ta){var b;for(q=new s.Buf32(512),r=new s.Buf32(32),b=0;b<144;)a.lens[b++]=8;for(;b<256;)a.lens[b++]=9;for(;b<280;)a.lens[b++]=7;for(;b<288;)a.lens[b++]=8;for(w(y,a.lens,0,288,q,0,a.work,{bits:9}),b=0;b<32;)a.lens[b++]=5;w(z,a.lens,0,32,r,0,a.work,{bits:5}),ta=!1}a.lencode=q,a.lenbits=9,a.distcode=r,a.distbits=5}function l(a,b,c,d){var e,f=a.state;return null===f.window&&(f.wsize=1<<f.wbits,f.wnext=0,f.whave=0,f.window=new s.Buf8(f.wsize)),d>=f.wsize?(s.arraySet(f.window,b,c-f.wsize,f.wsize,0),f.wnext=0,f.whave=f.wsize):(e=f.wsize-f.wnext,e>d&&(e=d),s.arraySet(f.window,b,c-d,e,f.wnext),d-=e,d?(s.arraySet(f.window,b,c-d,d,0),f.wnext=d,f.whave=f.wsize):(f.wnext+=e,f.wnext===f.wsize&&(f.wnext=0),f.whave<f.wsize&&(f.whave+=e))),0}function m(a,b){var c,e,f,g,h,i,j,m,n,o,p,q,r,pa,qa,ra,sa,ta,ua,va,wa,xa,ya,za,Aa=0,Ba=new s.Buf8(4),Ca=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];if(!a||!a.state||!a.output||!a.input&&0!==a.avail_in)return G;c=a.state,c.mode===W&&(c.mode=X),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,o=i,p=j,xa=D;a:for(;;)switch(c.mode){case L:if(0===c.wrap){c.mode=X;break}for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(2&c.wrap&&35615===m){c.check=0,Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0),m=0,n=0,c.mode=M;break}if(c.flags=0,c.head&&(c.head.done=!1),!(1&c.wrap)||(((255&m)<<8)+(m>>8))%31){a.msg="incorrect header check",c.mode=ma;break}if((15&m)!==K){a.msg="unknown compression method",c.mode=ma;break}if(m>>>=4,n-=4,wa=(15&m)+8,0===c.wbits)c.wbits=wa;else if(wa>c.wbits){a.msg="invalid window size",c.mode=ma;break}c.dmax=1<<wa,a.adler=c.check=1,c.mode=512&m?U:W,m=0,n=0;break;case M:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.flags=m,(255&c.flags)!==K){a.msg="unknown compression method",c.mode=ma;break}if(57344&c.flags){a.msg="unknown header flags set",c.mode=ma;break}c.head&&(c.head.text=m>>8&1),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=N;case N:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.time=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,Ba[2]=m>>>16&255,Ba[3]=m>>>24&255,c.check=u(c.check,Ba,4,0)),m=0,n=0,c.mode=O;case O:for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.head&&(c.head.xflags=255&m,c.head.os=m>>8),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0,c.mode=P;case P:if(1024&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length=m,c.head&&(c.head.extra_len=m),512&c.flags&&(Ba[0]=255&m,Ba[1]=m>>>8&255,c.check=u(c.check,Ba,2,0)),m=0,n=0}else c.head&&(c.head.extra=null);c.mode=Q;case Q:if(1024&c.flags&&(q=c.length,q>i&&(q=i),q&&(c.head&&(wa=c.head.extra_len-c.length,c.head.extra||(c.head.extra=new Array(c.head.extra_len)),s.arraySet(c.head.extra,e,g,q,wa)),512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,c.length-=q),c.length))break a;c.length=0,c.mode=R;case R:if(2048&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.name+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.name=null);c.length=0,c.mode=S;case S:if(4096&c.flags){if(0===i)break a;q=0;do wa=e[g+q++],c.head&&wa&&c.length<65536&&(c.head.comment+=String.fromCharCode(wa));while(wa&&q<i);if(512&c.flags&&(c.check=u(c.check,e,q,g)),i-=q,g+=q,wa)break a}else c.head&&(c.head.comment=null);c.mode=T;case T:if(512&c.flags){for(;n<16;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(65535&c.check)){a.msg="header crc mismatch",c.mode=ma;break}m=0,n=0}c.head&&(c.head.hcrc=c.flags>>9&1,c.head.done=!0),a.adler=c.check=0,c.mode=W;break;case U:for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}a.adler=c.check=d(m),m=0,n=0,c.mode=V;case V:if(0===c.havedict)return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,F;a.adler=c.check=1,c.mode=W;case W:if(b===B||b===C)break a;case X:if(c.last){m>>>=7&n,n-=7&n,c.mode=ja;break}for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}switch(c.last=1&m,m>>>=1,n-=1,3&m){case 0:c.mode=Y;break;case 1:if(k(c),c.mode=ca,b===C){m>>>=2,n-=2;break a}break;case 2:c.mode=_;break;case 3:a.msg="invalid block type",c.mode=ma}m>>>=2,n-=2;break;case Y:for(m>>>=7&n,n-=7&n;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if((65535&m)!==(m>>>16^65535)){a.msg="invalid stored block lengths",c.mode=ma;break}if(c.length=65535&m,m=0,n=0,c.mode=Z,b===C)break a;case Z:c.mode=$;case $:if(q=c.length){if(q>i&&(q=i),q>j&&(q=j),0===q)break a;s.arraySet(f,e,g,q,h),i-=q,g+=q,j-=q,h+=q,c.length-=q;break}c.mode=W;break;case _:for(;n<14;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(c.nlen=(31&m)+257,m>>>=5,n-=5,c.ndist=(31&m)+1,m>>>=5,n-=5,c.ncode=(15&m)+4,m>>>=4,n-=4,c.nlen>286||c.ndist>30){a.msg="too many length or distance symbols",c.mode=ma;break}c.have=0,c.mode=aa;case aa:for(;c.have<c.ncode;){for(;n<3;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.lens[Ca[c.have++]]=7&m,m>>>=3,n-=3}for(;c.have<19;)c.lens[Ca[c.have++]]=0;if(c.lencode=c.lendyn,c.lenbits=7,ya={bits:c.lenbits},xa=w(x,c.lens,0,19,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid code lengths set",c.mode=ma;break}c.have=0,c.mode=ba;case ba:for(;c.have<c.nlen+c.ndist;){for(;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(sa<16)m>>>=qa,n-=qa,c.lens[c.have++]=sa;else{if(16===sa){for(za=qa+2;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m>>>=qa,n-=qa,0===c.have){a.msg="invalid bit length repeat",c.mode=ma;break}wa=c.lens[c.have-1],q=3+(3&m),m>>>=2,n-=2}else if(17===sa){for(za=qa+3;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=3+(7&m),m>>>=3,n-=3}else{for(za=qa+7;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=qa,n-=qa,wa=0,q=11+(127&m),m>>>=7,n-=7}if(c.have+q>c.nlen+c.ndist){a.msg="invalid bit length repeat",c.mode=ma;break}for(;q--;)c.lens[c.have++]=wa}}if(c.mode===ma)break;if(0===c.lens[256]){a.msg="invalid code -- missing end-of-block",c.mode=ma;break}if(c.lenbits=9,ya={bits:c.lenbits},xa=w(y,c.lens,0,c.nlen,c.lencode,0,c.work,ya),c.lenbits=ya.bits,xa){a.msg="invalid literal/lengths set",c.mode=ma;break}if(c.distbits=6,c.distcode=c.distdyn,ya={bits:c.distbits},xa=w(z,c.lens,c.nlen,c.ndist,c.distcode,0,c.work,ya),c.distbits=ya.bits,xa){a.msg="invalid distances set",c.mode=ma;break}if(c.mode=ca,b===C)break a;case ca:c.mode=da;case da:if(i>=6&&j>=258){a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,v(a,p),h=a.next_out,f=a.output,j=a.avail_out,g=a.next_in,e=a.input,i=a.avail_in,m=c.hold,n=c.bits,c.mode===W&&(c.back=-1);break}for(c.back=0;Aa=c.lencode[m&(1<<c.lenbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(ra&&0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.lencode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,c.length=sa,0===ra){c.mode=ia;break}if(32&ra){c.back=-1,c.mode=W;break}if(64&ra){a.msg="invalid literal/length code",c.mode=ma;break}c.extra=15&ra,c.mode=ea;case ea:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.length+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}c.was=c.length,c.mode=fa;case fa:for(;Aa=c.distcode[m&(1<<c.distbits)-1],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(0===(240&ra)){for(ta=qa,ua=ra,va=sa;Aa=c.distcode[va+((m&(1<<ta+ua)-1)>>ta)],qa=Aa>>>24,ra=Aa>>>16&255,sa=65535&Aa,!(ta+qa<=n);){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}m>>>=ta,n-=ta,c.back+=ta}if(m>>>=qa,n-=qa,c.back+=qa,64&ra){a.msg="invalid distance code",c.mode=ma;break}c.offset=sa,c.extra=15&ra,c.mode=ga;case ga:if(c.extra){for(za=c.extra;n<za;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}c.offset+=m&(1<<c.extra)-1,m>>>=c.extra,n-=c.extra,c.back+=c.extra}if(c.offset>c.dmax){a.msg="invalid distance too far back",c.mode=ma;break}c.mode=ha;case ha:if(0===j)break a;if(q=p-j,c.offset>q){if(q=c.offset-q,q>c.whave&&c.sane){a.msg="invalid distance too far back",c.mode=ma;break}q>c.wnext?(q-=c.wnext,r=c.wsize-q):r=c.wnext-q,q>c.length&&(q=c.length),pa=c.window}else pa=f,r=h-c.offset,q=c.length;q>j&&(q=j),j-=q,c.length-=q;do f[h++]=pa[r++];while(--q);0===c.length&&(c.mode=da);break;case ia:if(0===j)break a;f[h++]=c.length,j--,c.mode=da;break;case ja:if(c.wrap){for(;n<32;){if(0===i)break a;i--,m|=e[g++]<<n,n+=8}if(p-=j,a.total_out+=p,c.total+=p,p&&(a.adler=c.check=c.flags?u(c.check,f,p,h-p):t(c.check,f,p,h-p)),p=j,(c.flags?m:d(m))!==c.check){a.msg="incorrect data check",c.mode=ma;break}m=0,n=0}c.mode=ka;case ka:if(c.wrap&&c.flags){for(;n<32;){if(0===i)break a;i--,m+=e[g++]<<n,n+=8}if(m!==(4294967295&c.total)){a.msg="incorrect length check",c.mode=ma;break}m=0,n=0}c.mode=la;case la:xa=E;break a;case ma:xa=H;break a;case na:return I;case oa:default:return G}return a.next_out=h,a.avail_out=j,a.next_in=g,a.avail_in=i,c.hold=m,c.bits=n,(c.wsize||p!==a.avail_out&&c.mode<ma&&(c.mode<ja||b!==A))&&l(a,a.output,a.next_out,p-a.avail_out)?(c.mode=na,I):(o-=a.avail_in,p-=a.avail_out,a.total_in+=o,a.total_out+=p,c.total+=p,c.wrap&&p&&(a.adler=c.check=c.flags?u(c.check,f,p,a.next_out-p):t(c.check,f,p,a.next_out-p)),a.data_type=c.bits+(c.last?64:0)+(c.mode===W?128:0)+(c.mode===ca||c.mode===Z?256:0),(0===o&&0===p||b===A)&&xa===D&&(xa=J),xa)}function n(a){if(!a||!a.state)return G;var b=a.state;return b.window&&(b.window=null),a.state=null,D}function o(a,b){var c;return a&&a.state?(c=a.state,0===(2&c.wrap)?G:(c.head=b,b.done=!1,D)):G}function p(a,b){var c,d,e,f=b.length;return a&&a.state?(c=a.state,0!==c.wrap&&c.mode!==V?G:c.mode===V&&(d=1,d=t(d,b,f,0),d!==c.check)?H:(e=l(a,b,f,f))?(c.mode=na,I):(c.havedict=1,D)):G}var q,r,s=a("../utils/common"),t=a("./adler32"),u=a("./crc32"),v=a("./inffast"),w=a("./inftrees"),x=0,y=1,z=2,A=4,B=5,C=6,D=0,E=1,F=2,G=-2,H=-3,I=-4,J=-5,K=8,L=1,M=2,N=3,O=4,P=5,Q=6,R=7,S=8,T=9,U=10,V=11,W=12,X=13,Y=14,Z=15,$=16,_=17,aa=18,ba=19,ca=20,da=21,ea=22,fa=23,ga=24,ha=25,ia=26,ja=27,ka=28,la=29,ma=30,na=31,oa=32,pa=852,qa=592,ra=15,sa=ra,ta=!0;c.inflateReset=g,c.inflateReset2=h,c.inflateResetKeep=f,c.inflateInit=j,c.inflateInit2=i,c.inflate=m,c.inflateEnd=n,c.inflateGetHeader=o,c.inflateSetDictionary=p,c.inflateInfo="pako inflate (from Nodeca project)"},{"../utils/common":62,"./adler32":64,"./crc32":66,"./inffast":69,"./inftrees":71}],71:[function(a,b,c){"use strict";var d=a("../utils/common"),e=15,f=852,g=592,h=0,i=1,j=2,k=[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,0,0],l=[16,16,16,16,16,16,16,16,17,17,17,17,18,18,18,18,19,19,19,19,20,20,20,20,21,21,21,21,16,72,78],m=[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,0,0],n=[16,16,16,16,17,17,18,18,19,19,20,20,21,21,22,22,23,23,24,24,25,25,26,26,27,27,28,28,29,29,64,64];b.exports=function(a,b,c,o,p,q,r,s){var t,u,v,w,x,y,z,A,B,C=s.bits,D=0,E=0,F=0,G=0,H=0,I=0,J=0,K=0,L=0,M=0,N=null,O=0,P=new d.Buf16(e+1),Q=new d.Buf16(e+1),R=null,S=0;for(D=0;D<=e;D++)P[D]=0;for(E=0;E<o;E++)P[b[c+E]]++;for(H=C,G=e;G>=1&&0===P[G];G--);if(H>G&&(H=G),0===G)return p[q++]=20971520,p[q++]=20971520,s.bits=1,0;for(F=1;F<G&&0===P[F];F++);for(H<F&&(H=F),K=1,D=1;D<=e;D++)if(K<<=1,K-=P[D],K<0)return-1;if(K>0&&(a===h||1!==G))return-1;for(Q[1]=0,D=1;D<e;D++)Q[D+1]=Q[D]+P[D];for(E=0;E<o;E++)0!==b[c+E]&&(r[Q[b[c+E]]++]=E);if(a===h?(N=R=r,y=19):a===i?(N=k,O-=257,R=l,S-=257,y=256):(N=m,R=n,y=-1),M=0,E=0,D=F,x=q,I=H,J=0,v=-1,L=1<<H,w=L-1,a===i&&L>f||a===j&&L>g)return 1;for(;;){z=D-J,r[E]<y?(A=0,B=r[E]):r[E]>y?(A=R[S+r[E]],B=N[O+r[E]]):(A=96,B=0),t=1<<D-J,u=1<<I,F=u;do u-=t,p[x+(M>>J)+u]=z<<24|A<<16|B|0;while(0!==u);for(t=1<<D-1;M&t;)t>>=1;if(0!==t?(M&=t-1,M+=t):M=0,E++,0===--P[D]){if(D===G)break;D=b[c+r[E]]}if(D>H&&(M&w)!==v){for(0===J&&(J=H),x+=F,I=D-J,K=1<<I;I+J<G&&(K-=P[I+J],!(K<=0));)I++,K<<=1;if(L+=1<<I,a===i&&L>f||a===j&&L>g)return 1;v=M&w,p[v]=H<<24|I<<16|x-q|0}}return 0!==M&&(p[x+M]=D-J<<24|64<<16|0),s.bits=H,0}},{"../utils/common":62}],72:[function(a,b,c){"use strict";b.exports={2:"need dictionary",1:"stream end",0:"","-1":"file error","-2":"stream error","-3":"data error","-4":"insufficient memory","-5":"buffer error","-6":"incompatible version"}},{}],73:[function(a,b,c){"use strict";function d(a){for(var b=a.length;--b>=0;)a[b]=0}function e(a,b,c,d,e){this.static_tree=a,this.extra_bits=b,this.extra_base=c,this.elems=d,this.max_length=e,this.has_stree=a&&a.length}function f(a,b){this.dyn_tree=a,this.max_code=0,this.stat_desc=b}function g(a){return a<256?ia[a]:ia[256+(a>>>7)]}function h(a,b){a.pending_buf[a.pending++]=255&b,a.pending_buf[a.pending++]=b>>>8&255}function i(a,b,c){a.bi_valid>X-c?(a.bi_buf|=b<<a.bi_valid&65535,h(a,a.bi_buf),a.bi_buf=b>>X-a.bi_valid,a.bi_valid+=c-X):(a.bi_buf|=b<<a.bi_valid&65535,a.bi_valid+=c)}function j(a,b,c){i(a,c[2*b],c[2*b+1])}function k(a,b){var c=0;do c|=1&a,a>>>=1,c<<=1;while(--b>0);return c>>>1}function l(a){16===a.bi_valid?(h(a,a.bi_buf),a.bi_buf=0,a.bi_valid=0):a.bi_valid>=8&&(a.pending_buf[a.pending++]=255&a.bi_buf,a.bi_buf>>=8,a.bi_valid-=8)}function m(a,b){var c,d,e,f,g,h,i=b.dyn_tree,j=b.max_code,k=b.stat_desc.static_tree,l=b.stat_desc.has_stree,m=b.stat_desc.extra_bits,n=b.stat_desc.extra_base,o=b.stat_desc.max_length,p=0;for(f=0;f<=W;f++)a.bl_count[f]=0;for(i[2*a.heap[a.heap_max]+1]=0,
c=a.heap_max+1;c<V;c++)d=a.heap[c],f=i[2*i[2*d+1]+1]+1,f>o&&(f=o,p++),i[2*d+1]=f,d>j||(a.bl_count[f]++,g=0,d>=n&&(g=m[d-n]),h=i[2*d],a.opt_len+=h*(f+g),l&&(a.static_len+=h*(k[2*d+1]+g)));if(0!==p){do{for(f=o-1;0===a.bl_count[f];)f--;a.bl_count[f]--,a.bl_count[f+1]+=2,a.bl_count[o]--,p-=2}while(p>0);for(f=o;0!==f;f--)for(d=a.bl_count[f];0!==d;)e=a.heap[--c],e>j||(i[2*e+1]!==f&&(a.opt_len+=(f-i[2*e+1])*i[2*e],i[2*e+1]=f),d--)}}function n(a,b,c){var d,e,f=new Array(W+1),g=0;for(d=1;d<=W;d++)f[d]=g=g+c[d-1]<<1;for(e=0;e<=b;e++){var h=a[2*e+1];0!==h&&(a[2*e]=k(f[h]++,h))}}function o(){var a,b,c,d,f,g=new Array(W+1);for(c=0,d=0;d<Q-1;d++)for(ka[d]=c,a=0;a<1<<ba[d];a++)ja[c++]=d;for(ja[c-1]=d,f=0,d=0;d<16;d++)for(la[d]=f,a=0;a<1<<ca[d];a++)ia[f++]=d;for(f>>=7;d<T;d++)for(la[d]=f<<7,a=0;a<1<<ca[d]-7;a++)ia[256+f++]=d;for(b=0;b<=W;b++)g[b]=0;for(a=0;a<=143;)ga[2*a+1]=8,a++,g[8]++;for(;a<=255;)ga[2*a+1]=9,a++,g[9]++;for(;a<=279;)ga[2*a+1]=7,a++,g[7]++;for(;a<=287;)ga[2*a+1]=8,a++,g[8]++;for(n(ga,S+1,g),a=0;a<T;a++)ha[2*a+1]=5,ha[2*a]=k(a,5);ma=new e(ga,ba,R+1,S,W),na=new e(ha,ca,0,T,W),oa=new e(new Array(0),da,0,U,Y)}function p(a){var b;for(b=0;b<S;b++)a.dyn_ltree[2*b]=0;for(b=0;b<T;b++)a.dyn_dtree[2*b]=0;for(b=0;b<U;b++)a.bl_tree[2*b]=0;a.dyn_ltree[2*Z]=1,a.opt_len=a.static_len=0,a.last_lit=a.matches=0}function q(a){a.bi_valid>8?h(a,a.bi_buf):a.bi_valid>0&&(a.pending_buf[a.pending++]=a.bi_buf),a.bi_buf=0,a.bi_valid=0}function r(a,b,c,d){q(a),d&&(h(a,c),h(a,~c)),G.arraySet(a.pending_buf,a.window,b,c,a.pending),a.pending+=c}function s(a,b,c,d){var e=2*b,f=2*c;return a[e]<a[f]||a[e]===a[f]&&d[b]<=d[c]}function t(a,b,c){for(var d=a.heap[c],e=c<<1;e<=a.heap_len&&(e<a.heap_len&&s(b,a.heap[e+1],a.heap[e],a.depth)&&e++,!s(b,d,a.heap[e],a.depth));)a.heap[c]=a.heap[e],c=e,e<<=1;a.heap[c]=d}function u(a,b,c){var d,e,f,h,k=0;if(0!==a.last_lit)do d=a.pending_buf[a.d_buf+2*k]<<8|a.pending_buf[a.d_buf+2*k+1],e=a.pending_buf[a.l_buf+k],k++,0===d?j(a,e,b):(f=ja[e],j(a,f+R+1,b),h=ba[f],0!==h&&(e-=ka[f],i(a,e,h)),d--,f=g(d),j(a,f,c),h=ca[f],0!==h&&(d-=la[f],i(a,d,h)));while(k<a.last_lit);j(a,Z,b)}function v(a,b){var c,d,e,f=b.dyn_tree,g=b.stat_desc.static_tree,h=b.stat_desc.has_stree,i=b.stat_desc.elems,j=-1;for(a.heap_len=0,a.heap_max=V,c=0;c<i;c++)0!==f[2*c]?(a.heap[++a.heap_len]=j=c,a.depth[c]=0):f[2*c+1]=0;for(;a.heap_len<2;)e=a.heap[++a.heap_len]=j<2?++j:0,f[2*e]=1,a.depth[e]=0,a.opt_len--,h&&(a.static_len-=g[2*e+1]);for(b.max_code=j,c=a.heap_len>>1;c>=1;c--)t(a,f,c);e=i;do c=a.heap[1],a.heap[1]=a.heap[a.heap_len--],t(a,f,1),d=a.heap[1],a.heap[--a.heap_max]=c,a.heap[--a.heap_max]=d,f[2*e]=f[2*c]+f[2*d],a.depth[e]=(a.depth[c]>=a.depth[d]?a.depth[c]:a.depth[d])+1,f[2*c+1]=f[2*d+1]=e,a.heap[1]=e++,t(a,f,1);while(a.heap_len>=2);a.heap[--a.heap_max]=a.heap[1],m(a,b),n(f,j,a.bl_count)}function w(a,b,c){var d,e,f=-1,g=b[1],h=0,i=7,j=4;for(0===g&&(i=138,j=3),b[2*(c+1)+1]=65535,d=0;d<=c;d++)e=g,g=b[2*(d+1)+1],++h<i&&e===g||(h<j?a.bl_tree[2*e]+=h:0!==e?(e!==f&&a.bl_tree[2*e]++,a.bl_tree[2*$]++):h<=10?a.bl_tree[2*_]++:a.bl_tree[2*aa]++,h=0,f=e,0===g?(i=138,j=3):e===g?(i=6,j=3):(i=7,j=4))}function x(a,b,c){var d,e,f=-1,g=b[1],h=0,k=7,l=4;for(0===g&&(k=138,l=3),d=0;d<=c;d++)if(e=g,g=b[2*(d+1)+1],!(++h<k&&e===g)){if(h<l){do j(a,e,a.bl_tree);while(0!==--h)}else 0!==e?(e!==f&&(j(a,e,a.bl_tree),h--),j(a,$,a.bl_tree),i(a,h-3,2)):h<=10?(j(a,_,a.bl_tree),i(a,h-3,3)):(j(a,aa,a.bl_tree),i(a,h-11,7));h=0,f=e,0===g?(k=138,l=3):e===g?(k=6,l=3):(k=7,l=4)}}function y(a){var b;for(w(a,a.dyn_ltree,a.l_desc.max_code),w(a,a.dyn_dtree,a.d_desc.max_code),v(a,a.bl_desc),b=U-1;b>=3&&0===a.bl_tree[2*ea[b]+1];b--);return a.opt_len+=3*(b+1)+5+5+4,b}function z(a,b,c,d){var e;for(i(a,b-257,5),i(a,c-1,5),i(a,d-4,4),e=0;e<d;e++)i(a,a.bl_tree[2*ea[e]+1],3);x(a,a.dyn_ltree,b-1),x(a,a.dyn_dtree,c-1)}function A(a){var b,c=4093624447;for(b=0;b<=31;b++,c>>>=1)if(1&c&&0!==a.dyn_ltree[2*b])return I;if(0!==a.dyn_ltree[18]||0!==a.dyn_ltree[20]||0!==a.dyn_ltree[26])return J;for(b=32;b<R;b++)if(0!==a.dyn_ltree[2*b])return J;return I}function B(a){pa||(o(),pa=!0),a.l_desc=new f(a.dyn_ltree,ma),a.d_desc=new f(a.dyn_dtree,na),a.bl_desc=new f(a.bl_tree,oa),a.bi_buf=0,a.bi_valid=0,p(a)}function C(a,b,c,d){i(a,(L<<1)+(d?1:0),3),r(a,b,c,!0)}function D(a){i(a,M<<1,3),j(a,Z,ga),l(a)}function E(a,b,c,d){var e,f,g=0;a.level>0?(a.strm.data_type===K&&(a.strm.data_type=A(a)),v(a,a.l_desc),v(a,a.d_desc),g=y(a),e=a.opt_len+3+7>>>3,f=a.static_len+3+7>>>3,f<=e&&(e=f)):e=f=c+5,c+4<=e&&b!==-1?C(a,b,c,d):a.strategy===H||f===e?(i(a,(M<<1)+(d?1:0),3),u(a,ga,ha)):(i(a,(N<<1)+(d?1:0),3),z(a,a.l_desc.max_code+1,a.d_desc.max_code+1,g+1),u(a,a.dyn_ltree,a.dyn_dtree)),p(a),d&&q(a)}function F(a,b,c){return a.pending_buf[a.d_buf+2*a.last_lit]=b>>>8&255,a.pending_buf[a.d_buf+2*a.last_lit+1]=255&b,a.pending_buf[a.l_buf+a.last_lit]=255&c,a.last_lit++,0===b?a.dyn_ltree[2*c]++:(a.matches++,b--,a.dyn_ltree[2*(ja[c]+R+1)]++,a.dyn_dtree[2*g(b)]++),a.last_lit===a.lit_bufsize-1}var G=a("../utils/common"),H=4,I=0,J=1,K=2,L=0,M=1,N=2,O=3,P=258,Q=29,R=256,S=R+1+Q,T=30,U=19,V=2*S+1,W=15,X=16,Y=7,Z=256,$=16,_=17,aa=18,ba=[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0],ca=[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13],da=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7],ea=[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],fa=512,ga=new Array(2*(S+2));d(ga);var ha=new Array(2*T);d(ha);var ia=new Array(fa);d(ia);var ja=new Array(P-O+1);d(ja);var ka=new Array(Q);d(ka);var la=new Array(T);d(la);var ma,na,oa,pa=!1;c._tr_init=B,c._tr_stored_block=C,c._tr_flush_block=E,c._tr_tally=F,c._tr_align=D},{"../utils/common":62}],74:[function(a,b,c){"use strict";function d(){this.input=null,this.next_in=0,this.avail_in=0,this.total_in=0,this.output=null,this.next_out=0,this.avail_out=0,this.total_out=0,this.msg="",this.state=null,this.data_type=2,this.adler=0}b.exports=d},{}]},{},[10])(10)});
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",[],function(){return saveAs})}
;
define("saveAs", function(){});

/*******************************************************************************
 * Copyright 2012-2015 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Tool designed to select areas on planet
 */

define('Services/ExportToolCore',["jquery", "underscore-min", "jszip", "saveAs","../Gui/dialog/ErrorDialog", "../Utils/Constants"],
    function ($, _, JSZip, saveAs, ErrorDialog, Constants) {

        var self, mizarAPI, layers, availableLayers;

        /**************************************************************************************************************/

        /**
         *    Keep only layers having available searching services
         */
        function filterServicesAvailableOnLayers() {
            availableLayers = [];
            _.each(layers, function (layer) {
                if (layer.isVisible() && layer.category !== "Other" && layer.category !== "Solar System"
                    && layer.name !== "SAMP" && layer.name !== "Planets") {
                    layer.layerId = _.uniqueId('layer_');
                    availableLayers.push(layer);
                }
            });
            return availableLayers;
        }

        /**************************************************************************************************************/

        /**
         * Export data included in the passed coordinates selection
         *
         * @param event.data = coordinates
         */
        function exportSelection(event) {

            self.coordinates = event.data;

            $("body").mask('Exporting data...');

            var JSZip = require("jszip");

            // creating empty archive
            var zip = new JSZip();

            // getting all visible and displayed layers
            var backgroundLayers = [];
            var dataLayers = [];
            _.each(availableLayers, function (layer) {
                if ($('#' + layer.layerId).is(':checked')) {
                    if (layer.type === Constants.LAYER.OpenSearch || layer.type === Constants.LAYER.GeoJSON) {
                        //if (layer.type === "DynamicOpenSearch") {
                        dataLayers.push(layer);
                    } else if (layer.type === Constants.LAYER.Hips || layer.type === Constants.LAYER.HipsCat) {
                        backgroundLayers.push(layer);
                    }
                }
            });

            // Adding a middle point the bbox to be sure no data/image will be omitted
            var middlePoint = [
                (self.coordinates[0][1] + self.coordinates[1][1]) / 2,
                (self.coordinates[0][0] + self.coordinates[3][0]) / 2,
                0
            ];
            self.coordinates.push(middlePoint);

            // getting data url from layer using tile and bbox coordinates
            var tileLayerFeatures = [];
            _.each(dataLayers, function (dataLayer, index) {
                for (var i = 0; i < self.coordinates.length; i++) {
                    var tile = mizarAPI.getActivatedContext().getTileManager().getVisibleTile(self.coordinates[i][0], self.coordinates[i][1]);

                    if (_.isEmpty(tile)) {
                        return;
                    }

                    var osData = tile.extension[dataLayer.extId];

                    if (!_.isEmpty(osData) && !_.isEmpty(osData.featureIds)) {
                        _.each(osData.featureIds, function (fId) {
                            var featureSet = dataLayer.featuresSet[fId];
                            if (!_.isEmpty(featureSet)) {
                                var feature = dataLayer.features[featureSet.index];

                                var isIncluded = true;
                                switch (feature.geometry.type) {
                                    case Constants.GEOMETRY.Point:
                                        isIncluded = self.checkIfPointInBbox(feature.geometry.coordinates, self.coordinates);
                                        break;

                                    case Constants.GEOMETRY.Polygon:
                                        for (var i = 0; i < feature.geometry.coordinates.length; i++) {
                                            if (!isIncluded) {
                                                return;
                                            }
                                            isIncluded = self.checkIfPointInBbox(feature.geometry.coordinates[0][i], self.coordinates);
                                        }
                                        break;
                                }
                                if (isIncluded) {
                                    // Adding layer information in order to rank data in archive
                                    feature.parentInformation = {
                                        copyright: dataLayer.copyright || "",
                                        copyrightUrl: dataLayer.copyrightUrl || "",
                                        category: dataLayer.category,
                                        name: dataLayer.name
                                    };
                                    tileLayerFeatures.push(feature);
                                }
                            }
                        });
                    }
                }
            });

            // Adding features archive
            _.each(tileLayerFeatures, function (feature) {
                var folder = zip.folder(feature.parentInformation.category + "/" + feature.parentInformation.name);

                // Adding a copyright file into each folder
                if (!_.isEmpty(feature.parentInformation.copyright) || !_.isEmpty(feature.parentInformation.copyrightUrl)) {
                    var copyright = "Copyright : " + feature.parentInformation.copyright + " - link : " + feature.parentInformation.copyrightUrl;
                    folder.file(feature.parentInformation.name + ".txt", copyright);
                }

                var featureToStringify = {
                    geometry: {
                        coordinates: feature.geometry.coordinates,
                        gid: feature.geometry.gid,
                        type: feature.geometry.type,
                        crs: {
                            type: "name",
                            properties: {
                                name: mizarAPI.getCrs().getGeoideName()
                            }
                        }
                    },
                    id: feature.id,
                    properties: feature.properties,
                    type: feature.type
                };

                folder.file(feature.properties.identifier + ".json", JSON.stringify(featureToStringify, null, '\t'));
            });


            if (backgroundLayers.length === 0) {
                self.downloadArchive(zip);
            } else {
                var numberOfImages = 0;
                var imageNotFound = false;
                // get images url from Background layer
                _.each(backgroundLayers, function (backgroundLayer, index) {
                    backgroundLayer.urlImages = [];
                    backgroundLayer.images = [];

                    for (var i = 0; i < self.coordinates.length; i++) {

                        // Retrieve the tile according to a
                        var tile = mizarAPI.getActivatedContext().getTileManager().getVisibleTile(self.coordinates[i][0], self.coordinates[i][1]);

                        if (_.isEmpty(tile)) {
                            return;
                        }

                        numberOfImages++;
                        var url = backgroundLayer.getUrl(tile);

                        var image = new Image();
                        image.aborted = false;
                        image.crossOrigin = '';
                        image.backgroundName = backgroundLayer.name;
                        image.parentFolder = backgroundLayer.category + "/" + backgroundLayer.name + "/images";
                        image.imageName = url.substring(url.lastIndexOf('/') + 1, url.length);

                        image.onload = function () {
                            self.addImageToArchive(this, zip);
                            numberOfImages--;

                            if (numberOfImages == 0) {
                                self.downloadArchive(zip);
                            }
                        };
                        image.onerror = function () {
                            imageNotFound = true;
                            console.dir('Error while retrieving image : ' + this.imageName);
                            numberOfImages--;
                            if (numberOfImages == 0) {
                                if (imageNotFound) {
                                    ErrorDialog.open("Some images not found. Change zoom level and retry downloading");
                                }

                                self.downloadArchive(zip);
                            }
                        };
                        image.src = url;
                    }
                });
            }
        }

        /**************************************************************************************************************/

        /**
         * Create a zip file containing data + readme file and download it
         *
         * @param zip
         */
        function downloadArchive(zip) {
            var saveAs = require("saveAs");

            var date = new Date();
            var currentDate = $.datepicker.formatDate('yy/mm/dd ' + date.getHours() + ":" + date.getMinutes(), date);
            var readme = "Date : " + currentDate + "\n" +
                "Query :" + JSON.stringify(self.coordinates, null, '\t') + "\n" +
                "Copyright : Generated by MIZAR";

            zip.file("README.txt", readme);

            var content = zip.generate({type: "blob"});
            saveAs(content, "archive_" + currentDate + ".zip");
            $("body").unmask();
        }

        /**************************************************************************************************************/

        /**
         * Check if given is included into the drawn bbox
         * @param point
         * @param bbox
         * @returns {boolean}
         */
        function checkIfPointInBbox(point, bbox) {
            if((point[1] >= bbox[0][1] && point[1] <= bbox[1][1])
                && (point[0] <= bbox[0][0]
                && point[0] >= bbox[3][0])) {
                return true;
            } else {
                return false;
            }
        }

        /**************************************************************************************************************/

        /**
         * Add an image into the passed archive
         * @param img
         * @param zip
         */
        function addImageToArchive(img, zip) {
            var folder = zip.folder(img.parentFolder);
            folder.file(img.imageName, self.getBase64Image(img), {base64: true});
        }

        /**************************************************************************************************************/

        /**
         * Convert an image into base64
         * @param img
         * @returns {string}
         */
        function getBase64Image(img) {
            // Create an empty canvas element
            var canvas = document.createElement("canvas");
            canvas.width = img.width;
            canvas.height = img.height;

            // Copy the image contents to the canvas
            var ctx = canvas.getContext("2d");
            ctx.drawImage(img, 0, 0);

            // Get the data-URL formatted image
            // Firefox supports PNG and JPEG. You could check img.src to
            // guess the original format, but be aware the using "image/jpg"
            // will re-encode the image.
            var dataURL = canvas.toDataURL("image/png");

            return dataURL.replace(/^data:image\/(png|jpg);base64,/, "");
        }

        /**************************************************************************************************************/

        return {
            /**
             *    @constructor
             *    @param options Configuration options
             *        <ul>
             *            <li>planet: planet</li>
             *            <li>layers: Layers</li>
             *        </ul>
             */
            init: function (mizar, options) {
                // Required options
                mizarAPI = mizar;
                layers = mizarAPI.getLayers(Constants.CONTEXT.Sky);
                self = this;
            },
            exportSelection: exportSelection,
            addImageToArchive: addImageToArchive,
            downloadArchive: downloadArchive,
            getBase64Image: getBase64Image,
            filterServicesAvailableOnLayers: filterServicesAvailableOnLayers
        };
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/AbstractNameResolver',[],
    function () {

        /**************************************************************************************************************/

        /**
         * @name AbstractNameResolverer
         * @class
         * Abstract Wrapper constructor
         * @param {Context} options - Context
         * @constructor
         * @implements {NameResolver}
         */
        var AbstractNameResolver = function (options) {
            this.ctx = options;
        };

        /**************************************************************************************************************/

        /**
         * @function handle
         * @memberOf AbstractNameResolver#
         * @abstract
         */
        AbstractNameResolver.prototype.handle = function (options) {
            throw new SyntaxError("handle from NameResolver not implemented", "AbstractNameResolver.js");
        };

        /**
         * @function remove
         * @memberOf AbstractNameResolver#
         * @abstract
         */
        AbstractNameResolver.prototype.remove = function () {
            throw new SyntaxError("remove from NameResolver not implemented", "AbstractNameResolver.js");
        };        

        /**************************************************************************************************************/

        return AbstractNameResolver;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Name resolver module : API allowing to search object name and zoom to it
 * @module NameResolver
 * @implements {NameResolver}
 */
define('NameResolver/CDSNameResolver',["jquery", "underscore-min", "../Utils/Constants", "../Utils/Utils", "./AbstractNameResolver"],
    function ($, _, Constants, Utils, AbstractNameResolver) {

        /**************************************************************************************************************/

        /**
         * @name CDSNameResolver
         * @class
         *   Plugin to access to CDS name resolver
         * @augments AbstractNameResolver
         * @param {Context} options - Context
         * @memberOf module:NameResolver
         */
        var CDSNameResolver = function (options) {
            AbstractNameResolver.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractNameResolver, CDSNameResolver);

        /**************************************************************************************************************/


        /**
         * Queries CDS using this URL : http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?<i>objectName</i>
         * and the layers
         * @function handle
         * @memberOf CDSNameResolver#
         */
        CDSNameResolver.prototype.handle = function (options) {
            var context = this.ctx;
            var objectName = options.objectName;
            var onError = options.onError;
            var onComplete = options.onComplete;
            var onSuccess = options.onSuccess;
            var searchLayer = options.searchLayer;
            var zoomTo = options.zoomTo;

            var url = "http://cdsweb.u-strasbg.fr/cgi-bin/nph-sesame/-oxp/A?" + objectName;
            $.ajax({
                type: "GET",
                url: url,
                dataType: "xml",
                success: function (xmlResponse) {
                    var target = $(xmlResponse).find("Target");
                    var name = $(target).find("name").text();
                    var features = [];

                    $(target).find("Resolver").each(function (index) {
                        var resolver = this;
                        var ra = $(resolver).find("jradeg");
                        var dec = $(resolver).find("jdedeg");

                        if (!_.isEmpty(ra.text()) && !_.isEmpty(dec.text())) {
                            ra = parseFloat(ra.text());
                            dec = parseFloat(dec.text());
                            var feature = {};
                            feature.ra = ra;
                            feature.dec = dec;
                            feature.credit = $(resolver).attr('name');
                            features.push(feature);
                        }
                    });

                    var response = {
                        totalResults: features.length,
                        type: "FeatureCollection",
                        features: []
                    };

                    _.each(features, function (feature) {
                        response.features.push({
                            type: 'Feature',
                            geometry: {
                                coordinates: [feature.ra, feature.dec],
                                type: Constants.GEOMETRY.Point,
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                identifier: "CDS0",
                                name: name,
                                credits: "Powered by <a href=\"http://cdsweb.u-strasbg.fr/cgi-bin/Sesame\">Sesame API</a> (" + feature.credit + ")"
                            }
                        })
                    });

                    // Check if response contains features
                    if (response.type === "FeatureCollection" && response.features.length > 0) {
                        var firstFeature = response.features[0];
                        var zoomToCallback = function () {
                            searchLayer(objectName, onSuccess, onError, response);
                        };
                        zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], Constants.CRS.Equatorial, zoomToCallback, response);
                    } else {
                        searchLayer(objectName, onSuccess, onError, response);
                    }
                },
                error: function (xhr) {
                    searchLayer(objectName, onSuccess, onError);
                    console.error(xhr.responseText);
                },
                complete: function (xhr, textStatus) {
                    if (onComplete) {
                        onComplete(xhr);
                    }
                }
            });
        };

        /**
         * @function remove
         * @memberOf CDSNameResolver#
         */
        CDSNameResolver.prototype.remove = function () {
        };

        return CDSNameResolver;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/DictionaryNameResolver',["jquery", "underscore-min", "../Utils/Utils", "./AbstractNameResolver","../Layer/VectorLayer", "../Renderer/FeatureStyle","../Utils/Constants"],
    function ($, _, Utils, AbstractNameResolver, VectorLayer, FeatureStyle, Constants) {

      var dictionary;

      /**
       * In case if base url isn't a service but a json containing all known places
       * this method allows to retrieve it
       */
      var retrieveDictionary = function (context) {
          var containsDictionary = context.getContextConfiguration().nameResolver.baseUrl.indexOf("json") >= 0;
          if (containsDictionary) {
              // Dictionary as json
              var marsResolverUrl = context.getContextConfiguration().nameResolver.baseUrl;//.replace('mizar_gui', 'mizar_lite');
              $.ajax({
                  type: "GET",
                  dataType : "json",
                  url: marsResolverUrl,
                  success: function (response) {
                      dictionary = response;
                      //nameResolverLayer = new VectorLayer();
                      //for (var i = 0; i < response.features.length; i++) {
                      //    var feature = response.features[i];
                      //    feature.properties.style = new FeatureStyle({
                      //        label: feature.properties.Name,
                      //        fillColor: [1, 0.7, 0, 1]
                      //    });
                      //}
                      //nameResolverLayer.addFeatureCollection(response);
                      //context.globe.addLayer(nameResolverLayer);
                  },
                  error: function (thrownError) {
                      console.error(thrownError);
                  }
              });
          }
          else {
              dictionary = null;
          }
      };

      /**************************************************************************************************************/
         /**
          @name DictionaryNameResolver
          @class
              Plugin to access to the dictionary name resolver
          @augments AbstractNameResolver
          @param {Context} options - Configuration properties
          @memberOf module:NameResolver
          */
        var DictionaryNameResolver = function (options) {
            AbstractNameResolver.prototype.constructor.call(this, options);
            dictionary = retrieveDictionary(options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractNameResolver, DictionaryNameResolver);


        /**
         * Queries the GeoJSON passed in parameter in the Mizar options
         * @function handle
         * @memberOf DictionaryNameResolver#
         */
        DictionaryNameResolver.prototype.handle = function (options) {
            var context = this.ctx;
            var crs = this.ctx.getCoordinateSystem();
            var objectName = options.objectName;
            var onError = options.onError;
            var onComplete = options.onComplete;
            var onSuccess = options.onSuccess;
            var searchLayer = options.searchLayer;
            var zoomTo = options.zoomTo;

            // Planet resolver(Mars only currently)
            var feature = _.find(dictionary.features, function (f) {
                var name = (f.properties.Name == undefined) ? f.properties.name : f.properties.Name;
                return name.toLowerCase() === objectName.toLowerCase();
            });

            if (feature) {
                var lon = parseFloat(feature.properties.center_lon);
                var lat = parseFloat(feature.properties.center_lat);
                feature.geometry.crs = {
                    type: "name",
                    properties: {
                        name: context.getCoordinateSystem().getGeoideName()
                    }
                };
                var zoomToCallback = function () {
                    searchLayer(objectName, onSuccess, onError, {features: [feature]});
                };                

                zoomTo(lon, lat, crs.getGeoideName(), zoomToCallback, {features: [feature]});
            }
            else {
                searchLayer(objectName, onSuccess, onError);
            }
        };

        /**
         * Code to execute when remove
         * @function remove
         * @memberof DictionaryNameResolver#
         */
        DictionaryNameResolver.prototype.remove = function () {
            dictionary = null;
        };

        return DictionaryNameResolver;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/IMCCENameResolver',["jquery", "underscore-min", "../Utils/Utils", "./AbstractNameResolver","../Utils/Constants"],
    function ($, _, Utils, AbstractNameResolver, Constants) {
        /**************************************************************************************************************/

        /**
         * @name IMCCENameResolver
         * @class
         *     Plugin to access to IMCCE name resolver
         * @augments AbstractNameResolver
         * @param {Context} options - Context
         * @memberOf module:NameResolver
         */
        var IMCCENameResolver = function (options) {
            AbstractNameResolver.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractNameResolver, IMCCENameResolver);

        /**************************************************************************************************************/

        /**
         * Queries SSODnet using this URL https://api.ssodnet.imcce.fr/quaero/1/sso?q=<i>objectName</i>
         * and the layers
         * @function handle
         * @memberOf IMCCENameResolver#
         */
        IMCCENameResolver.prototype.handle = function (options) {
            var objectName = options.objectName;
            var onError = options.onError;
            var onComplete = options.onComplete;
            var onSuccess = options.onSuccess;
            var searchLayer = options.searchLayer;
            var zoomTo = options.zoomTo;
            var url = "https://api.ssodnet.imcce.fr/quaero/1/sso?q=" + objectName +"&from=Mizar";
            $.ajax({
                type: "GET",
                url: url,
                dataType: "json",
                success: function (jsonResponse) {
                    var data = jsonResponse.data;
                    parseResponse(data, createsGeoJsonResponse);

                    function parseResponse(data, callback) {
                        var features = [];
                        var i=0;
                        var dataLength = data.length;
                        if (dataLength === 0) {
                            onError();
                        } else {
                            _.each(data, function(data) {
                                parseItem(data, function(feature){
                                    i++;
                                    if(!_.isEmpty(feature)) {
                                        features.push(feature);
                                    }
                                    if(i === dataLength) {
                                        callback(features);
                                    }
                                });
                            });
                        }
                    }

                    function parseItem(data, callback) {
                        var type = data.type;
                        var id = data.id;
                        var name = data.name;
                        if ($.inArray(type, ["Planet","Asteroid","Satellite","Star","Comet"])!== -1) {
                            var url = "https://api.ssodnet.imcce.fr/quaero/1/sso/"+id+"/resolver";
                            $.ajax({
                                type: "GET",
                                url: url,
                                dataType: "json",
                                success: function (data) {
                                    var coordinates = data.geometry.coordinates;
                                    var ra = coordinates[0]*360/24;
                                    var dec = coordinates[1];
                                    if(_.isNumber(ra) && _.isNumber(dec)) {
                                        ra = parseFloat(ra);
                                        dec = parseFloat(dec);
                                        var feature = {};
                                        feature.ra=ra;
                                        feature.dec=dec;
                                        feature.credits = "Powered by <a href=\"http://vo.imcce.fr/webservices/ssodnet/?quaero\" target=\"_blank\">SsODNet/Quaero API</a>.";
                                        feature.id = id;
                                        feature.type = type;
                                        feature.name = name;
                                        callback(feature);							       					 		}
                                },
                                error: function (xhr) {
                                    //TODO : Network problem
                                    console.error(xhr.responseText);
                                }
                            });
                        } else {
                            callback();
                        }
                    }

                    function createsGeoJsonResponse (features) {
                        var response = {
                            totalResults: features.length,
                            type: "FeatureCollection",
                            features: [
                            ]
                        };
                        _.each(features, function(feature) {
                            response.features.push({
                                type: "Feature",
                                geometry: {
                                    coordinates: [feature.ra, feature.dec],
                                    type: "Point",
                                    crs: {
                                        type: "name",
                                        properties: {
                                            name: Constants.CRS.Equatorial
                                        }
                                    }
                                },
                                properties: {
                                    identifier: feature.id,
                                    type: feature.type,
                                    name:feature.name,
                                    credits: feature.credits
                                }
                            })
                        });
                        if (response.type === "FeatureCollection" && response.features.length > 0) {
                            var firstFeature = response.features[0];
                            var zoomToCallback = function () {
                                searchLayer(objectName, onSuccess, onError, response);
                            };
                            zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], Constants.CRS.Equatorial, zoomToCallback, response);
                        } else {
                            onError();
                        }
                    }
                },
                error: function (xhr) {
                    searchLayer(objectName, onSuccess, onError);
                    if(onError) {
                        //TODO : network problem
                    }
                    console.error(xhr.responseText);
                },
                complete: function (xhr) {
                    if (onComplete) {
                        onComplete(xhr);
                    }
                }
            });
        };

        /**
         * @function remove
         * @memberOf IMCCENameResolver#
         */
        IMCCENameResolver.prototype.remove = function() {
        };

        return IMCCENameResolver;
    });
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('NameResolver/DefaultNameResolver',["jquery", "underscore-min", "../Utils/Utils", "./AbstractNameResolver"],
    function ($, _, Utils, AbstractNameResolver) {

        /**************************************************************************************************************/

         /**
          * @name DefaultNameResolver
          * @class
          *  Plugin to access to default name resolver
          * @augments AbstractNameResolver
          * @param {Context} options - Context
          * @memberOf module:NameResolver          
          */
        var DefaultNameResolver = function (options) {
            AbstractNameResolver.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractNameResolver, DefaultNameResolver);

        /**************************************************************************************************************/

        /**
         * Convert passed url into an url understandable by the service (input transformer)
         * @function handle
         * @memberOf DefaultNameResolver#
         */
        DefaultNameResolver.prototype.handle = function (options) {
            var context = this.ctx;
            var objectName = options.objectName;
            var onError = options.onError;
            var onComplete = options.onComplete;
            var onSuccess = options.onSuccess;
            var searchLayer = options.searchLayer;
            var zoomTo = options.zoomTo;

            var url = context.getMizarConfiguration().nameResolver.baseUrl + "/" + objectName + "/EQUATORIAL";
            $.ajax({
                type: "GET",
                url: url,
                success: function (response) {
                    // Check if response contains features
                    if (response.type === "FeatureCollection") {
                        var firstFeature = response.features[0];
                        var zoomToCallback = function() {
                            searchLayer(objectName, onSuccess, onError, response);
                        };
                        zoomTo(firstFeature.geometry.coordinates[0], firstFeature.geometry.coordinates[1], zoomToCallback, response);

                    } else {
                        onError();
                    }
                },
                error: function (xhr) {
                    searchLayer(objectName, onSuccess, onError);
                    console.error(xhr.responseText);
                },
                complete: function (xhr, textStatus) {
                    if (onComplete) {
                        onComplete(xhr);
                    }
                }
            });
        };

        /**
         * @function remove
         * @memberOf DefaultNameResolver#
         */
        DefaultNameResolver.prototype.remove = function() {
        };        

        /**************************************************************************************************************/

        return DefaultNameResolver;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NameResolver
 * @class
 * Name resolver
 * @memberOf module:NameResolver
 */
define('NameResolver/NameResolver',["jquery", "underscore-min", "../Utils/Constants",
        "../Renderer/FeatureStyle", "../Layer/VectorLayer", "../Tiling/HEALPixBase",
        "jquery.ui", "./CDSNameResolver", "./DictionaryNameResolver", "./IMCCENameResolver", "./DefaultNameResolver"],
    function ($, _, Constants, FeatureStyle, VectorLayer, HEALPixBase) {

        // Name resolver globals
        var mizarAPI;
        var context;

        // Name resolver properties
        var duration;
        var zoomFov;
        var targetLayer; 			  // Layer containing target feature(cross) on zoom
        var targetFeature;			  // Zooming destination feature

        //Wrapper Object
        var nameResolverImplementation = null;

        /**************************************************************************************************************/

        /**
         *    Update targetFeature and add it to the target layer
         *
         *    @param lon Destination longitude/right ascension in degrees
         *    @param lat Destination latitude/declination in degrees
         *    @param crs coordinate reference system of the (longitude,latitude)
         */
        function addTarget(lon, lat, crs) {
            targetFeature = {
                geometry: {
                    coordinates: [
                        lon,
                        lat
                    ],
                    type: Constants.GEOMETRY.Point,
                    crs: {
                        type: "name",
                        properties: {
                            name: crs
                        }
                    }
                },
                type: "Feature"
            };

            targetLayer.addFeature(targetFeature);
        }

        function zoomToHips(matchHealpix, onSuccess) {
            var order = parseInt(matchHealpix[1], 10);
            var pixelIndex = parseInt(matchHealpix[2], 10);

            // Compute vertices
            var nside = Math.pow(2, order);
            /*jslint bitwise: true */
            var pix = pixelIndex & (nside * nside - 1);
            var ix = HEALPixBase.compress_bits(pix);
            /*jslint bitwise: true */
            var iy = HEALPixBase.compress_bits(pix >>> 1);
            /*jslint bitwise: true */
            var face = (pixelIndex >>> (2 * order));

            var i = 0.5;
            var j = 0.5;
            var vert = HEALPixBase.fxyf((ix + i) / nside, (iy + j) / nside, face);
            var geoPos = [];
            mizarAPI.getCrs().getWorldFrom3D(vert, geoPos);
            zoomTo(geoPos[0], geoPos[1], mizarAPI.getCrs().getGeoideName(), onSuccess);
        }

        function zoomToSexagesimal(coordinates, onSuccess) {
            // Format to equatorial coordinates
            var word = coordinates.split(" "); // [RA, Dec]

            word[0] = word[0].replace(/h|m|:/g, " ");
            word[0] = word[0].replace("s", "");
            word[1] = word[1].replace(/°|'|:/g, " ");
            word[1] = word[1].replace("\"", "");

            // Convert to geo and zoom
            var geoPos = [];
            mizarAPI.getCrs().getDecimalDegFromSexagesimal([word[0], word[1]], geoPos);
            zoomTo(geoPos[0], geoPos[1], mizarAPI.getCrs().getGeoideName(), onSuccess);
        }

        function zoomToDecimal(matchDegree, onSuccess, onErrorOutOfBound) {
            var currentGeoBound = mizarAPI.getCrs().getGeoBound();
            var lon = parseFloat(matchDegree[1]);
            var lat = parseFloat(matchDegree[3]);
            var geo = [lon, lat];
            if (currentGeoBound.isPointInside(geo)) {
              zoomTo(geo[0], geo[1], mizarAPI.getCrs().getGeoideName(), onSuccess);
            } else {
              onErrorOutOfBound.call(this);
            }
        }

        /**************************************************************************************************************/

        /**
         *    Search for object name
         *    Object name could be:
         *        * Degree in "HMS DMS" or "deg deg"
         *        * Object name as "Mars", "m31", "Mizar"
         *        * For debug : healpix(order,pixelIndex)
         *    @fires Mizar#plugin:not_found
         */
        function search(objectName, onSuccess, onError, onErrorOutOfBound, onComplete) {
            var geoPos;
            // regexp used only to distinct equatorial coordinates and objects
            // TODO more accurate ( "x < 24h", "x < 60mn", etc.. )
            objectName = objectName.replace(/\s{2,}/g, ' '); // Replace multiple spaces by a single one
            var coordinatesExp = new RegExp("\\d{1,2}[h|:]\\d{1,2}[m|:]\\d{1,2}([\\.]\\d+)?s?\\s[-+]?[\\d]+[°|:]\\d{1,2}['|:]\\d{1,2}([\\.]\\d+)?\"?", "g");
            var healpixRE = /^healpix\((\d)+,(\d+)\)/;
            var degRE = /^(-?\d+(\.\d+)?),?\s(-?\d+(\.\d+)?)/;
            var layerRE = /^layer:(.)*?/;
            var matchHealpix = healpixRE.exec(objectName);
            var matchDegree = degRE.exec(objectName);
            var matchLayer = layerRE.exec(objectName);
            if (matchHealpix) {
                zoomToHips(matchHealpix, onSuccess);
            }
            else if (objectName.match(coordinatesExp)) {
                zoomToSexagesimal(objectName, coordinatesExp, onSuccess);
            }
            else if (matchDegree) {
                zoomToDecimal(matchDegree, onSuccess,onErrorOutOfBound);
            }
            else {
                var options = {
                    objectName: objectName,
                    onError: onError,
                    onComplete: onComplete,
                    onSuccess: onSuccess,
                    searchLayer: searchLayer,
                    zoomTo: zoomTo
                };

                if (nameResolverImplementation) {
                    nameResolverImplementation.handle(options);
                } else {
                    mizarAPI.publish("plugin:not_found", "No name resolver found");
                }
            }
        }


        function searchLayer(objectName, onSuccess, onError, response) {
            var layers = mizarAPI.searchOnLayerDescription(objectName, mizarAPI.getActivatedContext().getMode());
            if (layers.length === 0 && (!response || response.totalResults === 0)) {
                if (onError) {
                    onError();
                }
                return;
            }

            layers = _.sortBy(layers, function (layer) {
                return (layer.category === "background") ? 0 : 1;
            });


            var results;
            // Check if response contains features
            if (response && response.type === "FeatureCollection") {
                results = response;
            } else {
                results = {};
                results.type = "FeatureCollection";
                results.features = [];
            }

            _.each(layers, function (layer) {
                results.features.push(
                    {
                        type: 'Feature',
                        properties: {
                            type: 'layer',
                            name: layer.name,
                            description: layer.description,
                            layerType: layer.type,
                            visible: layer.visible,
                            background: layer.category === "background"
                        }
                    }
                )
            });

            onSuccess(results);
        }

        /**************************************************************************************************************/

        /**
         *    Zoom to the given longitude/latitude and add target at the end
         *    @param lon Longitude
         *    @param lat Latitude
         *    @param crs coordinate reference system of the (longitude, latitude)
         *    @param callback Callback once animation is over
         *    @param args Callback arguments
         */
        function zoomTo(lon, lat, crs, callback, args) {

            if (args !== null && typeof args !== 'undefined') {
                // updates the coordinates, which is displayed at the screen in the current CRS
                var idx = 0;
                while (idx < args.features.length) {
                    args.features[idx].geometry.coordinates = mizarAPI.getCrs().convert(args.features[idx].geometry.coordinates, crs, mizarAPI.getCrs().getGeoideName());
                    args.features[idx].geometry.crs.properties.name = crs;
                    idx++;
                }
            }

            // Add target feature on animation stop
            var addTargetCallback = function () {
                addTarget(lon, lat, crs);
                if (callback) {
                    callback.call(this, args);
                }
            };
            [lon, lat] = mizarAPI.getCrs().convert([lon, lat], crs, mizarAPI.getCrs().getGeoideName());
            if (mizarAPI.getActivatedContext().getMode() === Constants.CONTEXT.Sky) {
                mizarAPI.getActivatedContext().getNavigation().zoomTo([lon, lat], {
                    fov: zoomFov,
                    duration: duration,
                    callback: addTargetCallback
                });
            }
            else {
                var distance = mizarAPI.getActivatedContext().getNavigation().getDistance();
                mizarAPI.getActivatedContext().getNavigation().zoomTo([lon, lat], {
                    distance: distance,
                    duration: duration,
                    callback: addTargetCallback
                });
            }
        }

        /**************************************************************************************************************/

        /**
         *    Delete target image
         */
        function removeTarget() {
            if (targetFeature) {
                targetLayer.removeFeature(targetFeature);
                targetFeature = null;
            }
        }

        /**************************************************************************************************************/


        /**************************************************************************************************************/

        return {
            /**
             * Init name resolver
             * @param {Mizar} m - Mizar API
             * @alias module:NameResolver.NameResolver.init
             */
            init: function (m) {
                if (!context) {
                    mizarAPI = m;
                    this.setContext(mizarAPI.getActivatedContext());
                } else {
                    console.error("Name resolver is already initialized");
                }
            },

            /**
             * Unregisters all event handlers
             * @alias module:NameResolver.NameResolver.remove
             */
            remove: function () {
                if (context) {
                    mizarAPI.getActivatedContext().removeDraw(targetLayer);
                    if (nameResolverImplementation !== undefined) {
                        nameResolverImplementation.remove();
                    }
                    mizarAPI.getActivatedContext().unsubscribe("modifiedNavigation", removeTarget);
                    context = null;
                }
            },

            /**
             *    Search for object name
             *    Object name could be:
             *    <ul>
             *        <li>Degree in "HMS DMS" or "deg deg"</li>
             *        <li>Object name as "Mars", "m31", "Mizar"</li>
             *        <li>For debug : healpix(order,pixelIndex)</li>
             *    </ul>
             *    @alias module:NameResolver.NameResolver.goTo
             *    @fires Mizar#plugin:not_found
             */
            goTo: search,

            /**
             *    Zoom to the given longitude/latitude and add target at the end
             *    @param lon Longitude
             *    @param lat Latitude
             *    @param crs coordinate reference system of the (longitude, latitude)
             *    @param callback Callback once animation is over
             *    @param args Callback arguments
             *    @alias module:NameResolver.NameResolver.zoomTo
             */
            zoomTo: zoomTo,

            /**
             *    Set context
             *    @alias module:NameResolver.NameResolver.setContext
             *    @listens Context#modifiedNavigation
             */
            setContext: function (ctx) {
                // Remove previous context
                this.remove();
                context = ctx;

                //instantiate name resolver nameResolverImplementation object
                var isDefaultNameResolver;
                var nameResolverClass;
                if (typeof context.getContextConfiguration().nameResolver !== 'undefined') {
                    nameResolverClass = require(context.getContextConfiguration().nameResolver.jsObject);
                    isDefaultNameResolver = false;
                }
                else {
                    //Use default name resolver if none defined...
                    nameResolverClass = require("gw/NameResolver/DefaultNameResolver");
                    isDefaultNameResolver = true;
                }

                nameResolverImplementation = new nameResolverClass(context);

                var style = new FeatureStyle({
                    iconUrl: ctx.getMizarConfiguration().mizarBaseUrl + "css/images/target.png",
                    fillColor: [1, 1, 1, 1]
                });
                targetLayer = new VectorLayer({style: style, visible: true});

                mizarAPI.getActivatedContext().addDraw(targetLayer);

                // Update name resolver properties
                duration = isDefaultNameResolver ? 3000 : context.getContextConfiguration().nameResolver.duration;
                zoomFov = isDefaultNameResolver ? 15 : context.getContextConfiguration().nameResolver.zoomFov;

                ctx.subscribe("modifiedNavigation", removeTarget);
            }
        };

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('ReverseNameResolver/AbstractReverseNameResolver',[],
    function () {

        /**************************************************************************************************************/

        /**
         *   Abstract Wrapper constructor
         *   @param {Context} options - context
         *   @constructor
         *   @implements {ReverseNameResolver}
         */
        var AbstractReverseNameResolver = function (options) {
            this.ctx = options;
        };

        /**************************************************************************************************************/

        /**
         * @function handle
         * @memberOf AbstractReverseNameResolver#
         * @abstract
         */
        AbstractReverseNameResolver.prototype.handle = function () {
            throw new SyntaxError("handle from AbstractReverseNameResolver not implemented", "AbstractReverseNameResolver.js");
        };


        /**
         * @function remove
         * @memberOf AbstractReverseNameResolver#
         * @abstract
         */
        AbstractReverseNameResolver.prototype.remove = function () {
            throw new SyntaxError("remove from AbstractReverseNameResolver not implemented", "AbstractReverseNameResolver.js");
        };

        /**************************************************************************************************************/

        ///**
        // *    Extract HealpixId, order from url
        // */
        //AbstractReverseNameResolver.prototype.extractFilters = function (url) {
        //    var filtersUrl = url.substring(url.indexOf('?') + 1, url.length);
        //
        //    var filtersParts = filtersUrl.split('&');
        //
        //    var startOrder, startHealpixID;
        //    var order, healpixID;
        //    _.each(filtersParts, function (part) {
        //
        //        var keyAndValue = part.split('=');
        //
        //        if (keyAndValue[0] === "order") {
        //            order = keyAndValue[1];
        //        }
        //        if (keyAndValue[0] === "healpix") {
        //            healpixID = keyAndValue[1];
        //        }
        //    });
        //
        //    return this.filters = {
        //        "healpixID": healpixID,
        //        "order": order
        //    };
        //};

        return AbstractReverseNameResolver;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

/**
 * Reverse Name resolver module : API allowing to retrieve information from a geo picking
 * @module ReverseNameResolver
 * @implements {ReverseNameResolver}
 */
define('ReverseNameResolver/CDSReverseNameResolver',["jquery", "underscore-min", "../Utils/Constants","../Utils/Utils", "./AbstractReverseNameResolver", "../Tiling/HEALPixBase"],
    function ($, _, Constants, Utils, AbstractReverseNameResolver, HEALPixBase) {

        /**************************************************************************************************************/

        var HOUR_TO_DEG = 15.0;
        var lastCallTime = null;
        var callTimeInterval = 6000;

        /**
         * @name CDSReverseNameResolver
         * @class
         *   Plugin to access to CDS reverse name resolver
         * @augments AbstractReverseNameResolver
         * @param {Context} options - Context
         * @memberOf module:ReverseNameResolver
         */
        var CDSReverseNameResolver = function (options) {
            AbstractReverseNameResolver.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractReverseNameResolver, CDSReverseNameResolver);

        /**************************************************************************************************************/

        /**
         * Queries the CDS reverse name resolver
         * @function handle
         * @memberOf CDSReverseNameResolver#
         * @param {Object} options - parameters
         * @param {int} options.maxOrder - Max Hips order
         * @param {float[]} options.pos - position
         * @param {Mizar} options.mizarAPI - mizar API
         * @param {Function} options.error - error function
         * @param {Function} options.success - success function
         */
        CDSReverseNameResolver.prototype.handle = function (options) {
            //Do not call the service to often
            var now = Date.now();
            var diff = now - callTimeInterval;
            if (lastCallTime !== null && diff <= lastCallTime) {
                if (options && options.error) {
                    options.error({
                        status : 503
                    });
                }
                return;
            }

            var self = this;

            var maxOrder = options.maxOrder;
            var pos = options.pos;
            var mizarAPI = options.mizarAPI;
            pos = mizarAPI.getCrs().convert(pos, mizarAPI.getCrs().getGeoideName(), Constants.CRS.Equatorial);

            var equatorialCoordinates = [];
            mizarAPI.getCrs().getSexagesimalFromDeg(pos, equatorialCoordinates);

            // Format to equatorial coordinates
            equatorialCoordinates[0] = equatorialCoordinates[0].replace("h ", ":");
            equatorialCoordinates[0] = equatorialCoordinates[0].replace("m ", ":");
            equatorialCoordinates[0] = equatorialCoordinates[0].replace("s", "");

            equatorialCoordinates[1] = equatorialCoordinates[1].replace("° ", ":");
            equatorialCoordinates[1] = equatorialCoordinates[1].replace("' ", ":");
            equatorialCoordinates[1] = equatorialCoordinates[1].replace("\"", "");            

            //BEGINING OF SPECIFIC PROCESSING
            //DO IT WITHOUT REQUESTING SITOOLS
            /**
             * Arsec 2 degree conversion.
             */
            var ARCSEC_2_DEG = 1 / 3600.0;
            /**
             * MAX radius of a cone in arcsec.
             */
            var MAX_RADIUS = 1800.0;

            var nside = Math.pow(2, maxOrder);

            var pixRes = HEALPixBase.getPixRes(nside);
            var radius = (pixRes > MAX_RADIUS) ? MAX_RADIUS : pixRes / 2;
            radius *= ARCSEC_2_DEG;

            var requestUrl = mizarAPI.getActivatedContext().getContextConfiguration().reverseNameResolver.baseUrl;

            requestUrl = requestUrl.replace("{coordinates}", equatorialCoordinates[0] + " " + equatorialCoordinates[1]);
            requestUrl = requestUrl.replace("{radius}", radius);

            $.ajax({
                type: "GET",
                url: requestUrl,
                success: function (response) {
                    lastCallTime = Date.now();

                    // we parse the message that is returned by the server
                    var posParenthesis = response.indexOf('(');
                    var posComma = response.indexOf(',');
                    var posSlash = response.indexOf('/');
                    var position = response.substring(0, posSlash);
                    var name = response.substring(posSlash + 1, posParenthesis);

                    var magnitude = parseFloat(response.substring(posParenthesis + 1, posComma));
                    var objectType = response.substring(posComma + 1, response.length - 2);

                    var positionElts = position.split(" ");

                    //GET HMS
                    var hours = parseFloat(positionElts[0]);
                    var min = parseFloat(positionElts[1]);
                    var sec = parseFloat(positionElts[2]);

                    var degrees = parseFloat(positionElts[3]);
                    var min2 = parseFloat(positionElts[4]);
                    var sec2 = parseFloat(positionElts[5]);

                    var ra = self._parseRa(hours, min, sec);
                    var dec = self._parseDec(degrees, min2, sec2);

                    var features = {
                        totalResults: 1,
                        type: "FeatureCollection",
                        features: [{
                            type: "Feature",
                            geometry: {
                                coordinates: [ra, dec],
                                type: Constants.GEOMETRY.Point,
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                title: name,
                                magnitude: magnitude,
                                credits: "CDS",
                                seeAlso: "http://simbad.u-strasbg.fr/simbad/sim-id?Ident=" + name,
                                type: objectType,
                                identifier: name
                            }
                        }]
                    };

                    if (options && options.success) {
                        options.success(features);
                    }
                    //END OF SPECIFIC PROCESSING
                },
                error: function (xhr, ajaxOptions, thrownError) {
                    if (options && options.error) {
                        options.error(xhr);
                    }
                }
            });
        };

        /**
         * Parse RA.
         * @function _parseRa
         * @memberOf CDSReverseNameResolver#
         * @param hours
         * @param min
         * @param sec
         * @returns {number}
         * @private
         */
        CDSReverseNameResolver.prototype._parseRa = function (hours, min, sec) {
            var intHours = parseInt(hours, 10);
            var val = (sec / 60.0 + min) / 60.0;

            if (hours < 0.0 || parseFloat(hours) === -0.0) {
                val = hours - val;
                intHours = -intHours;
            } else {
                val = intHours + val;
            }
            return val * HOUR_TO_DEG;
        };

        /**
         * Parse dec
         * @function _parseDec
         * @memberOf CDSReverseNameResolver#
         * @param degrees
         * @param min
         * @param sec
         * @returns {number}
         * @private
         */
        CDSReverseNameResolver.prototype._parseDec = function (degrees, min, sec) {
            var intDegrees = parseInt(degrees, 10);

            var val = (sec / 60.0 + min) / 60.0;

            if (degrees < 0.0 || parseFloat(degrees) === -0.0) {
                val = degrees - val;
                intDegrees = -intDegrees;
            } else {
                val = intDegrees + val;
            }
            return val;
        };

        /**
         * @function remove
         * @memberOf CDSReverseNameResolver#
         */
        CDSReverseNameResolver.prototype.remove = function() {

        };

        /**************************************************************************************************************/

        return CDSReverseNameResolver;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('ReverseNameResolver/DefaultReverseNameResolver',["jquery", "underscore-min", "../Utils/Utils", "./AbstractReverseNameResolver"],
    function ($, _, Utils, AbstractReverseNameResolver) {

        /**************************************************************************************************************/

        /**
         * @name DefaultReverseNameResolver
         * @class
         *   Plugin to access to Default reverse name resolver
         * @augments AbstractReverseNameResolver
         * @param {Context} options - Context
         * @memberOf module:ReverseNameResolver
         */
        var DefaultReverseNameResolver = function (options) {
            AbstractReverseNameResolver.prototype.constructor.call(this, options);
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractReverseNameResolver, DefaultReverseNameResolver);

        /**************************************************************************************************************/

        /**
         * @function handle
         * @memberOf DefaultReverseNameResolver#
         * @param {Object} options
         */
        DefaultReverseNameResolver.prototype.handle = function (options) {
            var self = this;

            var maxOrder = options.maxOrder;
            var equatorialCoordinates = options.equatorialCoordinates;
            var context = options.context;

            var requestUrl = context.getMizarConfiguration().reverseNameResolver.baseUrl + '/EQUATORIAL/' + equatorialCoordinates[0] + " " + equatorialCoordinates[1] + ";" + maxOrder;

            $.ajax({
                type: "GET",
                url: requestUrl,
                success: function (response) {
                    if (options && options.success) {
                        options.success(response);
                    }
                },
                error: function (xhr, ajaxOptions, thrownError) {
                    if (options && options.error) {
                        options.error(xhr);
                    }
                }
            });
        };

        /**
         * @function remove
         * @memberOf DefaultReverseNameResolver#
         */
        DefaultReverseNameResolver.prototype.remove = function (options) {
        };

        /**************************************************************************************************************/

        return DefaultReverseNameResolver;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Name resolver module : search object name from its coordinates
 * TODO : move _handleMouseDown&Up to View ?
 */
define('ReverseNameResolver/ReverseNameResolver',["jquery", "../Utils/Constants",
        "./CDSReverseNameResolver","./DefaultReverseNameResolver"],
        function ($, Constants) {

    var mizarAPI;
    var context;

    var reverseNameResolverImplementation = null;

    return {
        init: function (m) {
            mizarAPI = m;
            this.setContext(mizarAPI.getActivatedContext());
        },

        /**************************************************************************************************************/

        /**
         *    Send request to reverse name resolver service for the given gepoint
         *    @param geoPick    Geographic position of point of interest
         *    @param options
         *        <li>success: Function called on success with the response of server as argument</li>
         *        <li>error: Function called on error with the xhr object as argument</li>
         *    @fires Mizar#plugin:not_found  
         */
        sendRequest: function (geoPick, options) {
            var self = this;
            // TODO: depending on context, send the request
            // Currently only sky context is handled
            if (mizarAPI.getActivatedContext().getMode() === Constants.CONTEXT.Sky) {
                // Find max order
                var maxOrder = 3;
                mizarAPI.getActivatedContext().getTileManager().visitTiles(function (tile) {
                    if (maxOrder < tile.order) {
                      maxOrder = tile.order;
                    }
                });

                options.maxOrder = maxOrder;
                options.pos = geoPick;
                options.mizarAPI = mizarAPI;

                if (reverseNameResolverImplementation) {
                    reverseNameResolverImplementation.handle(options);
                } else {
                    mizarAPI.publish("plugin:not_found", "No reserve name resolver found");
                }
                
            }
            else {
                console.error("Not implemented yet");
                if (options && options.error) {
                    options.error();
                }
            }
        },

        /**************************************************************************************************************/

        /**
         *    Set new context
         */
        setContext: function (ctx) {
            context = ctx;

            //instantiate reverse name resolver nameResolverImplementation object
            var reverseNameResolverClass;
            if (typeof context.getContextConfiguration().reverseNameResolver !== 'undefined') {
                reverseNameResolverClass = require(context.getContextConfiguration().reverseNameResolver.jsObject);
            }
            else {
                //Use default reverse name resolver if none defined...
                reverseNameResolverClass = require("gw/ReverseNameResolver/DefaultReverseNameResolver");
            }

            reverseNameResolverImplementation = new reverseNameResolverClass(context);
        }
    };

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Services/ServiceFactory',["../Utils/Constants", "../Services/FitsVisu", "../Services/HistogramCore",
        "../Services/ImageProcessingCore", "../Services/MeasureToolPlanetCore", "../Services/MeasureToolSkyCore",
        "../Services/MocBase", "../Services/MollweideViewerCore", "../Services/PickingManagerCore",
        "../Services/SampCore", "../Services/SelectionToolCore", "../Services/ExportToolCore",
        "../NameResolver/NameResolver", "../ReverseNameResolver/ReverseNameResolver"],
    function (Constants, FitsVisu, HistogramCore,
              ImageProcessingCore, MeasureToolPlanetCore, MeasureToolSkyCore,
              MocBase, MollweideViewerCore, PickingManagerCore,
              SampCore, SelectionToolCore, ExportToolCore,
              NameResolver, ReverseNameResolver) {

        return {

            create: function (serviceType, userOptions) {
                var obj;
                switch (serviceType) {
                    case Constants.SERVICE.FitsVisu:
                        obj =  FitsVisu;
                        break;
                    case Constants.SERVICE.Histogram:
                        obj = HistogramCore;
                        break;
                    case Constants.SERVICE.ImageProcessing:
                        obj = ImageProcessingCore;
                        break;
                    case Constants.SERVICE.MeasureToolPlanet:
                        obj = MeasureToolPlanetCore;
                        break;
                    case Constants.SERVICE.MeasureToolSky:
                        obj = MeasureToolSkyCore;
                        break;
                    case Constants.SERVICE.MocBase:
                        obj = MocBase;
                        break;
                    case Constants.SERVICE.MollweideViewer:
                        obj = MollweideViewerCore;
                        break;
                    case Constants.SERVICE.PickingManager:
                        obj = PickingManagerCore;
                        break;
                    case Constants.SERVICE.Samp:
                        obj = SampCore;
                        break;
                    case Constants.SERVICE.SelectionTool:
                        obj = new SelectionToolCore(userOptions);
                        break;
                    case Constants.SERVICE.NameResolver:
                        obj = NameResolver;
                        break;
                    case Constants.SERVICE.ReverseNameResolver:
                        obj = ReverseNameResolver;
                        break;
                    case Constants.SERVICE.ExportTool:
                        obj = ExportToolCore;
                        break;
                    default:
                        throw new RangeError("Cannot retrieve service " + serviceType, "ServiceFactory.js");

                }
                return obj;
            }
        }
    });


/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/AbstractTracker',["jquery"],
    function ($) {

        /**
         * @name AbstractTracker
         * @class
         *    Abstract class for tracker (position, elevation...)
         * @param {object} options
         * @constructor
         * @implements {Tracker}
         */
        var AbstractTracker = function (options) {
            this.options = options;
            this.globe = null;
            this.element = options.element;
            if (options.position) {
                $("#" + this.element).css(options.position, "2px");
            }
        };

        /**
         * @function _getGlobe
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype._getGlobe = function () {
            return this.globe;
        };

        /**
         * @function _setGlobe
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype._setGlobe = function (globe) {
            this.globe = globe;
        };

        AbstractTracker.prototype._getElement = function () {
            return this.element;
        };

        /**
         * @function update
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype.update = function (event) {
            throw new SyntaxError("update from AbstractTracker not implemented", "AbstractTracker.js");
        };

        /**
         * @function compute
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype.compute = function (geoPosition) {
            throw new SyntaxError("compute from AbstractTracker not implemented", "AbstractTracker.js");
        };

        /**
         * @function attachTo
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype.attachTo = function (globeContext) {
            this._setGlobe(globeContext);
            this._getGlobe().getRenderContext().canvas.addEventListener('mousemove', this.update);
            if (this.options.isMobile) {
                this._getGlobe().getRenderContext().canvas.addEventListener('touchmove', this.update);
            }
        };

        /**
         * @function detach
         * @memberOf AbstractTracker#
         */
        AbstractTracker.prototype.detach = function () {
            this._getGlobe().getRenderContext().canvas.removeEventListener('mousemove', this.update);
            if (this.options.isMobile) {
                this._getGlobe().getRenderContext().canvas.removeEventListener('touchmove', this.update);
            }
        };

        /**
         * @function destroy
         * @memberOf AbstractTracker#
         * @abstract
         */
        AbstractTracker.prototype.destroy = function () {
            this.element = null;
            this.options = null;
            this.globe = null;
        };


        return AbstractTracker;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Error dialog module
 */
define('Gui/dialog/CrsDialog',["jquery", "jquery.ui"], function ($) {

// The main div for error
    var crsInfo = '<div id="crsInfo" style="text-align: left" title="Coordinate Reference System information"></div>';

// Create the div, use jQuery UI dialog

    var $text = "";

    var $crsInfo = $(crsInfo)
        .appendTo('body')
        .dialog({
            autoOpen: false,
            width: 700,
            minHeight: 300,
            maxHeight: 500,
            dialogClass: 'crsBox'
            //beforeClose: function( event, ui ) { $text = ""; }
        });
    var $active = false;

    return {
        /**
         *    Open dialog
         *
         *    @param html HTML text
         */
        open: function (crs) {
            if(this.isActive) {
                this.destroy();
            }
            var geoBound = crs.getGeoBound();
            $text += "<p align='center'><u><i><b>" + crs.getName() + " CRS description </b></i></u></p>";
            $text += "<p align='justify'>" + crs.getDescription() + "</p>";
            $text += "<table>" +
                "<caption><i>Sphere parameters</i></caption>" +
                "<tr><th>Parameter</th><th>Value</th></tr>" +
                "<tr><td>Projection</td><td>"+(crs.isProjected() ? crs.getProjection().getName() : "3D") + "</td></tr>" +
                "<tr><td>radius (meters)</td><td>"+crs.getGeoide().getRealPlanetRadius()+"</td></tr>" +
                "<tr><td>"+crs.getLongitudeLabel()+"</td><td>["+geoBound.getWest()+"&deg; , "+geoBound.getEast() +"&deg;]</td></tr>" +
                "<tr><td>"+crs.getLatitudeLabel()+"</td><td>["+geoBound.getSouth()+"&deg; , "+geoBound.getNorth() +"&deg;]</td></tr>" +
                "</table>";
            $crsInfo.on('dialogclose', function (event) {
                $active = false;
            });
        },
        view: function () {
            $crsInfo
                .html($text)
                .dialog("open");

            $crsInfo.scrollTop(5000);
            $active = true;
        },
        hide: function () {
            $crsInfo.dialog("close");
            $active = false;
        },
        isActive: function () {
            return $active;
        },
        destroy : function() {
            this.hide();
            $text = "";
            $active = false;
        }

    };

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/PositionTracker',["jquery", "./AbstractTracker", "../dialog/CrsDialog","../../Utils/Utils"],
    function ($, AbstractTracker, CrsDialog, Utils) {

        var self;
        /**
         * Position tracker configuration
         * @typedef {Object} AbstractTracker.position_configuration
         * @property {string} element - tracker div element
         * @property {string} position - tracker position in the GUI
         * @property {boolean} [isMobile = false] - Mobile device         
         */

        /**
         * @name PositionTracker
         * @class
         *    PositionTracker constructor
         * @augments AbstractTracker
         * @param {AbstractTracker.position_configuration} options - Position tracker configuration
         * @constructor
         */
        var PositionTracker = function (options) {
            AbstractTracker.prototype.constructor.call(this, options);
        };
        /**************************************************************************************************************/

        Utils.inherits(AbstractTracker, PositionTracker);

        /**************************************************************************************************************/

        PositionTracker.prototype._updateTracker = function(tracker) {
            self = tracker;
            CrsDialog.open(tracker._getGlobe().getCoordinateSystem());
        };

        /**
         * Update the tracker
         * @function update
         * @memberOf PositionTracker#
         * @param {object} event
         */
        PositionTracker.prototype.update = function (event) {
            if (event.type.search("touch") >= 0) {
                event.clientX = event.changedTouches[0].clientX;
                event.clientY = event.changedTouches[0].clientY;
            }

            if (document.getElementById(self._getElement())) {
                var $crsInfo = $("#" + self._getElement()+"Info");
                var geoPos = self._getGlobe().getLonLatFromPixel(event.clientX, event.clientY);
                if (geoPos) {
                    var astro = self.compute([geoPos[0], geoPos[1]]);
                    document.getElementById(self._getElement()).innerHTML = astro[0] + " x " + astro[1];
                    if( $crsInfo.css('display') == 'none' ){
                        $crsInfo.show();
                    }
                } else {
                    document.getElementById(self._getElement()).innerHTML = "";
                    if( $crsInfo.css('display') != 'none' ){
                        $crsInfo.hide();
                    }
                }
            }
        };

        /**
         * Compute position from a specific point
         * @function compute
         * @memberOf PositionTracker#
         * @param geoPosition
         * @returns {number} coordinates
         */
        PositionTracker.prototype.compute = function (geoPosition) {
            return this._getGlobe().getCoordinateSystem().formatCoordinates([geoPosition[0], geoPosition[1]]);
        };

        /**
         * @function attachTo
         * @memberOf PositionTracker#
         */
        PositionTracker.prototype.attachTo = function (globeContext) {
            AbstractTracker.prototype.attachTo.call(this, globeContext);
            CrsDialog.open(globeContext.getCoordinateSystem());
            $('#posTrackerInfoButton').on('click', function () {
                if (CrsDialog.isActive() === true) {
                    CrsDialog.hide();
                } else {
                    CrsDialog.view();
                }
            });
            self = this;
        };

        /**
         * @function detach
         * @memberOf PositionTracker#
         */
        PositionTracker.prototype.detach = function () {
            AbstractTracker.prototype.detach.call(this);
            $("#posTrackerInfoButton").off("click");
            CrsDialog.destroy();
        };

        /**
         * Destroy the elevation tracker.
         * @function destroy
         * @memberOf AbstractTracker.prototype
         */
        PositionTracker.prototype.destroy = function() {
            this.detach(this);
            //AbstractTracker.prototype.destroy.call(this);
        };


        /**************************************************************************************************************/

        return PositionTracker;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with SITools2. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Gui/Tracker/ElevationTracker',["jquery", "./AbstractTracker", "../../Utils/Utils", "../../Utils/Numeric"],
    function ($, AbstractTracker, Utils, Numeric) {

        var self;

        /**
         * Elevation tracker configuration
         * @typedef {AbstractTracker.position_configuration} AbstractTracker.elevation_configuration
         * @property {Layer} [elevationLayer] - elevationLayer
         */

        /**
         * @name ElevationTracker
         * @class
         *   ElevationTracker context constructor
         * @augments AbstractTracker
         * @param {AbstractTracker.elevation_configuration} options - Elevation tracker configuration
         * @constructor
         */
        var ElevationTracker = function (options) {
            AbstractTracker.prototype.constructor.call(this, options);
            this.scale = null;
            if (options.elevationLayer !== null && options.elevationLayer !== undefined) {
                this.scale = options.elevationLayer.hasOwnProperty('scale') ? options.elevationLayer.scale : 1;
            }

        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractTracker, ElevationTracker);

        /**************************************************************************************************************/

        /**
         * Sets the scale layer taken from the elevationLayer
         * @param elevationLayer
         */
        ElevationTracker.prototype.setScaleLayer = function (elevationLayer) {
            this.scale = elevationLayer.hasOwnProperty('scale') ? elevationLayer.scale : 1;
        };

        /**
         * Update the tracker
         * @function update
         * @memberof AbstractTracker.prototype
         * @param {object} event
         */
        ElevationTracker.prototype.update = function (event) {
            if (event.type.search("touch") >= 0) {
                event.clientX = event.changedTouches[0].clientX;
                event.clientY = event.changedTouches[0].clientY;
            }
            if (document.getElementById(self._getElement())) {
                var geoPos = self._getGlobe().getLonLatFromPixel(event.clientX, event.clientY);
                if (geoPos && self.scale) {
                    var elevation = self.compute([geoPos[0], geoPos[1]]);
                    document.getElementById(self._getElement()).innerHTML = "Elevation : " + Numeric.roundNumber(elevation / self.scale, 0) + " meters";
                } else {
                    document.getElementById(self._getElement()).innerHTML = "";
                }
            }

        };

        /**************************************************************************************************************/

        /**
         * Compute elevation from a specific point
         * @function compute
         * @memberOf AbstractTracker.prototype
         * @param geoPosition
         * @returns {number} elevation
         */
        ElevationTracker.prototype.compute = function (geoPosition) {
            return this._getGlobe().getElevation(geoPosition[0], geoPosition[1]);
        };

        /**
         * @function attachTo
         * @memberOf ElevationTracker#
         */
        ElevationTracker.prototype.attachTo = function (globeContext) {
            AbstractTracker.prototype.attachTo.call(this, globeContext);
            self = this;
        };

        /**
         * @function detach
         * @memberOf ElevationTracker#
         */
        ElevationTracker.prototype.detach = function () {
            AbstractTracker.prototype.detach.call(this);
        };

        /**
         * Destroy the elevation tracker.
         * @function destroy
         * @memberOf AbstractTracker.prototype
         */
        ElevationTracker.prototype.destroy = function() {
            this.detach.call(this);
            AbstractTracker.prototype.destroy.call(this);
            this.scale = null;
        };

        /**************************************************************************************************************/

        return ElevationTracker;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/AttributionHandler',[],function () {
  /**
    @name AttributionHandler
    @class
    Manage the attributions
    @param {Globe} globe Globe
    @param options Configuration properties
    <ul>
    <li>element : the HTML element to show attributions, can be a string (the ID) or the DOM element itself</li>
    </ul>
  */
    var AttributionHandler = function (globe, options) {

		// Search for the element to use
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
            }
            else {
                this.element = elt;
            }
        }

		// Only add the attribution handler to the globe if element is not null
		if (this.element) {
			 globe.attributionHandler = this;
		}
    };

     /**
      * Remove attribution from HTML
      * @function removeAttribution
      * @memberOf AttributionHandler.prototype
      * @param {Layer} layer Layer
      */
    AttributionHandler.prototype.removeAttribution = function (layer) {
        var div = document.getElementById(this.element.id + "_" + layer.id);
        if (div) {
            this.element.removeChild(div);
        }
    };

     /**
      * Add attribution in HTML
      * @function addAttribution
      * @memberOf AttributionHandler.prototype
      * @param {Layer} layer Layer
      */
    AttributionHandler.prototype.addAttribution = function (layer) {
        var div = document.createElement('div');

        var attribution;
        var title = (layer.ack !== undefined) ? layer.ack : "";
        if (layer.copyrightUrl !== "" && layer.copyrightUrl !== undefined) {
            attribution = '<a class="whiteLink" href="' + layer.copyrightUrl  + '" target="_blank" title="'+ title +'">' + layer.attribution + '</a>';
        } else {
            attribution = layer.attribution;
        }

        div.innerHTML = attribution;
        div.id = this.element.id + "_" + layer.id;

        if (layer.id === 0) {
            // Background layer
            this.element.insertBefore(div, this.element.firstChild);
        }
        else {
            this.element.appendChild(div);
        }
    };

     /**
      * Toggle attribution
      * @function toggleAttribution
      * @memberOf AttributionHandler.prototype
      * @param {Layer} layer Layer
      */
    AttributionHandler.prototype.toggleAttribution = function (layer) {
        var div = document.getElementById(this.element.id + "_" + layer.id);
        if (div) {
            this.removeAttribution(layer);
        }
        else {
            this.addAttribution(layer);
        }
    };

    /**************************************************************************************************************/

    return AttributionHandler;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/VectorRenderer',['./RendererTileData','../Tiling/Tile'],
	function(RendererTileData, Tile) {

/**************************************************************************************************************/

/**
  @name VectorRenderer
  @class
	  VectorRenderer constructor
  @param {AbstractGlobe} globe AbstractGlobe
  @constructor
  */
var VectorRenderer = function(globe)
{
	this.tileManager = globe.tileManager;
	this.globe = globe;
	this.buckets = [];
	this.maxTilePerGeometry = 100;
	this.levelZeroTiledGeometries = [];
};

/**************************************************************************************************************/

/**
 * Find a compatible bucket
 * @function findBucket
 * @memberof VectorRenderer.prototype
 * @param layer
 * @param style
 * @return {Bucket} Bucket
 */
VectorRenderer.prototype.findBucket = function(layer,style)
{
	// Find an existing bucket for the given style
	for ( var i = 0; i < this.buckets.length; i++ )
	{
		var bucket = this.buckets[i];
		if ( bucket.layer === layer &&
			bucket.isCompatible(style) )
		{
			return bucket;
		}
	}

	return null;
};


/**************************************************************************************************************/

/**
 * Generate the level zero for a tile
 * @function generateLevelZero
 * @memberof VectorRenderer.prototype
 * @param {Tile} tile Tile
 */
VectorRenderer.prototype.generateLevelZero = function(tile)
{
	for ( var i=0; i < this.levelZeroTiledGeometries.length; i++ )
	{
		var geometry = this.levelZeroTiledGeometries[i];

		// Check that the geometry is on this tile
		var isFound = false;
		for ( var n = 0; n < geometry._tileIndices.length && !isFound; n++ )
		{
			var t = this.tileManager.level0Tiles[ geometry._tileIndices[n] ];
			isFound = ( t === tile );
		}

		// Found the tile, so add it
		if ( isFound )
		{
			this._addGeometryToTile(geometry._bucket, geometry, tile);
		}
	}
};

/**************************************************************************************************************/

/**
 * Recursively add a geometry to a tile
 * @function _recursiveAddGeometryToTile
 * @memberof VectorRenderer.prototype
 * @param {Bucket} bucket Bucket
 * @param geometry
 * @param {Tile} tile Tile
 * @private
*/
VectorRenderer.prototype._recursiveAddGeometryToTile = function(bucket, geometry, tile)
{
	var renderable = this._addGeometryToTile(bucket, geometry, tile);

	if ( renderable && renderable.generateChild && tile.children)
	{
		for ( var i = 0; i < 4; i++ )
		{
			if ( tile.children[i].state === Tile.State.LOADED )
			{
				renderable.hasChildren = true;
				this._recursiveAddGeometryToTile( bucket, geometry, tile.children[i] );
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Add a geometry to a vector renderer
 * @function addGeometry
 * @memberof VectorRenderer.prototype
 * @param layer
 * @param geometry
 * @param style
 */
VectorRenderer.prototype.addGeometry = function(layer, geometry, style)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;

	var tileIndices = this.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null;
	if ( tileIndices && tileIndices.length < this.maxTilePerGeometry )
	{
		// Add geometry to each tile in range
		for ( var i=0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			if ( tile && (tile.state === Tile.State.LOADED) )
			{
				this._recursiveAddGeometryToTile(bucket, geometry, tile);
			}
		}

		geometry._tileIndices = tileIndices;
		this.levelZeroTiledGeometries.push(geometry);
	}
	else
	{
		// Attach to mainRenderable
		if (!bucket.mainRenderable)
		{
			bucket.mainRenderable = bucket.createRenderable();
		}
		bucket.mainRenderable.add(geometry);
	}
};

/**************************************************************************************************************/

/**
 * Remove a geometry from a vector renderer
 * @function removeGeometry
 * @memberof VectorRenderer.prototype
 * @param geometry
 */
VectorRenderer.prototype.removeGeometry = function(geometry)
{
	var tileIndices = geometry._tileIndices;

	if ( tileIndices )
	{
		// Remove from tile
		for ( var i = 0; i < tileIndices.length; i++ )
		{
			var tile = this.tileManager.level0Tiles[ tileIndices[i] ];
			this.removeGeometryFromTile(geometry, tile);
		}
		// Remove from geometry arrays
		this.levelZeroTiledGeometries.splice( this.levelZeroTiledGeometries.indexOf(geometry), 1 );

		 geometry._tileIndices = null;
	}
	else
	{
		var bucket = geometry._bucket;
		if ( bucket.mainRenderable )
		{
			var numGeometries = bucket.mainRenderable.remove(geometry);
			if ( numGeometries === 0 )
			{
				bucket.mainRenderable.dispose(this.renderContext);
				bucket.mainRenderable = null;
			}
		}
	}
};

/**************************************************************************************************************/

/**
 * Get or create a bucket for the given configuration
 * @function getOrCreateBucket
 * @memberof VectorRenderer.prototype
 * @param layer
 * @param geometry
 * @param style
 * @return {Bucket} Bucket
 */
VectorRenderer.prototype.getOrCreateBucket = function(layer, geometry, style )
{
	// Then find an existing bucket
	var bucket = this.findBucket(layer,style);
	if (!bucket)
	{
		bucket = this.createBucket(layer,style);
		bucket.renderer = this;
		bucket.id = this.globe.vectorRendererManager.bucketId++;
		this.buckets.push( bucket );
	}
	return bucket;
};

/**************************************************************************************************************/

/**
 * Add a geometry to a tile
 * @function addGeometryToTile
 * @memberof VectorRenderer.prototype
 * @param layer
 * @param geometry
 * @param style
 * @param {Tile} tile Tile
 */
VectorRenderer.prototype.addGeometryToTile = function(layer, geometry, style, tile)
{
	var bucket = this.getOrCreateBucket(layer, geometry, style);
	geometry._bucket = bucket;
	return this._addGeometryToTile( bucket, geometry, tile );
};

/**************************************************************************************************************/

/**
 * Internal method to add a geometry to a tile
 * @function _addGeometryToTile
 * @memberof VectorRenderer.prototype
 * @param {Bucket} bucket Bucket
 * @param geometry
 * @param {Tile} tile Tile
 * @private
 */
VectorRenderer.prototype._addGeometryToTile = function(bucket, geometry, tile)
{
	var tileData = tile.extension.renderer;
	if (!tileData)
	{
		tileData = tile.extension.renderer = new RendererTileData(this.globe.vectorRendererManager);
	}

	var renderable = tileData.getRenderable(bucket);
	var needsToAdd = false;
	if (!renderable)
	{
		renderable = bucket.createRenderable();
		needsToAdd = true;
	}
	if ( renderable.add(geometry, tile) )
	{
		if (needsToAdd)
		{
			tileData.renderables.push(renderable);
		}
		return renderable;
	}

	return null;
};

/**************************************************************************************************************/

/**
 * Remove a geometry from a tile
 * @function removeGeometryFromTile
 * @memberof VectorRenderer.prototype
 * @param geometry
 * @param {Tile} tile Tile
 */
VectorRenderer.prototype.removeGeometryFromTile = function(geometry,tile)
{
	var tileData = null;
	if (tile && tile.extension) {
		tileData = tile.extension.renderer;
	}
	if (tileData)
	{
		var i = 0;
		while ( i < tileData.renderables.length )
		{
			var renderable = tileData.renderables[i];
			var renderer = renderable.bucket.renderer;
			if ( renderer === this )
			{
				// Remove renderable
				var numGeometries = renderable.remove(geometry);
				if ( numGeometries === 0 )
				{
					tileData.renderables.splice(i,1);
				}
				else
				{
					i++;
				}

				// Remove geoemtry from children if needed
				if ( renderable.hasChildren && tile.children)
				{
					for ( var n = 0; n < 4; n++ )
					{
						if ( tile.children[n].state === Tile.State.LOADED )
						{
							this.removeGeometryFromTile( geometry, tile.children[n] );
						}
					}
				}
			}
			else
			{
				i++;
			}
		}
	}
};

/**************************************************************************************************************/

return VectorRenderer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/PointRenderer',['../Utils/Utils', '../Utils/Constants', './VectorRenderer', './VectorRendererManager', './FeatureStyle', './Program', './GeoBound'],
    function (Utils, Constants, VectorRenderer, VectorRendererManager, FeatureStyle, Program, GeoBound) {

        /**************************************************************************************************************/

        /**
         Basic module to generate texture from text
         */
        var Text = (function () {
            var fontSize = 18;
            var margin = 1;
            var canvas2d = null;

            var initialize = function () {
                canvas2d = document.createElement("canvas");
                canvas2d.width = 512;
                canvas2d.height = fontSize + 2 * margin;
            };

            var generateImageData = function (text, textColor) {
                if (!canvas2d) {
                    initialize();
                }

                var fillColor = textColor;
                if (!fillColor) {
                    fillColor = '#fff';
                } else {
                    if (fillColor instanceof Array) {
                        fillColor = FeatureStyle.fromColorToString(textColor);
                    }
                }

                var ctx = canvas2d.getContext("2d");
                ctx.clearRect(0, 0, canvas2d.width, canvas2d.height);
                ctx.fillStyle = fillColor;
                ctx.font = fontSize + 'px sans-serif';
                ctx.textBaseline = 'top';
                ctx.shadowColor = '#000';
                ctx.shadowOffsetX = 1;
                ctx.shadowOffsetY = 1;
                ctx.shadowBlur = 2;
                ctx.fillText(text, margin, margin);
                //ctx.lineWidth = 1.0;
                //ctx.strokeText(text, margin, margin);

                var metrics = ctx.measureText(text);
                return ctx.getImageData(0, 0, Math.floor(metrics.width) + 2 * margin, canvas2d.height);
            };


            return {generateImageData: generateImageData};
        })();

        /**************************************************************************************************************/

        /**
         @name PointRenderer
         @class
             POI Renderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
        var PointRenderer = function (globe) {
            VectorRenderer.prototype.constructor.call(this, globe);

            // Store object for rendering
            this.renderContext = globe.tileManager.renderContext;
            this.tileConfig = globe.tileManager.tileConfig;

            // For stats
            this.numberOfRenderPoints = 0;

            var vertexShader = "attribute vec3 vertex; // vertex have z = 0, spans in x,y from -0.5 to 0.5 \n";
            vertexShader += "uniform mat4 viewProjectionMatrix; \n";
            vertexShader += "uniform vec3 poiPosition; // world position \n";
            vertexShader += "uniform vec2 poiScale; // x,y scale \n";
            vertexShader += "uniform vec2 tst; \n";
            vertexShader += "\n";
            vertexShader += "varying vec2 texCoord; \n";
            vertexShader += "\n";
            vertexShader += "void main(void)  \n";
            vertexShader += "{ \n";
            vertexShader += "	// Generate texture coordinates, input vertex goes from -0.5 to 0.5 (on x,y) \n";
            vertexShader += "	texCoord = vertex.xy + vec2(0.5) + tst; \n";
            vertexShader += "	// Invert y \n";
            vertexShader += "	texCoord.y = 1.0 - texCoord.y; \n";
            vertexShader += "	\n";
            vertexShader += "	// Compute poi position in clip coordinate \n";
            vertexShader += "	gl_Position = viewProjectionMatrix * vec4(poiPosition, 1.0); \n";
            vertexShader += "	gl_Position.xy += vertex.xy * gl_Position.w * poiScale; \n";
            vertexShader += "} \n";

            var fragmentShader = "precision lowp float; \n";
            fragmentShader += "varying vec2 texCoord; \n";
            fragmentShader += "uniform sampler2D texture; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "\n";
            fragmentShader += "void main(void) \n";
            fragmentShader += "{ \n";
            fragmentShader += "	vec4 textureColor = texture2D(texture, texCoord); \n";
            fragmentShader += "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
            fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
            fragmentShader += "} \n";

            this.program = new Program(this.renderContext);
            this.program.createFromSource(vertexShader, fragmentShader);

            var vertices = new Float32Array([-0.5, -0.5, 0.0,
                0.5, -0.5, 0.0,
                0.5, 0.5, 0.0,
                -0.5, 0.5, 0.0]);

            var gl = this.renderContext.gl;
            this.vertexBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            this.defaultTexture = null;
        };

        Utils.inherits(VectorRenderer, PointRenderer);

        /**************************************************************************************************************/

        /**
         * Build a default texture
         * @function _buildDefaultTexture
         * @memberof PointRenderer.prototype
         * @param {Bucket} bucket Bucket
         * @private
         */
        PointRenderer.prototype._buildDefaultTexture = function (bucket) {
            if (!this.defaultTexture) {
                var gl = this.renderContext.gl;
                this.defaultTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
                var whitePixel = new Uint8Array([255, 255, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
            }

            bucket.texture = this.defaultTexture;
            bucket.textureWidth = 10;
            bucket.textureHeight = 10;
        };

        /**************************************************************************************************************/
        /**
         * Build a texture from an image and store in a bucket
         * @function _buildTextureFromImage
         * @memberof PointRenderer.prototype
         * @param {Bucket} bucket Bucket
         * @param image
         * @private
         */
        PointRenderer.prototype._buildTextureFromImage = function (bucket, image) {
            bucket.texture = this.renderContext.createNonPowerOfTwoTextureFromImage(image);
            bucket.textureWidth = image.width;
            bucket.textureHeight = image.height;
        };

        /**************************************************************************************************************/

        /**
         @name PointRenderable
         @class
             Renderable constructor for Point
         @param {Bucket} bucket Bucket
         @constructor
         */
        var PointRenderable = function (bucket) {
            this.bucket = bucket;
            this.points = [];
        };

        /**************************************************************************************************************/

        /**
         * Add a geometry to the renderable
         * @function add
         * @memberOf PointRenderable.prototype
         * @param geometry
         * @return {Boolean} If the geometry has been successfully added to the renderable
         */
        PointRenderable.prototype.add = function (geometry) {
            // TODO: Find a better way to access to coordinate system
            var coordinateSystem = this.bucket.layer.globe.getCoordinateSystem();
            var posGeo = geometry.coordinates;

            posGeo = coordinateSystem.convert(posGeo, geometry.crs.properties.name, coordinateSystem.getGeoideName());

            var csBound = new GeoBound(coordinateSystem.getGeoBound().getWest(), coordinateSystem.getGeoBound().getSouth(), coordinateSystem.getGeoBound().getEast(), coordinateSystem.getGeoBound().getNorth());

            if (csBound.isPointInside(posGeo)) {
                var pos3d = coordinateSystem.get3DFromWorld(posGeo);
                var vertical = coordinateSystem.getVerticalAt3D(pos3d);

                this.points.push({
                    pos3d: pos3d,
                    vertical: vertical,
                    geometry: geometry
                });

                return true;
            } else {
                return false;
            }
        };

        /**************************************************************************************************************/

        /**
         * Remove a geometry from the renderable
         * @function remove
         * @memberof PointRenderable.prototype
         * @param geometry
         * @return {Integer} Number of points after remove
         */
        PointRenderable.prototype.remove = function (geometry) {
            for (var j = 0; j < this.points.length; j++) {
                if (this.points[j].geometry === geometry) {
                    this.points.splice(j, 1);
                    return this.points.length;
                }
            }
            return this.points.length;
        };

        /**************************************************************************************************************/

        /**
         * Dispose the renderable
         * @function dispose
         * @memberof PointRenderable.prototype
         * @param renderContext
         */
        PointRenderable.prototype.dispose = function (renderContext) {
            // Nothing to do
        };


        /**************************************************************************************************************/

        /**
         @name PointBucket
         @class
             Bucket constructor for PointRenderer
         @param layer
         @param style
         @constructor
         */
        var PointBucket = function (layer, style) {
            this.layer = layer;
            this.style = new FeatureStyle(style);
            this.renderer = null;
            this.texture = null;
        };

        /**************************************************************************************************************/

        /**
         * Create a renderable for this bucket
         * @function createRenderable
         * @memberof PointBucket.prototype
         * @return {PointRenderable} Renderable
         */
        PointBucket.prototype.createRenderable = function () {
            return new PointRenderable(this);
        };

        /**************************************************************************************************************/

        /**
         * Check if a bucket is compatible
         * @function isCompatible
         * @memberof PointBucket.prototype
         * @param style
         * @return {Boolean} Is compatible ?
         */
        PointBucket.prototype.isCompatible = function (style) {
            return this.style.iconUrl === style.iconUrl &&
                this.style.icon === style.icon &&
                this.style.label === style.label;
        };

        /**************************************************************************************************************/

        /**
         * Create bucket to render a point
         * @function createBucket
         * @memberof PointRenderer.prototype
         * @param layer
         * @param style
         * @return {PointBucket} Bucket
         */
        PointRenderer.prototype.createBucket = function (layer, style) {
            // Create a bucket
            var bucket = new PointBucket(layer, style);

            // Initialize bucket : create the texture
            if (style.label) {
                var imageData = Text.generateImageData(style.label, style.textColor);
                this._buildTextureFromImage(bucket, imageData);
            }
            else if (style.iconUrl) {
                var image = new Image();
                image.crossOrigin = '';
                var self = this;
                image.onload = function () {
                    self._buildTextureFromImage(bucket, image);
                    self.renderContext.requestFrame();
                };
                image.onerror = function () {
                    self._buildDefaultTexture(bucket);
                };
                image.src = style.iconUrl;
            }
            else if (style.icon) {
                this._buildTextureFromImage(bucket, style.icon);
            }
            else {
                this._buildDefaultTexture(bucket);
            }

            return bucket;
        };

        /**************************************************************************************************************/

        /**
         * Render all the POIs
         * @function render
         * @memberof PointRenderer.prototype
         * @param renderables
         * @param {Integer} start Start index
         * @param {Integer} end End index
         */
        PointRenderer.prototype.render = function (renderables, start, end) {
            this.numberOfRenderPoints = 0;

            var renderContext = this.renderContext;
            var gl = this.renderContext.gl;
            // TODO
            //var level = renderContext.renderers[0].tileManager.visibleTiles[0].level;
            //if(level < 5) {
            //    return;
            //}
            // end todo

            // Setup states
            // gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Setup program
            this.program.apply();

            // The shader only needs the viewProjection matrix, use modelViewMatrix as a temporary storage
            mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
            gl.uniformMatrix4fv(this.program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
            gl.uniform1i(this.program.uniforms.texture, 0);

            // Compute eye direction from inverse view matrix
            mat4.inverse(renderContext.viewMatrix, renderContext.modelViewMatrix);
            var camZ = [renderContext.modelViewMatrix[8], renderContext.modelViewMatrix[9], renderContext.modelViewMatrix[10]];
            vec3.normalize(camZ);
            vec3.scale(camZ, this.tileConfig.cullSign, camZ);

            // Compute pixel size vector to offset the points from the earth
            var pixelSizeVector = renderContext.computePixelSizeVector();

            // Warning : use quoted strings to access properties of the attributes, to work correclty in advanced mode with closure compiler
            gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
            gl.vertexAttribPointer(this.program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);
            var scale;
            var currentBucket = null;
            for (var n = start; n < end; n++) {
                var renderable = renderables[n];
                var bucket = renderable.bucket;

                if (renderable.points.length === 0) {
                    continue;
                }

                if (bucket !== currentBucket) {
                    // Bind point texture
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                    // 2.0 * because normalized device coordinates goes from -1 to 1
                    scale = [2.0 * bucket.textureWidth / renderContext.canvas.width,
                        2.0 * bucket.textureHeight / renderContext.canvas.height];
                    gl.uniform2fv(this.program.uniforms.poiScale, scale);
                    gl.uniform2fv(this.program.uniforms.tst, [0.5 / (bucket.textureWidth), 0.5 / (bucket.textureHeight)]);
                }

                for (var i = 0; i < renderable.points.length; i++) {
                    // Poi culling
                    var worldPoi = renderable.points[i].pos3d;
                    var poiVec = renderable.points[i].vertical;
                    scale = bucket.textureHeight * ( pixelSizeVector[0] * worldPoi[0] + pixelSizeVector[1] * worldPoi[1] + pixelSizeVector[2] * worldPoi[2] + pixelSizeVector[3] );
                    scale *= this.tileConfig.cullSign;
                    var scaleInKm = (scale / this.globe.getCoordinateSystem().getGeoide().getHeightScale()) * 0.001;
                    if (scaleInKm > bucket.style.pointMaxSize) {
                        continue;
                    }

                    if (vec3.dot(poiVec, camZ) > 0 &&
                        renderContext.worldFrustum.containsSphere(worldPoi, scale) >= 0) {
                        var x = poiVec[0] * scale + worldPoi[0];
                        var y = poiVec[1] * scale + worldPoi[1];
                        var z = poiVec[2] * scale + worldPoi[2];

                        gl.uniform3f(this.program.uniforms.poiPosition, x, y, z);
                        gl.uniform1f(this.program.uniforms.alpha, bucket.layer.opacity);
                        var color = bucket.style.fillColor;
                        gl.uniform3f(this.program.uniforms.color, color[0], color[1], color[2]);

                        gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);

                        this.numberOfRenderPoints++;
                    }
                }
            }

//    gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
        };

        /**************************************************************************************************************/

        /**
         * Check if renderer is applicable
         * @function canApply
         * @memberof PointRenderer.prototype
         * @param type
         * @param style
         * @return {Boolean} Can apply ?
         */
        PointRenderer.prototype.canApply = function (type, style) {

            return ( (type === Constants.GEOMETRY.Point) && (style.iconUrl === null) );
        };

        /**************************************************************************************************************/

// Register the renderer
        VectorRendererManager.factory.push(function (globe) {
            return new PointRenderer(globe);
        });

        return PointRenderer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/BatchRenderable',[],function() {
/**
 @name BatchRenderable
 @class
  Base renderable
 @constructor
 */
var BatchRenderable = function( bucket )
{
	this.bucket = bucket;
 	this.vertexBuffer = null;
 	this.indexBuffer = null;
	this.vertices = [];
	this.triIndices = [];
	this.lineIndices = [];
	this.geometryInfos = [];
	this.bufferDirty = true;
	this.vertexSize = 3;
	this.indexType = 0;
	this.vertexBufferShared = false;
};

 /**
   Remove a geometry from the renderable
   @function remove
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
 */
BatchRenderable.prototype.remove = function( geometry )
{
	var fiIndex = -1;

	// Find the feature
	var vertexIt = 0;
	var lineIndexIt = 0;
	var triIndexIt = 0;
  var n;
	for ( var i = 0; i < this.geometryInfos.length; i++ )
	{
		var fi = this.geometryInfos[i];
		if ( fi.geometry === geometry )
		{
			// Remove feature from vertex and index buffer
			this.vertices.splice( vertexIt, fi.vertexCount );
			this.lineIndices.splice( lineIndexIt, fi.lineIndexCount );
			this.triIndices.splice( triIndexIt, fi.triIndexCount );

			// Update index buffer
			var vertexOffset = fi.vertexCount / this.vertexSize;
			for ( n = lineIndexIt; n < this.lineIndices.length; n++ )
			{
				this.lineIndices[n] -= vertexOffset;
			}
			for ( n = triIndexIt; n < this.triIndices.length; n++ )
			{
				this.triIndices[n] -= vertexOffset;
			}
			fiIndex = i;

			break;
		}

		vertexIt += fi.vertexCount;
		lineIndexIt += fi.lineIndexCount;
		triIndexIt += fi.triIndexCount;
	}

	if ( fiIndex >= 0 )
	{
		this.bufferDirty = true;

		// Remove the feature from the infos array
		this.geometryInfos.splice( fiIndex, 1 );

		return this.vertices.length;
	}
	else
	{
		return this.vertices.length;
	}
};

 /**
   Add a feature to the renderable
   @function add
   @memberof BatchRenderable.prototype
   @param {JSON} geometry Geometry
   @param {?} tile Tile
 */
BatchRenderable.prototype.add = function( geometry, tile )
{
	this.tile = tile;

	// Store previous number of vertices/indices needed for "after-build" computation
	var numVertices = this.vertices.length;
	var numLineIndices = this.lineIndices.length;
	var numTriIndices = this.triIndices.length;

	var geometryInTile = this.build( geometry, tile );
	if ( geometryInTile )
	{
		this.geometryInfos.push({
			geometry: geometry,
			vertexCount: this.vertices.length - numVertices,
			lineIndexCount: this.lineIndices.length - numLineIndices,
			triIndexCount: this.triIndices.length - numTriIndices
		});
		this.bufferDirty = true;

		return true;
	}
	else
	{
		// Feature not in the tile
		return false;
	}
};

 /**
   Dispose graphics data
   @function dispose
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
BatchRenderable.prototype.dispose = function(renderContext)
{
	var gl = renderContext.gl;

	if ( this.indexBuffer ) {
		gl.deleteBuffer(this.indexBuffer);
	}
	this.indexBuffer = null;
	if ( this.vertexBuffer && !this.vertexBufferShared)
	{
		gl.deleteBuffer(this.vertexBuffer);
		this.vertexBuffer = null;
	}
};

 /**
   Must be call before rendering
   @function bindBuffers
   @memberof BatchRenderable.prototype
   @param {renderContext} renderContext Render context
 */
BatchRenderable.prototype.bindBuffers = function(renderContext)
{
	var gl = renderContext.gl;

	if ( this.bufferDirty )
	{
		this.dispose(renderContext);

		// Create vertex buffer if needed
		if (this.vertexBuffer)
		{
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		}
		else
		{
			this.vertexBuffer = gl.createBuffer();
			gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
			gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( this.vertices ), gl.STATIC_DRAW);
		}

		// Create index buffer
		this.indexBuffer = gl.createBuffer();
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);

		var indices = this.triIndices;
		if ( this.triIndices.length > 0  )
		{
			if (this.lineIndices.length > 0) {
				indices = this.triIndices.concat(this.lineIndices);
			} else {
				indices = this.triIndices;
			}
		}
		else
		{
			indices = this.lineIndices;
		}

		var vertexCount = this.vertices.length / this.vertexSize;
		if ( vertexCount > 65535 )
		{
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint32Array( indices ), gl.STATIC_DRAW);
			this.indexType = gl.UNSIGNED_INT;
		}
		else
		{
			gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array( indices ), gl.STATIC_DRAW);
			this.indexType = gl.UNSIGNED_SHORT;
		}
		this.bufferDirty = false;
	}
	else
	{
		gl.bindBuffer(gl.ARRAY_BUFFER, this.vertexBuffer);
		gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.indexBuffer);
	}
};


/**************************************************************************************************************/

return BatchRenderable;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TiledVectorRenderable',['../Utils/Utils', '../Renderer/BatchRenderable','../Utils/Constants'],
    function (Utils, BatchRenderable, Constants) {

        /**************************************************************************************************************/


        /** @constructor
         *    TiledVectorRenderable constructor
         */
        var TiledVectorRenderable = function (bucket) {
            BatchRenderable.prototype.constructor.call(this, bucket);

            this.tile = null;
            // The tiled vector renderable always has a children
            this.hasChildren = true;
        };

        /**************************************************************************************************************/

        Utils.inherits(BatchRenderable, TiledVectorRenderable);

        /**************************************************************************************************************/

        /**
         * Initialize a child renderable
         */
        TiledVectorRenderable.prototype.initChild = function (i, j) {
            var child = new TiledVectorRenderable(this.bucket);
            child.tile = this.tile;
            child.vertexBufferShared = true;
            child.vertexBuffer = this.vertexBuffer;
            child.vertices = this.vertices;
            child.buildChildrenIndices(this, j * 2 + i);
            return child;
        };

        /**************************************************************************************************************/

        /**
         * Generate a child renderable
         */
        TiledVectorRenderable.prototype.generateChild = function (tile) {
            for (var j = 0; j < this.geometryInfos.length; j++) {
                this.bucket.renderer._addGeometryToTile(this.bucket, this.geometryInfos[j].geometry, tile);
            }
        };

        /**************************************************************************************************************/

        /**
         * Build children indices.
         * Children indices are used to render a tile children when it is not completely loaded.
         */
        TiledVectorRenderable.prototype.buildChildrenIndices = function (parent, index) {
            var n;
            var vertexOffset1,vertexOffset2,vertexOffset3;
            var x1,x2,x3,i;
            var y1,y2,y3,j;
            for (n = 0; n < parent.triIndices.length; n += 3) {
                vertexOffset1 = 3 * parent.triIndices[n];
                vertexOffset2 = 3 * parent.triIndices[n + 1];
                vertexOffset3 = 3 * parent.triIndices[n + 2];

                x1 = parent.vertices[vertexOffset1];
                x2 = parent.vertices[vertexOffset2];
                x3 = parent.vertices[vertexOffset3];

                i = 0;
                if (x1 > 0 || ( x1 === 0 && x2 > 0 ) || (x1 === 0 && x2 === 0 && x3 > 0)) {
                    i = 1;
                }

                y1 = parent.vertices[vertexOffset1 + 1];
                y2 = parent.vertices[vertexOffset2 + 1];
                y3 = parent.vertices[vertexOffset3 + 1];

                j = 1;
                if (y1 > 0 || ( y1 === 0 && y2 > 0 ) || (y1 === 0 && y2 === 0 && y3 > 0)) {
                    j = 0;
                }

                if (index === 2 * j + i) {
                    this.triIndices.push(parent.triIndices[n], parent.triIndices[n + 1], parent.triIndices[n + 2]);
                }
            }
            for (n = 0; n < parent.lineIndices.length / 2; n++) {
                vertexOffset1 = 3 * parent.lineIndices[2 * n];
                vertexOffset2 = 3 * parent.lineIndices[2 * n + 1];

                x1 = parent.vertices[vertexOffset1];
                x2 = parent.vertices[vertexOffset2];

                i = 0;
                if (x1 > 0 || ( x1 === 0 && x2 > 0 )) {
                    i = 1;
                }

                y1 = parent.vertices[vertexOffset1 + 1];
                y2 = parent.vertices[vertexOffset2 + 1];

                j = 1;
                if (y1 > 0 || ( y1 === 0 && y2 > 0 )) {
                    j = 0;
                }

                if (index === 2 * j + i) {
                    this.lineIndices.push(parent.lineIndices[2 * n], parent.lineIndices[2 * n + 1]);
                }
            }
        };


        /**************************************************************************************************************/

        /**
         *    Add a feature to the renderable
         *    @return    Boolean indicating if geometry intersects the given tile
         */
        TiledVectorRenderable.prototype.build = function (geometry, tile) {
            this.tile = tile;
            var i,j;
            var tileInRange = this.bucket.layer.minLevel <= tile.level && this.bucket.layer.maxLevel > tile.level;
            if (tileInRange) {
                var coords = geometry.coordinates;
                switch (geometry.type) {
                    case Constants.GEOMETRY.LineString:
                        this.buildVerticesAndIndices(tile, coords);
                        break;
                    case Constants.GEOMETRY.Polygon:
                        for (i = 0; i < coords.length; i++) {
                            this.buildVerticesAndIndices(tile, coords[i]);
                        }
                        break;
                    case Constants.GEOMETRY.MultiLineString:
                        for (i = 0; i < coords.length; i++) {
                            this.buildVerticesAndIndices(tile, coords[i]);
                        }
                        break;
                    case Constants.GEOMETRY.MultiPolygon:
                        for (j = 0; j < coords.length; j++) {
                            for (i = 0; i < coords[j].length; i++) {
                                this.buildVerticesAndIndices(tile, coords[j][i]);
                            }
                        }
                        break;
                }
            }
            return tile.geoBound.intersectsGeometry(geometry);
        };

        /**************************************************************************************************************/

        return TiledVectorRenderable;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TiledVectorRenderer',['../Utils/Utils', '../Renderer/VectorRenderer', '../Renderer/Program'], function (Utils, VectorRenderer, Program) {

    /**************************************************************************************************************/


    /** @constructor
     TiledVectorRenderer constructor
     */
    var TiledVectorRenderer = function (globe) {
        VectorRenderer.prototype.constructor.call(this, globe);

        var vertexShader = "attribute vec3 vertex; \n";
	      vertexShader    += "uniform float zOffset; \n";
	      vertexShader    += "uniform mat4 modelViewMatrix;\n";
	      vertexShader    += "uniform mat4 projectionMatrix;\n";
	      vertexShader    += "\n";
	      vertexShader    += "void main(void)  \n";
	      vertexShader    += "{ \n";
	      vertexShader    += "	gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex.x, vertex.y, vertex.z + zOffset, 1.0); \n";
	      vertexShader    += "} \n";

        var fragmentShader = "#ifdef GL_ES \n";
        fragmentShader    += "precision highp float; \n";
	      fragmentShader    += "#endif \n";
	      fragmentShader    += "uniform vec4 color; \n";
	      fragmentShader    += "\n";
	      fragmentShader    += "void main(void) \n";
	      fragmentShader    += "{ \n";
	      fragmentShader    += "	gl_FragColor = color; \n";
	      fragmentShader    += "} \n";


        this.program = new Program(this.tileManager.renderContext);
        this.program.createFromSource(vertexShader, fragmentShader);
    };

    Utils.inherits(VectorRenderer, TiledVectorRenderer);

    /**************************************************************************************************************/

    /**
     Render all redenrable on the given tiles
     */
    TiledVectorRenderer.prototype.render = function (renderables, start, end) {
        var renderContext = this.tileManager.renderContext;
        var gl = renderContext.gl;

        var modelViewMatrix = mat4.create();

        // Setup program
        this.program.apply();

        gl.depthFunc(gl.LEQUAL);
        // Do not write into z-buffer : the tiled vector are clamped to terrain, so the z of terrain should not change
        gl.depthMask(false);
        gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, renderContext.projectionMatrix);

        var currentStyle = null;

        for (var n = start; n < end; n++) {
            var renderable = renderables[n];
            var tile = renderable.tile;

            mat4.multiply(renderContext.viewMatrix, tile.matrix, modelViewMatrix);
            gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, modelViewMatrix);
            gl.uniform1f(this.program.uniforms.zOffset, tile.radius * 0.0007);

            currentStyle = renderable.bucket.style;

            renderable.bindBuffers(renderContext);

            gl.vertexAttribPointer(this.program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

            if (renderable.triIndices.length > 0) {
                gl.uniform4f(this.program.uniforms.color, currentStyle.fillColor[0], currentStyle.fillColor[1], currentStyle.fillColor[2],
                    currentStyle.fillColor[3] * renderable.bucket.layer.opacity);
                gl.drawElements(gl.TRIANGLES, renderable.triIndices.length, renderable.indexType, 0);
            }

            if (renderable.lineIndices.length > 0) {
                gl.lineWidth(currentStyle.strokeWidth);
                gl.uniform4f(this.program.uniforms.color, currentStyle.strokeColor[0], currentStyle.strokeColor[1], currentStyle.strokeColor[2],
                    currentStyle.strokeColor[3] * renderable.bucket.layer.opacity);
                var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
                gl.drawElements(gl.LINES, renderable.lineIndices.length, renderable.indexType, renderable.triIndices.length * size);
            }
        }

        gl.depthMask(true);
        gl.depthFunc(gl.LESS);
    };

    /**************************************************************************************************************/

    return TiledVectorRenderer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/LineStringRenderable',['../Utils/Constants', '../Utils/Utils', './FeatureStyle', './VectorRendererManager', '../Tiling/TiledVectorRenderable', '../Tiling/TiledVectorRenderer', '../Utils/Numeric'],
    function (Constants, Utils, FeatureStyle, VectorRendererManager, TiledVectorRenderable, TiledVectorRenderer, Numeric) {

        /**************************************************************************************************************/

        /**
         @name LineRenderer
         @class
             LineStringRenderable manages lineString data to be rendered on a tile.
         @augments TiledVectorRenderable
         @param {Bucket} bucket Bucket
         @constructor
         */

        var LineStringRenderable = function (bucket) {
            TiledVectorRenderable.prototype.constructor.call(this, bucket);
        };

        /**************************************************************************************************************/

// Inheritance
        Utils.inherits(TiledVectorRenderable, LineStringRenderable);

        /**************************************************************************************************************/

        /**************************************************************************************************************/

        /**
         * Check if a geometry crosses the date line
         * @function _fixDateLine
         * @memberof LineStringRenderable.prototype
         * @param {Tile} tile Tile
         * @param coords
         * @return {Array} Lines
         * @private
         */
        LineStringRenderable.prototype._fixDateLine = function (tile, coords) {
            var newCoords = [];
            var lines = [newCoords];
            for (var n = 0; n < coords.length - 1; n++) {

                newCoords.push(coords[n]);

                var x1 = coords[n][0];
                var y1 = coords[n][1];
                var x2 = coords[n + 1][0];
                var y2 = coords[n + 1][1];
                if (Math.abs(x2 - x1) > 180) {
                    if (x1 < 0) {
                        x1 += 360;
                    }
                    if (x2 < 0) {
                        x2 += 360;
                    }

                    var t = (180 - x1) / (x2 - x1);
                    if (t > 0 && t < 1) {
                        var y = y1 + t * (y2 - y1);
                        var x = coords[n][0] > 0 ? 180 : -180;
                        newCoords.push([x, y]);
                        newCoords = [[-x, y]];
                        lines.push(newCoords);
                    }
                }
            }
            newCoords.push(coords[coords.length - 1]);
            //newCoords.push( coords[0] );

            return lines;
        };

        /**
         * Build vertices and indices from the coordinates.
         * Clamp a line string on a tile
         * @function buildVerticesAndIndices
         * @memberof LineStringRenderable.prototype
         * @param {Tile} tile Tile
         * @param coords
         */
        LineStringRenderable.prototype.buildVerticesAndIndices = function (tile, coords) {
            if (coords.length === 0) {
                return;
            }

            // Fix date line for coordinates first
            var coordinates = this._fixDateLine(tile, coords);

            for (var i = 0; i < coordinates.length; i++) {
                this._buildVerticesAndIndices(tile, coordinates[i]);
            }
        };

        /**
         * Build vertices and indices from the coordinates.
         * Clamp a line string on a tile
         * @function _buildVerticesAndIndices
         * @memberof LineStringRenderable.prototype
         * @param {Tile} tile Tile
         * @param coords
         * @private
         */
        LineStringRenderable.prototype._buildVerticesAndIndices = function (tile, coords) {
            var size = tile.config.tesselation;
            var vs = tile.config.vertexSize;

            coords.push(coords[coords.length - 1]);
            // Convert lon/lat coordinates to tile coordinates (between [0,size-1] inside the tile)
            var tileCoords = tile.lonlat2tile(coords);

            for (var i = 0; i < coords.length - 1; i++) {
                var u1 = tileCoords[i][0];
                var v1 = tileCoords[i][1];

                var u2 = tileCoords[i + 1][0];
                var v2 = tileCoords[i + 1][1];

                var intersections = [];
                var n, v, res, u;
                var vertexOffset, x, y, z;
                // Intersect the segment with the tile grid

                // First intersect with columns
                // uStart, uEnd represent a range of the tile columns that the segment can intersect
                var uStart = Math.max(-1, Math.min(u1, u2));
                var uEnd = Math.min(size - 1, Math.max(u1, u2));
                for (n = Math.floor(uStart) + 1; n < Math.floor(uEnd) + 1; n++) {
                    u = n;
                    res = Numeric.lineIntersection(u1, v1, u2, v2, u, 0.0, u, size - 1);
                    if (res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0) {
                        v = res[1] * (size - 1);
                        var vFloor = Math.floor(v);
                        var vFrac = v - vFloor;
                        vertexOffset = vs * ( vFloor * size + n );
                        x = (1.0 - vFrac) * tile.vertices[vertexOffset] + vFrac * tile.vertices[vertexOffset + vs * size];
                        y = (1.0 - vFrac) * tile.vertices[vertexOffset + 1] + vFrac * tile.vertices[vertexOffset + vs * size + 1];
                        z = (1.0 - vFrac) * tile.vertices[vertexOffset + 2] + vFrac * tile.vertices[vertexOffset + vs * size + 2];
                        intersections.push([res[0], x, y, z]);
                    }
                }

                // Then intersect with rows
                // vStart, vEnd represent a range of the tile rows that the segement can intersect
                var vStart = Math.max(-1, Math.min(v1, v2));
                var vEnd = Math.min(size - 1, Math.max(v1, v2));
                for (n = Math.floor(vStart) + 1; n < Math.floor(vEnd) + 1; n++) {
                    v = n;
                    res = Numeric.lineIntersection(u1, v1, u2, v2, 0.0, v, size - 1, v);
                    if (res[0] > 0.0 && res[0] < 1.0 && res[1] >= 0.0 && res[1] <= 1.0) {
                        u = res[1] * (size - 1);
                        var uFloor = Math.floor(u);
                        var uFrac = u - uFloor;
                        vertexOffset = vs * ( n * size + uFloor );
                        x = (1.0 - uFrac) * tile.vertices[vertexOffset] + uFrac * tile.vertices[vertexOffset + vs];
                        y = (1.0 - uFrac) * tile.vertices[vertexOffset + 1] + uFrac * tile.vertices[vertexOffset + vs + 1];
                        z = (1.0 - uFrac) * tile.vertices[vertexOffset + 2] + uFrac * tile.vertices[vertexOffset + vs + 2];
                        intersections.push([res[0], x, y, z]);
                    }
                }
                // Sort intersections found on the segment
                intersections.sort(function (a, b) {
                    return a[0] > b[0];
                });

                // Build the vertices from the intersections found
                var startIndex = this.vertices.length / 3;
                var vec;
                if (u1 >= 0.0 && u1 <= size - 1 && v1 >= 0.0 && v1 <= size - 1) {
                    vec = tile.computePosition(u1, v1);
                    this.vertices.push(vec[0]);
                    this.vertices.push(vec[1]);
                    this.vertices.push(vec[2]);
                }

                for (n = 0; n < intersections.length; n++) {
                    this.vertices.push(intersections[n][1]);
                    this.vertices.push(intersections[n][2]);
                    this.vertices.push(intersections[n][3]);
                }

                if (u2 >= 0.0 && u2 <= size - 1 && v2 >= 0.0 && v2 <= size - 1) {
                    vec = tile.computePosition(u2, v2);
                    this.vertices.push(vec[0]);
                    this.vertices.push(vec[1]);
                    this.vertices.push(vec[2]);
                }

                var endIndex = this.vertices.length / 3;

                for (n = startIndex; n < endIndex - 1; n++) {
                    this.lineIndices.push(n);
                    this.lineIndices.push(n + 1);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         @name LineStringRenderer
         @class
             LineStringRenderer manages lineString data to be rendered on a tile.
         @augments TiledVectorRenderer
         @param {Planet} planet Planet
         @constructor
         */

        var LineStringRenderer = function (globe) {
            TiledVectorRenderer.prototype.constructor.call(this, globe);
        };

// Inheritance
        Utils.inherits(TiledVectorRenderer, LineStringRenderer);

        /**************************************************************************************************************/

        /**
         * Check if renderer is applicable
         * @function canApply
         * @memberof LineStringRenderer.prototype
         * @param type
         * @param style
         * @return {Boolean} Can apply ?
         */
        LineStringRenderer.prototype.canApply = function (type, style) {
            if (this.globe.isSky()) {
                return false;
            }

            return (type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString ||
                (!style.fill && (type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon))) && !style.gradientLength;
        };
        /**************************************************************************************************************/
        /**
         @name LineStringBucket
         @class
             Bucket constructor for LineStringRenderer
         @param layer
         @param style
         @constructor
         */
        var LineStringBucket = function (layer, style) {
            this.layer = layer;
            this.style = new FeatureStyle(style);
            this.renderer = null;
        };

        /**************************************************************************************************************/

        /**
         * Create a renderable for this bucket
         * @function createRenderable
         * @memberof LineStringBucket.prototype
         * @return {LineStringRenderable} Renderable
         */
        LineStringBucket.prototype.createRenderable = function () {
            return new LineStringRenderable(this);
        };

        /**************************************************************************************************************/

        /**
         * Check if a bucket is compatible
         * @function isCompatible
         * @memberof LineStringBucket.prototype
         * @param style
         * @return {Boolean} Is compatible ?
         */
        LineStringBucket.prototype.isCompatible = function (style) {
            return this.style.strokeColor[0] === style.strokeColor[0] &&
                this.style.strokeColor[1] === style.strokeColor[1] &&
                this.style.strokeColor[2] === style.strokeColor[2] &&
                this.style.strokeColor[3] === style.strokeColor[3] &&
                this.style.strokeWidth === style.strokeWidth;
        };

        /**************************************************************************************************************/

        /**
         * Get or create a bucket to store a feature with the given style
         * @function createBucket
         * @memberof LineStringRenderer.prototype
         * @param layer
         * @param style
         * @return {LineStringBucket} Bucket
         */
        LineStringRenderer.prototype.createBucket = function (layer, style) {
            // Create a bucket
            return new LineStringBucket(layer, style);
        };

        /**************************************************************************************************************/

// Register the renderer
        VectorRendererManager.factory.push(function (globe) {
            return new LineStringRenderer(globe);
        });

        return LineStringRenderable;

    });

// jshint ignore: start
define('Renderer/pnltri',[],function() {

// pnltri.js / raw.github.com/jahting/pnltri.js/master/LICENSE
/**
 * @author jahting / http://www.ameco.tv/
 *
 *	(Simple) Polygon Near-Linear Triangulation
 *	  with fast ear-clipping for polygons without holes
 *
 */

var PNLTRI = { REVISION: '2.1.1' };

//	#####  Global Constants  #####


//	#####  Global Variables  #####


/**
 * @author jahting / http://www.ameco.tv/
 */

PNLTRI.Math = {

	random: Math.random,		// function to use for random number generation

	// generate random ordering in place:
	//	Fisher-Yates shuffle
	array_shuffle: function( inoutArray ) {
		for (var i = inoutArray.length - 1; i > 0; i-- ) {
			var j = Math.floor( PNLTRI.Math.random() * (i+1) );
			var tmp = inoutArray[i];
			inoutArray[i] = inoutArray[j];
			inoutArray[j] = tmp;
		}
		return	inoutArray;
	},


	//	like compare (<=>)
	//		yA > yB resp. xA > xB: 1, equal: 0, otherwise: -1
	compare_pts_yx: function ( inPtA, inPtB ) {
		var deltaY = inPtA.y - inPtB.y;
		if ( deltaY < PNLTRI.Math.EPSILON_N ) {
			return -1;
		} else if ( deltaY > PNLTRI.Math.EPSILON_P ) {
			return 1;
		} else {
			var deltaX = inPtA.x - inPtB.x;
			if ( deltaX < PNLTRI.Math.EPSILON_N ) {
				return -1;
			} else if ( deltaX > PNLTRI.Math.EPSILON_P ) {
				return  1;
			} else {
				return  0;
			}
		}
	},


	ptsCrossProd: function ( inPtVertex, inPtFrom, inPtTo ) {
		// two vectors: ( v0: inPtVertex -> inPtFrom ), ( v1: inPtVertex -> inPtTo )
		// CROSS_SINE: sin(theta) * len(v0) * len(v1)
		return	( inPtFrom.x - inPtVertex.x ) * ( inPtTo.y - inPtVertex.y ) -
				( inPtFrom.y - inPtVertex.y ) * ( inPtTo.x - inPtVertex.x );
		// <=> crossProd( inPtFrom-inPtVertex, inPtTo-inPtVertex )
		// == 0: colinear (angle == 0 or 180 deg == PI rad)
		// > 0:  v1 lies left of v0, CCW angle from v0 to v1 is convex ( < 180 deg )
		// < 0:  v1 lies right of v0, CW angle from v0 to v1 is convex ( < 180 deg )
	},

};

// precision of floating point arithmetic
//	PNLTRI.Math.EPSILON_P = Math.pow(2,-32);	// ~ 0.0000000001
	PNLTRI.Math.EPSILON_P = Math.pow(2,-43);	// ~ 0.0000000000001
	PNLTRI.Math.EPSILON_N = -PNLTRI.Math.EPSILON_P;

//	Problem with EPSILON-compares:
//	- especially when there is a x-coordinate ordering on equal y-coordinates
//		=> either NO EPSILON-compares on y-coordinates, since almost equal y
//			can have very different x - so they are not nearly close
//		or EPSILON must be bigger: Solution so far.
/**
 * @author jahting / http://www.ameco.tv/
 */

PNLTRI.PolygonData = function ( inPolygonChainList ) {

	// list of polygon vertices
	//	.x, .y: coordinates
	this.vertices = [];

	// list of polygon segments, original polygons ane holes
	//	and additional ones added during the subdivision into
	//	uni-y-monotone polygons (s. this.monoSubPolyChains)
	//	doubly linked by: snext, sprev
	this.segments = [];
	this.diagonals = [];

	// for the ORIGINAL polygon chains
	this.idNextPolyChain = 0;
	//	for each original chain: lies the polygon inside to the left?
	//	"true": winding order is CCW for a contour or CW for a hole
	//	"false": winding order is CW for a contour or CCW for a hole
	this.PolyLeftArr = [];

	// indices into this.segments: at least one for each monoton chain for the polygon
	//  these subdivide the polygon into uni-y-monotone polygons, that is
	//  polygons that have only one segment between ymax and ymin on one side
	//  and the other side has monotone increasing y from ymin to ymax
	// the monoSubPolyChains are doubly linked by: mnext, mprev
	this.monoSubPolyChains = [];

	// list of triangles: each 3 indices into this.vertices
	this.triangles = [];

	// initialize optional polygon chains
	if ( inPolygonChainList ) {
		for (var i=0, j=inPolygonChainList.length; i<j; i++) {
			this.addPolygonChain( inPolygonChainList[i] );
		}
	}

};


PNLTRI.PolygonData.prototype = {

	constructor: PNLTRI.PolygonData,


	/*	Accessors  */

	nbVertices: function () {
		return	this.vertices.length;
	},
	getSegments: function () {
		return	this.segments;
	},
	getFirstSegment: function () {
		return	this.segments[0];
	},
	getMonoSubPolys: function () {
		return	this.monoSubPolyChains;
	},
	getTriangles: function () {
		return	this.triangles.concat();
	},

	nbPolyChains: function () {
		return	this.idNextPolyChain;
	},

	// for the polygon data AFTER triangulation
	//	returns an Array of flags, one flag for each polygon chain:
	//		lies the inside of the polygon to the left?
	//		"true" implies CCW for contours and CW for holes
	get_PolyLeftArr: function () {
		return	this.PolyLeftArr.concat();
	},
	set_PolyLeft_wrong: function ( inChainId ) {
		this.PolyLeftArr[inChainId] = false;
	},


	/*	Helper  */

	// checks winding order by calculating the area of the polygon
	isClockWise: function ( inStartSeg ) {
		var cursor = inStartSeg, doubleArea = 0;
		do {
			doubleArea += ( cursor.vFrom.x - cursor.vTo.x ) * ( cursor.vFrom.y + cursor.vTo.y );
			cursor = cursor.snext;
		} while ( cursor != inStartSeg );
		return	( doubleArea < 0 );
	},


	/*	Operations  */

	appendVertexEntry: function ( inVertexX, inVertexY ) {			// private
		var vertex = {
				id: this.vertices.length,	// vertex id, representing input sequence
				x: inVertexX,				// coordinates
				y: inVertexY,
			};
		this.vertices.push( vertex );
		return	vertex;
	},


	createSegmentEntry: function ( inVertexFrom, inVertexTo ) {			// private
		return	{
			chainId: this.idNextPolyChain,
			// end points of segment
			vFrom: inVertexFrom,	// -> start point entry in vertices
			vTo: inVertexTo,		// -> end point entry in vertices
			// upward segment? (i.e. vTo > vFrom) !!! only valid for sprev,snext NOT for mprev,mnext !!!
			upward: ( PNLTRI.Math.compare_pts_yx(inVertexTo, inVertexFrom) == 1 ),
			// doubly linked list of original polygon chains (not the monoChains !)
			sprev: null,			// previous segment
			snext: null,			// next segment
			//
			//	for performance reasons:
			//	 initialization of all fields added later
			//
			// for trapezoids
			rootFrom: null,			// root of partial tree where vFrom is located
			rootTo: null,			// root of partial tree where vTo is located
			is_inserted: false,		// already inserted into QueryStructure ?
			// for assigning depth: trapezoids
			trLeft: null,			// one trapezoid bordering on the left of this segment
			trRight: null,			// one trapezoid bordering on the right of this segment
			// for monochains
			mprev: null,			// doubly linked list for monotone chains (sub-polygons)
			mnext: null,
			marked: false,			// already visited during unique monoChain identification ?
		};
	},

	appendSegmentEntry: function ( inSegment ) {				// private
		this.segments.push( inSegment );
		return	inSegment;
	},


	appendDiagonalsEntry: function ( inDiagonal ) {				// <<<<<	public
		this.diagonals.push( inDiagonal );
		return	inDiagonal;
	},


	addVertexChain: function ( inRawPointList ) {			// private

		function verts_equal( inVert1, inVert2 ) {
			return ( ( Math.abs(inVert1.x - inVert2.x) < PNLTRI.Math.EPSILON_P ) &&
					 ( Math.abs(inVert1.y - inVert2.y) < PNLTRI.Math.EPSILON_P ) );
		}

		function verts_colinear_chain( inVert1, inVert2, inVert3 ) {
			if ( Math.abs( PNLTRI.Math.ptsCrossProd( inVert2, inVert1, inVert3 ) ) > PNLTRI.Math.EPSILON_P )	return false;
			// only real sequences, not direction reversals
			var low, middle, high;
			if ( Math.abs( inVert1.y - inVert2.y ) < PNLTRI.Math.EPSILON_P ) {
				// horizontal line
				middle = inVert2.x;
				if ( inVert1.x < inVert3.x ) {
					low = inVert1.x;
					high = inVert3.x;
				} else {
					low = inVert3.x;
					high = inVert1.x;
				}
			} else {
				middle = inVert2.y;
				if ( inVert1.y < inVert3.y ) {
					low = inVert1.y;
					high = inVert3.y;
				} else {
					low = inVert3.y;
					high = inVert1.y;
				}
			}
			return	( ( ( low - middle ) < PNLTRI.Math.EPSILON_P ) && ( ( middle - high ) < PNLTRI.Math.EPSILON_P ) );
		}

		var newVertices = [];
		var newVertex, acceptVertex, lastIdx;
		for ( var i=0; i < inRawPointList.length; i++ ) {
			newVertex = this.appendVertexEntry( inRawPointList[i].x, inRawPointList[i].y );
			// suppresses zero-length segments
			acceptVertex = true;
			lastIdx = newVertices.length-1;
			if ( lastIdx >= 0 ) {
				if ( verts_equal( newVertex, newVertices[lastIdx] ) ) {
					acceptVertex = false;
				} else if ( lastIdx > 0 ) {
					if ( verts_colinear_chain( newVertices[lastIdx-1], newVertices[lastIdx], newVertex ) ) {
						newVertices.pop();
					}
				}
			}
			if ( acceptVertex )	newVertices.push( newVertex );
		}
		// compare last vertices to first: suppresses zero-length and co-linear segments
		lastIdx = newVertices.length - 1;
		if ( ( lastIdx > 0 ) &&
			 verts_equal( newVertices[lastIdx], newVertices[0] ) ) {
			newVertices.pop();
			lastIdx--;
		}
		if ( lastIdx > 1 ) {
			if ( verts_colinear_chain( newVertices[lastIdx-1], newVertices[lastIdx], newVertices[0] ) ) {
				newVertices.pop();
				lastIdx--;
			}
			if ( ( lastIdx > 1 ) &&
				 verts_colinear_chain( newVertices[lastIdx], newVertices[0], newVertices[1] ) ) {
				newVertices.shift();
			}
		}

		return	newVertices;
	},


	addPolygonChain: function ( inRawPointList ) {			// <<<<<< public

		// vertices
		var newVertices = this.addVertexChain( inRawPointList );
		if ( newVertices.length < 3 ) {
			console.log( "Polygon has < 3 vertices!", newVertices );
			return	0;
		}

		// segments
		var	saveSegListLength = this.segments.length;
		//
		var	segment, firstSeg, prevSeg;
		for ( var i=0; i < newVertices.length-1; i++ ) {
			segment = this.createSegmentEntry( newVertices[i], newVertices[i+1] );
			if (prevSeg) {
				segment.sprev = prevSeg;
				prevSeg.snext = segment;
			} else {
				firstSeg = segment;
			}
			prevSeg = segment;
			this.appendSegmentEntry( segment );
		}
		// close polygon
		segment = this.createSegmentEntry( newVertices[newVertices.length-1], newVertices[0] );
		segment.sprev = prevSeg;
		prevSeg.snext = segment;
		this.appendSegmentEntry( segment );
		firstSeg.sprev = segment;
		segment.snext = firstSeg;

		this.PolyLeftArr[this.idNextPolyChain++] = true;
		return	this.segments.length - saveSegListLength;
	},


	/* Monotone Polygon Chains */

	// Generate the uni-y-monotone sub-polygons from
	//	the trapezoidation of the polygon.

	create_mono_chains: function () {						// <<<<<< public
		var newMono, newMonoTo, toFirstOutSeg, fromRevSeg;
		for ( var i = 0, j = this.segments.length; i < j; i++) {
			newMono = this.segments[i];
			if ( this.PolyLeftArr[newMono.chainId] ) {
				// preserve winding order
				newMonoTo = newMono.vTo;			// target of segment
				newMono.mprev = newMono.sprev;		// doubly linked list for monotone chains (sub-polygons)
				newMono.mnext = newMono.snext;
			} else {
				// reverse winding order
				newMonoTo = newMono.vFrom;
				newMono = newMono.snext;
				newMono.mprev = newMono.snext;
				newMono.mnext = newMono.sprev;
			}
			if ( fromRevSeg = newMono.vFrom.lastInDiag ) {		// assignment !
				fromRevSeg.mnext = newMono;
				newMono.mprev = fromRevSeg;
				newMono.vFrom.lastInDiag = null;		// cleanup
			}
			if ( toFirstOutSeg = newMonoTo.firstOutDiag ) {		// assignment !
				toFirstOutSeg.mprev = newMono;
				newMono.mnext = toFirstOutSeg;
				newMonoTo.firstOutDiag = null;			// cleanup
			}
		}
	},

	// For each monotone polygon, find the ymax (to determine the two
	// y-monotone chains) and skip duplicate monotone polygons

	unique_monotone_chains_max: function () {			// <<<<<< public

		function find_monotone_chain_max( frontMono ) {
			var frontPt, firstPt, ymaxPt;

			var monoPosmax = frontMono;
			firstPt = ymaxPt = frontMono.vFrom;

			frontMono.marked = true;
			frontMono = frontMono.mnext;
			while ( frontPt = frontMono.vFrom ) {				// assignment !
				if (frontMono.marked) {
					if ( frontPt == firstPt )	break;	// mono chain completed
					console.log("ERR unique_monotone: segment in two chains", firstPt, frontMono );
					return	null;
				} else {
/*					if ( frontPt == firstPt ) {			// check for robustness
						console.log("ERR unique_monotone: point double", firstPt, frontMono );
					}		*/
					frontMono.marked = true;
				}
				if ( PNLTRI.Math.compare_pts_yx( frontPt, ymaxPt ) == 1 ) {
					ymaxPt = frontPt;
					monoPosmax = frontMono;
				}
				frontMono = frontMono.mnext;
			}
			return	monoPosmax;
		}

		var frontMono, monoPosmax;

		// assumes attribute "marked" is NOT yet "true" for any mono chain segment
		this.monoSubPolyChains = [];
		// loop through all original segments
		for ( var i = 0, j = this.segments.length; i < j; i++ ) {
			frontMono = this.segments[i];
			if ( frontMono.marked )		continue;		// already in a processed mono chain
			monoPosmax = find_monotone_chain_max( frontMono );
			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
		}
		// loop through all additional segments (diagonals)			// TODO: Testcase for mono chain without original segments !!!
/*		for ( var i = 0, j = this.diagonals.length; i < j; i++ ) {
			frontMono = this.diagonals[i];
			if ( frontMono.marked )		continue;		// already in a processed mono chain
			monoPosmax = find_monotone_chain_max( frontMono );
			if ( monoPosmax )	this.monoSubPolyChains.push( monoPosmax );
		}	*/
		return	this.monoSubPolyChains;
	},


	/* Triangles */

	clearTriangles: function () {
		this.triangles = [];
	},

	addTriangle: function ( inVert1, inVert2, inVert3 ) {
		this.triangles.push( [ inVert1.id, inVert2.id, inVert3.id ] );
	}

};

/**
 * Simple Polygon Triangulation by Ear Clipping
 *
 * description of technique employed:
 *	http://www.siggraph.org/education/materials/HyperGraph/scanline/outprims/polygon1.htm
 *
 * This code is a quick port of code written in C++ which was submitted to
 *	flipcode.com by John W. Ratcliff  // July 22, 2000
 * See original code and more information here:
 *	http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
 *
 * ported to actionscript by Zevan Rosser
 *	http://actionsnippet.com/?p=1462
 *
 * ported to javascript by Joshua Koo
 *	http://www.lab4games.net/zz85/blog
 *
 * adapted to doubly linked list by Juergen Ahting
 *	http://www.ameco.tv
 *
 */

PNLTRI.EarClipTriangulator = function ( inPolygonData ) {

	this.polyData	= inPolygonData;

};


PNLTRI.EarClipTriangulator.prototype = {

	constructor: PNLTRI.EarClipTriangulator,


	// triangulates first doubly linked segment list in this.polyData
	//	algorithm uses ear-clipping and runs in O(n^2) time

	triangulate_polygon_no_holes: function () {

		function isEarAt( vertex ) {

			var prevX = vertex.mprev.vFrom.x;
			var prevY = vertex.mprev.vFrom.y;

			var vertX = vertex.vFrom.x;
			var vertY = vertex.vFrom.y;

			var nextX = vertex.mnext.vFrom.x;
			var nextY = vertex.mnext.vFrom.y;

			var vnX = nextX - vertX,  vnY = nextY - vertY;
			var npX = prevX - nextX,  npY = prevY - nextY;
			var pvX = vertX - prevX,  pvY = vertY - prevY;

			// concave angle at vertex -> not an ear to cut off
			if ( PNLTRI.Math.EPSILON_P > ( ( pvX * vnY ) - ( vnX * pvY ) ) ) return false;

			// check whether any other point lieas within the triangle abc
			var vStop	= vertex.mprev.mprev;
			var vOther	= vertex.mnext;
			while ( vOther != vStop ) {
				vOther = vOther.mnext;
				var otherX = vOther.vFrom.x;
				var otherY = vOther.vFrom.y;

				var poX = otherX - prevX,  poY = otherY - prevY;
					// just in case there are several vertices with the same coordinate
					if ( ( poX === 0 ) && ( poY === 0 ) )		continue;	// vOther == vertex.mprev
				var voX = otherX - vertX,  voY = otherY - vertY;
					if ( ( voX === 0 ) && ( voY === 0 ) )		continue;	// vOther == vertex
				var noX = otherX - nextX,  noY = otherY - nextY;
					if ( ( noX === 0 ) && ( noY === 0 ) )		continue;	// vOther == vertex.mnext

				// if vOther is inside triangle abc -> not an ear to cut off
				if ( ( ( vnX * voY - vnY * voX ) >= PNLTRI.Math.EPSILON_N ) &&
					 ( ( pvX * poY - pvY * poX ) >= PNLTRI.Math.EPSILON_N ) &&
					 ( ( npX * noY - npY * noX ) >= PNLTRI.Math.EPSILON_N ) ) return false;
			}
			return true;

		}

		var myPolyData = this.polyData;
		var startSeg = myPolyData.getFirstSegment();

		// create a counter-clockwise ordered doubly linked list (monoChain links)

		var cursor = startSeg;
		if ( myPolyData.isClockWise( startSeg ) ) {
			do {	// reverses chain order
				cursor.mprev = cursor.snext;
				cursor.mnext = cursor.sprev;
				cursor = cursor.sprev;
			} while ( cursor != startSeg );
			myPolyData.set_PolyLeft_wrong(0);
		} else {
			do {
				cursor.mprev = cursor.sprev;
				cursor.mnext = cursor.snext;
				cursor = cursor.snext;
			} while ( cursor != startSeg );
		}

		//  remove all vertices except 2, creating 1 triangle every time

		var vertex = startSeg;
		var fullLoop = vertex;   // prevent infinite loop on "defective" polygons

		while ( vertex.mnext != vertex.mprev ) {
			if ( isEarAt( vertex ) ) {
				// found a triangle ear to cut off
				this.polyData.addTriangle( vertex.mprev.vFrom, vertex.vFrom, vertex.mnext.vFrom );
				// remove vertex from the remaining chain
				vertex.mprev.mnext = vertex.mnext;
				vertex.mnext.mprev = vertex.mprev;
				vertex = vertex.mnext;
				fullLoop = vertex;			// reset error detection
			} else {
				vertex = vertex.mnext;
				// loop?: probably non-simple polygon -> stop with error
				if ( vertex == fullLoop )	return false;
			}
		}

		return true;

	},

/*	// takes one element of a double linked segment list
	//	works on array of vertices

	triangulate_polygon_no_holes: function () {
		var startSeg = this.polyData.getFirstSegment();

		function vertList( inStartSeg ) {
			var verts = [];
			// we want a counter-clockwise polygon in verts
			var doubleArea = 0.0;
			var cursor = inStartSeg;
			var p,q;
			var idx = 0;
			do {
				p = cursor.sprev.vFrom;
				q = cursor.vFrom;
				doubleArea += p.x * q.y - q.x * p.y;
				verts[idx++] = q;
				cursor = cursor.snext;
			} while ( cursor != inStartSeg );
			if ( doubleArea < 0.0 ) {
				verts = verts.reverse();
				var tmp = verts.pop();
				verts.unshift( tmp );
			}
			return	verts;
		}

		function snip( verts, u, v, w, n ) {

			var ax = verts[ u ].x;
			var ay = verts[ u ].y;

			var bx = verts[ v ].x;
			var by = verts[ v ].y;

			var cx = verts[ w ].x;
			var cy = verts[ w ].y;

			if ( PNLTRI.Math.EPSILON_P > ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) ) ) return false;

			var aX, aY, bX, bY, cX, cY;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			var p, px, py;

			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			for ( p = 0; p < n; p ++ ) {

				px = verts[ p ].x
				py = verts[ p ].y

				apx = px - ax;  apy = py - ay;
					if ( ( apx == 0 ) && ( apy == 0 ) )		continue;
				bpx = px - bx;  bpy = py - by;
					if ( ( bpx == 0 ) && ( bpy == 0 ) )		continue;
				cpx = px - cx;  cpy = py - cy;
					if ( ( cpx == 0 ) && ( cpy == 0 ) )		continue;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= PNLTRI.Math.EPSILON_N ) &&
					 ( bCROSScp >= PNLTRI.Math.EPSILON_N ) &&
					 ( cCROSSap >= PNLTRI.Math.EPSILON_N ) ) return false;

			}

			return true;

		};

		var result = [];

		var	verts = vertList( startSeg );

		var n = verts.length;
		var nv = n;

		var u, v, w;

		//  remove nv - 2 vertices, creating 1 triangle every time

		var count = 2 * nv;   // error detection

		for ( v = nv - 1; nv > 2; ) {

			// if we loop, it is probably a non-simple polygon

			if ( ( count -- ) <= 0 )	return false;

			// three consecutive vertices in current polygon, <u,v,w>

			u = v; 	 	if ( nv <= u ) u = 0;     // previous
			v = u + 1;  if ( nv <= v ) v = 0;     // new v
			w = v + 1;  if ( nv <= w ) w = 0;     // next

			if ( snip( verts, u, v, w, nv ) ) {

				// output Triangle

				this.polyData.addTriangle( verts[ u ], verts[ v ], verts[ w ] );

				// remove v from the remaining polygon

				var s, t;

				for ( s = v, t = v + 1; t < nv; s++, t++ ) {

					verts[ s ] = verts[ t ];

				}

				nv --;

				v --;
				if ( v < 0 )	v = nv-1;

				// reset error detection counter

				count = 2 * nv;

			}

		}

		return true;

	},		*/

};

/**
 * @author jahting / http://www.ameco.tv/
 *
 *	Algorithm to create the trapezoidation of a polygon with holes
 *	 according to Seidel's algorithm [Sei91]
 */

PNLTRI.Trapezoid = function ( inHigh, inLow, inLeft, inRight ) {

	this.vHigh = inHigh ? inHigh : { x: Number.POSITIVE_INFINITY, y: Number.POSITIVE_INFINITY };
	this.vLow  = inLow  ? inLow  : { x: Number.NEGATIVE_INFINITY, y: Number.NEGATIVE_INFINITY };

	this.lseg = inLeft;
	this.rseg = inRight;

//	this.uL = null;				// -> Trapezoid: upper left neighbor
//	this.uR = null;				// -> Trapezoid: upper right neighbor
//	this.dL = null;				// -> Trapezoid: lower left neighbor
//	this.dR = null;				// -> Trapezoid: lower right neighbor

//	this.sink = null;			// link to corresponding SINK-Node in QueryStructure

//	this.usave = null;			// temp: uL/uR, preserved for next step
//	this.uleft = null;			// temp: from uL? (true) or uR (false)

	this.depth = -1;			// no depth assigned yet

	this.monoDone = false;		// monotonization: done with trying to split this trapezoid ?

};

PNLTRI.Trapezoid.prototype = {

	constructor: PNLTRI.Trapezoid,

	clone: function () {
		var newTrap = new PNLTRI.Trapezoid( this.vHigh, this.vLow, this.lseg, this.rseg );

		newTrap.uL = this.uL;
		newTrap.uR = this.uR;

		newTrap.dL = this.dL;
		newTrap.dR = this.dR;

		newTrap.sink = this.sink;

		return	newTrap;
	},


	splitOffLower: function ( inSplitPt ) {
		var trLower = this.clone();				// new lower trapezoid

		this.vLow = trLower.vHigh = inSplitPt;

		// L/R unknown, anyway changed later
		this.dL = trLower;		// setBelow
		trLower.uL = this;		// setAbove
		this.dR = trLower.uR = null;

		// setAbove
		if ( trLower.dL )	trLower.dL.uL = trLower;	// dL always connects to uL
		if ( trLower.dR )	trLower.dR.uR = trLower;	// dR always connects to uR

		return	trLower;
	}

};


/*==============================================================================
 *
 *============================================================================*/

// PNLTRI.qsCounter = 0;

PNLTRI.QsNode = function ( inTrapezoid ) {
//	this.qsId = PNLTRI.qsCounter++;				// Debug only
	// Only SINK-nodes are created directly.
	// The others originate from splitting trapezoids
	// - by a horizontal line: SINK-Node -> Y-Node
	// - by a segment: SINK-Node -> X-Node
	this.trap = inTrapezoid;
	inTrapezoid.sink = this;
};

PNLTRI.QsNode.prototype = {

	constructor: PNLTRI.QsNode

};

/*==============================================================================
 *
 *============================================================================*/

PNLTRI.QueryStructure = function ( inPolygonData ) {
	// initialise the query structure and trapezoid list
	var initialTrap = new PNLTRI.Trapezoid( null, null, null, null );
	this.trapArray = [];
	this.appendTrapEntry( initialTrap );

//	PNLTRI.qsCounter = 0;
	this.root = new PNLTRI.QsNode( initialTrap );

	if ( inPolygonData ) {
		/*
		 * adds and initializes specific attributes for all segments
		 *	// -> QueryStructure: roots of partial tree where vertex is located
		 *	rootFrom, rootTo:	for vFrom, vTo
		 *	// marker
		 *	is_inserted:	already inserted into QueryStructure ?
		 */
		var segListArray = inPolygonData.getSegments();
		for ( var i = 0; i < segListArray.length; i++ ) {
			segListArray[i].rootFrom = segListArray[i].rootTo = this.root;
			segListArray[i].is_inserted = false;
		}
	}
};

PNLTRI.QueryStructure.prototype = {

	constructor: PNLTRI.QueryStructure,

	getRoot: function () {
		return this.root;
	},


	appendTrapEntry: function ( inTrapezoid ) {
		inTrapezoid.trapID = this.trapArray.length;			// for Debug
		this.trapArray.push( inTrapezoid );
	},
	cloneTrap: function ( inTrapezoid ) {
		var trap = inTrapezoid.clone();
		this.appendTrapEntry( trap );
		return	trap;
	},


	splitNodeAtPoint: function ( inNode, inPoint, inReturnUpper ) {
		// inNode: SINK-Node with trapezoid containing inPoint
		var trUpper = inNode.trap;							// trUpper: trapezoid includes the point
		if (trUpper.vHigh == inPoint)	return	inNode;				// (ERROR) inPoint is already inserted
		if (trUpper.vLow == inPoint)	return	inNode;				// (ERROR) inPoint is already inserted
		var trLower = trUpper.splitOffLower( inPoint );		// trLower: new lower trapezoid
		this.appendTrapEntry( trLower );

		// SINK-Node -> Y-Node
		inNode.yval = inPoint;
		inNode.trap = null;

		inNode.right = new PNLTRI.QsNode( trUpper );		// Upper trapezoid sink
		inNode.left = new PNLTRI.QsNode( trLower );			// Lower trapezoid sink

		return	inReturnUpper ? trUpper.sink : trLower.sink;
	},


	/*
	 * Mathematics & Geometry helper methods
	 */

	fpEqual: function ( inNum0, inNum1 ) {
		 return		Math.abs( inNum0 - inNum1 ) < PNLTRI.Math.EPSILON_P;
	},


	// Checks, whether the vertex inPt is to the left of line segment inSeg.
	//	Returns:
	//		>0: inPt is left of inSeg,
	//		<0: inPt is right of inSeg,
	//		=0: inPt is co-linear with inSeg
	//
	//	ATTENTION: always viewed from -y, not as if moving along the segment chain !!

	is_left_of: function ( inSeg, inPt, inBetweenY ) {
		var retVal;
		var dXfrom = inSeg.vFrom.x - inPt.x;
		var dXto = inSeg.vTo.x - inPt.x;
		var dYfromZero = this.fpEqual( inSeg.vFrom.y, inPt.y );
		if ( this.fpEqual( inSeg.vTo.y, inPt.y ) ) {
			if ( dYfromZero )	return 0;		// all points on a horizontal line
			retVal = dXto;
		} else if ( dYfromZero ) {
			retVal = dXfrom;
/*		} else if ( inBetweenY && ( dXfrom * dXto > 0 ) ) {
			// both x-coordinates of inSeg are on the same side of inPt
			if ( Math.abs( dXto ) >= PNLTRI.Math.EPSILON_P )	return	dXto;
			retVal = dXfrom;	*/
		} else {
			if ( inSeg.upward ) {
				return	PNLTRI.Math.ptsCrossProd( inSeg.vFrom, inSeg.vTo, inPt );
			} else {
				return	PNLTRI.Math.ptsCrossProd( inSeg.vTo, inSeg.vFrom, inPt );
			}
		}
		if ( Math.abs( retVal ) < PNLTRI.Math.EPSILON_P )		return	0;
		return	retVal;
	},


	/*
	 * Query structure main methods
	 */

	//	This method finds the Nodes in the QueryStructure corresponding
	//   to the trapezoids that contain the endpoints of inSegment,
	//	 starting from Nodes rootFrom/rootTo and replacing them with the results.

	segNodes: function ( inSegment ) {
		this.ptNode( inSegment, true );
		this.ptNode( inSegment, false );
	},

	// TODO: may need to prevent infinite loop in case of messed up
	//	trapezoid structure (s. test_add_segment_special_6)

	ptNode: function ( inSegment, inUseFrom ) {
		var ptMain, ptOther, qsNode;
		if ( inUseFrom ) {
			ptMain = inSegment.vFrom;
			ptOther = inSegment.vTo;		// used if ptMain is not sufficient
			qsNode = inSegment.rootFrom;
		} else {
			ptMain = inSegment.vTo;
			ptOther = inSegment.vFrom;
			qsNode = inSegment.rootTo;
		}
		var compPt, compRes;
		var isInSegmentShorter;

		while ( qsNode ) {
			if ( qsNode.yval ) {			// Y-Node: horizontal line
											// 4 times as often as X-Node
				qsNode = ( PNLTRI.Math.compare_pts_yx( ( ( ptMain == qsNode.yval ) ?	// is the point already inserted ?
									ptOther : ptMain ), qsNode.yval ) == -1 ) ?
									qsNode.left : qsNode.right;						// below : above
			} else if ( qsNode.seg ) {		// X-Node: segment (~vertical line)
											// 0.8 to 1.5 times as often as SINK-Node
				if ( ( ptMain == qsNode.seg.vFrom ) ||
					 ( ptMain == qsNode.seg.vTo ) ) {
					// the point is already inserted
					if ( this.fpEqual( ptMain.y, ptOther.y ) ) {
						// horizontal segment
						if ( !this.fpEqual( qsNode.seg.vFrom.y, qsNode.seg.vTo.y ) ) {
							qsNode = ( ptOther.x < ptMain.x ) ? qsNode.left : qsNode.right;		// left : right
						} else {	// co-linear horizontal reversal: test_add_segment_special_7
							if ( ptMain == qsNode.seg.vFrom ) {
								// connected at qsNode.seg.vFrom
//								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vFrom", inUseFrom, inSegment, qsNode )
								isInSegmentShorter = inSegment.upward ?
										( ptOther.x >= qsNode.seg.vTo.x ) :
										( ptOther.x <  qsNode.seg.vTo.x );
								qsNode = ( isInSegmentShorter ?
												inSegment.sprev.upward :
												qsNode.seg.snext.upward ) ? qsNode.right : qsNode.left;		// above : below
							} else {
								// connected at qsNode.seg.vTo
//								console.log("ptNode: co-linear horizontal reversal, connected at qsNode.seg.vTo", inUseFrom, inSegment, qsNode );
								isInSegmentShorter = inSegment.upward ?
										( ptOther.x <  qsNode.seg.vFrom.x ) :
										( ptOther.x >= qsNode.seg.vFrom.x );
								qsNode = ( isInSegmentShorter ?
												inSegment.snext.upward :
												qsNode.seg.sprev.upward ) ? qsNode.left : qsNode.right;		// below : above
							}
						}
						continue;
					} else {
						compRes = this.is_left_of( qsNode.seg, ptOther, false );
						if ( compRes === 0 ) {
							// co-linear reversal (not horizontal)
							//	a co-linear continuation would not reach this point
							//  since the previous Y-node comparison would have led to a sink instead
//							console.log("ptNode: co-linear, going back on previous segment", ptMain, ptOther, qsNode );
							// now as we have two consecutive co-linear segments we have to avoid a cross-over
							//	for this we need the far point on the "next" segment to the SHORTER of our two
							//	segments to avoid that "next" segment to cross the longer of our two segments
							if ( ptMain == qsNode.seg.vFrom ) {
								// connected at qsNode.seg.vFrom
//								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vFrom", ptMain, ptOther, qsNode );
								isInSegmentShorter = inSegment.upward ?
										( ptOther.y >= qsNode.seg.vTo.y ) :
										( ptOther.y <  qsNode.seg.vTo.y );
								compRes = isInSegmentShorter ?
										this.is_left_of( qsNode.seg, inSegment.sprev.vFrom, false ) :
										-this.is_left_of( qsNode.seg, qsNode.seg.snext.vTo, false );
							} else {
								// connected at qsNode.seg.vTo
//								console.log("ptNode: co-linear, going back on previous segment, connected at qsNode.seg.vTo", ptMain, ptOther, qsNode );
								isInSegmentShorter = inSegment.upward ?
										( ptOther.y <  qsNode.seg.vFrom.y ) :
										( ptOther.y >= qsNode.seg.vFrom.y );
								compRes = isInSegmentShorter ?
										this.is_left_of( qsNode.seg, inSegment.snext.vTo, false ) :
										-this.is_left_of( qsNode.seg, qsNode.seg.sprev.vFrom, false );
							}
						}
					}
				} else {
/*					if ( ( PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vFrom ) *			// TODO: Testcase
							PNLTRI.Math.compare_pts_yx( ptMain, qsNode.seg.vTo )
						   ) == 0 ) {
						console.log("ptNode: Pts too close together#2: ", ptMain, qsNode.seg );
					}		*/
					compRes = this.is_left_of( qsNode.seg, ptMain, true );
					if ( compRes === 0 ) {
						// touching: ptMain lies on qsNode.seg but is none of its endpoints
						//	should happen quite seldom
						compRes = this.is_left_of( qsNode.seg, ptOther, false );
						if ( compRes === 0 ) {
							// co-linear: inSegment and qsNode.seg
							//	includes case with ptOther connected to qsNode.seg
							var tmpPtOther = inUseFrom ? inSegment.sprev.vFrom : inSegment.snext.vTo;
							compRes = this.is_left_of( qsNode.seg, tmpPtOther, false );
						}
					}
				}
				if ( compRes > 0 ) {
					qsNode = qsNode.left;
				} else if ( compRes < 0 ) {
					qsNode = qsNode.right;
				} else {
					// ???	TODO - not reached with current tests
					//				possible at all ?
					return qsNode;
					// qsNode = qsNode.left;		// left
					// qsNode = qsNode.right;		// right
				}
			} else {		// SINK-Node: trapezoid area
							// least often
				if ( !qsNode.trap )	{ console.log("ptNode: unknown type", qsNode); }
				if ( inUseFrom )	{ inSegment.rootFrom = qsNode; }
				else				{ inSegment.rootTo = qsNode; }
				return qsNode;
			}
		}	// end while - should not exit here
	},


 	// Add a new segment into the trapezoidation and update QueryStructure and Trapezoids
	// 1) locates the two endpoints of the segment in the QueryStructure and inserts them
	// 2) goes from the high-end trapezoid down to the low-end trapezoid
	//		changing all the trapezoids in between.
	// Except for the high-end and low-end no new trapezoids are created.
	// For all in between either:
	// - the existing trapezoid is restricted to the left of the new segment
	//		and on the right side the trapezoid from above is extended downwards
	// - or the other way round:
	//	 the existing trapezoid is restricted to the right of the new segment
	//		and on the left side the trapezoid from above is extended downwards

	add_segment: function ( inSegment ) {
		var scope = this;

		// functions handling the relationship to the upper neighbors (uL, uR)
		//	of trNewLeft and trNewRight

		function fresh_seg_or_upward_cusp() {
			// trCurrent has at most 1 upper neighbor
			//	and should also have at least 1, since the high-point trapezoid
			//	has been split off another one, which is now above
			var trUpper = trCurrent.uL || trCurrent.uR;

			// trNewLeft and trNewRight CANNOT have been extended from above
			if ( trUpper.dL && trUpper.dR ) {
				// upward cusp: top forms a triangle

				// ATTENTION: the decision whether trNewLeft or trNewRight is the
				//	triangle trapezoid formed by the two segments has already been taken
				//	when selecting trCurrent as the left or right lower neighbor to trUpper !!

				if ( trCurrent == trUpper.dL ) {
					//	*** Case: FUC_UC_LEFT; prev: ----
					// console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg to the left!" );
					//		  upper
					//   -------*-------
					//		   + \
					//	  NL  +   \
					//		 +	NR \
					//		+		\
					trNewRight.uL	= null;			// setAbove; trNewRight.uR, trNewLeft unchanged
					trUpper.dL		= trNewLeft;	// setBelow; dR: unchanged, NEVER null
				} else {
					//	*** Case: FUC_UC_RIGHT; prev: ----
					// console.log( "fresh_seg_or_upward_cusp: upward cusp, new seg from the right!" );
					//		  upper
					//   -------*-------
					//		   / +
					//		  /   +	 NR
					//		 /	NL +
					//		/		+
					trNewLeft.uR	= null;			// setAbove; trNewLeft.uL, trNewRight unchanged
					trUpper.dR		= trNewRight;	// setBelow; dL: unchanged, NEVER null
				}
			} else {
				//	*** Case: FUC_FS; prev: "splitOffLower"
				// console.log( "fresh_seg_or_upward_cusp: fresh segment, high adjacent segment still missing" );
				//		  upper
				//   -------*-------
				//		   +
				//	  NL  +
				//		 +	NR
				//		+
				trNewRight.uL = null;			// setAbove; trNewLeft unchanged, set by "splitOffLower"
				trNewRight.uR = trUpper;
				trUpper.dR = trNewRight;		// setBelow; trUpper.dL unchanged, set by "splitOffLower"
			}
 		}

		function continue_chain_from_above() {
			// trCurrent has at least 2 upper neighbors
			if ( trCurrent.usave ) {
				// 3 upper neighbors (part II)
				if ( trCurrent.uleft ) {
					//	*** Case: CC_3UN_LEFT; prev: 1B_3UN_LEFT
					// console.log( "continue_chain_from_above: 3 upper neighbors (part II): u0a, u0b, uR(usave)" );
					// => left gets one, right gets two of the upper neighbors
					// !! trNewRight cannot have been extended from above
					//		and trNewLeft must have been !!
					//		   +		/
					//	  C.uL  + C.uR / C.usave
					//    - - - -+----*----------
					//		NL	  +		NR
					trNewRight.uL = trCurrent.uR;		// setAbove
					trNewRight.uR = trCurrent.usave;
					trNewRight.uL.dL = trNewRight;		// setBelow; trNewRight.uL.dR == null, unchanged
					trNewRight.uR.dR = trNewRight;		// setBelow; trNewRight.uR.dL == null, unchanged
				} else {
					//	*** Case: CC_3UN_RIGHT; prev: 1B_3UN_RIGHT
					// console.log( "continue_chain_from_above: 3 upper neighbors (part II): uL(usave), u1a, u1b" );
					// => left gets two, right gets one of the upper neighbors
					// !! trNewLeft cannot have been extended from above
					//		and trNewRight must have been !!
					//			\		 +
					//	 C.usave \ C.uL + C.uR
					//   ---------*----+- - - -
					//			NL    +   NR
					trNewLeft.uR = trCurrent.uL;		// setAbove; first uR !!!
					trNewLeft.uL = trCurrent.usave;
					trNewLeft.uL.dL = trNewLeft;		// setBelow; dR == null, unchanged
					trNewLeft.uR.dR = trNewLeft;		// setBelow; dL == null, unchanged
				}
				trNewLeft.usave = trNewRight.usave = null;
			} else if ( trCurrent.vHigh == trFirst.vHigh ) {		// && meetsHighAdjSeg ??? TODO
				//	*** Case: CC_2UN_CONN; prev: ----
				// console.log( "continue_chain_from_above: 2 upper neighbors, fresh seg, continues high adjacent seg" );
				// !! trNewLeft and trNewRight cannot have been extended from above !!
				//	  C.uL	 /  C.uR
				//   -------*---------
				//	   NL  +	NR
				trNewRight.uR.dR = trNewRight;			// setBelow; dL == null, unchanged
				trNewLeft.uR = trNewRight.uL = null;	// setAbove; trNewLeft.uL, trNewRight.uR unchanged
			} else {
				//	*** Case: CC_2UN; prev: 1B_1UN_CONT, 2B_NOCON_RIGHT/LEFT, 2B_TOUCH_RIGHT/LEFT, 2B_COLIN_RIGHT/LEFT
				// console.log( "continue_chain_from_above: simple case, 2 upper neighbors (no usave, not fresh seg)" );
				// !! trNewLeft XOR trNewRight will have been extended from above !!
				//	  C.uL	 +  C.uR
				//   -------+---------
				//	   NL  +	NR
				if ( trNewRight == trCurrent ) {		// trNewLeft has been extended from above
					// setAbove
					trNewRight.uL = trNewRight.uR;
					trNewRight.uR = null;
					// setBelow; dR: unchanged, is NOT always null (prev: 2B_NOCON_LEFT, 2B_TOUCH_LEFT, 2B_COLIN_LEFT)
					trNewRight.uL.dL = trNewRight;
				} else {								// trNewRight has been extended from above
					trNewLeft.uR = trNewLeft.uL;	// setAbove; first uR !!!
					trNewLeft.uL = null;
				}
			}
		}

		// functions handling the relationship to the lower neighbors (dL, dR)
		//	of trNewLeft and trNewRight
		// trNewLeft or trNewRight MIGHT have been extended from above
		//  !! in that case dL and dR are different from trCurrent and MUST be set here !!

		function only_one_trap_below( inTrNext ) {

			if ( trCurrent.vLow == trLast.vLow ) {
				// final part of segment

				if ( meetsLowAdjSeg ) {
					// downward cusp: bottom forms a triangle

					// ATTENTION: the decision whether trNewLeft and trNewRight are to the
					//	left or right of the already inserted segment the new one meets here
					//	has already been taken when selecting trLast to the left or right
					//	of that already inserted segment !!

					if ( trCurrent.dL ) {
						//	*** Case: 1B_DC_LEFT; next: ----
						// console.log( "only_one_trap_below: downward cusp, new seg from the left!" );
						//		+		/
						//		 +  NR /
						//	  NL  +	  /
						//		   + /
						//   -------*-------
						//	   C.dL = next

						// setAbove
						inTrNext.uL = trNewLeft;	// uR: unchanged, NEVER null
						// setBelow part 1
						trNewLeft.dL = inTrNext;
						trNewRight.dR = null;
					} else {
						//	*** Case: 1B_DC_RIGHT; next: ----
						// console.log( "only_one_trap_below: downward cusp, new seg to the right!" );
						//		\		+
						//		 \  NL +
						//		  \	  +  NR
						//		   \ +
						//   -------*-------
						//	   C.dR = next

						// setAbove
						inTrNext.uR = trNewRight;	// uL: unchanged, NEVER null
						// setBelow part 1
						trNewLeft.dL = null;
						trNewRight.dR = inTrNext;
					}
				} else {
					//	*** Case: 1B_1UN_END; next: ----
					// console.log( "only_one_trap_below: simple case, new seg ends here, low adjacent seg still missing" );
					//			  +
					//		NL	 +  NR
					//			+
					//   ------*-------
					//		  next

					// setAbove
					inTrNext.uL = trNewLeft;									// trNewLeft must
					inTrNext.uR = trNewRight;		// must
					// setBelow part 1
					trNewLeft.dL = trNewRight.dR = inTrNext;					// Error
//					trNewRight.dR = inTrNext;
				}
				// setBelow part 2
				trNewLeft.dR = trNewRight.dL = null;
			} else {
				// NOT final part of segment

				if ( inTrNext.uL && inTrNext.uR ) {
					// inTrNext has two upper neighbors
					// => a segment ends on the upper Y-line of inTrNext
					// => inTrNext has temporarily 3 upper neighbors
					// => marks whether the new segment cuts through
					//		uL or uR of inTrNext and saves the other in .usave
					if ( inTrNext.uL == trCurrent ) {
						//	*** Case: 1B_3UN_LEFT; next: CC_3UN_LEFT
						// console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): u0a, u0b, uR(usave)" );
						//		 +		  /
						//	  NL  +	 NR	 /
						//		   +	/
						//   - - - -+--*----
						//			 +
						//		  next
//						if ( inTrNext.uR != trNewRight ) {		// for robustness	TODO: prevent
							inTrNext.usave = inTrNext.uR;
							inTrNext.uleft = true;
							// trNewLeft: L/R undefined, will be extended down and changed anyway
						// } else {
							// ERROR: should not happen
							// console.log( "ERR add_segment: Trapezoid Loop right", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
//						}
					} else {
						//	*** Case: 1B_3UN_RIGHT; next: CC_3UN_RIGHT
						// console.log( "only_one_trap_below: inTrNext has 3 upper neighbors (part I): uL(usave), u1a, u1b" );
						//	 \		   +
						//	  \	  NL  +  NR
						//	   \	 +
						//   ---*---+- - - -
						//		   +
						//		  next
//						if ( inTrNext.uL != trNewLeft ) {		// for robustness	TODO: prevent
							inTrNext.usave = inTrNext.uL;
							inTrNext.uleft = false;
							// trNewRight: L/R undefined, will be extended down and changed anyway
						// } else {
							// ERROR: should not happen
							// console.log( "ERR add_segment: Trapezoid Loop left", inTrNext, trCurrent, trNewLeft, trNewRight, inSegment, this );
//						}
					}
				//} else {
					//	*** Case: 1B_1UN_CONT; next: CC_2UN
					// console.log( "only_one_trap_below: simple case, new seg continues down" );
					//			  +
					//		NL	 +  NR
					//			+
					//   ------+-------
					//	 	  +
					//		next

					// L/R for one side undefined, which one is not fixed
					//	but that one will be extended down and changed anyway
					// for the other side, vLow must lie at the opposite end
					//	thus both are set accordingly
				}
				// setAbove
				inTrNext.uL = trNewLeft;
				inTrNext.uR = trNewRight;
				// setBelow
				trNewLeft.dR = trNewRight.dL = inTrNext;
				trNewLeft.dL = trNewRight.dR = null;
			}
		}

		function two_trap_below() {
			// Find out which one (dL,dR) is intersected by this segment and
			//	continue down that one
			var trNext;
			if ( ( trCurrent.vLow == trLast.vLow ) && meetsLowAdjSeg ) {	// meetsLowAdjSeg necessary? TODO
				//	*** Case: 2B_CON_END; next: ----
				// console.log( "two_trap_below: finished, meets low adjacent segment" );
				//			  +
				//		NL	 +  NR
				//			+
				//   ------*-------
				//	 		\  C.dR
				//	  C.dL	 \

				// setAbove
				trCurrent.dL.uL = trNewLeft;
				trCurrent.dR.uR = trNewRight;
				// setBelow; sequence of assignments essential, just in case: trCurrent == trNewLeft
				trNewLeft.dL = trCurrent.dL;
				trNewRight.dR = trCurrent.dR;
				trNewLeft.dR = trNewRight.dL = null;

				trNext = null;	      	// segment finished
			} else {
				// setAbove part 1
				trCurrent.dL.uL = trNewLeft;
				trCurrent.dR.uR = trNewRight;

				var goDownRight;
				// passes left or right of an already inserted NOT connected segment
				//	trCurrent.vLow: high-end of existing segment
				var compRes = scope.is_left_of( inSegment, trCurrent.vLow, true );
				if ( compRes > 0 ) {				// trCurrent.vLow is left of inSegment
					//	*** Case: 2B_NOCON_RIGHT; next: CC_2UN
					// console.log( "two_trap_below: (intersecting dR)" );
					//		 +
					//	  NL  +  NR
					//		   +
					//   ---*---+- - - -
					//		 \	 +
					//	 C.dL \	C.dR
					goDownRight = true;
				} else if ( compRes < 0 ) {			// trCurrent.vLow is right of inSegment
					//	*** Case: 2B_NOCON_LEFT; next: CC_2UN
					// console.log( "two_trap_below: (intersecting dL)" );
					//			  +
					//		NL	 +  NR
					//			+
					//    - - -+---*-------
					//	 	  +		\  C.dR
					//	 	 C.dL	 \
					goDownRight = false;
				} else {							// trCurrent.vLow lies ON inSegment
					var vLowSeg = trCurrent.dL.rseg;
					var directionIsUp = vLowSeg.upward;
					var otherPt = directionIsUp ? vLowSeg.vFrom : vLowSeg.vTo;
					compRes = scope.is_left_of( inSegment, otherPt, false );
					if ( compRes > 0 ) {				// otherPt is left of inSegment
						//	*** Case: 2B_TOUCH_RIGHT; next: CC_2UN
						// console.log( "two_trap_below: vLow ON new segment, touching from right" );
						//		 +
						//	  NL  +  NR
						//		   +
						//   -------*- - - -
						//		   / +
						//	 C.dL /	C.dR
						goDownRight = true;		// like intersecting dR
					} else if ( compRes < 0 ) {			// otherPt is right of inSegment
						//	*** Case: 2B_TOUCH_LEFT; next: CC_2UN
						// console.log( "two_trap_below: vLow ON new segment, touching from left" );
						//			  +
						//		NL	 +  NR
						//			+
						//    - - -*-------
						//	 	  +	\  C.dR
						//	  C.dL	 \
						goDownRight = false;	// like intersecting dL
					} else {							// otherPt lies ON inSegment
						vLowSeg = directionIsUp ? vLowSeg.snext : vLowSeg.sprev;		// other segment with trCurrent.vLow
						otherPt = directionIsUp ? vLowSeg.vTo : vLowSeg.vFrom;
						compRes = scope.is_left_of( inSegment, otherPt, false );
						if ( compRes > 0 ) {				// otherPt is left of inSegment
							//	*** Case: 2B_COLIN_RIGHT; next: CC_2UN
							// console.log( "two_trap_below: vLow ON new segment, touching from right" );
							//		  +
							//	  NL   +  NR
							//   -------*- - - -
							//	  C.dL 	\+  C.dR
							//			 \+
							goDownRight = true;		// like intersecting dR
					//	} else if ( compRes == 0 ) {		//	NOT POSSIBLE, since 3 points on a line is prevented during input of polychains
					//		goDownRight = true;		// like intersecting dR
						} else {							// otherPt is right of inSegment
							//	*** Case: 2B_COLIN_LEFT; next: CC_2UN
							// console.log( "two_trap_below: vLow ON new segment, touching from left" );
							//			   +
							//		NL	  +  NR
							//    - - - -*-------
							//	  C.dL	+/  C.dR
							//		   +/
							goDownRight = false;		// TODO: for test_add_segment_special_4 -> like intersecting dL
						}
					}
				}
				if ( goDownRight ) {
					trNext = trCurrent.dR;
					// setAbove part 2
					trCurrent.dR.uL = trNewLeft;
					// setBelow part 1
					trNewLeft.dL = trCurrent.dL;
					trNewRight.dR = null;	// L/R undefined, will be extended down and changed anyway
				} else {
					trNext = trCurrent.dL;
					// setAbove part 2
					trCurrent.dL.uR = trNewRight;
					// setBelow part 1
					trNewRight.dR = trCurrent.dR;
					trNewLeft.dL = null;	// L/R undefined, will be extended down and changed anyway
				}
				// setBelow part 2
				trNewLeft.dR = trNewRight.dL = trNext;
			}

 			return	trNext;
		}

		//
		//	main function body
		//

/*		if ( ( inSegment.sprev.vTo != inSegment.vFrom ) || ( inSegment.vTo != inSegment.snext.vFrom ) ) {
			console.log( "add_segment: inconsistent point order of adjacent segments: ",
						 inSegment.sprev.vTo, inSegment.vFrom, inSegment.vTo, inSegment.snext.vFrom );
			return;
		}		*/

		//	Find the top-most and bottom-most intersecting trapezoids -> rootXXX
		this.segNodes( inSegment );

		var segLowVert , segLowNode, meetsLowAdjSeg;		// y-min vertex
		var segHighVert, segHighNode, meetsHighAdjSeg;		// y-max vertex

		if ( inSegment.upward ) {
			segLowVert	= inSegment.vFrom;
			segHighVert	= inSegment.vTo;
			segLowNode		= inSegment.rootFrom;
			segHighNode		= inSegment.rootTo;
			// was lower point already inserted earlier? => segments meet at their ends
			meetsLowAdjSeg	= inSegment.sprev.is_inserted;
			// was higher point already inserted earlier? => segments meet at their ends
			meetsHighAdjSeg	= inSegment.snext.is_inserted;
		} else {
			segLowVert	= inSegment.vTo;
			segHighVert	= inSegment.vFrom;
			segLowNode		= inSegment.rootTo;
			segHighNode		= inSegment.rootFrom;
			meetsLowAdjSeg	= inSegment.snext.is_inserted;
			meetsHighAdjSeg	= inSegment.sprev.is_inserted;
		}

		//	insert higher vertex into QueryStructure
		if ( !meetsHighAdjSeg ) {
			// higher vertex not yet inserted => split trapezoid horizontally
			var tmpNode = this.splitNodeAtPoint( segHighNode, segHighVert, false );
			// move segLowNode to new (lower) trapezoid, if it was the one which was just split
			if ( segHighNode == segLowNode )	segLowNode = tmpNode;
			segHighNode = tmpNode;
		}
		var trFirst = segHighNode.trap;		// top-most trapezoid for this segment

		// check for robustness		// TODO: prevent
		if ( !trFirst.uL && !trFirst.uR ) {
			console.log("ERR add_segment: missing trFirst.uX: ", trFirst );
			return;
		}
		if ( trFirst.vHigh != segHighVert ) {
			console.log("ERR add_segment: trFirstHigh != segHigh: ", trFirst );
			return;
		}

		//	insert lower vertex into QueryStructure
		if ( !meetsLowAdjSeg ) {
			// lower vertex not yet inserted => split trapezoid horizontally
			segLowNode = this.splitNodeAtPoint( segLowNode, segLowVert, true );
		}
		var trLast = segLowNode.trap;			// bottom-most trapezoid for this segment

		//
		// Thread the segment into the query "tree" from top to bottom.
		// All the trapezoids which are intersected by inSegment are "split" into two.
		// For each the SINK-QsNode is converted into an X-Node and
		//  new sinks for the new partial trapezoids are added.
		// In fact a real split only happens at the top and/or bottom end of the segment
		//	since at every y-line seperating two trapezoids is traverses it
		//	cuts off the "beam" from the y-vertex on one side, so that at that side
		//	the trapezoid from above can be extended down.
		//

		var trCurrent = trFirst;

		var trNewLeft, trNewRight, trPrevLeft, trPrevRight;

		var counter = this.trapArray.length + 2;		// just to prevent infinite loop
		var trNext;
		while ( trCurrent ) {
			if ( --counter < 0 ) {
				console.log( "ERR add_segment: infinite loop", trCurrent, inSegment, this );
				return;
			}
			if ( !trCurrent.dL && !trCurrent.dR ) {
				// ERROR: no successors, cannot arise if data is correct
				console.log( "ERR add_segment: missing successors", trCurrent, inSegment, this );
				return;
			}

			var qs_trCurrent = trCurrent.sink;
			// SINK-Node -> X-Node
			qs_trCurrent.seg = inSegment;
			qs_trCurrent.trap = null;
			//
			// successive trapezoids bordered by the same segments are merged
			//  by extending the trPrevRight or trPrevLeft down
			//  and redirecting the parent X-Node to the extended sink
			// !!! destroys tree structure since several nodes now point to the same SINK-Node !!!
			// TODO: maybe it's not a problem;
			//  merging of X-Nodes is no option, since they are used as "rootFrom/rootTo" !
			//
			if ( trPrevRight && ( trPrevRight.rseg == trCurrent.rseg ) ) {
				// console.log( "add_segment: extending right predecessor down!", trPrevRight );
				trNewLeft = trCurrent;
				trNewRight = trPrevRight;
				trNewRight.vLow = trCurrent.vLow;
				// redirect parent X-Node to extended sink
				qs_trCurrent.left = new PNLTRI.QsNode( trNewLeft );			// trCurrent -> left SINK-Node
				qs_trCurrent.right = trPrevRight.sink;						// deforms tree by multiple links to trPrevRight.sink
			} else if ( trPrevLeft && ( trPrevLeft.lseg == trCurrent.lseg ) ) {
				// console.log( "add_segment: extending left predecessor down!", trPrevLeft );
				trNewRight = trCurrent;
				trNewLeft = trPrevLeft;
				trNewLeft.vLow = trCurrent.vLow;
				// redirect parent X-Node to extended sink
				qs_trCurrent.left = trPrevLeft.sink;						// deforms tree by multiple links to trPrevLeft.sink
				qs_trCurrent.right = new PNLTRI.QsNode( trNewRight );		// trCurrent -> right SINK-Node
			} else {
				trNewLeft = trCurrent;
				trNewRight = this.cloneTrap(trCurrent);
				qs_trCurrent.left = new PNLTRI.QsNode( trNewLeft );			// trCurrent -> left SINK-Node
				qs_trCurrent.right = new PNLTRI.QsNode( trNewRight );		// new clone -> right SINK-Node
			}

			// handle neighbors above
			if ( trCurrent.uL && trCurrent.uR )	{
				continue_chain_from_above();
			} else {
				fresh_seg_or_upward_cusp();
			}

			// handle neighbors below
			if ( trCurrent.dL && trCurrent.dR ) {
				trNext = two_trap_below();
			} else {
				if ( trCurrent.dL ) {
					// console.log( "add_segment: only_one_trap_below! (dL)" );
					trNext = trCurrent.dL;
				} else {
					// console.log( "add_segment: only_one_trap_below! (dR)" );
					trNext = trCurrent.dR;
				}
				only_one_trap_below( trNext );
			}

			if ( trNewLeft.rseg )	trNewLeft.rseg.trLeft = trNewRight;
			if ( trNewRight.lseg )	trNewRight.lseg.trRight = trNewLeft;
			trNewLeft.rseg = trNewRight.lseg  = inSegment;
			inSegment.trLeft = trNewLeft;
			inSegment.trRight = trNewRight;

			// further loop-step down ?
			if ( trCurrent.vLow != trLast.vLow ) {
				trPrevLeft = trNewLeft;
				trPrevRight = trNewRight;

				trCurrent = trNext;
			} else {
				trCurrent = null;
			}
		}	// end while

		inSegment.is_inserted = true;
		// console.log( "add_segment: ###### DONE ######" );
	},

	// Assigns a depth to all trapezoids;
	//	0: outside, 1: main polygon, 2: holes, 3:polygons in holes, ...
	// Checks segment orientation and marks those polygon chains for reversal
	//	where the polygon inside lies to their right (contour in CW, holes in CCW)
	assignDepths: function ( inPolyData ) {
		var thisDepth = [ this.trapArray[0] ];
		var nextDepth = [];

		var thisTrap, borderSeg, curDepth = 0;
		do {
			// rseg should exactely go upward on trapezoids inside the polygon (odd depth)
			var expectedRsegUpward = ( ( curDepth % 2 ) == 1 );
			while ( thisTrap = thisDepth.pop() ) {			// assignment !
				if ( thisTrap.depth != -1 )	continue;
				thisTrap.depth = curDepth;
				//
				if ( thisTrap.uL )	thisDepth.push( thisTrap.uL );
				if ( thisTrap.uR )	thisDepth.push( thisTrap.uR );
				if ( thisTrap.dL )	thisDepth.push( thisTrap.dL );
				if ( thisTrap.dR )	thisDepth.push( thisTrap.dR );
				//
				if ( ( borderSeg = thisTrap.lseg ) && ( borderSeg.trLeft.depth == -1 ) )	// assignment !
					nextDepth.push( borderSeg.trLeft );
				if ( borderSeg = thisTrap.rseg ) {											// assignment !
					if ( borderSeg.trRight.depth == -1 )
						nextDepth.push( borderSeg.trRight );
					if ( borderSeg.upward != expectedRsegUpward )
						inPolyData.set_PolyLeft_wrong( borderSeg.chainId );
				}
			}
			thisDepth = nextDepth; nextDepth = [];
			curDepth++;
		} while ( thisDepth.length > 0 );
	},

	// creates the visibility map:
	//	for each vertex the list of all vertices in CW order which are directly
	//	visible through neighboring trapezoids and thus can be connected by a diagonal

	create_visibility_map: function ( inPolygonData ) {
		// positional slots for neighboring trapezoid-diagonals
		var DIAG_UL = 0, DIAG_UM = 1, DIAG_ULR = 2, DIAG_UR = 3;
		var DIAG_DR = 4, DIAG_DM = 5, DIAG_DLR = 6, DIAG_DL = 7;

		var i, j;
		var nbVertices = inPolygonData.nbVertices();

		// initialize arrays for neighboring trapezoid-diagonals and vertices
		var myVisibleDiagonals	= new Array(nbVertices);
		for ( i = 0; i < nbVertices; i++ ) {
			myVisibleDiagonals[i] = new Array(DIAG_DL+1);
		}
		// create the list of neighboring trapezoid-diagonals
		//	put into their positional slots
		var myExternalNeighbors = new Array(nbVertices);
		for ( i = 0, j = this.trapArray.length; i < j; i++ ) {
			var curTrap = this.trapArray[i];
			var highPos = curTrap.uL ?
						( curTrap.uR ? DIAG_DM : DIAG_DL ) :
						( curTrap.uR ? DIAG_DR : DIAG_DLR );
			var lowPos = curTrap.dL ?
						( curTrap.dR ? DIAG_UM : DIAG_UL ) :
						( curTrap.dR ? DIAG_UR : DIAG_ULR );

			if ( ( curTrap.depth % 2 ) == 1 ) {		// inside ?
				if ( ( highPos == DIAG_DM ) || ( lowPos == DIAG_UM ) ||
					 ( ( highPos == DIAG_DL ) && ( lowPos == DIAG_UR ) ) ||
					 ( ( highPos == DIAG_DR ) && ( lowPos == DIAG_UL ) ) ) {
					var lhDiag = inPolygonData.appendDiagonalsEntry( {
									vFrom: curTrap.vLow, vTo: curTrap.vHigh,
									mprev: null, mnext: null, marked: false } );
					var hlDiag = inPolygonData.appendDiagonalsEntry( {
									vFrom: curTrap.vHigh, vTo: curTrap.vLow, revDiag: lhDiag,
									mprev: null, mnext: null, marked: false } );
					lhDiag.revDiag = hlDiag;
					myVisibleDiagonals[ curTrap.vLow.id][ lowPos] = lhDiag;
					myVisibleDiagonals[curTrap.vHigh.id][highPos] = hlDiag;
				}
			} else {		// outside, hole
				if ( curTrap.vHigh.id !== null )	myExternalNeighbors[curTrap.vHigh.id] = highPos;
				if ( curTrap.vLow.id  !== null )	myExternalNeighbors[ curTrap.vLow.id] = lowPos;
			}
		}
		// create the list of outgoing diagonals in the right order (CW)
		//	from the ordered list of neighboring trapezoid-diagonals
		//	- starting from an external one
		// and connect those incoming to
		var curDiag, curDiags, firstElem, fromVertex, lastIncoming;
		for ( i = 0; i < nbVertices; i++ ) {
			curDiags  = myVisibleDiagonals[i];
			firstElem = myExternalNeighbors[i];
			if ( firstElem == null )	continue;		// eg. skipped vertices (zero length, co-linear		// NOT: === !
			j = firstElem;
			lastIncoming = null;
			do {
				if ( j++ > DIAG_DL )			j = DIAG_UL;	// circular positional list
				if ( curDiag = curDiags[j] ) {
					if ( lastIncoming ) {
						curDiag.mprev = lastIncoming;
						lastIncoming.mnext = curDiag;
					} else {
						fromVertex = curDiag.vFrom;
						fromVertex.firstOutDiag = curDiag;
					}
					lastIncoming = curDiag.revDiag;
				}
			} while ( j != firstElem );
			if ( lastIncoming )		fromVertex.lastInDiag = lastIncoming;
		}
	},


};


/*==============================================================================
 *
 *============================================================================*/

PNLTRI.Trapezoider = function ( inPolygonData ) {

	this.polyData		= inPolygonData;
	this.queryStructure	= new PNLTRI.QueryStructure( this.polyData );

};

PNLTRI.Trapezoider.prototype = {

	constructor: PNLTRI.Trapezoider,


	/*
	 * Mathematics helper methods
	 */

	optimise_randomlist: function ( inOutSegListArray ) {
		// makes sure that the first N segments are one from each of the N polygon chains
		var mainIdx = 0;
		var helpIdx = this.polyData.nbPolyChains();
		if ( helpIdx == 1 )		return;
		var chainMarker = new Array(helpIdx);
		var oldSegListArray = inOutSegListArray.concat();
		for (var i=0; i<oldSegListArray.length; i++) {
			var chainId = oldSegListArray[i].chainId;
			if ( chainMarker[chainId] ) {
				inOutSegListArray[helpIdx++] = oldSegListArray[i];
			} else {
				inOutSegListArray[mainIdx++] = oldSegListArray[i];
				chainMarker[chainId] = true;
			}
		}
	},


	/*
	 * main methods
	 */

	// Creates the trapezoidation of the polygon
	//  and assigns a depth to all trapezoids (odd: inside, even: outside).

	trapezoide_polygon: function () {							// <<<< public
		var randSegListArray = this.polyData.getSegments().concat();
//		console.log( "Polygon Chains: ", dumpSegmentList( randSegListArray ) );
		PNLTRI.Math.array_shuffle( randSegListArray );
		this.optimise_randomlist( randSegListArray );
//		console.log( "Random Segment Sequence: ", dumpRandomSequence( randSegListArray ) );

		var nbSegs = randSegListArray.length;
		var myQs = this.queryStructure;

		var i, current = 0, logstar = nbSegs;
		while ( current < nbSegs ) {
			// The CENTRAL mechanism for the near-linear performance:
			//	stratefies the loop through all segments into log* parts
			//	and computes new root-Nodes for the remaining segments in each
			//	partition.
			logstar = Math.log(logstar)/Math.LN2;		// == log2(logstar)
			var partEnd = ( logstar > 1 ) ? Math.floor( nbSegs / logstar ) : nbSegs;

			// Core: adds next partition of the segments
			for (; current < partEnd; current++ ) { myQs.add_segment( randSegListArray[current] ); }
//			console.log( nbSegs, current );

			// To speed up the segment insertion into the trapezoidation
			//	the endponts of those segments not yet inserted
			//	are repeatedly pre-located,
			// thus their final location-query can start at the top of the
			//	appropriate sub-tree instead of the root of the whole
			//	query structure.
			//
			for (i = current; i < nbSegs; i++) { this.queryStructure.segNodes( randSegListArray[i] ); }
		}

		myQs.assignDepths( this.polyData );
		// cleanup to support garbage collection
		for (i = 0; i < nbSegs; i++) { randSegListArray[i].trLeft = randSegListArray[i].trRight = null; }
	},

	// Creates a visibility map:
	//	for each vertex the list of all vertices in CW order which are directly
	//	visible through neighboring trapezoids and thus can be connected by a diagonal

	create_visibility_map: function () {
		return	this.queryStructure.create_visibility_map( this.polyData );
	},

};

/**
 * @author jahting / http://www.ameco.tv/
 *
 *	Algorithm to split a polygon into uni-y-monotone sub-polygons
 *
 *	1) creates a trapezoidation of the main polygon according to Seidel's
 *	   algorithm [Sei91]
 *	2) uses diagonals of the trapezoids as additional segments
 *		to split the main polygon into uni-y-monotone sub-polygons
 */

PNLTRI.MonoSplitter = function ( inPolygonData ) {

	this.polyData = inPolygonData;

	this.trapezoider = null;

};


PNLTRI.MonoSplitter.prototype = {

	constructor: PNLTRI.MonoSplitter,


	monotonate_trapezoids: function () {					// <<<<<<<<<< public
		// Trapezoidation
		this.trapezoider = new PNLTRI.Trapezoider( this.polyData );
		//	=> one triangular trapezoid which lies inside the polygon
		this.trapezoider.trapezoide_polygon();

		// create segments for diagonals
		this.trapezoider.create_visibility_map();
		// create mono chains by inserting diagonals
		this.polyData.create_mono_chains();

		// create UNIQUE monotone sub-polygons
		this.polyData.unique_monotone_chains_max();
	},

};

/**
 * @author jahting / http://www.ameco.tv/
 *
 *	Algorithm to triangulate uni-y-monotone polygons [FoM84]
 *
 *	expects list of doubly linked monoChains, with Y-max as first vertex
 */


PNLTRI.MonoTriangulator = function ( inPolygonData ) {

	this.polyData	= inPolygonData;

};


PNLTRI.MonoTriangulator.prototype = {

	constructor: PNLTRI.MonoTriangulator,


	// Pass each uni-y-monotone polygon with start at Y-max for greedy triangulation.

	triangulate_all_polygons: function () {					// <<<<<<<<<< public
		var	normedMonoChains = this.polyData.getMonoSubPolys();
		this.polyData.clearTriangles();
		for ( var i=0; i<normedMonoChains.length; i++ ) {
			// loop through uni-y-monotone chains
			// => monoPosmin is next to monoPosmax (left or right)
			var monoPosmax = normedMonoChains[i];
			var prevMono = monoPosmax.mprev;
			var nextMono = monoPosmax.mnext;

			if ( nextMono.mnext == prevMono ) {		// already a triangle
				this.polyData.addTriangle( monoPosmax.vFrom, nextMono.vFrom, prevMono.vFrom );
			} else {								// triangulate the polygon
				this.triangulate_monotone_polygon( monoPosmax );
			}
		}
	},

	//	algorithm to triangulate an uni-y-monotone polygon in O(n) time.[FoM84]

	triangulate_monotone_polygon: function ( monoPosmax ) {			// private
		var scope = this;

		function error_cleanup() {
			// Error in algorithm OR polygon is not uni-y-monotone
			console.log( "ERR uni-y-monotone: only concave angles left", vertBackLog );
			// push all "wrong" triangles => loop ends
			while (vertBackLogIdx > 1) {
				vertBackLogIdx--;
				scope.polyData.addTriangle(	vertBackLog[vertBackLogIdx-1],
											vertBackLog[vertBackLogIdx],
											vertBackLog[vertBackLogIdx+1] );
			}
		}

		//
		// Decisive for this algorithm to work correctly is to make sure
		//  the polygon stays uni-y-monotone when cutting off ears, i.e.
		//  to make sure the top-most and bottom-most vertices are removed last
		// Usually this is done by handling the LHS-case ("LeftHandSide is a single segment")
		//	and the RHS-case ("RightHandSide segment is a single segment")
		//	differently by starting at the bottom for LHS and at the top for RHS.
		// This is not necessary. It can be seen easily, that starting
		//	from the vertex next to top handles both cases correctly.
		//

		var frontMono = monoPosmax.mnext;		// == LHS: YminPoint; RHS: YmaxPoint.mnext
		var endVert = monoPosmax.vFrom;

		var vertBackLog = [ frontMono.vFrom ];
		var vertBackLogIdx = 0;

		frontMono = frontMono.mnext;
		var frontVert = frontMono.vFrom;

		// check for robustness		// TODO
		if (frontVert == endVert)	return;		// Error: only 2 vertices

		while ( (frontVert != endVert) || (vertBackLogIdx > 1) ) {
			if ( vertBackLogIdx > 0 ) {
				// vertBackLog is not empty
				var insideAngleCCW = PNLTRI.Math.ptsCrossProd( vertBackLog[vertBackLogIdx], frontVert, vertBackLog[vertBackLogIdx-1] );
				if ( Math.abs(insideAngleCCW) <= PNLTRI.Math.EPSILON_P ) {
					// co-linear
					if ( (frontVert == endVert) ||		// all remaining triangles are co-linear (180 degree)
						 ( PNLTRI.Math.compare_pts_yx( vertBackLog[vertBackLogIdx], frontVert ) ==				// co-linear-reversal
						   PNLTRI.Math.compare_pts_yx( vertBackLog[vertBackLogIdx], vertBackLog[vertBackLogIdx-1] ) ) ) {
						insideAngleCCW = 1;		// => create triangle
					}
				}
				if ( insideAngleCCW > 0 ) {
					// convex corner: cut if off
					this.polyData.addTriangle( vertBackLog[vertBackLogIdx-1], vertBackLog[vertBackLogIdx], frontVert );
					vertBackLogIdx--;
				} else {
					// non-convex: add frontVert to the vertBackLog
					vertBackLog[++vertBackLogIdx] = frontVert;
					if (frontVert == endVert)	error_cleanup();	// should never happen !!
					else {
						frontMono = frontMono.mnext;
						frontVert = frontMono.vFrom;
					}
				}
			} else {
				// vertBackLog contains only start vertex:
				//	add frontVert to the vertBackLog and advance frontVert
				vertBackLog[++vertBackLogIdx] = frontVert;
				frontMono = frontMono.mnext;
				frontVert = frontMono.vFrom;
			}
		}
		// reached the last vertex. Add in the triangle formed
		this.polyData.addTriangle( vertBackLog[vertBackLogIdx - 1], vertBackLog[vertBackLogIdx], frontVert );
	},

};

/**
 * @author jahting / http://www.ameco.tv/
 */

/*******************************************************************************
 *
 *	Triangulator for Simple Polygons with Holes
 *
 *  polygon with holes:
 *	- one closed contour polygon chain
 *  - zero or more closed hole polygon chains
 *
 *	polygon chain (closed):
 *	- Array of vertex Objects with attributes "x" and "y"
 *		- representing the sequence of line segments
 *		- closing line segment (last->first vertex) is implied
 *		- line segments are non-zero length and non-crossing
 *
 *	"global vertex index":
 *	- vertex number resulting from concatenation all polygon chains (starts with 0)
 *
 *
 *	Parameters (will not be changed):
 *		inPolygonChains:
 *		- Array of polygon chains
 *
 *	Results (are a fresh copy):
 *		triangulate_polygon:
 *		- Array of Triangles ( Array of 3 "global vertex index" values )
 *
 ******************************************************************************/

PNLTRI.Triangulator = function () {

	this.lastPolyData = null;		// for Debug purposes only

};


PNLTRI.Triangulator.prototype = {

	constructor: PNLTRI.Triangulator,


	clear_lastData: function () {	// save memory after Debug
		this.lastPolyData = null;
	},

	// for the polygon data AFTER triangulation
	//	returns an Array of flags, one flag for each polygon chain:
	//		lies the inside of the polygon to the left?
	//		"true" implies CCW for contours and CW for holes
	get_PolyLeftArr: function () {
		if ( this.lastPolyData )	return this.lastPolyData.get_PolyLeftArr();
		return	null;
	},


	triangulate_polygon: function ( inPolygonChains, inForceTrapezoidation ) {

		// collected conditions for selecting EarClipTriangulator over Seidel's algorithm
		function is_basic_polygon() {
			if (inForceTrapezoidation)	return	false;
			return	( myPolygonData.nbPolyChains() == 1 );
		}


		this.clear_lastData();
		if ( ( !inPolygonChains ) || ( inPolygonChains.length === 0 ) )		return	[];
		//
		// initializes general polygon data structure
		//
		var myPolygonData = new PNLTRI.PolygonData( inPolygonChains );
		//
		var basicPolygon = is_basic_polygon();
		var	myTriangulator;
		if ( basicPolygon ) {
			//
			// triangulates single polygon without holes
			//
			myTriangulator = new PNLTRI.EarClipTriangulator( myPolygonData );
			basicPolygon = myTriangulator.triangulate_polygon_no_holes();
		}
		if ( !basicPolygon ) {
			//
			// splits polygon into uni-y-monotone sub-polygons
			//
			var	myMonoSplitter = new PNLTRI.MonoSplitter( myPolygonData );
			myMonoSplitter.monotonate_trapezoids();
			//
			// triangulates all uni-y-monotone sub-polygons
			//
			myTriangulator = new PNLTRI.MonoTriangulator( myPolygonData );
			myTriangulator.triangulate_all_polygons();
		}
		//
		this.lastPolyData = myPolygonData;
		return	myPolygonData.getTriangles();	// copy of triangle list
	}


};

return PNLTRI;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/PolygonRenderer',['../Utils/Constants','../Utils/Utils','./VectorRenderer','./VectorRendererManager','./FeatureStyle','./Program','./BatchRenderable','./pnltri','./GeoBound'],
	function(Constants, Utils,VectorRenderer,VectorRendererManager,FeatureStyle,Program,BatchRenderable,PNLTRI,GeoBound) {


/**************************************************************************************************************/
 /**
	 @name PolygonRenderer
	 @class
	   Basic renderer for polygon
	 @param {AbstractGlobe} globe AbstractGlobe
 	 @augments VectorRenderer
	 @constructor
	 */
var PolygonRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	this.maxTilePerGeometry = 2;
	this.renderContext = globe.renderContext;
	this.defaultVertexShader = "attribute vec3 vertex;\n";
	this.defaultVertexShader+= "uniform mat4 mvp;\n";
	this.defaultVertexShader+= "void main(void) \n";
	this.defaultVertexShader+= "{\n";
	this.defaultVertexShader+= "	gl_Position = mvp * vec4(vertex, 1.0);\n";
	this.defaultVertexShader+= "}\n";

	this.extrudeVertexShader = "attribute vec3 vertex;\n";
	this.extrudeVertexShader+= "attribute vec4 normal;\n";
	this.extrudeVertexShader+= "uniform float extrusionScale; \n";
	this.extrudeVertexShader+= "uniform mat4 mvp;\n";
	this.extrudeVertexShader+= "void main(void) \n";
	this.extrudeVertexShader+= "{\n";
	this.extrudeVertexShader+= "	vec3 extrudedVertex = vertex + normal.w * vec3(normal.x, normal.y, normal.z) * extrusionScale;";
	this.extrudeVertexShader+= "	gl_Position = mvp * vec4(extrudedVertex, 1.0);\n";
	this.extrudeVertexShader+= "}\n";

	this.fragmentShader = "precision lowp float; \n";
	this.fragmentShader+= "uniform vec4 u_color;\n";
	this.fragmentShader+= "void main(void)\n";
	this.fragmentShader+= "{\n";
	this.fragmentShader+= "	gl_FragColor = u_color;\n";
	this.fragmentShader+= "	//if (u_color.a == 0.0) discard;\n";
	this.fragmentShader+= "}\n";

	this.program = new Program(globe.renderContext);
	this.program.createFromSource(this.defaultVertexShader, this.fragmentShader);

	this.extrudeProgram = new Program(globe.renderContext);
	this.extrudeProgram.createFromSource(this.extrudeVertexShader, this.fragmentShader );
};

/**************************************************************************************************************/

Utils.inherits(VectorRenderer,PolygonRenderer);

/**************************************************************************************************************/

 /**
	@name PolygonRenderable
	@class
		Renderable constructor for Polygon
	@param {Bucket} bucket Bucket
	@augments BatchRenderable
	@constructor
	*/
var PolygonRenderable = function(bucket)
{
	BatchRenderable.prototype.constructor.call( this, bucket );

	this.origin = null;

	this.vertexSize = bucket.style.extrude ? 7 : 3;
	this.matrix = mat4.create();
};

Utils.inherits(BatchRenderable,PolygonRenderable);

/**************************************************************************************************************/

/**
 * Create an interpolated for polygon clipping
 */
var _createInterpolatedVertex = function( t, p1, p2 )
{
	return [ p1[0] + t * (p2[0] - p1[0]), p1[1] + t * (p2[1] - p1[1]) ];
};

/**************************************************************************************************************/

/**
	Clip polygon to a side
 */
var clipPolygonToSide = function( coord, sign, value, polygon )
{
	var clippedPolygon = [];
	var t,newPoint;
	// iterate through vertices
	for ( var i = 0; i < polygon.length; i++ )
	{
		var p1 = polygon[i];
		var p2 = polygon[ (i+1) % polygon.length ];
		var val1 = p1[coord];
		var val2 = p2[coord];

		// test containement
		var firstInside = (val1 - value) * sign >= 0.0;
		var secondInside = (val2 - value) * sign >= 0.0;

		// output vertices for inside polygon
		if ( !firstInside && secondInside )
		{
			t = (value - val1) / (val2- val1);
			newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && secondInside )
		{
			clippedPolygon.push( p2 );
		}
		else if ( firstInside && !secondInside )
		{
			t = (value - val1) / (val2- val1);
			newPoint = _createInterpolatedVertex( t, p1, p2 );
			clippedPolygon.push( newPoint );
		}
	}

	return clippedPolygon;
};

/**************************************************************************************************************/

/**
	Clip polygon
 */
 var clipPolygon = function( coordinates, bound )
{
	var c;
	c = clipPolygonToSide( 0, 1, bound.west, coordinates );
	c = clipPolygonToSide( 0, -1, bound.east, c );
	c = clipPolygonToSide( 1, 1, bound.south, c );
	c = clipPolygonToSide( 1, -1, bound.north, c );
	return c
};

/**************************************************************************************************************/

/**
  Check if a geometry crosses the date line
*/
var _fixDateLine = function( coords ) {
	//return [coords];
    var crossDateLine = false;
 	for (var i = 1; i < coords.length && !crossDateLine; i++) {
		var deltaLon = Math.abs(coords[i][0] - coords[i-1][0] );
		if (deltaLon > 180 && deltaLon < 360) {
			// DateLine!
			crossDateLine = true;
		}
	}
	var n;
	if (crossDateLine) {

		// Ensure coordinates are always negative
		var negCoords = [];
		for (n = 0; n < coords.length; n++) {
			if (coords[n][0] > 0) {
				negCoords[n] = [coords[n][0] - 360, coords[n][1]];
			} else {
				negCoords[n] = [coords[n][0], coords[n][1]];
			}
		}

		var posCoords = [];
		// Ensure coordinates are always positive
		for (n = 0; n < coords.length; n++) {
			if (coords[n][0] < 0) {
				posCoords[n] = [coords[n][0] + 360, coords[n][1]];
			} else {
				posCoords[n] = [coords[n][0], coords[n][1]];
			}
		}


		return [posCoords,negCoords];
	}
	else {
		return [coords];
	}
};


/**************************************************************************************************************/


/**
 * Add a geometry to the renderbale
 * Vertex buffer : geometry|extrude
 * Index buffer : geometry triangles|extrude triangles|lines
 * Normal buffer : normals.xyz, extrude value as w
 * @function build
 * @memberof PolygonRenderable.prototype
 * @param geometry
 */
PolygonRenderable.prototype.build = function(geometry)
{

	var renderer = this.bucket.renderer;
	var style = this.bucket.style;
	var coordinateSystem = renderer.globe.getCoordinateSystem();

	var polygons =  (geometry.type === Constants.GEOMETRY.MultiPolygon) ? geometry.coordinates : [geometry.coordinates];

	var geometryBound = new GeoBound();
	var csBound = new GeoBound(coordinateSystem.getGeoBound().getWest(),coordinateSystem.getGeoBound().getSouth(),coordinateSystem.getGeoBound().getEast(),coordinateSystem.getGeoBound().getNorth());
	var convertedCoord = geometryBound.computeFromCoordinatesInCrsTo(polygons[0][0], geometry.crs.properties.name, coordinateSystem);
	if
		(!geometryBound.intersects(csBound))
	{
		return;
	}


	var pos3d = vec3.create();
	var i,n;
	if (!this.origin)
	{
		this.origin = vec3.create();
		coordinateSystem.get3DFromWorld(convertedCoord[0], this.origin); // Correction : add [0]

		mat4.identity(this.matrix);
		mat4.translate(this.matrix,this.origin);
	}

	var lastIndex = this.vertices.length / this.vertexSize;
	var offset = this.vertices.length;
	var upOffset,lowOffset;

	var contours = [];
	for ( n=0; n < polygons.length; n++ ) {

		contours = contours.concat( _fixDateLine(polygons[n][0]) );
	}


	for ( n=0; n < contours.length; n++ ) {

		var coords = clipPolygon(contours[n],csBound);

		offset = this.vertices.length;

		// Build upper polygon vertices
		var clockwise = 0;
		for ( i=0; i < coords.length; i++)
		{
			// Always use coordinates at zero height on vertex construction, height will be taken into account on extrude
			coordinateSystem.get3DFromWorldInCrs([ coords[i][0], coords[i][1], 0.0 ], geometry.crs.properties.name, pos3d);
			this.vertices[offset] = pos3d[0] - this.origin[0];
			this.vertices[offset+1] = pos3d[1] - this.origin[1];
			this.vertices[offset+2] = pos3d[2] - this.origin[2];

			// Find out if its vertices ordered clockwise to build index buffer properly
			if ( i < coords.length - 1 ) {
				clockwise += (coords[i+1][0] - coords[i][0]) * (coords[i+1][1] + coords[i][1]);
			}

			if ( style.extrude )
			{
				// Compute normals
				vec3.normalize(pos3d);
				this.vertices[offset+3] = pos3d[0];
				this.vertices[offset+4] = pos3d[1];
				this.vertices[offset+5] = pos3d[2];
				var extrudeValue;
				if ( typeof style.extrude === "boolean" )
				{
					// Extrude value extracted from KML, use the height coordinate
					extrudeValue = coords[i][2];
				}
				else
				{
					// Extrude value is a float defined by user
					extrudeValue = style.extrude;
				}
				this.vertices[offset+6] = extrudeValue * coordinateSystem.geoide.heightScale;
			}

			offset += this.vertexSize;
		}

		// Build bottom polygon vertices on extrude
		if ( style.extrude )
		{
			// Use same vertices as upper polygon but resest the 4-th compoenent
			var prevOffset = lastIndex * this.vertexSize;
			this.vertices = this.vertices.concat( this.vertices.slice(prevOffset, offset) );
			// Reset the 4-th component for extrusion
			for ( i=offset; i < this.vertices.length; i+= this.vertexSize)
			{
				this.vertices[i+6] = 0.0;
			}
		}

		// Build triangle indices for upper polygon
		var triangulator = new PNLTRI.Triangulator();
		var contour = coords.map( function(value) {  return { x: value[0], y: value[1] }; });
		var triangList = triangulator.triangulate_polygon( [ contour ] );
		for (i=0; i<triangList.length; i++ )
		{
			this.triIndices.push(lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][2] );
			//this.lineIndices.push( lastIndex + triangList[i][0], lastIndex + triangList[i][1], lastIndex + triangList[i][1], lastIndex + triangList[i][2], lastIndex + triangList[i][2], lastIndex + triangList[i][0] );
		}


		// Build side triangle indices
		if ( style.extrude )
		{
			upOffset = lastIndex;
			lowOffset = lastIndex + coords.length;

			for (i = 0; i < coords.length-1; i++ )
			{
				// Depending on vertice order, push the
				if ( clockwise > 0 )
				{
					this.triIndices.push( upOffset, upOffset + 1, lowOffset );
					this.triIndices.push( upOffset + 1, lowOffset + 1, lowOffset );
				}
				else
				{
					this.triIndices.push( upOffset, lowOffset, upOffset + 1 );
					this.triIndices.push( upOffset + 1, lowOffset, lowOffset + 1 );
				}
				upOffset += 1;
				lowOffset += 1;
			}
		}

		// Build line indices for upper polygon
		for ( i = 0; i < coords.length-1; i++ )
		{
			this.lineIndices.push( lastIndex + i, lastIndex + i + 1 );
		}

		// Build top-to-bottom line indices
		if ( style.extrude )
		{
			upOffset = lastIndex;
			lowOffset = lastIndex + coords.length;
			for ( i = 0; i < coords.length-1; i++ )
			{
				this.lineIndices.push( upOffset + i, lowOffset + i );
			}
		}

		// Update last index
		lastIndex = this.vertices.length / this.vertexSize;
	}
	// Geometry is always added contrary to tiled renderables
	return true;
};

/**************************************************************************************************************/

 /**
	@name PolygonBucket
	@class
		Bucket constructor for PolygonRenderer
	@param layer
	@param style
	@constructor
	*/
var PolygonBucket = function(layer,style)
{
	this.layer = layer;
	this.style = style;
	this.renderer = null;
};

/**************************************************************************************************************/

/**
 * Create a renderable for this bucket
 * @function createRenderable
 * @memberof PolygonBucket.prototype
 * @return {PolygonRenderable} Renderable
 */
PolygonBucket.prototype.createRenderable = function()
{
	return new PolygonRenderable(this);
};

/**************************************************************************************************************/

/**
 * Check if a bucket is compatible
 * @function isCompatible
 * @memberof PolygonBucket.prototype
 * @param style
 * @return {Boolean} Is compatible ?
 */
PolygonBucket.prototype.isCompatible = function(style)
{
	return this.style === style;
};

/**************************************************************************************************************/

/**
 * 	Render all the polygons
 * @function render
 * @memberof PolygonRenderer.prototype
 * @param renderables
 * @param {Integer} start Start index
 * @param {Integer} end End index
 */
PolygonRenderer.prototype.render = function(renderables, start, end)
{
	var renderContext = this.globe.renderContext;
	var gl = renderContext.gl;

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.depthFunc(gl.LEQUAL);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(-2.0,-2.0);
	//gl.disable(gl.DEPTH_TEST);

	var currentProgram = null;

	// Compute the viewProj matrix
	var viewProjMatrix = mat4.create();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, viewProjMatrix);

	var modelViewProjMatrix = mat4.create();
	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var style = renderable.bucket.style;

		// Setup program
		var program = style.extrude ? this.extrudeProgram : this.program;
		if ( program !== currentProgram )
		{
			program.apply();
			currentProgram = program;
		}

		mat4.multiply(viewProjMatrix,renderable.matrix,modelViewProjMatrix);
		gl.uniformMatrix4fv(program.uniforms.mvp, false, modelViewProjMatrix);
		gl.uniform4f(program.uniforms.u_color, style.fillColor[0], style.fillColor[1], style.fillColor[2],
				style.fillColor[3] * renderable.bucket.layer.opacity);  // use fillColor

		renderable.bindBuffers(renderContext);
		gl.lineWidth( style.strokeWidth );

		// Setup attributes
		gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 4 * renderable.vertexSize, 0);
		if ( style.extrude )
		{
			gl.vertexAttribPointer(program.attributes.normal, 4, gl.FLOAT, false, 4 * renderable.vertexSize, 12);
			gl.uniform1f(program.uniforms.extrusionScale, style.extrusionScale);
		}

		// Draw
		gl.drawElements( gl.TRIANGLES, renderable.triIndices.length, renderable.indexType, 0);
		if ( renderable.lineIndices.length > 0 )
		{
			gl.uniform4f(program.uniforms.u_color, style.strokeColor[0], style.strokeColor[1], style.strokeColor[2], style.strokeColor[3] * renderable.bucket.layer.opacity);
			var size = renderable.indexType === gl.UNSIGNED_INT ? 4 : 2;
			gl.drawElements( gl.LINES, renderable.lineIndices.length, renderable.indexType, renderable.triIndices.length * size);
		}
	}

	// Revert line width
	gl.lineWidth(1.0);

	//gl.enable(gl.DEPTH_TEST);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc(gl.LESS);
	gl.disable(gl.BLEND);
};

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 * @function canApply
 * @memberof PolygonRenderer.prototype
 * @param type
 * @param style
 * @return {Boolean} Can apply ?
 */
PolygonRenderer.prototype.canApply = function(type,style)
{
	return (type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon) && style.fill;
};

/**************************************************************************************************************/

/**
 * Create a bucket
 * @function createBucket
 * @memberof PolygonRenderer.prototype
 * @param layer
 * @param style
 * @return {PolygonBucket} Bucket
 */
PolygonRenderer.prototype.createBucket = function(layer,style)
{
	return new PolygonBucket(layer,style);
};

/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new PolygonRenderer(globe); } );

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/LineRenderer',['../Utils/Constants','../Utils/Utils', '../Utils/Numeric', './VectorRenderer','./VectorRendererManager','./Program','./BatchRenderable'],
	function(Constants,Utils,Numeric,VectorRenderer,VectorRendererManager,Program,BatchRenderable) {

/**************************************************************************************************************/

 /**
 	@name LineRenderer
 	@class
 	 Basic renderer to animate lines with gradient color texture
 	@param {AbstractGlobe} globe AbstractGlobe
 	@constructor
 	*/
var LineRenderer = function(globe)
{
	VectorRenderer.prototype.constructor.call( this, globe );
	this.maxTilePerGeometry = 2;
	this.renderContext = globe.getRenderContext();

	this.defaultVertexShader = "attribute vec4 vertex;\n";
	this.defaultVertexShader+= "uniform mat4 mvp;\n";
	this.defaultVertexShader+= "varying float s;\n";
	this.defaultVertexShader+= "void main(void) \n";
	this.defaultVertexShader+= "{\n";
	this.defaultVertexShader+= "	s = vertex.w;\n";
	this.defaultVertexShader+= "	gl_Position = mvp * vec4(vertex.xyz, 1.0);\n";
	this.defaultVertexShader+= "}\n";

	this.fragmentShader = "precision lowp float; \n";
	this.fragmentShader+= "uniform vec4 u_color;\n";
	this.fragmentShader+= "uniform float speed;\n";
	this.fragmentShader+= "uniform float time;\n";
	this.fragmentShader+= "uniform float gradientLength;\n";
	this.fragmentShader+= "varying float s;\n";
	this.fragmentShader+= "uniform sampler2D colorTexture;\n";
	this.fragmentShader+= "void main(void)\n";
	this.fragmentShader+= "{\n";
	this.fragmentShader+= "	// 0.5 is a time scale parameter, parametrize it ?\n";
	this.fragmentShader+= "	float m = speed * time * 0.5;\n";
	this.fragmentShader+= "	float u = (-s+m)/gradientLength;\n";
	this.fragmentShader+= "	gl_FragColor.rgb = texture2D(colorTexture, vec2(u,0.)).rgb;\n";
	this.fragmentShader+= "	// TODO: handle appereance of rivers\n";
	this.fragmentShader+= "	if ( s < m )\n";
	this.fragmentShader+= "	{\n";
	this.fragmentShader+= "		gl_FragColor.a = 1.0;\n";
	this.fragmentShader+= "	}\n";
	this.fragmentShader+= "	else\n";
	this.fragmentShader+= "	{\n";
	this.fragmentShader+= "		gl_FragColor.a = 0.0;\n";
	this.fragmentShader+= "	}\n";
  this.fragmentShader+= "}\n";

	this.program = new Program(globe.renderContext);
	this.program.createFromSource(this.defaultVertexShader, this.fragmentShader);

	this.time = Date.now() / 1000; // Store it in seconds
	this.palette = null; // Palette is an array containing two colors(start/end and the middle one)
	this.colorTexture = this.generateTexture([[0.0,0.0,255.0],[0.0,200.0,255.0]]);
};

/**************************************************************************************************************/

Utils.inherits(VectorRenderer,LineRenderer);

/**************************************************************************************************************/

/**
 * Generate color texture from palette
 * The generated gradient is of type : start color -> middle color -> start color
 * @function generateTexture
 * @memberof LineRenderer.prototype
 * @param palette
 */
LineRenderer.prototype.generateTexture = function(palette)
{
	var startColor = palette[0];
	var middleColor = palette[1];
  var i,r,g,b;
	var pixels = [];
	var gl = this.globe.renderContext.gl;
	this.colorTexture = gl.createTexture();
	gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

	for ( i=0; i<128; i++ )
	{
		r = Numeric.coserp( i/128, startColor[0], middleColor[0] );
		g = Numeric.coserp( i/128, startColor[1], middleColor[1] );
		b = Numeric.coserp( i/128, startColor[2], middleColor[2] );
		pixels.push(r);
		pixels.push(g);
		pixels.push(b);
		pixels.push(255);
	}
	for ( i=0; i<128; i++ )
	{
		r = Numeric.coserp( i/128, middleColor[0], startColor[0] );
		g = Numeric.coserp( i/128, middleColor[1], startColor[1] );
		b = Numeric.coserp( i/128, middleColor[2], startColor[2] );
		pixels.push(r);
		pixels.push(g);
		pixels.push(b);
		pixels.push(255);
	}
	gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, pixels.length / 4, 1, 0,
	              gl.RGBA, gl.UNSIGNED_BYTE, new Uint8Array(pixels));
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);
	gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);

	this.palette = palette;
};

/**************************************************************************************************************/
 /**
 	@name LineRenderable
 	@class
 	 Renderable constructor for Line
 	@param {Bucket} bucket Bucket
	@augments BatchRenderable
 	@constructor
 	*/

var LineRenderable = function(bucket)
{
	BatchRenderable.prototype.constructor.call( this, bucket );

	this.vertexSize = 4;

	// TODO : remove matrix ??
	this.matrix = mat4.create();
	mat4.identity(this.matrix);
};

/**************************************************************************************************************/

Utils.inherits(BatchRenderable,LineRenderable);

/**************************************************************************************************************/

/**
 * Build vertices and indices for the given geometry
 * @function build
 * @memberof LineRenderable.prototype
 * @param geometry
 */
LineRenderable.prototype.build = function(geometry)
{
	var renderer = this.bucket.renderer;
	var style = this.bucket.style;
  var i,n;

	var lines =  (geometry.type === Constants.GEOMETRY.MultiLineString) ? geometry.coordinates : [geometry.coordinates];

	var currentPoint = vec3.create();
	var previousPoint = vec3.create();

	for ( n=0; n < lines.length; n++ ) {

		var coords = lines[n];

		var lastIndex = this.vertices.length / 4;
		var coordinateSystem = renderer.globe.getCoordinateSystem();

		// Build line vertices
		var offset = lastIndex * 4;
		var s = 0;
		for ( i=0; i < coords.length; i++)
		{
			coordinateSystem.get3DFromWorldInCrs(coords[i], geometry.crs.properties.name, currentPoint);
			this.vertices[offset] = currentPoint[0];
			this.vertices[offset+1] = currentPoint[1];
			this.vertices[offset+2] = currentPoint[2];
			// Compute s(length) between two points
			if ( i > 0 )
			{
				s += vec3.dist(currentPoint, previousPoint);
			}

			// Update previous point(do it by swapping with current cuz it's the same object)
			var tmp = previousPoint;
			previousPoint = currentPoint;
			currentPoint = tmp;

			this.vertices[offset+3] = s;
			offset += 4;
		}

		// Build line indices
		for ( i = 0; i < coords.length-1; i++ )
		{
			this.lineIndices.push( lastIndex + i, lastIndex + i + 1 );
		}
	}
	// Geometry is always added contrary to tiled renderables
	return true;
};

/**************************************************************************************************************/
 /**
 	@name LineBucket
 	@class
 	 Bucket constructor for LineRenderer
 	@param layer
	@param style
 	@constructor
 	*/
var LineBucket = function(layer,style)
{
	this.layer = layer;
	this.style = style;
	this.renderer = null;
};

/**************************************************************************************************************/

/**
 * Create a renderable for this bucket
 * @function createRenderable
 * @memberof LineBucket.prototype
 */
LineBucket.prototype.createRenderable = function()
{
	return new LineRenderable(this);
};

/**************************************************************************************************************/

/**
 * Check if a bucket is compatible
 * @function is Compatible
 * @memberof LineBucket.prototype
 * @param style
 * @return {Boolean} Is compatible ?
 */
LineBucket.prototype.isCompatible = function(style)
{
	return this.style === style;
};

/**************************************************************************************************************/

/**
 * 	Render all the polygons
 * @function render
 * @memberof LineRenderer.prototype
 * @param renderables
 * @param {Integer} start Start index
 * @param {Integer} end End index
 */
LineRenderer.prototype.render = function(renderables, start, end)
{
	var renderContext = this.globe.renderContext;
	var gl = renderContext.gl;

	gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
	gl.depthFunc(gl.LEQUAL);
	//gl.enable(gl.POLYGON_OFFSET_FILL);
	//gl.polygonOffset(-2.0,-2.0);
	//gl.disable(gl.DEPTH_TEST);

	// Compute the viewProj matrix
	var viewProjMatrix = mat4.create();
	mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, viewProjMatrix);
	var modelViewProjMatrix = mat4.create();

	this.program.apply();

	gl.activeTexture(gl.TEXTURE0);
	gl.uniform1i(this.program.uniforms.colorTexture, 0);
	gl.bindTexture(gl.TEXTURE_2D, this.colorTexture);

	for ( var n = start; n < end; n++ )
	{
		var renderable = renderables[n];
		var style = renderable.bucket.style;

		mat4.multiply(viewProjMatrix,renderable.matrix,modelViewProjMatrix);
		gl.uniformMatrix4fv(this.program.uniforms.mvp, false, modelViewProjMatrix);

		if ( style.palette && style.palette !== this.palette )
		{
			// Generate new color texture(create an array of color textures per bucket ?)
			gl.deleteTexture( this.colorTexture );
			this.generateTexture(style.palette);
		}

		gl.lineWidth( style.strokeWidth );

		// Update uniforms
		gl.uniform4f(this.program.uniforms.u_color, style.strokeColor[0], style.strokeColor[1], style.strokeColor[2], style.strokeColor[3] * renderable.bucket.layer.opacity);
		gl.uniform1f(this.program.uniforms.speed, style.hasOwnProperty('speed') ? style.speed : 1.0);
		gl.uniform1f(this.program.uniforms.time, Date.now()/1000 - this.time);
		gl.uniform1f(this.program.uniforms.gradientLength, style.hasOwnProperty('gradientLength') ? style.gradientLength : 10.0);

		renderable.bindBuffers( renderContext );

		gl.vertexAttribPointer(this.program.attributes.vertex, 4, gl.FLOAT, false, 0, 0);

		// Draw
		gl.drawElements( gl.LINES, renderable.lineIndices.length, renderable.indexType, 0);
	}

	// Revert to default
	gl.lineWidth(1);

	//gl.enable(gl.DEPTH_TEST);
	//gl.disable(gl.POLYGON_OFFSET_FILL);
	gl.depthFunc(gl.LESS);
	gl.disable(gl.BLEND);
};

/**************************************************************************************************************/

/**
 * Check if renderer is applicable
 * @function canApply
 * @memberof LineRenderer.prototype
 * @return {Boolean} Can apply ?
 */
LineRenderer.prototype.canApply = function(type,style)
{
	return (type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString) && style.gradientLength;
};

/**************************************************************************************************************/

/**
 * Create a bucket
 * @function createBucket
 * @memberof LineRenderer.prototype
 * @param layer
 * @param style
 * @return {LineBucket} Line bucket
 */
LineRenderer.prototype.createBucket = function(layer,style)
{
	return new LineBucket(layer,style);
};

/**************************************************************************************************************/

// Register the renderer
VectorRendererManager.factory.push( function(globe) { return new LineRenderer(globe); } );

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/PointSpriteRenderer',['../Utils/Utils', './VectorRenderer', './Program', './FeatureStyle', './VectorRendererManager', '../Utils/Constants'],
    function (Utils, VectorRenderer, Program, FeatureStyle, VectorRendererManager, Constants) {

        /**************************************************************************************************************/

        /**
         @name PointSpriteRenderer
         @class
             PointSpriteRenderer constructor
         @param {AbstractGlobe} globe AbstractGlobe
         @augments VectorRenderer
         @constructor
         */
        var PointSpriteRenderer = function (globe) {
            VectorRenderer.prototype.constructor.call(this, globe);

            // For stats
            this.numberOfRenderPoints = 0;

            var vertexShader = "attribute vec3 vertex; \n";
            vertexShader += "uniform mat4 viewProjectionMatrix; \n";
            vertexShader += "uniform float pointSize; \n";
            vertexShader += "void main(void)  \n";
            vertexShader += "{ \n";
            vertexShader += "	gl_Position = viewProjectionMatrix * vec4(vertex,1.0); \n";
            vertexShader += "	gl_PointSize = pointSize; \n";
            vertexShader += "} \n";

            var fragmentShader = "precision lowp float; \n";
            fragmentShader += "uniform sampler2D texture; \n";
            fragmentShader += "uniform float alpha; \n";
            fragmentShader += "uniform vec3 color; \n";
            fragmentShader += "\n";
            fragmentShader += "void main(void) \n";
            fragmentShader += "{ \n";
            fragmentShader += "	vec4 textureColor = texture2D(texture, gl_PointCoord); \n";
            fragmentShader += "	gl_FragColor = vec4(textureColor.rgb * color, textureColor.a * alpha); \n";
            fragmentShader += "	if (gl_FragColor.a <= 0.0) discard; \n";
            fragmentShader += "	//gl_FragColor = vec4(1.0); \n";
            fragmentShader += "} \n";

            this.program = new Program(globe.renderContext);
            this.program.createFromSource(vertexShader, fragmentShader);

            this.defaultTexture = null;
        };

        Utils.inherits(VectorRenderer, PointSpriteRenderer);

        /**************************************************************************************************************/

        /**
         @name Renderable
         @class
             Renderable constructor for PointSprite
         @param {Bucket} bucket Bucket
         @constructor
         */
        var Renderable = function (bucket) {
            this.bucket = bucket;
            this.geometry2vb = {};
            this.vertices = [];
            this.vertexBuffer = null;
            this.vertexBufferDirty = false;
        };

        /**************************************************************************************************************/

        /**
         * Add a geometry to the renderable
         * @function add
         * @memberof Renderable.prototype
         * @param geometry
         * @return {Boolean} If the geometry has been successfully added to the renderable
         */
        Renderable.prototype.add = function (geometry) {
            this.geometry2vb[geometry.gid] = this.vertices.length;
            // TODO: Find a better way to access to coordinate system
            var globe = this.bucket.renderer.globe;
            var crs = globe.getCoordinateSystem();
            var pt = crs.get3DFromWorldInCrs(geometry.coordinates, geometry.crs.properties.name);
            var realPlanetRadius = crs.getGeoide().getRealPlanetRadius();
            var planetRadius = crs.getGeoide().getRadius();
            var scale = this.bucket.renderer.globe.isSky() ? 0.95 : 1.0005 + crs.getElevation(globe, geometry) / realPlanetRadius;
            //TODO Instead of 0.95, it should be 0.9995. But with this value, the point is dislayed
            //TODO after order > 5. With order<=5, the image need more control points. Without these
            //TODO control point, the image does not fit perfectly the sphere and the point is behind the image
            this.vertices.push(scale * pt[0], scale * pt[1], scale * pt[2]);
            this.vertexBufferDirty = true;

            return true;
        };

        /**************************************************************************************************************/

        /**
         * Remove a geometry from the renderable
         * @function remove
         * @memberof Renderable.prototype
         * @param geometry
         */
        Renderable.prototype.remove = function (geometry) {
            if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
                var vbIndex = this.geometry2vb[geometry.gid];
                delete this.geometry2vb[geometry.gid];
                this.vertices.splice(vbIndex, 3);
                this.vertexBufferDirty = true;

                // Update render data for all other geometries
                for (var g in this.geometry2vb) {
                    if (g) {
                        if (this.geometry2vb[g] > vbIndex) {
                            this.geometry2vb[g] -= 3;
                        }
                    }
                }
            }
            return this.vertices.length;
        };

        /**************************************************************************************************************/

        /**
         * Dispose the renderable
         * @function dispose
         * @memberof Renderable.prototype
         * @param renderContext
         */
        Renderable.prototype.dispose = function (renderContext) {
            if (this.vertexBuffer) {
                renderContext.gl.deleteBuffer(this.vertexBuffer);
            }
        };

        /**************************************************************************************************************/

        /**
         * Build a default texture
         * @function _buildDefaultTexture
         * @memberof PointSpriteRenderer.prototype
         * @param {Bucket} bucket Bucket
         * @private
         */
        PointSpriteRenderer.prototype._buildDefaultTexture = function (bucket) {
            if (!this.defaultTexture) {
                var gl = this.globe.renderContext.gl;
                this.defaultTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
                var whitePixel = new Uint8Array([255, 255, 255, 255]);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);
            }

            bucket.texture = this.defaultTexture;
            bucket.textureWidth = 10;
            bucket.textureHeight = 10;
        };

        /**************************************************************************************************************/

        /**
         * Build a texture from an image and store in a bucket
         * @function _buildTextureFromImage
         * @memberof PointSpriteRenderer.prototype
         * @param {Bucket} bucket Bucket
         * @param image
         * @private
         */
        PointSpriteRenderer.prototype._buildTextureFromImage = function (bucket, image) {
            bucket.texture = this.globe.renderContext.createNonPowerOfTwoTextureFromImage(image);
            bucket.textureWidth = image.width;
            bucket.textureHeight = image.height;
        };

        /**************************************************************************************************************/

        /**
         * Check if renderer is applicable
         * @function canApply
         * @memberof PointSpriteRenderer.prototype
         * @param type
         * @param style
         * @return {Boolean} Is applicable ?
         */
        PointSpriteRenderer.prototype.canApply = function (type, style) {
            return type === Constants.GEOMETRY.Point && !style.label;
        };

        /**************************************************************************************************************/

        /**
         @name Bucket
         @class
             Bucket constructor for PointSpriteRenderer
         @param layer
         @param style
         @constructor
         */

        var Bucket = function (layer, style) {
            this.layer = layer;
            this.style = new FeatureStyle(style);
            this.texture = null;
            this.renderer = null;
        };

        /**************************************************************************************************************/

        /**
         * Create a renderable for this bucket
         * @function createRenderable
         * @memberof Bucket.prototype
         * @return {Renderable} Renderable
         */
        Bucket.prototype.createRenderable = function () {
            return new Renderable(this);
        };

        /**************************************************************************************************************/

        /**
         * Check if a bucket is compatible
         * @function isCompatible
         * @memberof Bucket.prototype
         * @param style
         * @return {Boolean} Is compatible ?
         */
        Bucket.prototype.isCompatible = function (style) {
            if (this.style.iconUrl === style.iconUrl &&
                this.style.icon === style.icon &&
                this.style.fillColor[0] === style.fillColor[0] &&
                this.style.fillColor[1] === style.fillColor[1] &&
                this.style.fillColor[2] === style.fillColor[2]) {
                return true;
            }

            return false;
        };

        /**************************************************************************************************************/

        /**
         * Create bucket to render a point
         * @function createBucket
         * @memberof PointSpriteRenderer.prototype
         * @param layer
         * @param style
         * @return {Bucket} Bucket
         */
        PointSpriteRenderer.prototype.createBucket = function (layer, style) {
            var gl = this.globe.renderContext.gl;
            var vb = gl.createBuffer();

            // Create a bucket
            var bucket = new Bucket(layer, style);
            bucket.renderer = this;

            // Initialize bucket : create the texture
            if (style.iconUrl) {
                var image = new Image();
                image.crossOrigin = '';
                var self = this;
                image.onload = function () {
                    self._buildTextureFromImage(bucket, image);
                    self.globe.renderContext.requestFrame();
                };
                image.onerror = function () {
                    self._buildDefaultTexture(bucket);
                };
                image.src = style.iconUrl;
            }
            else if (style.icon) {
                this._buildTextureFromImage(bucket, style.icon);
            }
            else {
                this._buildDefaultTexture(bucket);
            }

            return bucket;
        };

        /**************************************************************************************************************/

        /**
         * Render
         * @function render
         * @memberof PointSpriteRenderer.prototype
         * @param renderables
         * @param {Integer} start Start index
         * @param {Integer} end End index
         */
        PointSpriteRenderer.prototype.render = function (renderables, start, end) {
            var renderContext = this.globe.renderContext;
            var gl = renderContext.gl;

            // Setup states
            //gl.disable(gl.DEPTH_TEST);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Setup program
            this.program.apply();

            // The shader only needs the viewProjection matrix, use GlobWeb.modelViewMatrix as a temporary storage
            mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
            gl.uniformMatrix4fv(this.program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);
            gl.uniform1i(this.program.uniforms.texture, 0);

            // Render each renderables
            var currentBucket = null;
            for (var n = start; n < end; n++) {
                var renderable = renderables[n];
                var bucket = renderable.bucket;

                if (currentBucket !== bucket) {
                    gl.uniform1f(this.program.uniforms.alpha, bucket.layer.opacity);
                    var color = bucket.style.fillColor;
                    gl.uniform3f(this.program.uniforms.color, color[0], color[1], color[2]);
                    gl.uniform1f(this.program.uniforms.pointSize, bucket.textureWidth);

                    // Bind point texture
                    gl.activeTexture(gl.TEXTURE0);
                    gl.bindTexture(gl.TEXTURE_2D, bucket.texture);

                    currentBucket = bucket;
                }


                if (!renderable.vertexBuffer) {
                    renderable.vertexBuffer = gl.createBuffer();
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                gl.vertexAttribPointer(this.program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

                if (renderable.vertexBufferDirty) {
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
                    renderable.vertexBufferDirty = false;
                }


                gl.drawArrays(gl.POINTS, 0, renderable.vertices.length / 3);
            }

            //gl.enable(gl.DEPTH_TEST);
            gl.disable(gl.BLEND);
        };


        /**************************************************************************************************************/

// Register the renderer
        VectorRendererManager.factory.push(function (globe) {
            return new PointSpriteRenderer(globe);
        });
        return PointSpriteRenderer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/Triangulator',[],function () {

    /**
     Triangulator code taken from http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
     Does not manage holes
     Seems to be O(n^3)!
     */
    var EPSILON = 0.0000000001;

    /*
     Compute the signed area of a polygon
     */
    var Area = function (contour) {
        var n = contour.length;
        var A = 0.0;
        for (var p = n - 1, q = 0; q < n; p = q++) {
            A += contour[p][0] * contour[q][1] - contour[q][0] * contour[p][1];
        }
        return A * 0.5;
    };

    /*
     InsideTriangle decides if a point P is Inside of the triangle
     defined by A, B, C.
     */
    var InsideTriangle = function (Ax, Ay,
                                   Bx, By,
                                   Cx, Cy,
                                   Px, Py) {
        var ax, ay, bx, by, cx, cy, apx, apy, bpx, bpy, cpx, cpy;
        var cCROSSap, bCROSScp, aCROSSbp;

        ax = Cx - Bx;
        ay = Cy - By;
        bx = Ax - Cx;
        by = Ay - Cy;
        cx = Bx - Ax;
        cy = By - Ay;
        apx = Px - Ax;
        apy = Py - Ay;
        bpx = Px - Bx;
        bpy = Py - By;
        cpx = Px - Cx;
        cpy = Py - Cy;

        aCROSSbp = ax * bpy - ay * bpx;
        cCROSSap = cx * apy - cy * apx;
        bCROSScp = bx * cpy - by * cpx;

        return ((aCROSSbp >= 0.0) && (bCROSScp >= 0.0) && (cCROSSap >= 0.0));
    };

    /*
     Check if the giben triangle (u,v,w) is a ear : not other vertex inside
     */
    var Snip = function (contour, u, v, w, n, V) {
        var p;
        var Ax, Ay, Bx, By, Cx, Cy, Px, Py;

        Ax = contour[V[u]][0];
        Ay = contour[V[u]][1];

        Bx = contour[V[v]][0];
        By = contour[V[v]][1];

        Cx = contour[V[w]][0];
        Cy = contour[V[w]][1];

        if (EPSILON > (((Bx - Ax) * (Cy - Ay)) - ((By - Ay) * (Cx - Ax)))) {
          return false;
        }

        for (p = 0; p < n; p++) {
            if ((p === u) || (p === v) || (p === w)) {
              continue;
            }
            Px = contour[V[p]][0];
            Py = contour[V[p]][1];
            if (InsideTriangle(Ax, Ay, Bx, By, Cx, Cy, Px, Py)) {
              return false;
            }
        }

        return true;
    };

    /*
     Process triangulation on the given contour
     */
    var Process = function (contour) {
        /* allocate and initialize list of Vertices in polygon */

        var n = contour.length;
        if (contour[0][0] === contour[n - 1][0] && contour[0][1] === contour[n - 1][1]) {
            n--;
        }

        if (n < 3) {
          return null;
        }

        var V = new Array(n);
        var m,v;
        /* we want a counter-clockwise polygon in V */

        if (0.0 < Area(contour)) {
            for (v = 0; v < n; v++) {
              V[v] = v;
            }
        } else {
            for (v = 0; v < n; v++) {
              V[v] = (n - 1) - v;
            }
        }

        var nv = n;

        var results = [];

        /*  remove nv-2 Vertices, creating 1 triangle every time */
        var count = 2 * nv;
        /* error detection */

        for (m = 0, v = nv - 1; nv > 2;) {
            /* if we loop, it is probably a non-simple polygon */
            if (0 >= (count--)) {
                //** Triangulate: ERROR - probable bad polygon!
                return null;
            }

            /* three consecutive vertices in current polygon, <u,v,w> */
            var u = v;
            if (nv <= u) {
              u = 0;
            }
            /* previous */
            v = u + 1;
            if (nv <= v) {
              v = 0;
            }
            /* new v    */
            var w = v + 1;
            if (nv <= w) {
              w = 0;
            }
            /* next     */

            if (Snip(contour, u, v, w, nv, V)) {
                var a, b, c, s, t;

                /* true names of the vertices */
                a = V[u];
                b = V[v];
                c = V[w];

                /* output Triangle */
                results.push(a);
                results.push(b);
                results.push(c);

                m++;

                /* remove v from remaining polygon */
                for (s = v, t = v + 1; t < nv; s++, t++) {
                  V[s] = V[t];
                }
                nv--;

                /* resest error detection counter */
                count = 2 * nv;
            }
        }

        return results;
    };

    var Triangulator = {
        process: Process
    };

    return Triangulator;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/ConvexPolygonRenderer',['../Utils/Utils', '../Utils/Constants','./VectorRenderer', './Program', './FeatureStyle', './VectorRendererManager', '../Tiling/Triangulator', './glMatrix'],
    function (Utils, Constants, VectorRenderer, Program, FeatureStyle, VectorRendererManager, Triangulator) {

       /**
         @name Bucket
         @class
          Bucket constructor for ConvexPolygonRenderer
         @param layer
         @param style
         @constructor
         */
      var Bucket = function (layer, style) {
          this.layer = layer;
          this.style = new FeatureStyle(style);
          this.texture = null;
          this.polygonProgram = null;
          this.renderer = null;
          this.mainRenderable = null;
      };

      /**
       * Check if a bucket is compatible
       * @function isCompatible
       * @memberof Bucket.prototype
       * @param style
       * @return {boolean} Is compatible ?
       */
      Bucket.prototype.isCompatible = function (style) {
          if (this.style.strokeColor[0] === style.strokeColor[0] &&
              this.style.strokeColor[1] === style.strokeColor[1] &&
              this.style.strokeColor[2] === style.strokeColor[2] &&
              this.style.fill === style.fill                     &&
              this.style.fillTexture === style.fillTexture       &&
              this.style.fillTextureUrl === style.fillTextureUrl &&
              this.style.fillShader === style.fillShader) {
              return true;
          }

          return false;
      };

        /**************************************************************************************************************/

        /**
          @name Renderable
          @class
            Renderable constructor
            Attach to a bucket
          @param {Bucket} bucket Bucket
          @constructor
         */
        var Renderable = function (bucket) {
            this.bucket = bucket;
            this.geometry2vb = {};
            this.vertices = [];
            this.lineIndices = [];
            this.triangleIndices = [];
            this.vertexBuffer = null;
            this.lineIndexBuffer = null;
            this.triangleIndexBuffer = null;
            this.bufferDirty = false;
            this.triBufferDirty = false;
            this.tcoords = [];
        };

        /**************************************************************************************************************/

        /**
         * Add the geometry to the renderable
         * @function add
         * @memberof Renderable.prototype
         * @return if the geometry has been successfully added to the renderable
         */
        Renderable.prototype.add = function (geometry) {
            var rings = [];
            var geometryCrs = geometry.crs.properties.name;
            var i,r,pt;
            if (geometry.type === Constants.GEOMETRY.MultiPolygon) {
                for (i = 0; i < geometry.coordinates.length; i++) {
                    rings.push(geometry.coordinates[i][0]);
                }
            }
            else if (geometry.type === Constants.GEOMETRY.LineString) {
                rings.push(geometry.coordinates);

            }
            else if (geometry.type === Constants.GEOMETRY.MultiLineString) {
                for (i = 0; i < geometry.coordinates.length; i++) {
                    rings.push(geometry.coordinates[i]);
                }
            }
            else {
                rings.push(geometry.coordinates[0]);
            }

            for (r = 0; r < rings.length; r++) {
                var coords = rings[r];
                // var coords = geometry['coordinates'][0];
                //var numPoints = coords.length-1;
                var numPoints = coords.length;

                // Store information for the geometry in the buffers used for rendering
                var data = {
                    vertexStart: this.vertices.length,
                    vertexCount: 3 * numPoints,
                    lineIndexStart: this.lineIndices.length,
                    lineIndexCount: 2 * numPoints,
                    triIndexStart: 0,
                    triIndexCount: 0
                };

                var coordinateSystem = this.bucket.renderer.globe.getCoordinateSystem();
                // Compute texture coordinates if defined
                if (geometry._imageCoordinates) {
                    data.tcoordsStart = this.tcoords.length;
                    data.tcoordsCount = 2 * numPoints;

                    // Initialize variables used for texture coordinates computation
                    var p0 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][0], geometryCrs); // origin
                    var p1 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][1], geometryCrs);
                    var p3 = coordinateSystem.get3DFromWorldInCrs(geometry._imageCoordinates[0][3], geometryCrs);
                    var v01 = [];
                    vec3.subtract(p1, p0, v01); // U-axis
                    var v03 = [];
                    vec3.subtract(p3, p0, v03); // V-axis
                    var squaredU = vec3.length(v01) * vec3.length(v01);
                    var squaredV = vec3.length(v03) * vec3.length(v03);

                    for (i = 0; i < numPoints; i++) {
                        pt = coordinateSystem.get3DFromWorldInCrs(coords[i], geometryCrs);
                        var v0P = [];
                        vec3.subtract(pt, p0, v0P);

                        var uDotProduct = vec3.dot(v0P, v01);
                        var vDotProduct = vec3.dot(v0P, v03);
                        var u = uDotProduct / squaredU;
                        var v = vDotProduct / squaredV;
                        this.tcoords.push(u);
                        this.tcoords.push(v);
                    }

                }

                // Compute vertices and indices and store them in the buffers
                var startIndex = this.vertices.length / 3;
                for (i = 0; i < numPoints; i++) {
                    pt = coordinateSystem.get3DFromWorldInCrs(coords[i], geometryCrs);
                    this.vertices.push(pt[0], pt[1], pt[2]);

                    if ((geometry.type === Constants.GEOMETRY.MultiLineString || geometry.type === Constants.GEOMETRY.LineString) && i === (numPoints - 1)) {
                        break;
                    }
                    this.lineIndices.push(startIndex + i, startIndex + ((i + 1) % numPoints));
                }

                // If fill, build the triangle indices
                if (this.bucket.style.fill) {
                    data.triIndexStart = this.triangleIndices.length;
                    data.triIndexCount = 3 * (numPoints - 2);

                    var triangleIndices = Triangulator.process(coords);
                    if (triangleIndices !== null) {
                        this.triangleIndices = triangleIndices;
                    }
                    else {
                        // HACK for not trivial polygons
                        for (i = 0; i < numPoints - 2; i++) {
                            this.triangleIndices.push(startIndex, startIndex + i + 1, startIndex + i + 2);
                        }
                    }
                }

                if (this.geometry2vb[geometry.gid]) {
                    this.geometry2vb[geometry.gid].vertexCount += data.vertexCount;
                    this.geometry2vb[geometry.gid].lineIndexCount += data.lineIndexCount;
                    this.geometry2vb[geometry.gid].triIndexCount += data.triIndexCount;
                }
                else {
                    this.geometry2vb[geometry.gid] = data;
                }

                this.bufferDirty = true;
                this.triBufferDirty = true;
            }

            return true;
        };

        /**************************************************************************************************************/

        /**
         * Remove the geometry from the renderable
         * @function remove
         * @memberof Renderable.prototype
         * @param geometry
         */
        Renderable.prototype.remove = function (geometry) {
            var i;
            if (this.geometry2vb.hasOwnProperty(geometry.gid)) {
                // retreive the render data for the geometry
                var data = this.geometry2vb[geometry.gid];
                delete this.geometry2vb[geometry.gid];

                // Remove geometry vertex
                this.vertices.splice(data.vertexStart, data.vertexCount);

                // Update indices after vertex removal
                for (i = data.lineIndexStart + data.lineIndexCount; i < this.lineIndices.length; i++) {
                    this.lineIndices[i] -= (data.vertexCount / 3);
                }
                for (i = data.triIndexStart + data.triIndexCount; i < this.triangleIndices.length; i++) {
                    this.triangleIndices[i] -= (data.vertexCount / 3);
                }

                this.lineIndices.splice(data.lineIndexStart, data.lineIndexCount);
                this.triangleIndices.splice(data.triIndexStart, data.triIndexCount);
                if (data.tcoordsStart >= 0) {
                    this.tcoords.splice(data.tcoordsStart, data.tcoordsCount);
                }

                // Update render data for all other geometries
                for (var g in this.geometry2vb) {
                    if (g) {
                        var d = this.geometry2vb[g];
                        if (d.vertexStart > data.vertexStart) {
                            d.vertexStart -= data.vertexCount;
                            d.lineIndexStart -= data.lineIndexCount;
                            d.triIndexStart -= data.triIndexCount;
                            if (d.tcoordsStart >= 0) {
                                d.tcoordsStart -= data.tcoordsCount;
                            }
                        }
                    }
                }

                this.bufferDirty = true;
                this.triBufferDirty = true;
            }
            return this.vertices.length;
        };

        /**************************************************************************************************************/

        /**
         * Dispose the renderable : remove all buffers
         * @function dispose
         * @memberof Renderable.prototype
         * @param renderContext
         */
        Renderable.prototype.dispose = function (renderContext) {
            if (this.vertexBuffer) {
                renderContext.gl.deleteBuffer(this.vertexBuffer);
            }
            if (this.lineIndexBuffer) {
                renderContext.gl.deleteBuffer(this.lineIndexBuffer);
            }
            if (this.triangleIndexBuffer) {
                renderContext.gl.deleteBuffer(this.triangleIndexBuffer);
            }
            if (this.tcoordBuffer) {
                renderContext.gl.deleteBuffer(this.tcoordBuffer);
            }
        };

        /**
         * Create a renderable for this bucket
         * @function createRenderable
         * @memberof Bucket.prototype
         * @return {Renderable} Renderable
         */
        Bucket.prototype.createRenderable = function () {
            return new Renderable(this);
        };

        /**************************************************************************************************************/

         /**
          @name ConvexPolygonRenderer
          @class
            ConvexPolygonRenderer  constructor
          @augments VectorRenderer
          @param {AbstractGlobe} globe AbstractGlobe
          @constructor
          */
        var ConvexPolygonRenderer = function (globe) {
            VectorRenderer.prototype.constructor.call(this, globe);
            this.maxTilePerGeometry = 2;

            // Store object for rendering
            this.renderContext = globe.tileManager.renderContext;
            this.tileConfig = globe.tileManager.tileConfig;

            this.programs = [];

            this.basicVertexShader = "attribute vec3 vertex;\n";
            this.basicVertexShader+= "uniform mat4 viewProjectionMatrix;\n";
            this.basicVertexShader+= "    \n";
            this.basicVertexShader+= "    void main(void)\n";
            this.basicVertexShader+= "    {\n";
            this.basicVertexShader+= "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
            this.basicVertexShader+= "    }\n";

            this.basicFragmentShader = "precision lowp float; \n";
            this.basicFragmentShader+= "    uniform vec4 color; \n";
            this.basicFragmentShader+= "    \n";
            this.basicFragmentShader+= "    void main(void) \n";
            this.basicFragmentShader+= "    { \n";
            this.basicFragmentShader+= "        gl_FragColor = color; \n";
            this.basicFragmentShader+= "    } \n";

            this.texVertexShader = "attribute vec3 vertex;\n";
            this.texVertexShader+= "    attribute vec2 tcoord;\n";
            this.texVertexShader+= "    uniform mat4 viewProjectionMatrix;\n";
            this.texVertexShader+= "    \n";
            this.texVertexShader+= "    varying vec2 vTextureCoord;\n";
            this.texVertexShader+= "    \n";
            this.texVertexShader+= "    void main(void) \n";
            this.texVertexShader+= "    {\n";
            this.texVertexShader+= "        vTextureCoord = tcoord;\n";
            this.texVertexShader+= "        vTextureCoord.y = 1.0 - vTextureCoord.y; \n";
            this.texVertexShader+= "        gl_Position = viewProjectionMatrix * vec4(vertex, 1.0);\n";
            this.texVertexShader+= "    }\n";


            this.texFragmentShader = "precision lowp float; \n";
            this.texFragmentShader+= "    uniform vec4 color;\n";
            this.texFragmentShader+= "    varying vec2 vTextureCoord;\n";
            this.texFragmentShader+= "    uniform sampler2D texture; \n";
            this.texFragmentShader+= "    void main(void)\n";
            this.texFragmentShader+= "    {\n";
            this.texFragmentShader+= "        gl_FragColor = texture2D(texture, vTextureCoord) * color;\n";
            this.texFragmentShader+= "    }\n";

            this.basicFillShader = {
                vertexCode: this.basicVertexShader,
                fragmentCode: this.basicFragmentShader,
                updateUniforms: null
            };

            this.texFillShader = {
                vertexCode: this.texVertexShader,
                fragmentCode: this.texFragmentShader,
                updateUniforms: null
            };


            this.basicProgram = this.createProgram(this.basicFillShader);
            this.texProgram = this.createProgram(this.texFillShader);

            var gl = this.renderContext.gl;
            // Parameters used to implement ONE shader for color xor texture rendering
            this.whiteTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);
            var whitePixel = new Uint8Array([255, 255, 255, 255]);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, whitePixel);

            // Shared buffer
            // Create texCoord buffer
            this.tcoordBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);

            var textureCoords = [
                0.0, 0.0,
                1.0, 0.0,
                1.0, 1.0,
                0.0, 1.0,
                0.0, 0.0
            ];

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(textureCoords), gl.STATIC_DRAW);
            this.tcoordBuffer.itemSize = 2;
            this.tcoordBuffer.numItems = 5;
        };

        Utils.inherits(VectorRenderer, ConvexPolygonRenderer);

        /**************************************************************************************************************/


        /**
         * Check if renderer is applicable
         * @function canApply
         * @memberof ConvexPolygonRenderer.prototype
         * @param type
         * @param style
         * @return {boolean} Is applicable ?
         */
        ConvexPolygonRenderer.prototype.canApply = function (type, style) {
            if (!this.globe.isSky()) {
                return false;
            }

            return type === Constants.GEOMETRY.Polygon || type === Constants.GEOMETRY.MultiPolygon || type === Constants.GEOMETRY.LineString || type === Constants.GEOMETRY.MultiLineString;
        };

        /**************************************************************************************************************/

        /**
         * Create program from fillShader object
         * @function createProgram
         * @memberof ConvexPolygonRenderer.prototype
         * @param fillShader
         * @return {Program} Program
         */
        ConvexPolygonRenderer.prototype.createProgram = function (fillShader) {
            var program = new Program(this.renderContext);
            program.createFromSource(fillShader.vertexCode, fillShader.fragmentCode);

            // Add program
            program.id = this.programs.length;
            this.programs.push({
                fillShader: fillShader,
                program: program
            });
            return program;
        };

        /**************************************************************************************************************/

        /**
         * Get program if known by renderer, create otherwise
         * @function getProgram
         * @memberof ConvexPolygonRenderer.prototype
         * @param fillShader
         * @return {Program} Program
         */
        ConvexPolygonRenderer.prototype.getProgram = function (fillShader) {

            var program;

            for (var id = 0; id < this.programs.length; id++) {
                if (this.programs[id].fillShader === fillShader) {
                    program = this.programs[id].program;
                }
            }

            if (!program) {
                program = this.createProgram(fillShader);
            }
            return program;
        };


        /**************************************************************************************************************/

        /**
         * Create bucket to render a polygon
         * @function createBucket
         * @memberof ConvexPolygonRenderer.prototype
         * @param layer
         * @param style
         * @return {Bucket} Bucket
         */
        ConvexPolygonRenderer.prototype.createBucket = function (layer, style) {
            var gl = this.renderContext.gl;
            var vb = gl.createBuffer();

            // Create a bucket
            var bucket = new Bucket(layer, style);

            // Create texture
            var self = this;
            if (style.fill) {
                var hasTexture = false;
                if (style.fillTextureUrl) {
                    var image = new Image();
                    image.crossOrigin = '';
                    image.onload = function () {
                        bucket.texture = self.renderContext.createNonPowerOfTwoTextureFromImage(image, layer.invertY);
                    };

                    image.onerror = function (event) {
                        console.log("Cannot load " + image.src);
                    };

                    image.src = style.fillTextureUrl;
                    hasTexture = true;
                }
                else if (style.fillTexture) {
                    bucket.texture = style.fillTexture;
                    hasTexture = true;
                }

                if (style.fillShader && style.fillShader.fragmentCode) {
                    // User defined texture program
                    if (!style.fillShader.vertexCode) {
                        style.fillShader.vertexCode = this.texVertexShader;
                    }
                    if (!style.fillShader.vertexCode) {
                        style.fillShader.fragmentCode = this.texFragmentShader;
                    }

                    bucket.polygonProgram = this.getProgram(style.fillShader);
                }
                else {
                    // Default program
                    bucket.polygonProgram = hasTexture ? this.texProgram : this.basicProgram;
                }
            }

            return bucket;
        };

        /**************************************************************************************************************/

        /**
         * Render all the POIs
         * @function render
         * @memberof ConvexPolygonRenderer.prototype
         * @param renderables
         * @param {Integer} start Start index
         * @param {Integer} end End index
         */
        ConvexPolygonRenderer.prototype.render = function (renderables, start, end) {
            var renderContext = this.renderContext;
            var gl = this.renderContext.gl;

            // Setup states
            gl.disable(gl.DEPTH_TEST);
            gl.depthMask(false);
            gl.enable(gl.BLEND);
            gl.blendEquation(gl.FUNC_ADD);
            gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

            // Setup the basic program
            this.basicProgram.apply();
            mat4.multiply(renderContext.projectionMatrix, renderContext.viewMatrix, renderContext.modelViewMatrix);
            gl.uniformMatrix4fv(this.basicProgram.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);

            // Render each renderables
            var currentBucket = null;
            for (var n = start; n < end; n++) {
                var renderable = renderables[n];
                var bucket = renderable.bucket;

                // Set the color
                var color = bucket.style.strokeColor;
                gl.uniform4f(this.basicProgram.uniforms.color, color[0], color[1], color[2], color[3] * bucket.layer.getOpacity());

                // Update vertex buffer
                if (!renderable.vertexBuffer) {
                    renderable.vertexBuffer = gl.createBuffer();
                    renderable.lineIndexBuffer = gl.createBuffer();
                }

                gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                gl.vertexAttribPointer(this.basicProgram.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

                gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.lineIndexBuffer);

                if (renderable.bufferDirty) {
                    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.vertices), gl.STATIC_DRAW);
                    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.lineIndices), gl.STATIC_DRAW);
                    renderable.bufferDirty = false;
                }

                gl.drawElements(gl.LINES, renderable.lineIndices.length, gl.UNSIGNED_SHORT, 0);

                if (bucket.polygonProgram) {
                    var program = bucket.polygonProgram;

                    program.apply();
                    gl.uniformMatrix4fv(program.uniforms.viewProjectionMatrix, false, renderContext.modelViewMatrix);

                    gl.uniform1i(program.uniforms.texture, 0);
                    if (renderable.tcoords.length > 0) {
                        // Use tcoord buffer defined by _imageCoordinates
                        if (!renderable.tcoordBuffer) {
                            renderable.tcoordBuffer = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);

                            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(renderable.tcoords), gl.STATIC_DRAW);
                            renderable.tcoordBuffer.itemSize = 2;
                            renderable.tcoordBuffer.numItems = renderable.tcoords.length / 2;
                        }

                        gl.bindBuffer(gl.ARRAY_BUFFER, renderable.tcoordBuffer);
                    }
                    else {
                        // Use default tcoord buffer
                        gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
                    }
                    gl.vertexAttribPointer(program.attributes.tcoord, 2, gl.FLOAT, false, 0, 0);

                    gl.bindBuffer(gl.ARRAY_BUFFER, renderable.vertexBuffer);
                    gl.vertexAttribPointer(program.attributes.vertex, 3, gl.FLOAT, false, 0, 0);

                    if (bucket.style.fillShader && bucket.style.fillShader.updateUniforms) {
                        bucket.style.fillShader.updateUniforms(gl, renderable.bucket, program);
                    }

                    if (!renderable.triangleIndexBuffer) {
                        renderable.triangleIndexBuffer = gl.createBuffer();
                    }
                    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, renderable.triangleIndexBuffer);
                    if (renderable.triBufferDirty) {
                        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(renderable.triangleIndices), gl.STATIC_DRAW);
                        renderable.triBufferDirty = false;
                    }
                    // Add texture
                    gl.activeTexture(gl.TEXTURE0);
                    if (renderable.bucket.texture) {
                        gl.bindTexture(gl.TEXTURE_2D, renderable.bucket.texture); // use texture of renderable
                        gl.uniform4f(program.uniforms.color, 1.0, 1.0, 1.0, color[3] * bucket.layer.getOpacity());  // use whiteColor
                    }
                    else {
                        gl.bindTexture(gl.TEXTURE_2D, this.whiteTexture);  // use white texture
                        color = renderable.bucket.style.fillColor;
                        gl.uniform4f(program.uniforms.color, color[0], color[1], color[2], color[3] * bucket.layer.getOpacity());
                    }

                    gl.drawElements(gl.TRIANGLES, renderable.triangleIndices.length, gl.UNSIGNED_SHORT, 0);

                    this.basicProgram.apply();
                }
            }

            gl.enable(gl.DEPTH_TEST);
            gl.depthMask(true);
            gl.disable(gl.BLEND);
        };


        /**************************************************************************************************************/

        VectorRendererManager.factory.push( function(globe) { return new ConvexPolygonRenderer(globe); } );

        return ConvexPolygonRenderer;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Context/AbstractContext',["jquery", "underscore-min", "../Utils/Event", "../Utils/Utils", "../Layer/LayerFactory", "../Services/ServiceFactory", "../Utils/Constants",
        "../Gui/Tracker/PositionTracker", "../Gui/Tracker/ElevationTracker", "../Utils/AttributionHandler", "../Gui/dialog/ErrorDialog",
        "../Renderer/PointRenderer", "../Renderer/LineStringRenderable", "../Renderer/PolygonRenderer", "../Renderer/LineRenderer",
        "../Renderer/PointSpriteRenderer", "../Renderer/ConvexPolygonRenderer"],
    function ($, _, Event, Utils, LayerFactory, ServiceFactory, Constants,
              PositionTracker, ElevationTracker, AttributionHandler, ErrorDialog) {

        //TODO : attention de bien garder les ...Renderer dans le define

        /**
         * @name AbstractContext
         * @class
         * The active context object can normally be obtained from the {@link module:Context.ContextManager ContextManager}
         * class of the Mizar instance.<br/>
         * A context is the main webGL object that contains its own coordinate reference system,
         * its own data, its own navigation and its own GUI.<br/>
         * Client implementations should not normally instantiate this class directly.
         * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
         * @param {CONTEXT} mode - the type of context
         * @param {AbstractContext.skyContext|AbstractContext.planetContext} ctxOptions - sky or planet options
         * @constructor
         * @implements {Context}
         * @listens Context#baseLayersReady
         */
        var AbstractContext = function (mizarConfiguration, mode, ctxOptions) {
            Event.prototype.constructor.call(this);
            var self = this;
            this.globe = null;	// Sky or globe
            this.navigation = null;
            this.components = {};
            this.dataProviders = {};
            this.canvas = mizarConfiguration.canvas;
            this.subscribe("baseLayersReady", function (imagery) {
                // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
                // with empty values. Because of that, the globe cannot be displayed without moving the camera.
                // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
                if(self.getNavigation().getRenderContext().viewMatrix[0] !== "undefined") {
                    self.getNavigation().computeViewMatrix();
                }
            });
            this.mizarConfiguration = mizarConfiguration.hasOwnProperty('configuration') ? mizarConfiguration.configuration : {};
            this.credits = true;
            this.ctxOptions = ctxOptions;
            this.mode = mode;
            this.layers = [];

            this.initCanvas(this.canvas);
            this.positionTracker = _createTrackerPosition.call(this, this.mizarConfiguration);
            this.elevationTracker = _createTrackerElevation.call(this, this.mizarConfiguration, ctxOptions);
        };


        /**
         * Creates tracker position
         * @param {Mizar.configuration} mizarConfiguration
         * @returns {PositionTracker} positionTracker object
         * @private
         */
        function _createTrackerPosition(mizarConfiguration) {
            return new PositionTracker({
                element: (mizarConfiguration.positionTracker && mizarConfiguration.positionTracker.element) ? mizarConfiguration.positionTracker.element : "posTracker",
                isMobile: mizarConfiguration.isMobile,
                position: (mizarConfiguration.positionTracker && mizarConfiguration.positionTracker.position) ? mizarConfiguration.positionTracker.position : "bottom"
            });
        }

        /**
         * Creates elevation tracker
         * @param {Mizar.configuration} mizarConfiguration - Mizar configuration
         * @param {AbstractContext.planetContext} ctxOptions - options
         * @returns {ElevationTracker}
         * @private
         */
        function _createTrackerElevation(mizarConfiguration, ctxOptions) {
            return new ElevationTracker({
                element: (mizarConfiguration.elevationTracker && mizarConfiguration.elevationTracker.element) ? mizarConfiguration.elevationTracker.element : "elevTracker",
                isMobile: mizarConfiguration.isMobile,
                position: (mizarConfiguration.elevationTracker && mizarConfiguration.elevationTracker.elevation) ? mizarConfiguration.elevationTracker.position : "bottom",
                elevationLayer: (ctxOptions.planetLayer !== undefined) ? ctxOptions.planetLayer.elevationLayer : undefined
            });
        }

        /**
         * Adds to the globe either as background or as additional layer
         * @param {Layer} layer - layer to add.
         * @private
         */
        function _addToGlobe(layer) {
            if (layer.category === "background" && layer.isVisible()) {
                this.globe.setBaseImagery(layer);
            } else {
                this.globe.addLayer(layer);
            }
        }


        /**************************************************************************************************************/
        Utils.inherits(Event, AbstractContext);
        /**************************************************************************************************************/

        /**
         * ShowUp message.<br/>
         * Do not display the canvas with the ID <i>MizarCanvas</i> and the loading icon and displays
         * the HTML element with the ID <i>webGLNotAvailable</i>
         * @param err
         * @protected
         * @todo Mettre en paramètre MizarCanvas et webGLNotAvailable
         */
        AbstractContext.prototype._showUpError = function (err) {
            console.error("Globe creation error : ", err);
            if (document.getElementById('MizarCanvas')) {
                document.getElementById('MizarCanvas').style.display = "none";
            }
            if (document.getElementById('loading')) {
                document.getElementById('loading').style.display = "none";
            }
            if (document.getElementById('webGLNotAvailable')) {
                document.getElementById('webGLNotAvailable').style.display = "block";
            }
        };

        /**
         * Fill data-provider-type layer by features coming from data object
         * @function _fillDataProvider
         * @param {Layer} layer - layer in which data should be added.
         * @param {Object} mizarDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
         * @memberOf AbstractContext#
         * @protected
         */
        AbstractContext.prototype._fillDataProvider = function(layer, mizarDescription) {
            if (mizarDescription.data && this.dataProviders[mizarDescription.data.type]) {
                var callback = this.dataProviders[mizarDescription.data.type];
                callback(layer, mizarDescription.data);
            }
        };

        /**
         * Returns the data provider layers or an empty array when no data provider layer.
         * @function getDataProviderLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getDataProviderLayers = function() {
            var dpLayers = [];
            var layers = this.getLayers();
            for (var i in layers) {
                var layer = layers[i];
                if(layer.hasOwnProperty('options') && layer.options.hasOwnProperty('type') && layer.options.type === Constants.LAYER.GeoJSON) {
                    dpLayers.push(layer);
                }
            }
            return dpLayers;
        };

        /**
         * @function getTileManager
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getTileManager = function () {
            return this.globe.getTileManager();
        };

        /**
         * Registers no standard data provider and call them in the addLayer method.
         * @function registerNoStandardDataProvider
         * @param {string} type - data provider key
         * @param {Function} loadFunc - Function
         * @memberOf AbstractContext#
         * @example <caption>Registers planets on the sky</caption>
         *   var planetProvider = ProviderFactory.create(Constants.PROVIDER.Planet);
         *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
         */
        AbstractContext.prototype.registerNoStandardDataProvider = function (type, loadFunc) {
            this.dataProviders[type.toString()] = loadFunc;
        };

        /**
         * @function getContextConfiguration
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getContextConfiguration = function () {
            return this.ctxOptions;
        };

        /**
         * @function getMizarConfiguration
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getMizarConfiguration = function () {
            return this.mizarConfiguration;
        };

        /**
         * @function getLonLatFromPixel
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getLonLatFromPixel = function (x, y) {
            return this.globe.getLonLatFromPixel(x, y);
        };

        /**
         * @function getPixelFromLonLat
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getPixelFromLonLat = function(longitude, latitude){
            return this.globe.getPixelFromLonLat(longitude, latitude);
        };

        /**
         * @function getElevation
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getElevation = function (lon, lat) {
            return this.globe.getElevation(lon, lat);
        };

        /**
         * @function getPositionTracker
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getPositionTracker = function () {
            return this.positionTracker;
        };

        /**
         * @function getElevationTracker
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getElevationTracker = function () {
            return this.elevationTracker;
        };

        /**
         * @function getLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getLayers = function () {
            return this.layers;
        };

        /**
         * @function getLayerByID
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getLayerByID = function (layerId) {
            return _.find(_.union(this.getLayers()), function (layer) {
                return (layer.ID === layerId);
            });
        };

        /**
         * @function getLayerByName
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getLayerByName = function (layerName) {
            return _.findWhere(this.getLayers(), {name: layerName});
        };


        /**
         * @function addLayer
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.addLayer = function (layerDescription) {
            var layer = LayerFactory.create(layerDescription);
            if(layer === undefined) {
                var text = layerDescription.hipsMetadata.hipsMetadata.ID;
                ErrorDialog.open("<font style='color:orange'>Warning : No implementation is defined for this layer <b>" + text + "</b></font>");
            } else {
                this.layers.push(layer);
                _addToGlobe.call(this, layer);

                this._fillDataProvider(layer, layerDescription);

                if (layer.pickable) {
                    ServiceFactory.create(Constants.SERVICE.PickingManager).addPickableLayer(layer);
                }
                var self = this;
                layer.subscribe("visibility:changed", function (layer) {
                    if (layer.isVisible() && layer.properties && !layer.background
                        && layer.properties.hasOwnProperty("initialRa") && layer.properties.hasOwnProperty("initialDec") && layer.properties.hasOwnProperty("initialFov")) {

                        if (layer.globe.getType() === Constants.GLOBE.Sky) {
                            var fov = (layer.properties.initialFov) ? layer.properties.initialFov : layer.globe.getRenderContext().fov;
                            self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
                                fov: fov,
                                duration: 3000
                            });
                        }
                        else {
                            self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
                                distance: layer.properties.initialFov,
                                duration: 3000
                            });
                        }
                    }
                });
                var layerEvent = (layer.category === "background") ? "backgroundLayer:add" : "additionalLayer:add";
                this.publish(layerEvent, layer);
            }
            return layer;
        };

        // /**
        //  * Zoom to when the visibility is changed.
        //  * @param layer
        //  * @private
        //  */
        // function onVisibilityChange(layer) {
        //
        //     if (layer.isVisible() && layer.properties && !layer.background
        //         && layer.properties.hasOwnProperty("initialRa") && layer.properties.hasOwnProperty("initialDec") && layer.properties.hasOwnProperty("initialFov")) {
        //
        //         if (layer.globe.getType() === Constants.GLOBE.Sky) {
        //             var fov = (layer.properties.initialFov) ? layer.properties.initialFov : layer.globe.getRenderContext().fov;
        //             self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
        //                 fov: fov,
        //                 duration: 3000
        //             });
        //         }
        //         else {
        //             self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
        //                 distance: layer.properties.initialFov,
        //                 duration: 3000
        //             });
        //         }
        //     }
        // }


        /**
         * @function removeLayer
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.removeLayer = function (layerID) {
            var removedLayer = null;
            var indexes = $.map(this.layers, function (obj, index) {
                if (obj.ID === layerID) {
                    return index;
                }
            });
            if (indexes.length > 0) {
                var removedLayers = this.layers.splice(indexes[0], 1);
                removedLayer = removedLayers[0];
                var self = this;
                removedLayer.unsubscribe("visibility:changed", function (layer) {
                    if (layer.isVisible() && layer.properties && !layer.background
                        && layer.properties.hasOwnProperty("initialRa") && layer.properties.hasOwnProperty("initialDec") && layer.properties.hasOwnProperty("initialFov")) {

                        if (layer.globe.getType() === Constants.GLOBE.Sky) {
                            var fov = (layer.properties.initialFov) ? layer.properties.initialFov : layer.globe.getRenderContext().fov;
                            self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
                                fov: fov,
                                duration: 3000
                            });
                        }
                        else {
                            self.getNavigation().zoomTo([layer.properties.initialRa, layer.properties.initialDec], {
                                distance: layer.properties.initialFov,
                                duration: 3000
                            });
                        }
                    }
                });
                ServiceFactory.create(Constants.SERVICE.PickingManager).removePickableLayer(removedLayer);
                removedLayer._detach();

            }
            return removedLayer;
        };


        /**
         * @function removeAllLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.removeAllLayers = function () {
            for (var i = 0; i < this.layers.length; i++) {
                var layerID = this.layers[i].ID;
                this.removeLayer(layerID);
            }
        };

        /**
         * @function addDraw
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.addDraw = function(layer) {
            this.globe.addLayer(layer);
        };

         /**
         * @function removeDraw
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.removeDraw = function(layer) {
            this.globe.removeLayer(layer);
        };

        /**
         * Initializes the touch navigation handler.
         * @param {Object} options to add touch navigation
         * @param {Navigation} options.navigation Navigation object
         * @function initTouchNavigation
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.initTouchNavigation = function (options) {
            options.navigation.touch = {
                inversed: this.globe.isSky(),
                zoomOnDblClick: true
            };
            var self = this;
            window.addEventListener("orientationchange", function () {
                self.refresh();
            }, false);
        };

        /**
         * @function refresh
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.refresh = function () {
            if (this.globe) {
              this.globe.refresh();
            }
        };

        /**************************************************************************************************************/

        /**
         * Initialization of the canvas element.
         * When no canvas element is provided, sets to full screen.
         * @function initCanvas
         * @memberOf AbstractContext#
         * @param {Object} canvas Canvas object
         * @param {?Object} canvas.parentElement HTML object
         */
        AbstractContext.prototype.initCanvas = function (canvas) {
            var width, height;
            var parentCanvas = $(canvas.parentElement);
            $(canvas.parentElement).find('#loading').show();

            if ($(canvas).attr("width")) {
                width = $(canvas).attr("width");
            } else if (parentCanvas.attr("width")) {
                width = parentCanvas.attr("width");
            } else {
                //full screen
                width = window.innerWidth;
            }

            if ($(canvas).attr("height")) {
                height = $(canvas).attr("height");
            } else if (parentCanvas.attr("height")) {
                height = parentCanvas.attr("height");
            } else {
                //full screen
                height = window.innerHeight;
            }


            canvas.width = width;
            canvas.height = height;

            // Add some useful css properties to parent element
            if (parentCanvas) {
                parentCanvas.css({
                    position: "relative",
                    overflow: "hidden"
                });
            }

            // Define on resize function
            var self = this;
            var onResize = function () {
                if (parentCanvas && parentCanvas.attr("height") && parentCanvas.attr("width")) {
                    // Embedded
                    canvas.width = parentCanvas.width();
                    canvas.height = parentCanvas.height();
                }
                else {
                    // Fullscreen
                    canvas.width = window.innerWidth;
                    canvas.height = window.innerHeight;
                }
                self.refresh();
            };

            // Take into account window resize 1s after resizing stopped
            var timer;
            $(window).resize(function () {
                if (timer) {
                    clearTimeout(timer);
                }
                timer = setTimeout(onResize, 500);
            });

            // Context lost listener
            canvas.addEventListener("webglcontextlost", function (event) {
                // TODO
                event.preventDefault();
                document.getElementById('loading').style.display = "none";
                document.getElementById('webGLContextLost').style.display = "block";
            }, false);
        };

        /**
         * Initializes the planet or sky events.
         * @function iniGlobeEvents
         * @memberOf AbstractContext#
         * @param {AbstractGlobe} globe Planet or Sky object
         */
        AbstractContext.prototype.initGlobeEvents = function (globe) {
            if (globe) {
                this.globe = globe;
                new AttributionHandler(
                    this.globe,
                    {
                        element: (this.mizarConfiguration.attributionHandler && this.mizarConfiguration.attributionHandler.element)
                            ? this.mizarConfiguration.attributionHandler.element : 'globeAttributions'
                    }
                );
                if (this.mizarConfiguration.isMobile) {
                    this.initTouchNavigation(options);
                }
                this.positionTracker.attachTo(this.globe);
                this.elevationTracker.attachTo(this.globe);
            }
            //When base layer failed to load, open error dialog
            var self = this;
            this.subscribe("baseLayersError", function (layer) {
                $(self.canvas.parentElement).find('#loading').hide();
                //TODOFL console.log("Error with layer",layer);
            });
        };


        /**************************************************************************************************************/

        /**
         * @function show
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.show = function () {
            this.navigation.start();

            // Show UI components depending on its state
            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId) && this.components[componentId]) {
                    $("#" + componentId).fadeIn(1000);
                }
            }
        };

        /**
         * @function showComponents
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.showComponents = function () {
            // Show UI components depending on its state
            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId) && this.components[componentId]) {
                    $("#" + componentId).fadeIn(1000);
                }
            }
        };

        /**
         * @function hideComponents
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.hideComponents = function (uiArray) {
            // Hide all the UI components
            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId) && $.inArray(componentId, uiArray) === -1) {
                    $("#" + componentId).fadeOut();
                }
            }
        };

        /**
         * @function hide
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.hide = function () {
            this.navigation.stopAnimations();
            this.navigation.stop();

            // Hide all the UI components
            for (var componentId in this.components) {
                if (this.components.hasOwnProperty(componentId)) {
                    $("#" + componentId).fadeOut();
                }
            }
        };

        /**
         * @function setComponentVisibility
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.setComponentVisibility = function (componentId, isVisible) {
            var component = $("#" + componentId);
            if (isVisible) {
                component.show();
            }
            else {
                component.hide();
            }

            this.components[componentId] = isVisible;
        };

        /**************************************************************************************************************/

        /**
         * @function showAdditionalLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.showAdditionalLayers = function () {
            _.each(this.visibleLayers, function (layer) {
                layer.setVisible(true);
            });
        };


        /**
         * @function hideAdditionalLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.hideAdditionalLayers = function () {
            var self = this;
            this.visibleLayers = [];
            var gwLayers = this.getAdditionalLayers();
            _.each(gwLayers, function (layer) {
                if (layer.isVisible()) {
                    layer.setVisible(false);
                    self.visibleLayers.push(layer);
                }

            });
        };

        /**
         * @function setBackgroundLayer
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.setBackgroundLayer = function (survey) {
            //var globe = this.globe;

            // Find the layer by name among all the layers
            var gwLayer = this.getLayerByName(survey);
            if (gwLayer) {
                // Check if is not already set
                //if (gwLayer !== globe.baseImagery) {
                // Change visibility's of previous layer, because visibility is used to know the active background layer in the layers list (layers can be shared)
                //if (globe.baseImagery) {
                //    globe.baseImagery.setVisible(false);
                //}
                this.globe.setBaseImagery(gwLayer);
                this.publish("backgroundLayer:change", gwLayer);
                //gwLayer.setVisible(true);

                // // Clear selection
                // PickingManagerCore.getSelection().length = 0;
                //
                // for (var i = 0; i < gwLayers.length; i++) {
                //     var currentLayer = gwLayers[i];
                //     if (currentLayer.subLayers) {
                //         var len = currentLayer.subLayers.length;
                //         for (var j = 0; j < len; j++) {
                //             var subLayer = currentLayer.subLayers[j];
                //             if (subLayer.name === "SolarObjectsSublayer") {
                //                 PickingManagerCore.removePickableLayer(subLayer);
                //                 globe.removeLayer(subLayer);
                //                 currentLayer.subLayers.splice(j, 1);
                //             }
                //         }
                //     }
                // }

                //}
            } else {
                this.publish("backgroundSurveyError", "Survey " + layerName + " hasn't been found");
            }
            return gwLayer;
        };

        /**
         * @function setBackgroundLayerByID
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.setBackgroundLayerByID = function (surveyID) {
            // Find the layer by name among all the layers
            var gwLayer = this.getLayerByID(surveyID);
            if (gwLayer) {
                this.globe.setBaseImagery(gwLayer);
            }
            return gwLayer;
        };

        /**
         * @function getAdditionalLayers
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getAdditionalLayers = function () {
            return _.filter(this.layers, function (layer) {
                return layer.category !== "background";
            });
        };

        /**
         * @function getRenderContext
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getRenderContext = function () {
            return this.globe.getRenderContext();
        };

        /**
         * @function disbable
         * @memberOf AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.disable = function () {
            var renderers = this.getRenderContext().renderers;
            for (var i = 0; i < renderers.length; i++) {
                if (renderers[i].getType() === this.getMode()) {
                    renderers[i].disable();
                }
            }
        };

        /**
         * @function enable
         * @memberOf AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.enable = function () {
            var renderers = this.getRenderContext().renderers;
            for (var i = 0; i < renderers.length; i++) {
                if (renderers[i].getType() === this.getMode()) {
                    renderers[i].enable();
                }
            }
        };

        /**
         * @function setCompassVisible
         * @memberOf AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.setCompassVisible = function (divName, visible) {
            throw new SyntaxError("compass visible not implemented","AbstractContext.js");
        };


        /**
         * @function getMode
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getMode = function () {
            return this.mode;
        };

        /**
         * @function setCoordinateSystem
         * @memberOf AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.setCoordinateSystem = function (cs) {
            throw new SyntaxError("CRS not implemented", "AbstractContext.js");
        };

        /**
         * @function getNavigation
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getNavigation = function () {
            return this.navigation;
        };

        /**
         * @function getCoordinateSystem
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.getCoordinateSystem = function () {
            return this.globe.getCoordinateSystem();
        };

        /**
         * @function addAnimation
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.addAnimation = function (anim) {
            this.globe.addAnimation(anim);
        };

        /**
         * @function removeAnimation
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.removeAnimation = function (anim) {
            this.globe.removeAnimation(anim);
        };

        /**
         * @function render
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.render = function () {
            this.globe.render();
        };

        /**
         * @function dispose
         * @memberOf AbstractContext#
         */
        AbstractContext.prototype.dispose = function () {
            this.globe.dispose();
        };

        AbstractContext.prototype.trackerDestroy = function () {
            if(this.elevationTracker) {
                this.elevationTracker.destroy();
            }
            if (this.positionTracker) {
                this.positionTracker.destroy();
            }
        };

        /**
         * @function destroy
         * @memberOf AbstractContext#
         * @abstract
         */
        AbstractContext.prototype.destroy = function () {
            this.hide();
            this.trackerDestroy();
            this.removeAllLayers();
            this.components = null;
            this.layers = null;
            this.visibleLayers = null;
            this.dataProviders = null;
            this.mizarConfiguration = null;
            this.credits = null;
            this.ctxOptions = null;
            this.mode = null;

            this.unsubscribe("baseLayersReady", function (imagery) {
                // When the background takes time to load, the viewMatrix computed by "computeViewMatrix" is created but
                // with empty values. Because of that, the globe cannot be displayed without moving the camera.
                // So we rerun "computeViewMatrix" once "baseLayersReady" is loaded to display the globe
                if(self.getNavigation().getRenderContext().viewMatrix[0] !== "undefined") {
                    self.getNavigation().computeViewMatrix();
                }
            });

            this.navigation.destroy();
            this.globe.destroy();
            this.navigation = null;
            this.canvas = null;
            this.globe = null;
        };

        /**************************************************************************************************************/

        return AbstractContext;

    }
);

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TilePool',[],function () {

    /**************************************************************************************************************/

    /**
     @constructor
     TilePool constructor
     */
    var TilePool = function (rc) {
        // Private properties
        var gl = rc.gl;
        var glTexturePools = {};
        var glBuffers = [];
        var self = this;

        // Choose floating point texture filtering depending on extension support
        var float_linear_ext = gl.getExtension("OES_texture_float_linear");
        var float_filtering = float_linear_ext ? gl.LINEAR : gl.NEAREST;

        // Public properties
        this.numCreatedTextures = 0;
        this.numReusedTextures = 0;

        // Private methods

        /**************************************************************************************************************/

        /**
         Create a new GL texture
         */
        var createNewGLTexture = function (image, texturePool) {
            var glTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);
            if (image.dataType === "byte") {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, float_filtering);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, float_filtering);
            }

            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            glTexture.pool = texturePool;
            self.numCreatedTextures++;

            return glTexture;
        };

        /**************************************************************************************************************/

        /**
         Reuse a GL texture
         */
        var reuseGLTexture = function (image, texturePool) {
            var glTexture = texturePool.pop();
            gl.bindTexture(gl.TEXTURE_2D, glTexture);

            if (image.dataType === "byte") {
                //gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
                gl.generateMipmap(gl.TEXTURE_2D);
            }
            else {
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.LUMINANCE, image.width, image.height, 0, gl.LUMINANCE, gl.FLOAT, image.typedArray);
            }

            self.numReusedTextures++;

            return glTexture;
        };

        /**
         * Get or create a texture pool for the given image
         */
        var getOrCreateTexturePool = function (image) {
            var key = image.dataType + image.width;
            if (!glTexturePools[key]) {
                glTexturePools[key] = [];
            }
            return glTexturePools[key];
        };

        // Public methods

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLTexture = function (image) {
            var texturePool = getOrCreateTexturePool(image);

            if (texturePool.length > 0) {
                return reuseGLTexture(image, texturePool);
            }
            else {
                return createNewGLTexture(image, texturePool);
            }
        };

        /**************************************************************************************************************/

        /**
         Create a GL texture to be used by a tile
         */
        this.createGLBuffer = function (vertices) {
            var vb;
            if (glBuffers.length > 0) {
                vb = glBuffers.pop();
            }
            else {
                vb = gl.createBuffer();
            }
            gl.bindBuffer(gl.ARRAY_BUFFER, vb);
            gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

            return vb;
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLTexture = function (texture) {
            texture.pool.push(texture);
        };

        /**************************************************************************************************************/

        /**
         Dispose a texture
         */
        this.disposeGLBuffer = function (buffer) {
            glBuffers.push(buffer);
        };

        /**************************************************************************************************************/

        /**
         Dispose all
         */

        this.disposeAll = function () {
            var i;
            for (var key in glTexturePools) {
                if (glTexturePools.hasOwnProperty(key)) {
                    var glTextures = glTexturePools[key];
                    for (i = 0; i < glTextures.length; i++) {
                        gl.deleteTexture(glTextures[i]);
                    }
                }
            }
            glTexturePools = {};

            for (i = 0; i < glBuffers.length; i++) {
                gl.deleteBuffer(glBuffers[i]);
            }
            glBuffers.length = 0;
        };

        /**************************************************************************************************************/
    };

    return TilePool;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileRequest',['./Tile', '../Utils/ImageRequest'], function (Tile, ImageRequest) {
  /**************************************************************************************************************/


    /**************************************************************************************************************/

    /** @constructor
     TileRequest constructor
     */
    var TileRequest = function (tileManager) {
        // Private variables
        var _imageLoaded = false;
        var _elevationLoaded = true;
        var _xhr = new XMLHttpRequest();
        var _imageRequest;

        // Public variables
        this.tile = null;
        this.elevations = null;
        this.image = null;

        var self = this;

        /**
         Handle when elevation is loaded
         */
        var _handleLoadedElevation = function () {
            self.elevations = tileManager.elevationProvider.parseElevations(_xhr.responseText);
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading elevation failed
         */
        var _handleErrorElevation = function () {
            self.elevations = null;
            _elevationLoaded = true;

            if (_imageLoaded) {
                tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
                tileManager.completedRequests.push(self);
                tileManager.renderContext.requestFrame();
            }
        };

        // Setup the XHR callback
        _xhr.onreadystatechange = function (e) {
            if (_xhr.readyState === 4) {
                if (_xhr.status === 200) {
                    _handleLoadedElevation();
                }
                else {
                    _handleErrorElevation();
                }
            }
        };


        /**************************************************************************************************************/

        /**
         Handle when image is loaded
         */
        var _handleLoadedImage = function () {
            // The method can be called twice when the image is in the cache (see launch())
            if (!_imageLoaded) {
                _imageLoaded = true;
                if (_elevationLoaded) {
                    // Call post-process function if defined
                    if (tileManager.imageryProvider && tileManager.imageryProvider.handleImage) {
                        tileManager.imageryProvider.handleImage(_imageRequest);
                    }

                    tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
                    tileManager.completedRequests.push(self);
                    tileManager.renderContext.requestFrame();
                }
                self.image = _imageRequest.image;
            }
        };

        /**************************************************************************************************************/

        /**
         Handle when loading image failed
         */
        var _handleErrorImage = function () {
            self.tile.state = Tile.State.ERROR;
            tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
            tileManager.availableRequests.push(self);
        };

        /**************************************************************************************************************/

        /**
         Abort request
         */
        var _handleAbort = function () {
            self.tile.state = Tile.State.NONE;
            tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(self), 1);
            tileManager.availableRequests.push(self);
        };



        /**************************************************************************************************************/

        /**
         Launch the HTTP request for a tile
         */
        this.launch = function (tile) {
            tile.state = Tile.State.LOADING;
            this.tile = tile;
            tileManager.pendingRequests.push(this);

            this.image = null;
            this.elevations = null;

            // Request the elevation if needed
            if (tileManager.elevationProvider) {
                // TODO : handle the elevations coming from cache
                _elevationLoaded = false;
                _xhr.open("GET", tileManager.elevationProvider.getUrl(tile));

                // Set withCredentials property after "open": http://stackoverflow.com/questions/19666809/cors-withcredentials-support-limited?answertab=votes#tab-top
                var useCredentials = tileManager.elevationProvider.crossOrigin === 'use-credentials';
                _xhr.withCredentials = useCredentials;

                _xhr.send();
            }
            else {
                _elevationLoaded = true;
            }

            if (tileManager.imageryProvider) {
                if (!_imageRequest) {
                    _imageRequest = new ImageRequest({
                        successCallback: function () {
                            _handleLoadedImage();
                            if (tileManager.imageryProvider.cache) {
                                tileManager.imageryProvider.cache.storeInCache(self);
                            }
                        },
                        failCallback: _handleErrorImage,
                        abortCallback: _handleAbort
                    });
                }

                // Check if the image isn't already loaded in cache
                var cachedTileRequest;
                if (tileManager.imageryProvider.cache) {
                    cachedTileRequest = cachedTileRequest = tileManager.imageryProvider.cache.getFromCache(tile);
                }

                _imageLoaded = false;
                if (cachedTileRequest) {
                    _imageRequest.image = cachedTileRequest.image;
                    _handleLoadedImage();
                }
                else {
                    // Tile not found in cache or cache isn't activated, send the request
                    _imageRequest.send(tileManager.imageryProvider.getUrl(tile), tileManager.imageryProvider.crossOrigin);
                }

            }
            else {
                _imageLoaded = true;
            }

            // Check if there is nothing to load
            if (!tileManager.imageryProvider && !tileManager.elevationProvider) {
                tileManager.pendingRequests.splice(tileManager.pendingRequests.indexOf(this), 1);
                tileManager.completedRequests.push(this);
            }
        };

        /**************************************************************************************************************/

        /**
         *    Abort launched request
         */
        this.abort = function () {
            if (_imageRequest) {
                _imageRequest.abort();
            }
        };

    };

    /**************************************************************************************************************/

    return TileRequest;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileIndexBuffer',[],function () {

    /**************************************************************************************************************/

    /**
     @constructor TileIndexBuffer
     TileIndexBuffer
     */
    var TileIndexBuffer = function (renderContext, config) {
        this.renderContext = renderContext;
        this.config = config;
        this.solidIndexBuffer = null;
        this.subSolidIndexBuffer = [null, null, null, null];
        this.subIndices = [null, null, null, null];
    };

    /**************************************************************************************************************/

    /**
     * Reset the index buffers.
     */
    TileIndexBuffer.prototype.reset = function () {
        var gl = this.renderContext.gl;
        for (var i = 0; i < 4; i++) {
            if (this.subSolidIndexBuffer[i]) {
                gl.deleteBuffer(this.subSolidIndexBuffer[i]);
                this.subSolidIndexBuffer[i] = null;
            }
        }
        if (this.solidIndexBuffer) {
            gl.deleteBuffer(this.solidIndexBuffer);
            this.solidIndexBuffer = null;
        }
    };

    /**************************************************************************************************************/

    /**
     *    Get index buffer for sub solid
     */
    TileIndexBuffer.prototype.getSubSolid = function (ii) {
        if (this.subSolidIndexBuffer[ii] === null) {
            var i = ii % 2;
            var j = Math.floor(ii / 2);
            var n,k;

            var size = this.config.tesselation;
            var halfTesselation = (size - 1) / 2;

            // Build the sub grid for 'inside' tile
            var indices = [];
            for (n = halfTesselation * j; n < halfTesselation * (j + 1); n++) {
                for (k = halfTesselation * i; k < halfTesselation * (i + 1); k++) {
                    indices.push(n * size + k);
                    indices.push((n + 1) * size + k);
                    indices.push(n * size + k + 1);

                    indices.push(n * size + k + 1);
                    indices.push((n + 1) * size + k);
                    indices.push((n + 1) * size + k + 1);
                }
            }

            this.subIndices[ii] = indices;

            if (this.config.skirt) {
                // Build skirts
                // Top skirt
                var start = (j === 0) ? size * size : size * size + 4 * size;
                var src = (j === 0) ? 0 : halfTesselation * size;
                for (n = halfTesselation * i; n < halfTesselation * (i + 1); n++) {
                    indices.push(start + n);
                    indices.push(src + n);
                    indices.push(start + n + 1);

                    indices.push(start + n + 1);
                    indices.push(src + n);
                    indices.push(src + n + 1);
                }

                // Bottom skirt
                start = (j === 0) ? size * size + 4 * size : size * size + size;
                src = (j === 0) ? halfTesselation * size : (size - 1) * size;
                for (n = halfTesselation * i; n < halfTesselation * (i + 1); n++) {
                    indices.push(src + n);
                    indices.push(start + n);
                    indices.push(src + n + 1);

                    indices.push(src + n + 1);
                    indices.push(start + n);
                    indices.push(start + n + 1);
                }

                // Left skirt
                start = (i === 0) ? size * size + 2 * size : size * size + 5 * size;
                src = (i === 0) ? 0 : halfTesselation;
                for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
                    indices.push(start + k);
                    indices.push(start + k + 1);
                    indices.push(src + k * size);

                    indices.push(src + k * size);
                    indices.push(start + k + 1);
                    indices.push(src + (k + 1) * size);
                }

                // Right skirt
                start = (i === 0) ? size * size + 5 * size : size * size + 3 * size;
                src = (i === 0) ? halfTesselation : size - 1;
                for (k = halfTesselation * j; k < halfTesselation * (j + 1); k++) {
                    indices.push(k * size + src);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k);

                    indices.push(start + k);
                    indices.push((k + 1) * size + src);
                    indices.push(start + k + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            ib.numIndices = indices.length;
            this.subSolidIndexBuffer[ii] = ib;
        }

        return this.subSolidIndexBuffer[ii];
    };

    /**************************************************************************************************************/

    /*
     Build index buffer
     */
    TileIndexBuffer.prototype.getSolid = function () {
        if (this.solidIndexBuffer === null) {
            var i,j;
            var size = this.config.tesselation;
            var indices = [];
            // Build the grid
            for (j = 0; j < size - 1; j++) {
                for (i = 0; i < size - 1; i++) {
                    indices.push(j * size + i);
                    indices.push((j + 1) * size + i);
                    indices.push(j * size + i + 1);

                    indices.push(j * size + i + 1);
                    indices.push((j + 1) * size + i);
                    indices.push((j + 1) * size + i + 1);
                }
            }

            if (this.config.skirt) {
                // Top skirt
                var start = size * size;
                for (i = 0; i < size - 1; i++) {
                    indices.push(start + i);
                    indices.push(i);
                    indices.push(start + i + 1);

                    indices.push(start + i + 1);
                    indices.push(i);
                    indices.push(i + 1);
                }

                // Bottom skirt
                start += size;
                for (i = 0; i < size - 1; i++) {
                    indices.push((size - 1) * size + i);
                    indices.push(start + i);
                    indices.push((size - 1) * size + i + 1);

                    indices.push((size - 1) * size + i + 1);
                    indices.push(start + i);
                    indices.push(start + i + 1);
                }

                // Left skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    indices.push(start + j);
                    indices.push(start + j + 1);
                    indices.push(j * size);

                    indices.push(j * size);
                    indices.push(start + j + 1);
                    indices.push((j + 1) * size);
                }

                // Right skirt
                start += size;
                for (j = 0; j < size - 1; j++) {
                    indices.push(j * size + size - 1);
                    indices.push((j + 1) * size + size - 1);
                    indices.push(start + j);

                    indices.push(start + j);
                    indices.push((j + 1) * size + size - 1);
                    indices.push(start + j + 1);
                }
            }

            var gl = this.renderContext.gl;
            var ib = gl.createBuffer();
            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ib);
            gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(indices), gl.STATIC_DRAW);
            this.numIndices = indices.length;

            this.solidIndexBuffer = ib;
            this.solidIndexBuffer.numIndices = indices.length;
        }

        return this.solidIndexBuffer;
    };

    /**************************************************************************************************************/

    return TileIndexBuffer;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Tiling/TileManager',['./Tile', './GeoTiling', './TilePool', './TileRequest', './TileIndexBuffer', '../Renderer/Program'],
    function (Tile, GeoTiling, TilePool, TileRequest, TileIndexBuffer, Program) {
        /** @constructor
         TileManager constructor

         Take in parameters its parent : can be a globe or a sky
         */
        var TileManager = function (parent, options) {
            //TOOD f(tile)
            // this.processedLevel = 0;
            this.parent = parent;
            this.publishEvent = options.publishEvent;
            this.renderContext = this.parent.renderContext;
            // Create a new tile pool or use the one from the parent
            this.tilePool = parent.tilePool || new TilePool(this.renderContext);
            this.tiling = new GeoTiling(4, 2); // Use geo tiling by default

            this.imageryProvider = null;
            this.elevationProvider = null;
            this.tilesToRender = [];
            this.visibleTiles = [];
            this.tilesToRequest = [];
            this.postRenderers = [];

            // Init default texture
            var gl = this.renderContext.gl;
            this.defaultTexture = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
            var defaultColor = options.defaultColor ? options.defaultColor : [200, 200, 200, 255];
            var pixel = new Uint8Array(defaultColor);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, pixel);

            // Tile requests : limit to 4 at a given time
            this.maxRequests = 4;
            this.availableRequests = [];
            for (var i = 0; i < this.maxRequests; i++) {
                this.availableRequests[i] = new TileRequest(this);
            }
            this.pendingRequests = [];
            this.completedRequests = [];

            this.level0TilesLoaded = false;

            // Configuration for tile
            this.tileConfig = {
                tesselation: 9,
                skirt: true,
                cullSign: 1.0,
                imageSize: 256,
                vertexSize: this.renderContext.lighting ? 6 : 3,
                normals: this.renderContext.lighting,
                coordinateSystem: this.parent.coordinateSystem
            };
            this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool);

            // Shared index and texture coordinate buffer : all tiles uses the same
            this.tcoordBuffer = null;
            this.tileIndexBuffer = new TileIndexBuffer(this.renderContext, this.tileConfig);

            // HACK : to fix sky rendering, sets to false
            this.renderTileWithoutTexture = options.hasOwnProperty('renderTileWithoutTexture') ? options.renderTileWithoutTexture : true;

            // For debug
            this.freeze = false;

            // Stats
            this.numTilesGenerated = 0;
            this.frameNumber = 0;

            this.vertexShader = "attribute vec3 vertex;\n";
            this.vertexShader += "attribute vec2 tcoord;\n";
            this.vertexShader += "uniform mat4 modelViewMatrix;\n";
            this.vertexShader += "uniform mat4 projectionMatrix;\n";
            this.vertexShader += "varying vec2 texCoord;\n";
            if (this.renderContext.lighting) {
                this.vertexShader += "attribute vec3 normal;\nvarying vec3 color;\n";
            }
            this.vertexShader += "void main(void) \n";
            this.vertexShader += "{\n";
            this.vertexShader += "gl_Position = projectionMatrix * modelViewMatrix * vec4(vertex, 1.0);\n";
            if (this.renderContext.lighting) {
                this.vertexShader += "vec4 vn = modelViewMatrix * vec4(normal,0);\ncolor = max( vec3(-vn[2],-vn[2],-vn[2]), 0.0 );\n";
            }
            this.vertexShader += "texCoord = tcoord;\n";
            this.vertexShader += "}\n";

            this.fragmentShader = "precision lowp float; \n";
            this.fragmentShader += "varying vec2 texCoord;\n";
            if (this.renderContext.lighting) {
                this.fragmentShader += "varying vec3 color;\n";
            }
            this.fragmentShader += "uniform sampler2D colorTexture;\n";
            this.fragmentShader += "void main(void)\n";
            this.fragmentShader += "{\n";
            this.fragmentShader += "	gl_FragColor.rgb = texture2D(colorTexture, texCoord).rgb;\n";
            if (this.renderContext.lighting) {
                this.fragmentShader += "  gl_FragColor.rgb *= color;\n";
            }
            this.fragmentShader += "  gl_FragColor.a = 1.0;\n";
            this.fragmentShader += "}\n";

            this.program = new Program(this.renderContext);
            this.program.createFromSource(this.vertexShader, this.fragmentShader);
        };

        /**************************************************************************************************************/

        /**
         Add post renderer
         */
        TileManager.prototype.addPostRenderer = function (renderer) {
            this.postRenderers.push(renderer);

            this.postRenderers.sort(function (r1, r2) {
                var z1 = r1.zIndex | 0;
                var z2 = r2.zIndex | 0;
                return z1 - z2;
            });

            if (renderer.generate) {
                this.visitTiles(function (tile) {

                    renderer.generate(tile);
                });
            }
        };

        /**************************************************************************************************************/

        /**
         Remove a post renderer
         */
        TileManager.prototype.removePostRenderer = function (renderer) {
            var rendererIndex = this.postRenderers.indexOf(renderer);
            if (rendererIndex !== -1) {
                // Remove the renderer from all the tiles if it has a cleanupTile method
                if (renderer.cleanupTile) {
                    this.visitTiles(function (tile) {
                        renderer.cleanupTile(tile);
                    });
                }
                // Remove renderer from the list
                this.postRenderers.splice(rendererIndex, 1);
            }
        };

        /**************************************************************************************************************/

        /**
         Set the imagery provider to be used
         */
        TileManager.prototype.setImageryProvider = function (ip) {
            this.reset();
            this.imageryProvider = ip;

            if (ip) {
                // Clean tile pool
                this.tilePool.disposeAll();

                this.tiling = ip.tiling;

                // Rebuild level zero tiles
                this.tileConfig.imageSize = ip.tilePixelSize;
                this.level0Tiles = this.tiling.generateLevelZeroTiles(this.tileConfig, this.tilePool);

                // Update program
                if (ip.customShader) {
                    this.program.dispose();
                    this.program = new Program(this.renderContext);

                    // Memorize current fragment shader
                    this.currentFragmentShader = ip.customShader.fragmentCode ? ip.customShader.fragmentCode : this.fragmentShader;
                    this.program.createFromSource(ip.customShader.vertexCode ? ip.customShader.vertexCode : this.vertexShader,
                        this.currentFragmentShader);
                }
                else {
                    // Revert to default if needed
                    if (this.currentFragmentShader !== null) {
                        this.program.dispose();
                        this.program = new Program(this.renderContext);
                        this.program.createFromSource(this.vertexShader, this.fragmentShader);
                        this.currentFragmentShader = null;
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Set the elevation provider to be used
         */
        TileManager.prototype.setElevationProvider = function (tp) {
            this.reset();
            this.elevationProvider = tp;

            var newTesselation = tp ? tp.tilePixelSize : 9;
            if (newTesselation !== this.tileConfig.tesselation) {
                this.tileConfig.tesselation = newTesselation;

                // Reset the shared buffers : texture coordinate and indices
                var gl = this.renderContext.gl;
                this.tileIndexBuffer.reset();
                gl.deleteBuffer(this.tcoordBuffer);
                this.tcoordBuffer = null;
            }
        };

        /**************************************************************************************************************/

        /**
         Reset the tile manager : unload all tiles
         */
        TileManager.prototype.reset = function () {
            // Abort all pending requests
            this.abortRequests();

            // Reset all level zero tiles : destroy render data, and reset state to NONE
            for (var i = 0; i < this.level0Tiles.length; i++) {
                this.level0Tiles[i].deleteChildren(this.renderContext, this.tilePool);
                this.level0Tiles[i].dispose(this.renderContext, this.tilePool);
            }

            this.tileIndexBuffer.reset();

            this.level0TilesLoaded = false;
        };

        /**************************************************************************************************************/

        /**
         *    Abort all pending requests
         */
        TileManager.prototype.abortRequests = function () {
            for (var i = this.pendingRequests.length - 1; i >= 0; i--) {
                this.pendingRequests[i].abort();
            }
        };

        /**************************************************************************************************************/

        /**
         * Tile visitor
         * @param callback - Callback function on tile
         */
        TileManager.prototype.visitTiles = function (callback) {
            // Store the tiles to process in an array, first copy level0 tiles
            var tilesToProcess = this.level0Tiles.concat([]);

            while (tilesToProcess.length > 0) {
                // Retrieve the first tile and remove it from the array
                var tile = tilesToProcess.shift();

                callback(tile);

                // Add tile children to array to be processed later
                if (tile.children) {
                    tilesToProcess.push(tile.children[0]);
                    tilesToProcess.push(tile.children[1]);
                    tilesToProcess.push(tile.children[2]);
                    tilesToProcess.push(tile.children[3]);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Traverse tiless tiles
         @fires Context#baseLayersReady
         @fires Context#baseLayersError
         */
        TileManager.prototype.traverseTiles = function () {
            this.tilesToRender.length = 0;
            this.visibleTiles.length = 0;
            this.tilesToRequest.length = 0;
            this.numTraversedTiles = 0;
            var i, tile;

            // First load level 0 tiles if needed
            if (!this.level0TilesLoaded) {
                this.level0TilesLoaded = true;
                for (i = 0; i < this.level0Tiles.length; i++) {
                    tile = this.level0Tiles[i];

                    var tileIsLoaded = tile.state === Tile.State.LOADED;

                    // Update frame number
                    tile.frameNumber = this.frameNumber;

                    this.level0TilesLoaded = this.level0TilesLoaded && tileIsLoaded;
                    if (!tileIsLoaded) {
                        // Request tile if necessary
                        if (tile.state === Tile.State.NONE) {
                            tile.state = Tile.State.REQUESTED;
                            this.tilesToRequest.push(tile);
                        }
                        else if (tile.state === Tile.State.ERROR && this.imageryProvider) {
                            this.publishEvent("baseLayersError", this.imageryProvider);
                        }
                    }
                }
                if (this.level0TilesLoaded && this.imageryProvider) {
                    this.publishEvent("baseLayersReady", this.imageryProvider);
                }
            }

            // Traverse tiles
            if (this.level0TilesLoaded) {
                // Normal traversal, iterate through level zero tiles and process them recursively
                for (i = 0; i < this.level0Tiles.length; i++) {
                    tile = this.level0Tiles[i];
                    if (!tile.isCulled(this.renderContext)) {
                        this.processTile(tile, 0);
                    }
                    else {
                        // Delete its children
                        tile.deleteChildren(this.renderContext, this.tilePool);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Process a tile
         */
        TileManager.prototype.processTile = function (tile, level) {
            this.numTraversedTiles++;

            // Update frame number
            tile.frameNumber = this.frameNumber;

            var isLeaf = true;

            // Request the tile if needed
            if (tile.state === Tile.State.NONE) {
                tile.state = Tile.State.REQUESTED;

                // Add it to the request
                this.tilesToRequest.push(tile);
            }

            // Check if the tiles needs to be refined
            // We only refine loaded tile
            if (tile.state === Tile.State.LOADED) {
                if (this.imageryProvider) {
                    isLeaf = level >= this.imageryProvider.numberOfLevels;
                }
                else {
                    isLeaf = false;
                }

                isLeaf |= !tile.needsToBeRefined(this.renderContext);
            }

            if (isLeaf) {
                // Push the tiles to render only if the texture is valid or there is no imagery provider defined
                if (tile.texture || this.renderTileWithoutTexture) {
                    this.tilesToRender.push(tile);
                }
                this.visibleTiles.push(tile);
            }
            else {
                // Create the children if needed
                if (tile.children === null) {
                    tile.createChildren();
                }

                for (var i = 0; i < 4; i++) {
                    if (!tile.children[i].isCulled(this.renderContext)) {
                        this.processTile(tile.children[i], level + 1);
                    }
                    else {
                        tile.children[i].deleteChildren(this.renderContext, this.tilePool);
                    }
                }
            }

            // Traverse extension
            for (var x in tile.extension) {
                if(tile.extension.hasOwnProperty(x)) {
                    var e = tile.extension[x];
                    if (e.traverse) {
                        e.traverse(tile, isLeaf);
                    }
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Generate tile
         */
        TileManager.prototype.generateTile = function (tile, tileRequest) {
            //TODO display geojson=f(tile)
            //this.processedLevel = tile.level;
            //console.log("level="+tile.level);
            // Generate the tile using data from tileRequest if defined
            tile.generate(this.tilePool, tileRequest.image, tileRequest.elevations);

            // Now post renderers can generate their data on the new tile
            for (var i = 0; i < this.postRenderers.length; i++) {
                if (this.postRenderers[i].generate) {
                    this.postRenderers[i].generate(tile);
                }
            }

            this.numTilesGenerated++;
            this.renderContext.requestFrame();
        };

        /**************************************************************************************************************/

        /**
         Generate tiles
         @fires Context#endBackgroundLoad
         */
        TileManager.prototype.generateReceivedTiles = function () {
            while (this.completedRequests.length > 0) {
                var tileRequest = this.completedRequests.pop();
                var tile = tileRequest.tile;
                if (tile.frameNumber === this.frameNumber) {
                    this.generateTile(tile, tileRequest);
                }
                else {
                    tile.state = Tile.State.NONE;
                }
                this.availableRequests.push(tileRequest);
            }

            // All requests have been processed, send endBackgroundLoad event
            if (this.availableRequests.length === this.maxRequests && this.imageryProvider) {
                this.publishEvent("endBackgroundLoad");
            }

        };

        /**************************************************************************************************************/

        /**
         Render tiles
         */
        TileManager.prototype.renderTiles = function () {
            var rc = this.renderContext;
            var gl = rc.gl;
            var i, tile;
            // Compute near/far from tiles
            var nr;
            var fr;
            if (this.tileConfig.cullSign < 0) {
                // When in "Astro" mode, do not compute near/far from tiles not really needed
                // And the code used for "Earth" does not works really well, when the earth is seen from inside...
                nr = 0.2 * this.tileConfig.coordinateSystem.geoide.radius;
                fr = 1.1 * this.tileConfig.coordinateSystem.geoide.radius;
            }
            else {
                nr = 1e9;
                fr = 0.0;
                for (i = 0; i < this.visibleTiles.length; i++) {
                    tile = this.visibleTiles[i];
                    // Update near/far to take into account the tile
                    nr = Math.min(nr, tile.distance - 1.5 * tile.radius);
                    fr = Math.max(fr, tile.distance + 1.5 * tile.radius);
                }
            }
            rc.near = Math.max(rc.minNear, nr);
            rc.far = Math.max(rc.minFar, fr);

            if (this.tilesToRender.length !== 0) {
                // Set state (depends if geo or astro)
                if (this.tileConfig.cullSign < 0) {
                    gl.depthMask(false);
                    gl.disable(gl.DEPTH_TEST);
                    gl.disable(gl.CULL_FACE);
                }
                else {
                    gl.enable(gl.POLYGON_OFFSET_FILL);
                    gl.polygonOffset(0, 4);
                }

                // Check if the program of imagery provider changed
                // Only for fragment shader for now
                if (this.currentFragmentShader && this.currentFragmentShader !== this.imageryProvider.customShader.fragmentCode) {
                    this.program.dispose();
                    this.program = new Program(this.renderContext);

                    if (this.imageryProvider && this.imageryProvider.customShader) {
                        this.currentFragmentShader = this.imageryProvider.customShader.fragmentCode ? this.imageryProvider.customShader.fragmentCode : this.fragmentShader;
                        this.program.createFromSource(this.imageryProvider.customShader.vertexShader ? this.imageryProvider.customShader.vertexShader : this.vertexShader,
                            this.currentFragmentShader);
                    }
                }

                // Setup program
                this.program.apply();

                var attributes = this.program.attributes;

                // Update projection matrix with new near and far values
                mat4.perspective(rc.fov, rc.canvas.width / rc.canvas.height, rc.near, rc.far, rc.projectionMatrix);

                // Update uniforms if needed
                if (this.imageryProvider && this.imageryProvider.customShader) {
                    this.imageryProvider.customShader.updateUniforms(gl, this.program);
                }

                // Setup state
                gl.activeTexture(gl.TEXTURE0);
                gl.uniformMatrix4fv(this.program.uniforms.projectionMatrix, false, rc.projectionMatrix);
                gl.uniform1i(this.program.uniforms.colorTexture, 0);

                // Bind the texture coordinate buffer (shared between all tiles
                if (!this.tcoordBuffer) {
                    this.buildSharedTexCoordBuffer();
                }
                gl.bindBuffer(gl.ARRAY_BUFFER, this.tcoordBuffer);
                gl.vertexAttribPointer(attributes.tcoord, 2, gl.FLOAT, false, 0, 0);

                var currentIB = null;

                for (i = 0; i < this.tilesToRender.length; i++) {
                    tile = this.tilesToRender[i];

                    var isLoaded = ( tile.state === Tile.State.LOADED );
                    var isLevelZero = ( tile.parentIndex === -1 );

                    // Bind tile texture if defined, the default texture otherwise
                    if (tile.texture) {
                        gl.bindTexture(gl.TEXTURE_2D, tile.texture);
                    }
                    else {
                        gl.bindTexture(gl.TEXTURE_2D, this.defaultTexture);
                    }

                    // Update uniforms for modelview matrix
                    mat4.multiply(rc.viewMatrix, tile.matrix, rc.modelViewMatrix);
                    gl.uniformMatrix4fv(this.program.uniforms.modelViewMatrix, false, rc.modelViewMatrix);

                    // Bind the vertex buffer
                    gl.bindBuffer(gl.ARRAY_BUFFER, tile.vertexBuffer);
                    gl.vertexAttribPointer(attributes.vertex, 3, gl.FLOAT, false, 4 * this.tileConfig.vertexSize, 0);
                    if (this.tileConfig.normals) {
                        gl.vertexAttribPointer(attributes.normal, 3, gl.FLOAT, false, 4 * this.tileConfig.vertexSize, 12);
                    }

                    var indexBuffer = ( isLoaded || isLevelZero ) ? this.tileIndexBuffer.getSolid() : this.tileIndexBuffer.getSubSolid(tile.parentIndex);
                    // Bind the index buffer only if different (index buffer is shared between tiles)
                    if (currentIB !== indexBuffer) {
                        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
                        currentIB = indexBuffer;
                    }

                    // Finally draw the tiles
                    gl.drawElements(gl.TRIANGLES, currentIB.numIndices, gl.UNSIGNED_SHORT, 0);
                }

                if (this.tileConfig.cullSign < 0) {
                    gl.depthMask(true);
                    gl.enable(gl.DEPTH_TEST);
                }
                else {
                    gl.disable(gl.POLYGON_OFFSET_FILL);
                }
            }

            for (i = 0; i < this.postRenderers.length; i++) {
                this.postRenderers[i].render(this.visibleTiles);
            }
        };

// Internal function to sort tiles
        var _sortTilesByDistance = function (t1, t2) {
            return t1.distance - t2.distance;
        };

        /**************************************************************************************************************/

        /**
         Request tiles
         @fires Context#startBackgroundLoad
         */
        TileManager.prototype.launchRequests = function () {
            // Process request
            this.tilesToRequest.sort(_sortTilesByDistance);

            var trl = this.tilesToRequest.length;
            for (var i = 0; i < trl; i++) {
                var tile = this.tilesToRequest[i];
                if (this.availableRequests.length > 0) // Check to limit the number of requests done per frame
                {
                    // First launch request, send an event
                    if (this.availableRequests.length === this.maxRequests && this.imageryProvider) {
                        this.publishEvent("startBackgroundLoad");
                    }

                    var tileRequest = this.availableRequests.pop();
                    tileRequest.launch(tile);
                }
                else {
                    tile.state = Tile.State.NONE;
                }
            }
        };

        /**************************************************************************************************************/

        /**
         Render the tiles
         @fires Context#baseLayersReady
         */
        TileManager.prototype.render = function () {
            /*           console.log("TileManager.prototype.render",this.tileConfig.coordSystem);
             if (this.tileConfig.coordSystem === "GAL") {
             console.log("No rendering");
             return;
             }
             console.log("============================================");
             */
            if (this.imageryProvider && !this.imageryProvider._ready) {
                return;
            }

            // Specific case when the image provider has a level zero image : generate the texture for each level zero tile
            if (!this.level0TilesLoaded && this.imageryProvider && this.imageryProvider.levelZeroImage) {
                this.imageryProvider.generateLevel0Textures(this.level0Tiles, this.tilePool);

                for (var n = 0; n < this.level0Tiles.length; n++) {
                    var tile = this.level0Tiles[n];
                    // Generate the tile without tile request
                    this.generateTile(tile, {});
                }

                this.level0TilesLoaded = true;

                this.publishEvent("baseLayersReady", this.parent.isSky());
            }

            var stats = this.renderContext.stats;

            if (!this.freeze) {
                if (stats) {
                    stats.start("traverseTime");
                }
                this.traverseTiles();
                if (stats) {
                    stats.end("traverseTime");
                }
            }

            if (this.level0TilesLoaded || !this.imageryProvider) {
                if (stats) {
                    stats.start("renderTime");
                }
                this.renderTiles();
                if (stats) {
                    stats.end("renderTime");
                }
            }

            if (stats) {
                stats.start("generateTime");
            }
            this.generateReceivedTiles();
            if (stats) {
                stats.end("generateTime");
            }

            if (stats) {
                stats.start("requestTime");
            }
            this.launchRequests();
            if (stats) {
                stats.end("requestTime");
            }

            this.frameNumber++;
        };

        /**************************************************************************************************************/

        /**
         Returns visible tile for given longitude/latitude, null otherwise
         */
        TileManager.prototype.getVisibleTile = function (lon, lat) {
            return this.tiling.findInsideTile(lon, lat, this.visibleTiles);
        };

        /**************************************************************************************************************/

        /**
         Build shared texture coordinate buffer
         */
        TileManager.prototype.buildSharedTexCoordBuffer = function () {
            var size = this.tileConfig.tesselation;
            var skirt = this.tileConfig.skirt;
            var bufferSize = 2 * size * size;
            if (skirt) {
                bufferSize += 2 * size * 6;
            }

            var tcoords = new Float32Array(bufferSize);

            var step = 1.0 / (size - 1);

            var offset = 0;
            var u, v;
            var i, j;
            v = 0.0;
            for (j = 0; j < size; j++) {
                u = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;

                    offset += 2;
                    u += step;
                }

                v += step;
            }

            if (skirt) {
                // Top skirt
                u = 0.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }
                // Bottom skirt
                u = 0.0;
                v = 1.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }
                // Left skirt
                u = 0.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }
                // Right skirt
                u = 1.0;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }

                // Center skirt
                u = 0.0;
                v = 0.5;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    u += step;
                    offset += 2;
                }

                // Middle skirt
                u = 0.5;
                v = 0.0;
                for (i = 0; i < size; i++) {
                    tcoords[offset] = u;
                    tcoords[offset + 1] = v;
                    v += step;
                    offset += 2;
                }
            }

            var gl = this.renderContext.gl;
            var tcb = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, tcb);
            gl.bufferData(gl.ARRAY_BUFFER, tcoords, gl.STATIC_DRAW);

            this.tcoordBuffer = tcb;
        };

        /**
         * Set freeze
         * @function setFreeze
         * @memberof TileManager.prototype
         * @param {Boolean} freeze Freeze active or not
         */
        TileManager.prototype.setFreeze = function (freeze) {
            this.freeze = freeze;
        };
        /**
         * Get freeze
         * @function getFreeze
         * @memberof TileManager.prototype
         * @return {Boolean} Freeze active or not
         */
        TileManager.prototype.getFreeze = function () {
            return this.freeze;
        };

        /**************************************************************************************************************/

        return TileManager;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define( 'Renderer/Frustum',['./glMatrix'], function() {

/**************************************************************************************************************/

 /**
   @name Plane
   @class
   		Plane constructor
   @constructor
  */
var Plane = function()
{
	this.normal = vec3.create( [0.0, 0.0, 0.0] );
	this.d = 0.0;
};

/**************************************************************************************************************/

/**
 * Plane init from 3 points
 * @function init
 * @memberof Plane.prototype
 * @param v1 Point 1
 * @param v2 Point 2
 * @param v3 Point 3
 */
Plane.prototype.init = function( v1, v2, v3 )
{
	var vu = [];
	var vv = [];
	vec3.subtract( v2, v1, vu );
	vec3.subtract( v3, v1, vv );
	vec3.cross( vu, vv, this.normal );
	vec3.normalize( this.normal );
	this.d = - vec3.dot( v1, this.normal );
};


/**************************************************************************************************************/

/**
 * Transform the plane with the given matrix
 * @function transform
 * @memberof Plane.prototype
 * @param matrix Transformation matrix
 */
Plane.prototype.transform = function(matrix)
{
	var vec = [ this.normal[0], this.normal[1], this.normal[2], this.d ];
	mat4.multiplyVec4(matrix,vec);
	this.normal[0] = vec[0];
	this.normal[1] = vec[1];
	this.normal[2] = vec[2];
	this.d = vec[3];
};

/**************************************************************************************************************/

/**
 * Intersection test between plane and bounding sphere.
 * @function intersectSphere
 * @memberof Plane.prototype
 * @param center Center
 * @param radius Radius
 * @return {Integer}
 * <ul>
 *   <li>1 if the bounding sphere is completely above plane,</li>
 *   <li>0 if the bounding sphere intersects the plane,</li>
 *   <li>-1 if the bounding sphere is completely below the plane.</li>
 * </ul>
*/
Plane.prototype.intersectSphere = function( center, radius )
{
	var dist = vec3.dot( center, this.normal ) + this.d;
	if 	(dist > radius) {
		return 1;
	}	else {
		if ( dist < - radius ) {
			return -1;
		} else {
			return 0;
		}
	}
};

/**************************************************************************************************************/

/**
 * Return the distance between a point and the plane
 * @function distance
 * @memberof Plane.prototype
 * @param point Point
 * @return {Float} Distance
*/
Plane.prototype.distance = function( point )
{
	return point[0] * this.normal[0] + point[1] * this.normal[1] + point[2] * this.normal[2] +  this.d;
};


/**************************************************************************************************************/

/**
 * Intersection test between plane and bounding box.
 * @function intersectBoundingBox
 * @memberof Plane.prototype
 * @param {BoundingBox} bbox Bounding box
 * @return {Integer}
 * <ul>
 *   <li>1 if the bbox is completely above plane,</li>
 *   <li>0 if the bbox intersects the plane,</li>
 *   <li>-1 if the bbox is completely below the plane.</li>
 * </ul>
 */
Plane.prototype.intersectBoundingBox = function( bbox )
{
	var upperBBCorner = (this.normal[0]>=0.0?1:0) |
                             (this.normal[1]>=0.0?2:0) |
                             (this.normal[2]>=0.0?4:0);

	var lowerBBCorner = (~upperBBCorner)&7;

	// if lowest point above plane than all above.
	if ( this.distance(bbox.getCorner(lowerBBCorner)) > 0.0) {
		return 1;
	}

	// if highest point is below plane then all below.
	if ( this.distance(bbox.getCorner(upperBBCorner)) < 0.0) {
		return -1;
	}

	// d_lower<=0.0f && d_upper>=0.0f
	// therefore must be crossing plane.
	return 0;
};

/**************************************************************************************************************/

 /**
   @name Frustum
   @class
   		Frustum constructor
   @constructor
  */

var Frustum = function()
{
	// The frustum does not contains near and far plane, because near and far are computed during rendering.
	// Some tests have been done with a near plane but are not really useful
	this.planes = [ new Plane(), new Plane(), new Plane(), new Plane(), new Plane() ];
};

/**************************************************************************************************************/

/**
 * Compute the frustum from the given projection matrix
 * @function compute
 * @memberof Frustum.prototype
 * @param projectionMatrix Projection matrix
 */
Frustum.prototype.compute = function(projectionMatrix)
{
	var inverseProjectionMatrix = mat4.create();
	mat4.inverse( projectionMatrix, inverseProjectionMatrix );

	var bottomleft = mat4.project( inverseProjectionMatrix, [-1.0,-1.0,-1.0,1.0] );
	var topleft = mat4.project( inverseProjectionMatrix, [-1.0,1.0,-1.0,1.0] );
	var topright = mat4.project( inverseProjectionMatrix, [1.0,1.0,-1.0,1.0] );
	var bottomright = mat4.project( inverseProjectionMatrix, [1.0,-1.0,-1.0,1.0] );

	this.planes[0].init( [0.0,0.0,0.0], bottomleft, topleft );
	this.planes[1].init( [0.0,0.0,0.0], topleft, topright );
	this.planes[2].init( [0.0,0.0,0.0], topright, bottomright );
	this.planes[3].init( [0.0,0.0,0.0], bottomright, bottomleft );

	// A plane for near plane if needed
	this.planes[4].init( bottomleft, topleft, topright );
};

/**************************************************************************************************************/

/**
 * Transform the frustum with the given matrix
 * @function transform
 * @memberof Frustum.prototype
 * @param frustum
 * @param matrix Matrix
 */
Frustum.prototype.transform = function(frustum,matrix)
{
	var mat = mat4.create();
	mat4.inverse(matrix,mat);
	this.inverseTransform(frustum,mat);
};

/**************************************************************************************************************/

/**
 * Inverse transform the frustum with the given matrix
 * @function inverseTransform
 * @memberof Frustum.prototype
 * @param frustum
 * @param matrix Matrix
 */
Frustum.prototype.inverseTransform = function(frustum,matrix)
{
	// Optimized implementation
	for ( var i = 0; i < frustum.planes.length; i++ )
	{
		var plane = frustum.planes[i];

		var x = plane.normal[0];
		var y = plane.normal[1];
		var z = plane.normal[2];
		var w = plane.d;

		plane = this.planes[i];

		plane.normal[0] = matrix[0]*x + matrix[1]*y + matrix[2]*z + matrix[3]*w;
		plane.normal[1] = matrix[4]*x + matrix[5]*y + matrix[6]*z + matrix[7]*w;
		plane.normal[2] = matrix[8]*x + matrix[9]*y + matrix[10]*z + matrix[11]*w;
		plane.d = matrix[12]*x + matrix[13]*y + matrix[14]*z + matrix[15]*w;
	}
};

/**************************************************************************************************************/

/**
 * Intersection test between frustum and bounding sphere.
 * @function containsSphere
 * @memberof Frustum.prototype
 * @param {Array} center Center
 * @param {Float} radius Radius
 * @return {Integer}
 * <ul>
 *   <li>1 if the bounding sphere is completely inside the frustum,</li>
 *   <li>0 if the bounding sphere intersects the frustum,</li>
 *   <li>-1 if the bounding sphere is completely outside the frustum.</li>
 * </ul>
 */
Frustum.prototype.containsSphere = function( center, radius )
{
	var flag = 1;

	for (var i = 0; i < this.planes.length; i++)
	{
		var pn = this.planes[i].normal;

		// Compute distance between center and plane (inline to be more efficient)
		var dist = center[0]*pn[0] + center[1]*pn[1] + center[2]*pn[2] + this.planes[i].d;

		if 	(dist <= radius)
		{
			if ( dist < - radius ) {
				return -1;
			} else {
				flag = 0;
			}
		}
	}

	return flag;
};

/**************************************************************************************************************/

/**
 * Test if the frustum contains the given bounding box
 * @function containsBoundingBox
 * @memberof Frustum.prototype
 * @param {BoundingBox} bbox Bounding box
 * @return {boolean} Contains ?
 */
Frustum.prototype.containsBoundingBox = function( bbox )
{
	// Optimized implementation
	for (var i = 0; i < this.planes.length; i++)
	{
		var plane = this.planes[i];

		// Get the closest point on the bbox
		var bbx = plane.normal[0]>=0.0 ? bbox.max[0] : bbox.min[0];
		var bby = plane.normal[1]>=0.0 ? bbox.max[1] : bbox.min[1];
		var bbz = plane.normal[2]>=0.0 ? bbox.max[2] : bbox.min[2];

		// Compute the distance
		var distance = bbx * plane.normal[0] + bby * plane.normal[1] + bbz * plane.normal[2] +  plane.d;

		// if highest point is below plane then all below.
		if ( distance < 0.0) {
			return false;
		}
	}

	return true;
};

/**************************************************************************************************************/

// Export plane
Frustum.Plane = Plane;

return Frustum;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Renderer/RenderContext',['./Frustum', './glMatrix'],
    function (Frustum) {

        /**************************************************************************************************************/
        /**
         @name RenderContext
         @class
             RenderContext constructor
         @param options Configuration properties for the Planet :
         <ul>
         <li>shadersPath : Shaders directory path ( "../shaders/" as default)</li>
         <li>tileErrorTreshold : Tile error treshold (4 as default)</li>
         <li>lighting : Lighting ? (false as default))</li>
         <li>continuousRendering : Have to continuously render ? (false as default)</li>
         </ul>
         @constructor
         */
        var RenderContext = function (options) {
            this.activeAnimations = [];
            this.shadersPath = options.shadersPath || "../shaders/";
            this.tileErrorTreshold = options.tileErrorTreshold || 4;
            this.lighting = options.lighting || false;
            this.continuousRendering = options.continuousRendering || false;
            this.stats = null;
            this.isActive = true;

            // Init GL
            var canvas = null;

            // Check canvas options
            if (!options.canvas) {
                throw new ReferenceError("Mizar : no canvas in options");
            }

            if (typeof options.canvas === "string") {
                //canvas = document.getElementById(options.canvas);
                canvas = $(options.canvas);
            }
            else {
                canvas = options.canvas;
            }
            // Check canvas is valid
            if (!(canvas instanceof HTMLCanvasElement)) {
                throw new TypeError("Mizar : invalid canvas");
            }

            // Create the webl context
            var names = ["webgl", "experimental-webgl", "webkit-3d", "moz-webgl"];
            var gl = null;
            for (var ii = 0; ii < names.length && gl === null; ++ii) {
                try {
                    gl = canvas.getContext(names[ii], RenderContext.contextAttributes);
                }
                catch (e) {
                    /* continue regardless of error */
                }
            }

            if (gl === null) {
                throw new ReferenceError("Mizar : WebGL context cannot be initialized");
            }


            if (options.backgroundColor) {
                var color = options.backgroundColor;
                gl.clearColor(color[0], color[1], color[2], color[3]);
            }
            else {
                gl.clearColor(0.0, 0.0, 0.0, 1.0);
            }

            gl.getExtension('OES_element_index_uint');

            gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, gl.NONE);
            gl.enable(gl.DEPTH_TEST);
            gl.enable(gl.CULL_FACE);

            // Store local variable into static object
            this.viewMatrix = mat4.create();
            this.modelViewMatrix = mat4.create();
            this.projectionMatrix = mat4.create();
            this.gl = gl;
            this.canvas = canvas;
            this.frustum = new Frustum();
            this.worldFrustum = new Frustum();
            this.localFrustum = new Frustum();
            this.eyePosition = vec3.create();
            this.eyeDirection = vec3.create();
            this.minNear = 0.0001;
            this.minFar = options.minFar || 0; // No limit on far
            this.near = RenderContext.minNear;
            this.far = 6.0;
            this.numActiveAttribArray = 0;
            this.frameRequested = false;
            this.fov = 45;
            this.renderers = [];


            // Initialize the window requestAnimationFrame
            if (!window.requestAnimationFrame) {
                window.requestAnimationFrame = (function () {
                    return window.webkitRequestAnimationFrame ||
                        window.mozRequestAnimationFrame ||
                        window.oRequestAnimationFrame ||
                        window.msRequestAnimationFrame ||
                        function (callback, element) {
                            window.setTimeout(callback, 1000 / 60);
                        };
                })();
            }

            var self = this;
            this.frameCallback = function () {
                self.frame();
            };
        };

        /**************************************************************************************************************/

        /**
         The context attributes used when creating WebGL context, see WebGL specification.
         Can be changed by the renderers if needed, or by an external interface.
         */
        RenderContext.contextAttributes = {};

        /**************************************************************************************************************/

        /**
         * Request a frame
         * @function requestFrame
         * @memberof RenderContext.prototype
         */
        RenderContext.prototype.requestFrame = function () {
            if (!this.frameRequested) {
                window.requestAnimationFrame(this.frameCallback);
                this.frameRequested = true;
            }
        };


        /**************************************************************************************************************/

        /**
         * Deactivate render context
         * @function deactivate
         * @memberof RenderContext.prototype
         */
        RenderContext.prototype.deactivate = function () {
            this.isActive = false;
            this.frameRequested = false;
        };

        /**************************************************************************************************************/

        /**
         * Activate render context
         * @function activate
         * @memberof RenderContext.prototype
         */
        RenderContext.prototype.activate = function () {
            this.isActive = true;
        };

        /**************************************************************************************************************/

        /**
         * Frame of the application
         * @function frame
         * @memberof RenderContext.prototype
         */
        RenderContext.prototype.frame = function () {
            if (this.isActive) {
                // Reset frame requested flag first
                this.frameRequested = false;

                var stats = this.stats;
                var gl = this.gl;
                var i;

                if (this.stats) {
                    this.stats.start("globalRenderTime");
                }

                // Update active animations
                if (this.activeAnimations.length > 0) {
                    var time = Date.now();
                    for (i = 0; i < this.activeAnimations.length; i++) {
                        this.activeAnimations[i].update(time);
                    }
                }

                // Clear the buffer
                if (RenderContext.contextAttributes.stencil) {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
                }
                else {
                    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
                }

                // Check canvas size is valid
                if (this.canvas.width === 0 || this.canvas.height === 0) {
                    return;
                }

                gl.viewport(0, 0, this.canvas.width, this.canvas.height);

                // Update view dependent properties to be used during rendering : view matrix, frustum, projection, etc...
                this.updateViewDependentProperties();

                // Call render method of all registered renderers
                for (i = 0; i < this.renderers.length; i++) {
                    this.renderers[i].render();
                }

                if (this.stats) {
                    this.stats.end("globalRenderTime");
                }

                // Request next frame
                if (this.continuousRendering) {
                    this.requestFrame();
                }
                else if (this.activeAnimations.length > 0) {
                    this.requestFrame();
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Update properies that depends on the view matrix
         * @function updateViewDependentProperties
         * @memberof RenderContext.prototype
         */
        RenderContext.prototype.updateViewDependentProperties = function () {
            var inverseViewMatrix = mat4.create();
            mat4.inverse(this.viewMatrix, inverseViewMatrix);

            vec3.set([0.0, 0.0, 0.0], this.eyePosition);
            mat4.multiplyVec3(inverseViewMatrix, this.eyePosition);

            vec3.set([0.0, 0.0, -1.0], this.eyeDirection);
            mat4.rotateVec3(inverseViewMatrix, this.eyeDirection);

            // Init projection matrix
            mat4.perspective(this.fov, this.canvas.width / this.canvas.height, this.minNear, this.far, this.projectionMatrix);

            // Compute the frustum from the projection matrix
            this.frustum.compute(this.projectionMatrix);

            // Compute the world frustum
            this.worldFrustum.inverseTransform(this.frustum, this.viewMatrix);

            // Compute the pixel size vector from the current view/projection matrix
            this.pixelSizeVector = this.computePixelSizeVector();
        };

        /**************************************************************************************************************/

        /**
         * Get mouse coordinates relative to the canvas element
         * @function getXYRelativeToCanvas
         * @memberof RenderContext.prototype
         * @param event
         * @return Coordinates
         */
        RenderContext.prototype.getXYRelativeToCanvas = function (event) {
            // cf. http://stackoverflow.com/questions/55677/how-do-i-get-the-coordinates-of-a-mouse-click-on-a-canvas-element
            var pos = [];
            if (event.pageX || event.pageY) {
                pos[0] = event.pageX;
                pos[1] = event.pageY;
            }
            else {
                pos[0] = event.clientX + document.body.scrollLeft + document.documentElement.scrollLeft;
                pos[1] = event.clientY + document.body.scrollTop + document.documentElement.scrollTop;
            }

            var element = this.canvas;
            while (element) {
                pos[0] -= element.offsetLeft;
                pos[1] -= element.offsetTop;
                element = element.offsetParent;
            }

            return pos;
        };


        /**************************************************************************************************************/

        /**
         * Compute the pixel size vector
         * @function computePixelSizeVector
         * @memberof RenderContext.prototype
         * @param mv
         * @return pixelSizeVector
         */
        RenderContext.prototype.computePixelSizeVector = function (mv) {
            // pre adjust P00,P20,P23,P33 by multiplying them by the viewport window matrix.
            // here we do it in short hand with the knowledge of how the window matrix is formed
            // note P23,P33 are multiplied by an implicit 1 which would come from the window matrix.
            // Robert Osfield, June 2002.

            var width = this.canvas.width;
            var height = this.canvas.height;
            var P = this.projectionMatrix;
            var V = mv || this.viewMatrix;

            // scaling for horizontal pixels
            var P00 = P[0] * width * 0.5;
            var P20_00 = P[8] * width * 0.5 + P[11] * width * 0.5;
            var scale_00 = [V[0] * P00 + V[2] * P20_00,
                V[4] * P00 + V[6] * P20_00,
                V[8] * P00 + V[10] * P20_00];

            // scaling for vertical pixels
            var P10 = P[5] * height * 0.5;
            var P20_10 = P[9] * height * 0.5 + P[11] * height * 0.5;
            var scale_10 = [V[1] * P10 + V[2] * P20_10,
                V[5] * P10 + V[6] * P20_10,
                V[9] * P10 + V[10] * P20_10];

            var P23 = P[11];
            var P33 = P[15];
            var pixelSizeVector = [V[2] * P23,
                V[6] * P23,
                V[10] * P23,
                V[14] * P23 + V[15] * P33];

            var scaleRatio = 0.7071067811 / Math.sqrt(vec3.dot(scale_00, scale_00) + vec3.dot(scale_10, scale_10));
            pixelSizeVector[0] *= scaleRatio;
            pixelSizeVector[1] *= scaleRatio;
            pixelSizeVector[2] *= scaleRatio;
            pixelSizeVector[3] *= scaleRatio;

            return pixelSizeVector;
        };

        /**************************************************************************************************************/

        /**
         * Get pixel from 3D
         * TODO: move it to Planet/Sky too ?
         * @function getPixelFrom3D
         * @memberof RenderContext.prototype
         * @param x
         * @param y
         * @param z
         * @return {Array} Point as array of 2 float
         */
        RenderContext.prototype.getPixelFrom3D = function (x, y, z) {
            var viewProjectionMatrix = mat4.create();
            mat4.multiply(this.projectionMatrix, this.viewMatrix, viewProjectionMatrix);

            // transform world to clipping coordinates
            var point3D = [x, y, z, 1];
            mat4.project(viewProjectionMatrix, point3D);

            // transform clipping to window coordinates
            var winX = Math.round(( 1 + point3D[0] ) * 0.5 * this.canvas.width);

            // reverse y because (0,0) is top left but opengl's normalized
            // device coordinate (-1,-1) is bottom left
            var winY = Math.round(( 1 - point3D[1] ) * 0.5 * this.canvas.height);

            return [winX, winY];
        };

        /**************************************************************************************************************/

        /**
         * Create a non power of two texture from an image
         * @function createNonPowerOfTwoTextureFromImage
         * @memberof RenderContext.prototype
         * @param image
         * @param invertY
         * @return Texture
         */
        RenderContext.prototype.createNonPowerOfTwoTextureFromImage = function (image, invertY) {
            var gl = this.gl;
            var tex = gl.createTexture();
            gl.bindTexture(gl.TEXTURE_2D, tex);
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, invertY);
            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
            // Restore to default
            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
            return tex;
        };

        /**
         * Returns the canvas
         * @returns {Object} canvas
         */
        RenderContext.prototype.getCanvas = function() {
            return this.canvas;
        };

        /**
         * Returns the field of view in decimal degree.
         * @returns {Object} field of view
         */
        RenderContext.prototype.getFov = function() {
            return this.fov;
        };

        /**
         * Sets the field of fiew in decimal degree.
         * @param fov field of view
         */
        RenderContext.prototype.setFov = function(fov) {
            this.fov = fov;
        };

        /**
         * Returns the world frustum.
         * @returns {Frustum} frustum
         */
        RenderContext.prototype.getWorldFrustum = function() {
            return this.worldFrustum;
        };

        /**
         * Returns the view matrix.
         * @returns {mat4}
         */
        RenderContext.prototype.getViewMatrix = function() {
            return this.viewMatrix;
        };

        /**
         * Sets the view matrix.
         * @param {mat4} mat4 the matrix
         */
        RenderContext.prototype.setViewMatrix = function(mat4) {
            this.viewMatrix = mat4;
        };

        /**************************************************************************************************************/

        return RenderContext;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Globe/AbstractGlobe',['../Utils/Event', '../Utils/Utils',
        '../Tiling/TileManager', '../Renderer/VectorRendererManager', '../Renderer/Ray', '../Renderer/GeoBound',
        '../Crs/CoordinateSystemFactory', '../Renderer/RenderContext', '../Utils/Constants', '../Renderer/glMatrix'],
    function (Event, Utils,
              TileManager, VectorRendererManager, Ray, GeoBound,
              CoordinateSystemFactory, RenderContext, Constants) {


        /**
         * AbstractGlobe configuration
         * @typedef {Object} AbstractGlobe.configuration
         * @property {boolean} [options.continuousRendering=false] - Options that renders the globe in continue
         * @property {AbstractCrs.crsFactory} coordinateSystem - coordinate system data model
         * @property {Object} [renderContext] - RenderContext object.
         * @property {string} [shadersPath=../shaders/] - Option for RenderContext : shader location.
         * @property {int} [tileErrorTreshold=4] - Option for RenderContext : tile error
         * @property {boolean} [lighting=false] - Option for RenderContext : enable/disable lighting
         * @property {Object|string} canvas - Option for RenderContext : Canvas element to insert in the globe
         * @property {Array} [backgroundColor=[0.0, 0.0, 0.0, 1.0]] - Option for RenderContext : color for background
         * @property {int} [minFar=0] - Option for RenderContext : When 0 , no limit on far
         * @property {Array} [defaultColor=[200, 200, 200, 255]] - Option for TileManager : pixel default color
         *
         */
        /**
         * @name AbstractGlobe
         * @class
         * Creates a sky or a planet with it own coordinate reference system and renders the globe.
         * According to its coordinate reference system, the globe can be projected on a map.<br/>
         * Client implementations should not normally instantiate this class directly.
         * @param {GLOBE} type - Type of the globe.
         * @param {AbstractGlobe.configuration} options - Options for globe creation.
         * @throws {ReferenceError} Will throw an error when the options.coordinateSystem is not defined.
         * @throws {RangeError} Will throw an error when options.coordinateSystem.geoideName  is not part of {@link CRS}
         * @throws {RangeError} Will throw an error when options.coordinateSystem.projectionName is not part of {@link PROJECTION} when it is defined
         * @see {@link module:Crs.CoordinateSystemFactory}
         * @constructor
         * @implements {Globe}
         */
        var AbstractGlobe = function (type, options) {

            _checkOptions(options);

            this.type = type;

            this.coordinateSystem = CoordinateSystemFactory.create(options.coordinateSystem);

            if (!options.renderContext) {
                this.renderContext = new RenderContext(options);
            }
            else {
                this.renderContext = options.renderContext;
            }

            this.publishEvent = options.publishEvent;

            this.isEnable = true;
            this.sky = null; // the variable is overidden in the concrete constructor
            this.continuousRendering = options.continuousRendering || false;
            this.tileManager = new TileManager(this, options);
            this.vectorRendererManager = new VectorRendererManager(this);
            this.attributionHandler = null;
            this.baseImagery = null;
            this.preRenderers = [];
            this.nbCreatedLayers = 0;

            this.tileManager.addPostRenderer(this.vectorRendererManager);

            this.renderContext.renderers.push(this);
            this.renderContext.requestFrame();
        };

        /**
         * Check required options
         * @param options
         * @throws {ReferenceError} Will throw an error when the options.coordinateSystem is not defined.
         * @private
         */
        function _checkOptions(options) {
            if (!options.coordinateSystem) {
                throw new ReferenceError("coordinateSystem is not defined in " + JSON.stringify(options), "AbstractGLobe.js");
            }
        }

        /**
         * Compute intersections
         * @param ray
         * @param {Crs} crs - coordinate reference system
         * @returns {*}
         * @private
         */
        function _computeIntersection(ray, crs) {
            var intersection;
            if (crs.isFlat()) {
                intersection = ray.planeIntersect([0, 0, 0], [0, 0, 1]);
            } else {
                intersection = ray.sphereIntersect([0, 0, 0], crs.getGeoide().getRadius());
            }
            return intersection
        }

        /**
         * Computes the position
         * @param ray
         * @param intersection
         * @param {Crs} crs
         * @returns {float[]|null} the position
         * @private
         */
        function _computePosition(ray, intersection, crs) {
            if (intersection >= 0) {
                var pos = crs.getWorldFrom3D(ray.computePoint(intersection));
                var geoBound = crs.getGeoBound();
                if (!pos || pos[0] < geoBound[0] || pos[0] > geoBound[2] || pos[1] < geoBound[1] || pos[1] > geoBound[3] || isNaN(pos[0]) || isNaN(pos[1])) {
                    return null;
                } else {
                    return pos;
                }
            } else {
                return null;
            }
        }


        /*************************************************************************************************************/

        /**
         * @function getType
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getType = function () {
            return this.type;
        };

        /**
         * @function isSky
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.isSky = function () {
            return this.sky;
        };

        /**
         * @function dispose
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.dispose = function () {
            this.tileManager.tilePool.disposeAll();
            this.tileManager.reset();
        };

        /**
         * @function destroy
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.destroy = function () {
            this.dispose();
            this.tileManager.removePostRenderer(this.vectorRendererManager);
            this.renderContext.renderers.splice(this.renderContext.renderers.indexOf(this), 1);
            this.coordinateSystem.destroy();
            this.type = null;
            this.publishEvent = null;
            this.isEnable = null;
            this.sky = null;
            this.continuousRendering = null;
            this.tileManager = null;
            this.vectorRendererManager = null;
            this.attributionHandler = null;
            this.baseImagery = null;
            this.preRenderers = null;
            this.nbCreatedLayers = null;
        };

        /**
         * @function refresh
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.refresh = function () {
            this.renderContext.requestFrame();
        };

        /**
         * @function setBaseImagery
         * @memberOf AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.setBaseImagery = function (layer) {
            throw new SyntaxError("setBaseImagery Not implemented", "AbstractGlobe.js");
        };

        /**
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getBaseImagery = function () {
            return this.baseImagery;
        };

        /**
         * @function getBaseElevation
         * @memberOf AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.setBaseElevation = function (layer) {
            throw new Syntax("setBaseElevation Not implemented",  "AbstractGlobe.js");
        };

        /**
         * @funtion getBaseElevation
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getBaseElevation = function () {
            return this.tileManager.elevationProvider;
        };

        /**
         * @function addLayer
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.addLayer = function (layer) {
            var globe = this;
            if (layer.url) {
                $.ajax({
                    url: layer.url,
                    success: function (data) {
                        layer.addFeatureCollection(data);
                        layer.id = globe.nbCreatedLayers;
                        layer._attach(globe);
                        globe.renderContext.requestFrame();
                        globe.nbCreatedLayers++;
                        if (layer.callback) {
                            layer.callback(data);
                        }
                    }
                });
            } else {
                    layer.id = this.nbCreatedLayers;
                    layer._attach(globe);
                    this.renderContext.requestFrame();
                    this.nbCreatedLayers++;
            }
            this.publishEvent("layer:add", layer);
        };

        /**
         * @function removeLayer
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.removeLayer = function (layer) {
            layer.background = false;
            //layer.setVisible(false); <!-- cannot do it because of PlanetLayer -->
            layer._detach();
            this.renderContext.requestFrame();
            this.publishEvent("layer:remove", layer);
        };

        /**
         * @function addAnimation
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.addAnimation = function (anim) {
            anim.renderContext = this.renderContext;
        };

        /**
         * @function removeAnimation
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.removeAnimation = function (anim) {
            anim.renderContext = null;
        };

        /**
         * @function getElevation
         * @memberOf AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.getElevation = function (lon, lat) {
            throw new SyntaxError("getElevation Not implemented",  "AbstractGlobe.js");
        };

        /**
         * @function getViewportGeoBound
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getViewportGeoBound = function (transformCallback) {
            var rc = this.renderContext;
            var tmpMat = mat4.create();

            // Compute eye in world space
            mat4.inverse(rc.viewMatrix, tmpMat);
            var eye = [tmpMat[12], tmpMat[13], tmpMat[14]];

            // Compute the inverse of view/proj matrix
            mat4.multiply(rc.projectionMatrix, rc.viewMatrix, tmpMat);
            mat4.inverse(tmpMat);

            // Transform the four corners of the frustum into world space
            // and then for each corner compute the intersection of ray starting from the eye with the earth
            var points = [[-1, -1, 1, 1], [1, -1, 1, 1], [-1, 1, 1, 1], [1, 1, 1, 1]];
            var earthCenter = [0, 0, 0];
            for (var i = 0; i < 4; i++) {
                mat4.multiplyVec4(tmpMat, points[i]);
                vec3.scale(points[i], 1.0 / points[i][3]);
                vec3.subtract(points[i], eye, points[i]);
                vec3.normalize(points[i]);

                var ray = new Ray(eye, points[i]);
                var t = ray.sphereIntersect(earthCenter, this.coordinateSystem.getGeoide().getRadius());
                //var t = ray.sphereIntersect(earthCenter, 15);
                if (t < 0.0) {
                    return null;
                }
                var pos3d = ray.computePoint(t);
                points[i] = this.coordinateSystem.from3DToGeo(pos3d);
                if (transformCallback) {
                    points[i] = transformCallback(points[i]);
                }
            }

            var geoBound = new GeoBound();
            geoBound.computeFromCoordinates(points);

            return geoBound;
        };

        /**
         * @function getLonLatFromPixel
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getLonLatFromPixel = function (x, y) {
            var ray = Ray.createFromPixel(this.renderContext, x, y);
            var intersection = _computeIntersection.call(this, ray, this.coordinateSystem);
            return _computePosition.call(this, ray, intersection, this.coordinateSystem);
        };

        /**
         * @function getPixelFromLonLat
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getPixelFromLonLat = function (lon, lat) {
            var pos3d = vec3.create();
            this.coordinateSystem.get3DFromWorld([lon, lat], pos3d);
            return this.renderContext.getPixelFrom3D(pos3d[0], pos3d[1], pos3d[2]);
        };

        /**
         * @protected
         * @function render
         * @memberOf AbstractGlobe#
         * @abstract
         */
        AbstractGlobe.prototype.render = function () {
            throw new SyntaxError("render Not implemented", "AbstractGlobe.js");
        };

        /**
         * @function setCoordinateSystem
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.setCoordinateSystem = function (coordinateSystem) {
            var oldCrs = this.coordinateSystem;
            this.coordinateSystem = coordinateSystem;
            this.dispose();
            this.tileManager.tileConfig.coordinateSystem = coordinateSystem;
            this._updateGeoTiling(oldCrs, coordinateSystem);
        };

        /**
         * Updates the GeoTiling when the CRS changes.
         * The GeoTiling for Azimuthal projection is quite different of the others. We need to check when a GeoTiling
         * must be updated. Once a new GeoTiling is done then we need to update the geometry related to the old GeoTiling
         * @function _updateGeoTiling
         * @memberOf AbstractGlobe#
         * @private
         */
        AbstractGlobe.prototype._updateGeoTiling = function(oldCrs, crs) {
            var mustBeUpdated;
            if (crs.isProjected() && crs.getProjection().getName() === Constants.PROJECTION.Azimuth) {
                if(oldCrs.isProjected() && oldCrs.getProjection().getName() === Constants.PROJECTION.Azimuth) {
                    // nothing to update, same projection;
                    mustBeUpdated = false;
                } else {
                    // must be updated, the GeoTiling is quite different between azimuth and another one
                    mustBeUpdated = true;
                }
            } else if (oldCrs.isProjected() && oldCrs.getProjection().getName() === Constants.PROJECTION.Azimuth) {
                if(crs.isProjected() && crs.getProjection().getName() === crs.PROJECTION.Azimuth) {
                    // nothing to update, same projection;
                    mustBeUpdated = false;
                } else {
                    // must be updated, the GeoTiling is quite different between azimuth and another one
                    mustBeUpdated = true;
                }
            } else {
                // nothing to update, the geoTiling is the same.
                mustBeUpdated = false;
            }

            if(mustBeUpdated) {
                this.tileManager.level0Tiles = this.tileManager.tiling.generateLevelZeroTiles(this.tileManager.tileConfig, this.tileManager.tilePool);
                this._updateTileIndexInGeometry();
            }
        };

        /**
         * Updates the geometry related to the old GeoTiling to the new GeoTiling.
         * @function _updateTileIndexInGeometry
         * @memberOf AbstractGlobe#
         * @private
         */
        AbstractGlobe.prototype._updateTileIndexInGeometry = function() {
            var postRenderers = this.tileManager.postRenderers;
            var postRendererIdx = postRenderers.length;
            // we use while, this is the fastest loop in Javascript https://jsperf.com/fastest-array-loops-in-javascript/32
            while(postRendererIdx--) {
                // we iterate on renderers
                var postRenderer = postRenderers[postRendererIdx];
                if (postRenderer instanceof VectorRendererManager) {
                    // we look for VectorRendererManager because this one contains geometry
                    var vectorRendererManager = postRenderers[postRendererIdx];
                    var vectors = vectorRendererManager.renderers;
                    var vectorIdx = vectors.length;
                    while(vectorIdx--) {
                        // we iterate on vector
                        var vector = vectors[vectorIdx];
                        if (vector.levelZeroTiledGeometries && vector.levelZeroTiledGeometries.length > 0) {
                            // we retrieve the geometries
                            var geometries = vector.levelZeroTiledGeometries;
                            var geometryIdx = geometries.length;
                            while(geometryIdx--) {
                                // we iterate on each geometry to update the indexed tile related to the geometry
                                // the (0,0) is 0, the (1,0) is 1, ....
                                var geometry = geometries[geometryIdx];
                                var tileIndices = vector.maxTilePerGeometry > 0 ? this.tileManager.tiling.getOverlappedLevelZeroTiles(geometry) : null;
                                // update
                                geometry._tileIndices = tileIndices;
                            }
                        }
                    }
                }
            }
        };

        /**
         * @function getCoordinateSystem
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getCoordinateSystem = function () {
            return this.coordinateSystem;
        };

        /**
         * @function getRenderStats
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getRenderStats = function () {
            return "# rendered tiles : " + this.tileManager.tilesToRender.length;
        };

        /**
         * @function getRenderContext
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getRenderContext = function () {
            return this.renderContext;
        };

        /**
         * @function setRenderContext
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.setRenderContext = function (context) {
            this.renderContext = context;
        };

        /**
         * @function getTileManager
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.getTileManager = function () {
            return this.tileManager;
        };

        /**
         * @function isEnabled
         * @memberOf AbstractGlobe#
         */
        AbstractGlobe.prototype.isEnabled = function () {
            return this.isEnable;
        };

        /**
         * Enables the sky
         * @function enable
         * @memberOf Sky#
         */
        AbstractGlobe.prototype.enable = function () {
            this.isEnable = true;
        };

        /**
         * @function disable
         * @memberOf Sky#
         */
        AbstractGlobe.prototype.disable = function () {
            this.isEnable = false;
        };

        return AbstractGlobe;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributered in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Provides classes for handling a globe.
 * <p>
 * The different possible globes in MIZAR are :
 * <ul>
 *     <li>a sky</li>
 *     <li>a planet</li>
 * </ul>
 * <p>
 * A sky is a globe where the camera is located in it whereas the planet is a globe where the camera
 * is located outside.
 * <br/>
 * In addition to the classes, a {@link module:Globe.GlobeFactory factory} is available to help for creating globe.
 * Once the globe is created, the client can handle it by the use of its {@link Globe interface}.
 *
 * @module Globe
 * @implements {Globe}
 */
define('Globe/Planet',['../Tiling/Tile',
        '../Utils/Event', '../Utils/Utils',
        './AbstractGlobe', '../Utils/Constants'],
    function (Tile,
              Event, Utils,
              AbstractGlobe, Constants) {

        /**
         * @name Planet
         * @class
         * Create a virtual planet in a HTML canvas element with its own coordinate reference system.
         * @augments AbstractGlobe
         * @param {AbstractGlobe.configuration} options - Planet configuration
         * @constructor
         * @memberOf module:Globe
         */
        var Planet = function (options) {
            AbstractGlobe.prototype.constructor.call(this, Constants.GLOBE.Planet, options);
            this.sky = false;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractGlobe, Planet);

        /**************************************************************************************************************/

        /**
         * Sets the base imagery layer for the Planet.
         * @function setBaseImagery
         * @memberOf Planet#
         * @param {AbstractRasterLayer} layer the layer to use
         */
        Planet.prototype.setBaseImagery = function (layer) {
            if (this.baseImagery === layer) {
                return;
            }

            if (this.baseImagery) {
                this.removeLayer(this.baseImagery);
                this.baseImagery = null;
            }
            // Attach the layer to the globe
            if (layer) {
                layer._overlay = false;
                layer.background = true;
                this.addLayer(layer);
                this.baseImagery = layer;
                layer.setVisible(true);
            }
            // Modify the tile manager after the layer has been attached
            this.tileManager.setImageryProvider(layer);
        };

        /**
         * @function setBaseElevation
         * @memberOf Planet#
         */
        Planet.prototype.setBaseElevation = function (layer) {
            if (this.tileManager.elevationProvider) {
                this.removeLayer(this.tileManager.elevationProvider);
            }
            this.tileManager.setElevationProvider(layer);
            if (layer) {
                layer._overlay = false;
                this.addLayer(layer);
            }
        };

        /**
         * @function
         * @memberOf Planet#
         */
        Planet.prototype.getElevation = function (lon, lat) {
            // Use imagery provider tiling if defined, otherwise use globe default one
            var tiling = this.tileManager.tiling;
            if (this.baseImagery) {
                tiling = this.baseImagery.tiling;
            }
            var levelZeroTile = this.tileManager.level0Tiles[tiling.lonlat2LevelZeroIndex(lon, lat)];

            if (Tile.State && levelZeroTile && levelZeroTile.state === Tile.State.LOADED) {
                return levelZeroTile.getElevation(lon, lat);
            } else {
                return 0.0;
            }
        };

        /**
         * @private
         * @function render
         * @memberOf AbstractGlobe#
         */
        Planet.prototype.render = function () {
            if (this.isEnabled()) {
                // Call pre-renderers (only in 3D mode, no atmosphere for 2D)
                if (!this.coordinateSystem.isFlat()) {
                    for (var i = 0; i < this.preRenderers.length; i++) {
                        this.preRenderers[i].preRender();
                    }
                }
                // Render tiles
                this.tileManager.render();
            }
        };


        /**************************************************************************************************************/

        return Planet;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Globe/Sky',['../Tiling/TileManager', '../Tiling/TilePool',
        '../Utils/Utils', './AbstractGlobe', '../Utils/Constants'],
    function (TileManager, TilePool, Utils, AbstractGlobe, Constants) {

        /**
         * @name Sky
         * @class
         * Create a virtual sky in a HTML canvas element with its own coordinate reference system.
         *
         * The sky handles two different grids in the same time in order to display both
         * the galactic and equatorial rasters.
         *
         * @augments AbstractGlobe
         * @param {AbstractGlobe.configuration} options - Sky configuration
         * @constructor
         * @memberOf module:Globe
         */
        var Sky = function (options) {
            AbstractGlobe.prototype.constructor.call(this, Constants.GLOBE.Sky, options);
            this.sky = true;
            this.tilePool = new TilePool(this.renderContext);

            this.tileManagers = {
                'Equatorial': this.tileManager,
                'Galactic': new TileManager(this, options)
            };

            this.renderContext.requestFrame();
        };

        /**************************************************************************************************************/
        Utils.inherits(AbstractGlobe, Sky);

        /**************************************************************************************************************/

        /**
         * @function dispose
         * @memberOf Sky#
         */
        Sky.prototype.dispose = function () {
            for (var x in this.tileManagers) {
                if(this.tileManagers.hasOwnProperty(x)) {
                    this.tileManagers[x].tilePool.disposeAll();
                    this.tileManagers[x].reset();
                }
            }
        };


        /**
         * @function setBaseImagery
         * @memberOf Sky#
         **/
        Sky.prototype.setBaseImagery = function (layer) {
            if (this.baseImagery === layer) {
                return;
            }

            if (this.baseImagery) {
                this.removeLayer(this.baseImagery);
                this.tileManagers[this.baseImagery.tiling.coordinateSystem.getGeoideName()].setImageryProvider(null);
                this.baseImagery = null;
            }

            // Attach the layer to the globe
            if (layer) {
                layer._overlay = false;
                layer.background = true;
                this.addLayer(layer);
                // Modify the tile manager after the layer has been attached
                this.tileManagers[layer.tiling.coordinateSystem.getGeoideName()].setImageryProvider(layer);
                this.baseImagery = layer;
                layer.setVisible(true);
            }

        };

        /**
         * @function render
         * @memberOf Sky#
         */
        Sky.prototype.render = function () {
            // Render tiles manager
            if (this.isEnabled()) {
                this.tileManagers[Constants.CRS.Galactic].render();
                this.tileManagers[Constants.CRS.Equatorial].render();
            }
        };

        /**
         * @function destroy
         * @memberOf Sky#
         */
        Sky.prototype.destroy = function () {
            AbstractGlobe.prototype.destroy.call(this);
            this.tileManagers['Galactic'].tilePool.disposeAll();
            this.tileManagers['Galactic'].reset();
            this.tileManagers = null;
        };
        

        /**************************************************************************************************************/

        return Sky;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name GlobeFactory
 * @class
 * Factory to create a globe.
 * @memberOf module:Globe
 */
define('Globe/GlobeFactory',["./Planet", "./Sky", "../Utils/Constants"], function(Planet, Sky, Constants){

    return {
        /**
         * Creates a specific globe based on its type (e.g sky, planet).
         * @param {GLOBE} type - the type of globe
         * @param {AbstractGlobe.configuration} options - options to configure a globe
         * @return {Globe} a globe
         * @alias module:Globe.GlobeFactory.create
         * @throws {RangeError} Will throw an error when the type is not part of {@link GLOBE}
         * @see {@link module:Globe.Planet Planet}
         * @see {@link module:Globe.Sky Sky}
         */
        create : function(type, options) {
            var obj;
            switch (type) {
                case Constants.GLOBE.Planet:
                    obj = new Planet(options);
                    break;
                case Constants.GLOBE.Sky:
                    obj = new Sky(options);
                    break;
                default:
                    throw RangeError("The type "+type+" is not allowed, A valid type is included in the list GLOBE", "GlobeFactory.js");
            }
            
            return obj;
        }
        
    }
    
});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/GoogleMouseNavigationHandler',[],function () {

    /**
     * Google mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.googleMouse_configuration
     */

    /**
     * @name GoogleMouseNavigationHandler
     * @class
     * GoogleMouseNavigationHandler constructor
     * @param {AbstractNavigation.googleMouse_configuration} options
     * @constructor
     * @memberOf module:Navigation
     */
    var GoogleMouseNavigationHandler = function (options) {

        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _needsStartEvent = false;
        var _needsEndEvent = false;
        var _dx = 0;
        var _dy = 0;
        var _pressedGeo = null;
        var _changeInertia = null;
        var _slower = 0;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Event handler for mouse wheel
         * @function _handleMouseWheel
         * @param event Event
         * @returns {boolean}
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         * @fires Context#startNavigation
         * @fires Context#endNavigation
         */
        var _handleMouseWheel = function (event) {
            _navigation.ctx.publish("startNavigation");

            var factor;
            var geo,pos;

            // Check differences between firefox and the rest of the world
            if (typeof event.wheelDelta === 'undefined') {
                factor = event.detail;
            }
            else {
                factor = -event.wheelDelta / 120.0;
            }

            if (!_navigation.inertia) {
                // Compute mouse position and corresponding lon lat before zoom
                pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
            }

            _navigation.zoom(factor);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            }
            else {
                // Compute the new position of lon lat and pan the globe toward it
                if (geo) {
                    var pos2 = _navigation.ctx.getPixelFromLonLat(geo[0], geo[1]);

                    var dx = pos[0] - pos2[0];
                    var widthHeightFactor = Math.round(_navigation.ctx.getRenderContext().getCanvas().width / _navigation.ctx.getRenderContext().getCanvas().height);
                    widthHeightFactor = (widthHeightFactor < 1) ? 1 : widthHeightFactor;
                    dx *= widthHeightFactor;
                    var dy = pos[1] - pos2[1];
                    _navigation.pan(dx, dy);
                }
            }

            // Stop mouse wheel to be propagated, because default is to scroll the page
            // This is need when using Firefox event listener on DOMMouseScroll
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            _navigation.ctx.publish("endNavigation");
            _navigation.ctx.getRenderContext().requestFrame();

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         * @function _handleMouseDown
         * @param event
         * @returns {boolean}
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         */
        var _handleMouseDown = function (event) {
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;
            _dx = 0;
            _dy = 0;

            // Middle click
            if (event.button === 1) {
                // Cursor's style modification: Rotating icon
                _navigation.ctx.getRenderContext().getCanvas().style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto';
            }
            // Left and right click
            else {
                // Save the lon lat clicked
                var pressedPos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                _pressedGeo = _navigation.ctx.getLonLatFromPixel(pressedPos[0], pressedPos[1]);

                // Left click
                if (event.button === 0) {
                    // Cursor's style modification: Grabbing icon
                    _navigation.ctx.getRenderContext().getCanvas().style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAZUlEQVR42sSTQQrAMAgEHcn/v7w9tYgNNsGW7kkI2TgbRZJ15NbU+waAAFV11MiXz0yq2sxMEiVCDDcHLeky8nQAUDJnM88IuyGOGf/n3wjcQ1zhf+xgxSS+PkXY7aQ9yvy+jccAMs9AI/bwo38AAAAASUVORK5CYII=), auto';

                }
                // Right click
                else {
                    // Cursor's style modification: Zooming (same as Rotating) icon
                    _navigation.ctx.getRenderContext().getCanvas().style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAABeUlEQVR42u2XS07DMBCGbaCCQstzy4YDcAGWCAE3YI3omsN0XcSaGxSEWHIBDsCGLY9SykM80m/CFLkhIBycVpVi6ZetUez/S2x5JtYMudkCYJQBbGJ+pBoIgMybQKUoijrW2hnGr+jNFyILQM+8jHkLc0Nv6OeIPflC+AJ8M++1rBA+AD+a/wfCB2Bczdtp5gmIqkK8hwSQt69gcNu3gJ6BRGyB7kG/QlAAOe3rSD5zFeO6cwj3ibVRC52hTmgA2YJJVUUgML5wAFbVXN78RRV0C+TZMVUZLWJ86QCsELsxn3v/oQp6CN02hZYwvnIAloldo2efhQqAAqAAGKl7IL4JpQDpWyA9F8iVHfwmjHMBZnd/yIbzJodcEGdDtInJ0S/1wA7DE5NDNozrATSLtjE7SKmI9hg20b3JoR74qogUYgvThnMIa8SOHfPgFVEaxAbmh5jvMj71Nc8CkISYRmvoHD36mmcFcCFKOhbDgf0XuHOH9mcUrHUBoVXvIfh2krcAAAAASUVORK5CYII=), auto';
                }
            }

            _needsStartEvent = true;

            // Return false to stop mouse down to be propagated when using onmousedown
            return false;

        };

        /**
         * Event handler for mouse up
         * @function _handleMouseUp
         * @param event
         * @returns {boolean}
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         */
        var _handleMouseUp = function (event) {
            // No button pressed anymore
            _pressedButton = -1;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Left click
                if (event.button === 0) {
                    //different behavior if the move has change from pan to rotate
                    if (_changeInertia) {
                        _navigation.inertia.launch("rotate", _changeInertia, 0);
                    }
                    else {
                        _navigation.inertia.launch("pan", _dx, _dy);
                    }

                }
                // Middle click
                else if (event.button === 1) {
                    _navigation.inertia.launch("rotate", -_dx, -_dy);
                }
            }

            // Cursor's style modification : Hand icon
            _navigation.ctx.getRenderContext().getCanvas().style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto';

            _pressedGeo = null;
            _slower = 0;

            if (_needsEndEvent) {
                _navigation.ctx.publish("endNavigation");
            }

            _needsStartEvent = false;
            _needsEndEvent = false;

            // Stop mouse up event
            return false;
        };

        /**
         * Event handler for mouse move
         * @function _handleMouseMove
         * @param event
         * @returns {boolean}
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         * @fires Context#startNavigation
         * @fires Context#endNavigation         
         */
        var _handleMouseMove = function (event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = (event.clientX - _lastMouseX);
            _dy = (event.clientY - _lastMouseY);

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            var inside;
            var pos,pos2;

            // Pan on Left click
            if (_pressedButton === 0) {
                if (_needsStartEvent) {
                    _navigation.ctx.publish("startNavigation");
                    _needsStartEvent = false;
                    _needsEndEvent = true;
                }

                // Compute the mouse position
                pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                if (_pressedGeo) {
                    _changeInertia = null;
                    inside = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
                    if (inside) {
                        pos2 = _navigation.ctx.getPixelFromLonLat(_pressedGeo[0], _pressedGeo[1]);
                        _dx = pos[0] - pos2[0];
                        _dy = pos[1] - pos2[1];
                        _navigation.pan(_dx, _dy);
                    }
                }
                // If the mouse not on the globe
                if (!_pressedGeo || !inside) {
                    if (Math.abs(_dx) > Math.abs(_dy)) {
                        _changeInertia = (pos[1] > (_navigation.ctx.getRenderContext().getCanvas().height / 2)) ? -_dx : _dx;
                    }
                    else {
                        _changeInertia = (pos[0] > (_navigation.ctx.getRenderContext().getCanvas().width / 2)) ? _dy : -_dy;
                    }
                    _navigation.rotate(_changeInertia, 0);
                    pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                    _pressedGeo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);
                    if (_pressedGeo) {
                      _changeInertia = null;
                    }
                }

                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Rotate on Middle click
            else if (_pressedButton === 1) {
                _navigation.rotate(-_dx, -_dy);
                _navigation.ctx.getRenderContext().requestFrame();
                ret = true;
            }
            // Zoom on Right click
            else {
                // Mouse move is too fast for zooming, need to slow it down
                _slower++;
                if ((_slower % 3 === 0) && ( _slower > 1 )) {

                    _navigation.ctx.publish("startNavigation");

                    _navigation.zoom(-_dy / 10);

                    if (_dy > 0 && _dy > _dx) {
                        // Compute the new position of lon lat and pan the globe toward it
                        if (_pressedGeo) {

                            pos = [
                                _navigation.ctx.getRenderContext().getCanvas().clientLeft + (_navigation.ctx.getRenderContext().getCanvas().clientWidth / 2),
                                _navigation.ctx.getRenderContext().getCanvas().clientTop + (_navigation.ctx.getRenderContext().getCanvas().clientHeight / 2)
                            ];
                            pos2 = _navigation.ctx.getPixelFromLonLat(_pressedGeo[0], _pressedGeo[1]);

                            var dx = pos[0] - pos2[0];
                            dx = dx * 10 / 100;
                            var dy = pos[1] - pos2[1];
                            dy = dy * 10 / 100;

                            _navigation.pan(dx, dy);
                        }
                    }

                    // Stop all animations when an event is received
                    _navigation.stopAnimations();

                    _navigation.ctx.publish("endNavigation");
                    _navigation.ctx.getRenderContext().requestFrame();
                }

                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };


        /**
         * Event handler for mouse double click
         * @function _handleMouseDblClick
         * @param event
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         */
        var _handleMouseDblClick = function (event) {
            if (event.button === 0) {
                var pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                var geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo);
                }
            }
        };

        /**
         * Event handler for mouse context menu
         * @function _handleContextMenu
         * @param event
         * @private
         * @memberOf GoogleMouseNavigationHandler#
         */
        var _handleContextMenu = function (event) {
            // Need this so browser's context menu won't show up when using right click zooming
            event.preventDefault();
            return false;
        };


        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         * Setup the default event handlers for the _navigation
         * @function install
         * @param nav
         * @memberOf GoogleMouseNavigationHandler#
         */
        this.install = function (nav) {
            _navigation = nav;

            var canvas = _navigation.getRenderContext.getCanvas;

            // Cursor's style modification : Hand icon
            canvas.style.cursor = 'url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAACXBIWXMAAAsTAAALEwEAmpwYAAAKTWlDQ1BQaG90b3Nob3AgSUNDIHByb2ZpbGUAAHjanVN3WJP3Fj7f92UPVkLY8LGXbIEAIiOsCMgQWaIQkgBhhBASQMWFiApWFBURnEhVxILVCkidiOKgKLhnQYqIWotVXDjuH9yntX167+3t+9f7vOec5/zOec8PgBESJpHmomoAOVKFPDrYH49PSMTJvYACFUjgBCAQ5svCZwXFAADwA3l4fnSwP/wBr28AAgBw1S4kEsfh/4O6UCZXACCRAOAiEucLAZBSAMguVMgUAMgYALBTs2QKAJQAAGx5fEIiAKoNAOz0ST4FANipk9wXANiiHKkIAI0BAJkoRyQCQLsAYFWBUiwCwMIAoKxAIi4EwK4BgFm2MkcCgL0FAHaOWJAPQGAAgJlCLMwAIDgCAEMeE80DIEwDoDDSv+CpX3CFuEgBAMDLlc2XS9IzFLiV0Bp38vDg4iHiwmyxQmEXKRBmCeQinJebIxNI5wNMzgwAABr50cH+OD+Q5+bk4eZm52zv9MWi/mvwbyI+IfHf/ryMAgQAEE7P79pf5eXWA3DHAbB1v2upWwDaVgBo3/ldM9sJoFoK0Hr5i3k4/EAenqFQyDwdHAoLC+0lYqG9MOOLPv8z4W/gi372/EAe/tt68ABxmkCZrcCjg/1xYW52rlKO58sEQjFu9+cj/seFf/2OKdHiNLFcLBWK8ViJuFAiTcd5uVKRRCHJleIS6X8y8R+W/QmTdw0ArIZPwE62B7XLbMB+7gECiw5Y0nYAQH7zLYwaC5EAEGc0Mnn3AACTv/mPQCsBAM2XpOMAALzoGFyolBdMxggAAESggSqwQQcMwRSswA6cwR28wBcCYQZEQAwkwDwQQgbkgBwKoRiWQRlUwDrYBLWwAxqgEZrhELTBMTgN5+ASXIHrcBcGYBiewhi8hgkEQcgIE2EhOogRYo7YIs4IF5mOBCJhSDSSgKQg6YgUUSLFyHKkAqlCapFdSCPyLXIUOY1cQPqQ28ggMor8irxHMZSBslED1AJ1QLmoHxqKxqBz0XQ0D12AlqJr0Rq0Hj2AtqKn0UvodXQAfYqOY4DRMQ5mjNlhXIyHRWCJWBomxxZj5Vg1Vo81Yx1YN3YVG8CeYe8IJAKLgBPsCF6EEMJsgpCQR1hMWEOoJewjtBK6CFcJg4Qxwicik6hPtCV6EvnEeGI6sZBYRqwm7iEeIZ4lXicOE1+TSCQOyZLkTgohJZAySQtJa0jbSC2kU6Q+0hBpnEwm65Btyd7kCLKArCCXkbeQD5BPkvvJw+S3FDrFiOJMCaIkUqSUEko1ZT/lBKWfMkKZoKpRzame1AiqiDqfWkltoHZQL1OHqRM0dZolzZsWQ8ukLaPV0JppZ2n3aC/pdLoJ3YMeRZfQl9Jr6Afp5+mD9HcMDYYNg8dIYigZaxl7GacYtxkvmUymBdOXmchUMNcyG5lnmA+Yb1VYKvYqfBWRyhKVOpVWlX6V56pUVXNVP9V5qgtUq1UPq15WfaZGVbNQ46kJ1Bar1akdVbupNq7OUndSj1DPUV+jvl/9gvpjDbKGhUaghkijVGO3xhmNIRbGMmXxWELWclYD6yxrmE1iW7L57Ex2Bfsbdi97TFNDc6pmrGaRZp3mcc0BDsax4PA52ZxKziHODc57LQMtPy2x1mqtZq1+rTfaetq+2mLtcu0W7eva73VwnUCdLJ31Om0693UJuja6UbqFutt1z+o+02PreekJ9cr1Dund0Uf1bfSj9Rfq79bv0R83MDQINpAZbDE4Y/DMkGPoa5hpuNHwhOGoEctoupHEaKPRSaMnuCbuh2fjNXgXPmasbxxirDTeZdxrPGFiaTLbpMSkxeS+Kc2Ua5pmutG003TMzMgs3KzYrMnsjjnVnGueYb7ZvNv8jYWlRZzFSos2i8eW2pZ8ywWWTZb3rJhWPlZ5VvVW16xJ1lzrLOtt1ldsUBtXmwybOpvLtqitm63Edptt3xTiFI8p0in1U27aMez87ArsmuwG7Tn2YfYl9m32zx3MHBId1jt0O3xydHXMdmxwvOuk4TTDqcSpw+lXZxtnoXOd8zUXpkuQyxKXdpcXU22niqdun3rLleUa7rrStdP1o5u7m9yt2W3U3cw9xX2r+00umxvJXcM970H08PdY4nHM452nm6fC85DnL152Xlle+70eT7OcJp7WMG3I28Rb4L3Le2A6Pj1l+s7pAz7GPgKfep+Hvqa+It89viN+1n6Zfgf8nvs7+sv9j/i/4XnyFvFOBWABwQHlAb2BGoGzA2sDHwSZBKUHNQWNBbsGLww+FUIMCQ1ZH3KTb8AX8hv5YzPcZyya0RXKCJ0VWhv6MMwmTB7WEY6GzwjfEH5vpvlM6cy2CIjgR2yIuB9pGZkX+X0UKSoyqi7qUbRTdHF09yzWrORZ+2e9jvGPqYy5O9tqtnJ2Z6xqbFJsY+ybuIC4qriBeIf4RfGXEnQTJAntieTE2MQ9ieNzAudsmjOc5JpUlnRjruXcorkX5unOy553PFk1WZB8OIWYEpeyP+WDIEJQLxhP5aduTR0T8oSbhU9FvqKNolGxt7hKPJLmnVaV9jjdO31D+miGT0Z1xjMJT1IreZEZkrkj801WRNberM/ZcdktOZSclJyjUg1plrQr1zC3KLdPZisrkw3keeZtyhuTh8r35CP5c/PbFWyFTNGjtFKuUA4WTC+oK3hbGFt4uEi9SFrUM99m/ur5IwuCFny9kLBQuLCz2Lh4WfHgIr9FuxYji1MXdy4xXVK6ZHhp8NJ9y2jLspb9UOJYUlXyannc8o5Sg9KlpUMrglc0lamUycturvRauWMVYZVkVe9ql9VbVn8qF5VfrHCsqK74sEa45uJXTl/VfPV5bdra3kq3yu3rSOuk626s91m/r0q9akHV0IbwDa0b8Y3lG19tSt50oXpq9Y7NtM3KzQM1YTXtW8y2rNvyoTaj9nqdf13LVv2tq7e+2Sba1r/dd3vzDoMdFTve75TsvLUreFdrvUV99W7S7oLdjxpiG7q/5n7duEd3T8Wej3ulewf2Re/ranRvbNyvv7+yCW1SNo0eSDpw5ZuAb9qb7Zp3tXBaKg7CQeXBJ9+mfHvjUOihzsPcw83fmX+39QjrSHkr0jq/dawto22gPaG97+iMo50dXh1Hvrf/fu8x42N1xzWPV56gnSg98fnkgpPjp2Snnp1OPz3Umdx590z8mWtdUV29Z0PPnj8XdO5Mt1/3yfPe549d8Lxw9CL3Ytslt0utPa49R35w/eFIr1tv62X3y+1XPK509E3rO9Hv03/6asDVc9f41y5dn3m978bsG7duJt0cuCW69fh29u0XdwruTNxdeo94r/y+2v3qB/oP6n+0/rFlwG3g+GDAYM/DWQ/vDgmHnv6U/9OH4dJHzEfVI0YjjY+dHx8bDRq98mTOk+GnsqcTz8p+Vv9563Or59/94vtLz1j82PAL+YvPv655qfNy76uprzrHI8cfvM55PfGm/K3O233vuO+638e9H5ko/ED+UPPR+mPHp9BP9z7nfP78L/eE8/sl0p8zAAAABGdBTUEAALGOfPtRkwAAACBjSFJNAAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAAjElEQVR42pyRQRLAIAwCoePD8vT8jB7aONHRVuWagBuku2MmMxMAuDtnO2VmMDNJAgCQVOz0YSWbR4ZQnuWQC4cK2pLRSEoSJIHkp/nd0RFBnFMJUnkgiaAYGXrxmdeCfg2NmWxLXDWG2d15veUdhdRv7EO2A3YV+E3AKUVDsBKSXx+esEvC3dZ73QMAeuphLLn/cTIAAAAASUVORK5CYII=), auto';


            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mouseup", _handleMouseUp);
            canvas.addEventListener("mousemove", _handleMouseMove);
            canvas.addEventListener("contextmenu", _handleContextMenu);
            canvas.addEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.addEventListener("mousewheel", _handleMouseWheel);
        };

        /**
         * Remove the default event handlers for the _navigation
         * @function uninstall
         * @memberOf GoogleMouseNavigationHandler#
         */
        this.uninstall = function () {
            // Setup the mouse event handlers
            var canvas = _navigation.getRenderContext().getCanvas();

            canvas.style.cursor = 'auto';

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mouseup", _handleMouseUp);
            canvas.removeEventListener("mousemove", _handleMouseMove);
            canvas.removeEventListener("contextmenu", _handleContextMenu);
            canvas.removeEventListener("dblclick", _handleMouseDblClick);

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return GoogleMouseNavigationHandler;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/KeyboardNavigationHandler',[],function () {

    /**
     * Keyboard navigation handler configuration
     * @typedef {Object} AbstractNavigation.keyboard_configuration
     * @property {float} [panFactor = 10.0] - Factor for panning within the scene
     * @property {float} [zoomFactor = 1.0] - Factor for zooming into the scene
     * @property {boolean} [installOnDocument = false] -True to install the event listener on the document and not on the canvas
     */
    
    /**
     * @name KeyboardNavigationHandler
     * @class
     * KeyboardNavigationHandler constructor.<br/>
     * The keyboard shortcuts are the following :
     * <ul>
     *     <li><i>space bar</i> : Stop all animations when an event is received</li>
     *     <li><i>+</i> : zoom in the camera</li>
     *     <li><i>-</i> : zoom out the camera</li>
     *     <li><i>Left arrow</i> : pan the camera left</li>
     *     <li><i>shift + left arrow</i> : rotate the camera counterclockwise</li>
     *     <li><i>Right arrow</i> : pan the camera right</li>
     *     <li><i>shift + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Up arrow</i> : pan the camera up</li>
     *     <li><i>shift + up arrow</i> : rotate the camera up</li>
     *     <li><i>Down arrow</i> : pan the camera down</li>
     *     <li><i>shift + down arrow</i> : rotate the camera down</li>
     * </ul>
     *
     * @param {AbstractNavigation.keyboard_configuration} options - Keyboard navigation configuration
     * @constructor
     * @memberOf module:Navigation
     */
    var KeyboardNavigationHandler = function (options) {

        /**************************************************************************************************************/

        /**
         * Private variables
         */
        var _navigation = null;
        var self = this;

        /**
         * Public variables
         */
        this.panFactor = 10.0;
        this.zoomFactor = 1.0;

        // Setup options
        if (options) {
            if (options.panFactor && typeof options.panFactor === 'number') {
                this.panFactor = options.panFactor;
            }
            if (options.zoomFactor && typeof options.zoomFactor === 'number') {
                this.zoomFactor = options.zoomFactor;
            }
        }

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Set focus
         */
        var _setFocus = function (event) {
            this.focus();
            return false;
        };

        /**
         * Event handler for key down.
         * @param event
         * @private
         */
        var _handleKeyDown = function (event) {
            switch (event.keyCode) {
                case 32 :
                    // space bar
                    // Stop all animations when an event is received
                    _navigation.stopAnimations();
                    break;
                case 187 :
                // + on Safari
                // falls through
                case 61 :
                // +(=) on Firefox and Opera
                // falls through
                case 107 :
                    // + on other
                    _navigation.zoom(-self.zoomFactor);
                    break;
                case 189 :
                // - on Safari
                // falls through
                case 54 :
                // -(6) on Firefox and Opera
                // falls through
                case 109 :
                    // - on other
                    _navigation.zoom(self.zoomFactor);
                    break;
                case 81 :
                // q
                // falls through
                case 37 :
                    // Left arrow
                    if (event.shiftKey) {
                        _navigation.rotate(self.panFactor, 0);
                    }
                    else {
                        _navigation.pan(self.panFactor, 0);
                    }
                    break;
                case 90 :
                // z
                // falls through
                case 38 :
                    // Up arrow
                    if (event.shiftKey) {
                        _navigation.rotate(0, self.panFactor);
                    }
                    else {

                        _navigation.pan(0, self.panFactor);
                    }
                    break;
                case 68 :
                // d
                // falls through
                case 39 :
                    // Right arrow
                    if (event.shiftKey) {
                        _navigation.rotate(-self.panFactor, 0);
                    }
                    else {
                        _navigation.pan(-self.panFactor, 0);
                    }
                    break;
                case 83 :
                // s
                // falls through
                case 40 :
                    // Down arrow
                    if (event.shiftKey) {
                        _navigation.rotate(0, -self.panFactor);
                    }
                    else {

                        _navigation.pan(0, -self.panFactor);
                    }
                    break;
            }
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         Setup the default event handlers for the navigation
         */
        this.install = function (navigation) {
            // Setup the keyboard event handlers
            _navigation = navigation;

            if (options && options.installOnDocument) {
                document.addEventListener("keydown", _handleKeyDown);
            }
            else {
                var canvas = _navigation.renderContext.canvas;
                canvas.addEventListener("keydown", _handleKeyDown);
                // Setup focus handling to receive keyboard event on canvas
                canvas.tabIndex = "0";
                canvas.addEventListener("mousedown", _setFocus);
            }
        };

        /**
         Remove the default event handlers for the navigation
         */
        this.uninstall = function () {
            if (options && options.installOnDocument) {
                document.removeEventListener("keydown", _handleKeyDown);
            }
            else {
                var canvas = _navigation.renderContext.canvas;
                canvas.removeEventListener("keydown", _handleKeyDown);
                canvas.removeEventListener("mousedown", _setFocus);
            }
        };

    };

    return KeyboardNavigationHandler;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/MouseNavigationHandler',[],function () {

    /**
     * Mouse navigation handler configuration
     * @typedef {Object} AbstractNavigation.mouse_configuration
     * @property {float} [panButton = 0]
     * @property {float} [rotateButton = 1]
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     * @property {Object} [zoomOptions] - @see look at options in {@link Navigation#zoomTo} 
     */

    /**
     * @name MouseNavigationHandler
     * @class
     * Mouse_navigationHandler constructor.<br/>
     * The mouse movements are the following :
     * <ul>
     *     <li><i>Wheel up</i> : zoom in the camera</li>
     *     <li><i>Wheel down</i> : zoom out the camera</li>
     *     <li><i>Click left+Ri + left mouse</i> : pan the camera right</li>
     *     <li><i>Wheel press + left mouse</i> : rotate the camera counterclockwise</li>
     *     <li><i>Click left + right mouse</i> : pan the camera left</li>
     *     <li><i>Wheel press + right arrow</i> : rotate the camera clockwise</li>
     *     <li><i>Click left + up mouse</i> : pan the camera down</li>
     *     <li><i>Wheel press + up mouse</i> : rotate the camera down</li>
     *     <li><i>Click left + down mouse</i> : pan the camera up</li>
     *     <li><i>Wheel press + down mouse</i> : rotate the camera up</li>
     * </ul>
     * @param {AbstractNavigation.mouse_configuration} options - Mouse navigation configuration
     * @constructor
     * @memberOf module:Navigation
     */
    var MouseNavigationHandler = function (options) {

        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _pressedButton = -1;
        var _lastMouseX = -1;
        var _lastMouseY = -1;
        var _dx = 0;
        var _dy = 0;
        var _panButton = (options && options.panButton) || 0;
        var _rotateButton = (options && options.rotateButton) || 1;
        var _zoomOptions = (options && options.zoomOptions) ? options.zoomOptions : {};

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         Event handler for mouse wheel
         */
        var _handleMouseWheel = function (event) {
            var factor;

            // Check differences between firefox and the rest of the world
            if (event.wheelDelta === undefined) {
                factor = event.detail;
            }
            else {
                factor = -event.wheelDelta / 120.0;
            }
            _navigation.zoom(factor);

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            // Launch inertia if needed
            if (_navigation.inertia) {
                _navigation.inertia.launch("zoom", factor < 0 ? -1 : 1);
            }

            // Stop mouse wheel to be propagated, because default is to scroll the page
            // This is need when using Firefox event listener on DOMMouseScroll
            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            // Return false to stop mouse wheel to be propagated when using onmousewheel
            return false;
        };

        /**
         * Event handler for mouse down
         */
        var _handleMouseDown = function (event) {
            document.addEventListener("mouseup", _handleMouseUp);
            _pressedButton = event.button;

            // Stop all animations when an event is received
            _navigation.stopAnimations();

            if (event.button === _panButton || event.button === _rotateButton) {
                _lastMouseX = event.clientX;
                _lastMouseY = event.clientY;
                _dx = 0;
                _dy = 0;

                // Return false to stop mouse down to be propagated when using onmousedown
                return false;
            }

            return true;
        };

        /**
         * Event handler for mouse up
         */
        var _handleMouseUp = function (event) {
            // No button pressed anymore
            _pressedButton = -1;
            document.removeEventListener("mouseup", _handleMouseUp);

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                if (event.button === _panButton) {
                    _navigation.inertia.launch("pan", _dx, _dy);

                }
                if (event.button === _rotateButton) {
                    _navigation.inertia.launch("rotate", _dx, _dy);
                }
            }

            if (event.button === _panButton || event.button === _rotateButton) {
                event.preventDefault();

                // Stop mouse up event
                return false;
            }

            return true;
        };

        /**
         Event handler for mouse move
         */
        var _handleMouseMove = function (event) {
            // No button pressed
            if (_pressedButton < 0) {
                return;
            }

            _dx = (event.clientX - _lastMouseX);
            _dy = (event.clientY - _lastMouseY);

            if (_dx === 0 && _dy === 0) {
                return;
            }

            var ret = false;
            // Pan
            if (_pressedButton === _panButton) {
                _navigation.pan(_dx, _dy);
                ret = true;
            }
            // Rotate
            else if (_pressedButton === _rotateButton) {
                _navigation.rotate(_dx, _dy);
                ret = true;
            }

            _lastMouseX = event.clientX;
            _lastMouseY = event.clientY;

            return ret;
        };

        /**
         Event handler for mouse double click
         */
        var _handleMouseDblClick = function (event) {
            if (event.button === 0) {
                var pos,geo;
                pos = _navigation.ctx.getRenderContext().getXYRelativeToCanvas(event);
                geo = _navigation.ctx.getLonLatFromPixel(pos[0], pos[1]);

                if (geo) {
                    _navigation.zoomTo(geo,_zoomOptions);
                }
            }
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function (nav) {
            _navigation = nav;
            var canvas = _navigation.renderContext.canvas;

            // Setup the mouse event handlers
            canvas.addEventListener("mousedown", _handleMouseDown);
            canvas.addEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
              canvas.addEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.addEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.addEventListener("mousewheel", _handleMouseWheel);

            // Fix for Google Chrome : avoid dragging
            // TODO : a hack, should be more robust (restore on uninstall?)
            canvas.addEventListener("dragstart", function (event) {
                event.preventDefault();
                return false;
            });

            if (_rotateButton === 2) {
                canvas.addEventListener("contextmenu", function (e) {
                    e.preventDefault();
                    return false;
                }, false);
            }
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function () {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("mousedown", _handleMouseDown);
            canvas.removeEventListener("mousemove", _handleMouseMove);

            if (options && options.zoomOnDblClick) {
                canvas.removeEventListener("dblclick", _handleMouseDblClick);
            }

            // For Firefox
            canvas.removeEventListener("DOMMouseScroll", _handleMouseWheel);
            canvas.removeEventListener("mousewheel", _handleMouseWheel);
        };
    };

    return MouseNavigationHandler;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/TouchNavigationHandler',[],function () {

    /**************************************************************************************************************/

    /**
     *    Types of actions for inertia execution
     */
    var Type = {
        PAN: 0,
        ROTATE: 1,
        TILT: 2,
        ZOOM: 3
    };

    /**
     * Touch navigation handler configuration
     * @typedef {Object} AbstractNavigation.touch_configuration
     * @property {boolean} [inversed = false] - if true inverse the sens of touching events
     * @property {boolean} [zoomOnDblClick = false] - if true defines animation on double click
     */

    /**
     * @name TouchNavigationHandler
     * @class
     * TouchNavigationHandler constructor
     * @param {AbstractNavigation.touch_configuration} options - Touch navigation configuration
     * @constructor
     * @memberOf module:Navigation
     */
    var TouchNavigationHandler = function (options) {

        /**************************************************************************************************************/

        /**
         * Private variables
         */

        var _navigation = null;
        var _lastFingerDistance;

        var _startTouches = [];
        var _lastTouches;
        var _lastAngle;

        var _dx, _dy;

        // Parameters for intertia management
        var _actionHits = [0, 0, 0, 0];
        var _lastTapDate;
        var _rotation;


        // Double tap
        var _doubletap_interval = 300;
        var _inversed = (options && options.hasOwnProperty('inversed')) ? options.inversed : false;

        /**************************************************************************************************************/

        /**
         * Private methods
         */

        /**
         * Calculate the angle between two coordinates
         */
        var _getAngle = function (touch1, touch2) {
            var y = touch2.clientY - touch1.clientY,
                x = touch2.clientX - touch1.clientX;
            return Math.atan2(y, x) * 180 / Math.PI;
        };

        /**************************************************************************************************************/

        /**
         * Calculate the rotation degrees between two touchLists (fingers)
         */
        var _getRotation = function (start, end) {
            // Need two fingers
            if (start.length >= 2 && end.length >= 2) {
                return _getAngle(end[1], end[0]) - _getAngle(start[1], start[0]);
            }
            return 0;
        };

        /**************************************************************************************************************/

        /**
         Handle touch start event
         */
        var _handleTouchStart = function (event) {
            //console.log("# events : " + event.touches.length );
            _lastTouches = event.touches;
            _startTouches = event.touches;

            _actionHits = [0, 0, 0, 0];

            // Stop all animations when an event is received
            _navigation.stopAnimations();
            _dx = 0;
            _dy = 0;
            if (event.touches.length === 2) {
                var dx = event.touches[0].clientX - event.touches[1].clientX;
                var dy = event.touches[0].clientY - event.touches[1].clientY;
                _lastFingerDistance = Math.sqrt(dx * dx + dy * dy);
                console.log("Finger distance : " + _lastFingerDistance);

                _lastAngle = _getRotation(_startTouches, event.touches);
            }

            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            // Return false to stop event to be propagated
            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch move event
         */
        var _handleTouchMove = function (event) {
            _dx = event.touches[0].clientX - _lastTouches[0].clientX;
            _dy = event.touches[0].clientY - _lastTouches[0].clientY;
            var dx,dy;
            var rotation,fingerDistance,deltaDistance;

            if (event.touches.length === 1) {
                // Pan
                _navigation.pan(_dx, _dy);
                _actionHits[Type.PAN]++;
            }
            else {
                // Depending on direction of two fingers, decide if tilt OR rotation
                var sameDirection = ( (event.touches[0].clientY - _lastTouches[0].clientY) * (event.touches[1].clientY - _lastTouches[1].clientY) > 0 );
                if (sameDirection) {
                    // Tilt
                    _navigation.rotate(0.0, -_dy);
                    _actionHits[Type.TILT]++;
                }
                else {
                    // Rotation
                    rotation = _getRotation(_startTouches, event.touches);
                    dx = rotation - _lastAngle;
                    _lastAngle = rotation;

                    if (_inversed) {
                        dx *= -1;
                    }

                    _rotation = dx * 10;
                    _navigation.rotate(_rotation, 0);
                    _actionHits[Type.ROTATE]++;
                }

                // Zoom
                dx = event.touches[0].clientX - event.touches[1].clientX;
                dy = event.touches[0].clientY - event.touches[1].clientY;
                fingerDistance = Math.sqrt(dx * dx + dy * dy);
                deltaDistance = (fingerDistance - _lastFingerDistance);

                var scale;
                if (_inversed) {
                    scale = fingerDistance / _lastFingerDistance;
                }
                else {
                    scale = _lastFingerDistance / fingerDistance;
                }

                if (_lastFingerDistance !== 0) {
                    _navigation.zoom(deltaDistance * 0.025, scale);
                    _actionHits[Type.ZOOM]++;
                }
                _navigation.getRenderContext().requestFrame();
                _lastFingerDistance = fingerDistance;
            }

            // Update _lastTouches
            _lastTouches = event.touches;

            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            return false;
        };

        /**************************************************************************************************************/

        /**
         Handle touch end event
         */
        var _handleTouchEnd = function (event) {
            if (options && options.zoomOnDblClick && event.touches.length === 0 && _dx === 0 && _dy === 0) {
                // Handle double tap
                // TODO : take into account the distance
                var now = Date.now();
                if (now - _lastTapDate < _doubletap_interval) {
                    var geo = _navigation.ctx.getLonLatFromPixel(_lastTouches[0].clientX, _lastTouches[0].clientY);

                    if (geo) {
                        _navigation.zoomTo(geo);
                    }
                }
                _lastTapDate = now;
            }

            // Update last touches
            _lastTouches = event.touches;

            if (_navigation.inertia && (_dx !== 0 || _dy !== 0)) {
                // Launch inertia depending on action hits while "moving" phase
                var hitIndex = _actionHits.indexOf(Math.max.apply(this, _actionHits));
                if (hitIndex === Type.PAN) {
                    // Pan
                    _navigation.inertia.launch("pan", _dx, _dy);
                }
                else if (hitIndex === Type.ROTATE) {
                    console.log("Rotate not implemented in navigation");
                    // Rotate
                    //_navigation.inertia.launch("rotate", _rotation, 0);
                }
                else if (hitIndex === Type.TILT) {
                    console.log("Tilt not implemented in navigation");
                    // No inertia for tilt
                }
            }

            if (event.preventDefault) {
                event.preventDefault();
            }
            event.returnValue = false;

            return false;
        };

        /**************************************************************************************************************/

        /**
         * Public methods
         */

        /**
         *    Setup the default event handlers for the _navigation
         */
        this.install = function (nav) {
            _navigation = nav;

            // Setup the touch event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.addEventListener("touchstart", _handleTouchStart, false);
            canvas.addEventListener("touchend", _handleTouchEnd, false);
            canvas.addEventListener("touchmove", _handleTouchMove, false);
        };

        /**
         *    Remove the default event handlers for the _navigation
         */
        this.uninstall = function () {
            // Setup the mouse event handlers
            var canvas = _navigation.renderContext.canvas;

            canvas.removeEventListener("touchstart", _handleTouchStart, false);
            canvas.removeEventListener("touchend", _handleTouchEnd, false);
            canvas.removeEventListener("touchmove", _handleTouchMove, false);
        };
    };

    return TouchNavigationHandler;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationHandlerFactory
 * @class
 * Factory to create a device for the control of the camera.
 * @memberOf module:Navigation
 */
define('Navigation/NavigationHandlerFactory',["../Utils/Constants","./GoogleMouseNavigationHandler","./KeyboardNavigationHandler","./MouseNavigationHandler","./TouchNavigationHandler"],
    function(Constants, GoogleMouseNavigationHandler, KeyboardNavigationHandler, MouseNavigationHandler, TouchNavigationHandler) {

        return {
            /**
             * Creates a specific navigation based on its type (e.g Astro, Flat, Sky).
             * @param {HANDLER} type - the type of navigation
             * @param {AbstractNavigation.touch_configuration|AbstractNavigation.mouse_configuration|AbstractNavigation.googleMouse_configuration|AbstractNavigation.keyboard_configuration} options - see the handlers.
             * @return {Object} one of the handler
             * @alias module:Navigation.NavigationHandlerFactory.create
             * @see {@link GoogleMouseNavigationHandler} - Control the camera with mouse as Google movement
             * @see {@link KeyboardNavigationHandler} - Control the camera with the keyboard
             * @see {@link MouseNavigationHandler} - Control the camera with the mouse
             * @see {@link TouchNavigationHandler} - Control the camera with the smartphone
             * @throws {RangeError} Type not valid - a valid type is included in the list {@link HANDLER}
             */
            create : function(type, options) {
                var obj;
                switch (type) {
                    case Constants.HANDLER.GoogleMouse:
                        obj = new GoogleMouseNavigationHandler(options);
                        break;
                    case Constants.HANDLER.Keyboard:
                        obj = new KeyboardNavigationHandler(options);
                        break;
                    case Constants.HANDLER.Mouse:
                        obj = new MouseNavigationHandler(options);
                        break;
                    case Constants.HANDLER.Touch:
                        obj = new TouchNavigationHandler(options);
                        break;
                    default:
                        throw RangeError("The type "+type+" is not allowed, A valid type is included in the list Constants.HANDLER", "NavigationHandlerFactory.js");
                }
                return obj;
            }
    }});
 
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/


define('Animation/AbstractAnimation',[],function () {

    /**
     * @name AbstractAnimation
     * @class
     * AbstractAnimation is an abstract class for all animation contexts which allow
     * an application to create an animation of the camera around the globe.
     * @implements {Animation}
     * @todo Describes here and link to the tutos about Animation
     */
    var AbstractAnimation = function () {
        this.startTime = -1;
        this.pauseTime = -1;
        this.renderContext = null;
    };

    /**
     * @function getRenderContext
     * @memberOf AbstractAnimation#
     */
    AbstractAnimation.prototype.getRenderContext = function () {
        return this.renderContext;
    };

    /**
     * Unregisters animation.
     * @function _unregisterActive
     * @memberOf AbstractAnimation#
     * @private
     */
    AbstractAnimation.prototype._unregisterActive = function () {
        var index = this.renderContext.activeAnimations.indexOf(this);
        if (index >= 0) {
            this.renderContext.activeAnimations.splice(index, 1);
        }
    };


    /**
     * @function getStatus
     * @memberOf AbstractAnimation#
     */
    AbstractAnimation.prototype.getStatus = function () {
        if (this.startTime === -1) {
            return "STOPPED";
        } else {
            return this.pauseTime === -1 ? "RUNNING" : "PAUSED";
        }
    };
    
    /**
     * @function start
     * @memberOf AbstractAnimation#
     */
    AbstractAnimation.prototype.start = function () {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime === -1 || this.pauseTime !== -1) {
            var now = Date.now();
            if (this.startTime === -1) {
                this.startTime = now;
            }
            else {
                // resume after pause
                this.startTime += now - this.pauseTime;
                this.pauseTime = -1;
            }

            // Register animation as active
            this.renderContext.activeAnimations.push(this);
            this.renderContext.requestFrame();
        }
    };

    /**
     * @function pause
     * @memberOf AbstractAnimation#
     */
    AbstractAnimation.prototype.pause = function () {
        if (!this.renderContext) {
            return;
        }

        if (this.startTime !== -1 && this.pauseTime === -1) {
            this.pauseTime = Date.now();
            this._unregisterActive(this);
        }
    };

    /**
     * @function stop
     * @memberOf AbstractAnimation#
     */
    AbstractAnimation.prototype.stop = function () {
        this.startTime = -1;
        this.pauseTime = -1;

        if (this.onstop) {
            this.onstop();
        }

        // Unregister animation
        this._unregisterActive(this);
    };

    /**************************************************************************************************************/

    return AbstractAnimation;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/SegmentedAnimation',['../Utils/Utils', './AbstractAnimation', '../Utils/Numeric'],
    function (Utils, AbstractAnimation, Numeric) {

        /**
         * Segmented animation configuration
         * @typedef  {Object} AbstractAnimation.segmented_configuration
         * @param {float} duration - duration of the animation
         * @param {Object} valueSetter - the function used to set the value.
         */

        /**
         * @name SegmentedAnimation
         * @class
         * SegmentedAnimation is an animation defined with segments.
         * Each segment has a [start,end] pair of 't' value and a [start,end] pair of
         * values that will be interpolated with the interpolator set on the segment.
         * When the animation runs, a t parameter is mapped to [0,1] according to
         * current time and animation duration.
         * The current segment is then looked up with that 't' value and used to interpolate
         * the animation's current value.
         * @augments AbstractAnimation
         * @param {AbstractAnimation.segmented_configuration} options - Configuration of the animation
         * @constructor
         * @memberOf module:Animation
         */
        var SegmentedAnimation = function (options) {
            // Call ancestor constructor
            AbstractAnimation.prototype.constructor.call(this);

            this.segments = [];
            this.duration = options.duration;
            this.valueSetter = options.valueSetter;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractAnimation, SegmentedAnimation);

        /**
         * Creates a segment.
         * @param start t value at which the segment will be the current segment
         * @param startValue value at t=start
         * @param end value at which the segment will be the current segment
         * @param endValue value at t=end
         * @param interpolator
         * @constructor
         * @todo Create a tutorial with a simple SegmentedAnimation on Mars
         */
        var Segment = function (start, startValue, end, endValue, interpolator) {
            this.start = start;
            this.startValue = startValue;
            this.end = end;
            this.endValue = endValue;
            this.interpolator = interpolator;
        };

        /**************************************************************************************************************/

        /**
         * Adds a new segment to the animation.<br/>
         * start, end are 't' values at which the segment will be the current segment<br/>
         * startValue, endValue are animation values at 't'=start and 't'=end<br/>
         * interpolator is the function that will be called to interpolate bewteen startValue and endValue.
         * @function addSegment
         * @memberOf SegmentedAnimation
         * @param {float} start - t value at which the segment will be the current segment
         * @param {float} startValue - value at t=start
         * @param {float} end - value at which the segment will be the current segment
         * @param {float} endValue - value at t=end
         * @param {Function} interpolator - interpolator function
         */
        SegmentedAnimation.prototype.addSegment = function (start, startValue, end, endValue, interpolator) {
            var count = this.segments.length;
            var index = 0;
            while (index < count && this.segments[index].end <= start) {
                index++;
            }
            // Insert new segment at position 'index'
            this.segments.splice(index, 0, new Segment(start, startValue, end, endValue, interpolator));
        };

        /**
         * Animation update method
         * @function update
         * @memberOf SegmentedAnimation#
         * @param {float} now - Now
         */
        SegmentedAnimation.prototype.update = function (now) {
            var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);
            if (t >= 1) {
                // Set last value
                var lastIndex = this.segments.length - 1;
                this.valueSetter(this.segments[lastIndex].endValue);
                this.stop();
            }
            else {
                // Find current segment
                var count = this.segments.length;
                var index = 0;
                while (index < count && this.segments[index].end < t) {
                    index++;
                }
                index = Math.min(index, count - 1);

                // Remap t between segment bounds
                t = Numeric.map01(t, this.segments[index].start, this.segments[index].end);
                // Interpolate value
                var value = this.segments[index].interpolator(t, this.segments[index].startValue, this.segments[index].endValue);
                // Use value
                this.valueSetter(value);
            }
        };

        /**************************************************************************************************************/

        return SegmentedAnimation;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/PathAnimation',['../Utils/Utils', './AbstractAnimation', '../Utils/Numeric', '../Renderer/glMatrix'],
    function (Utils, AbstractAnimation, Numeric) {

        /**
         * Path animation configuration
         * @typedef {Object} AbstractAnimation.path_configuration
         * @param {Array.<float[]>} coords - The path coordinates
         * @param {float} speed - The speed value
         * @param {Function} setter - the function used to set the value
         * @param {Globe} globe - the globe to clamp path animations on the terrain
         */

        /**
         * @name PathAnimation
         * @class
         * PathAnimation is an animation defined with a path.
         * @augments AbstractAnimation
         * @param {AbstractAnimation.path_configuration} options Configuration of the animation
         * @constructor
         * @memberOf module:Animation
         * @todo Create a tutorial with a simple PathAnimation on Mars
         */
        var PathAnimation = function (options) {
            var i;
            var vec1, vec2;
            var dx, dy, dz;
            var node;
            var temp;

            // Call ancestor constructor
            AbstractAnimation.prototype.constructor.call(this);
            this.globe = options.globe;
            this.speed = options.speed * this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000;
            this.nodes = [];
            for (i = 0; i < options.coords.length; i++) {
                node = {
                    position: this.globe.getCoordinateSystem().get3DFromWorld(options.coords[i]),
                    velocity: null,
                    distance: 0.0
                };
                this.nodes.push(node);
                if (i > 0) {
                    dx = this.nodes[i].position[0] - this.nodes[i - 1].position[0];
                    dy = this.nodes[i].position[1] - this.nodes[i - 1].position[1];
                    dz = this.nodes[i].position[2] - this.nodes[i - 1].position[2];
                    this.nodes[i - 1].distance = Math.sqrt(dx * dx + dy * dy + dz * dz);
                }
            }

            for (i = 1; i < options.coords.length - 1; i++) {
                vec1 = vec3.subtract(this.nodes[i + 1].position, this.nodes[i].position, vec3.create());
                vec2 = vec3.subtract(this.nodes[i - 1].position, this.nodes[i].position, vec3.create());
                vec3.normalize(vec1);
                vec3.normalize(vec2);
                this.nodes[i].velocity = vec3.subtract(vec1, vec2, vec3.create());
                vec3.normalize(this.nodes[i].velocity);
            }

            // Start velocity
            temp = vec3.subtract(this.nodes[1].position, this.nodes[0].position, vec3.create());
            vec3.scale(temp, ( 3 / this.nodes[0].distance ));
            this.nodes[0].velocity = vec3.subtract(temp, this.nodes[1].velocity, vec3.create());
            vec3.scale(this.nodes[0].velocity, 0.5);

            // End velocity
            i = options.coords.length - 1;
            temp = vec3.subtract(this.nodes[i].position, this.nodes[i - 1].position, vec3.create());
            vec3.scale(temp, ( 3 / this.nodes[i - 1].distance ));
            this.nodes[i].velocity = vec3.subtract(temp, this.nodes[i - 1].velocity, vec3.create());
            vec3.scale(this.nodes[i].velocity, 0.5);

            this.index = 0;
            this.currentDistance = 0;
            this.previousTime = -1;
            this.centerOffset = -0.2;
            this.altitudeOffset = 1000;

            var that = this;
            if (options.setter) {
                this.valueSetter = options.setter;
            }
            else {
                this.valueSetter = function (value, direction) {
                    var up = vec3.normalize(value, vec3.create());

                    var eye;
                    if (options.globe) {
                        var geoEye = options.globe.getCoordinateSystem().getWorldFrom3D(value);
                        geoEye[2] = options.globe.getElevation(geoEye[0], geoEye[1]) + that.altitudeOffset;
                        eye = options.globe.getCoordinateSystem().get3DFromWorld(geoEye);
                    }
                    else {
                        eye = value;
                        eye[2] += that.altitudeOffset;
                    }

                    var dirn = vec3.normalize(direction, vec3.create());
                    var center = vec3.add(eye, dirn, vec3.create());
                    vec3.add(center, vec3.scale(up, that.centerOffset, vec3.create()));
                    mat4.lookAt(eye, center, up, that.renderContext.getViewMatrix());
                };
            }
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractAnimation, PathAnimation);

        /**************************************************************************************************************/

        /**
         * Sets the speed.
         * @function setSpeed
         * @memberOf PathAnimation#
         * @param {float} val Speed
         */
        PathAnimation.prototype.setSpeed = function (val) {
            this.speed = parseFloat(val) * this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000.0;
        };

        /**
         * Returns the speed.
         * @function getSpeed
         * @memberOf PathAnimation#
         * @return {float} Speed
         */
        PathAnimation.prototype.getSpeed = function () {
            return this.speed / (this.globe.getCoordinateSystem().getGeoide().getHeightScale() / 1000.0);
        };

        /**
         * Sets the altitude offset.
         * @function setAltitudeOffset
         * @memberOf PathAnimation#
         * @param {float} val Altitude offset
         */
        PathAnimation.prototype.setAltitudeOffset = function (val) {
            this.altitudeOffset = parseFloat(val);
        };

        /**
         * Returns the altitude offset.
         * @function getAltitudeOffset
         * @memberOf PathAnimation#
         * @return {float} Altitude offset
         */
        PathAnimation.prototype.getAltitudeOffset = function () {
            return this.altitudeOffset;
        };

        /**
         * Sets the direction angle.
         * @function setDirectionAngle
         * @memberOf PathAnimation#
         * @param {float} vertical Direction angle
         */
        PathAnimation.prototype.setDirectionAngle = function (vertical) {
            this.centerOffset = Math.tan(parseFloat(vertical) * Math.PI / 180.0);
        };

        /**
         * Starts the animation.
         * @function start
         * @memberOf PathAnimation#
         */
        PathAnimation.prototype.start = function () {
            var previousStartTime = -1;
            if (this.pauseTime !== -1) {
                previousStartTime = this.startTime;
            }

            Animation.prototype.start.call(this);

            if (previousStartTime !== -1) {
                this.previousTime += this.startTime - previousStartTime;
            }
            else {
                this.previousTime = -1;
            }
        };

        /**
         * Updates the animation.
         * @function update
         * @memberOf PathAnimation
         * @param {float} now the date now
         */
        PathAnimation.prototype.update = function (now) {
            if (this.previousTime === -1) {
                this.index = 0;
                this.currentDistance = 0;
            }
            else {
                this.currentDistance += (now - this.previousTime) * this.speed;
            }
            this.previousTime = now;

            while (this.currentDistance >= this.nodes[this.index].distance && this.index < this.nodes.length - 1) {
                this.currentDistance -= this.nodes[this.index].distance;
                this.index = this.index + 1;
            }

            if (this.index < this.nodes.length - 1) {
                var t = this.currentDistance / this.nodes[this.index].distance;
                var startPos = this.nodes[this.index].position;
                var endPos = this.nodes[this.index + 1].position;
                var startVel = vec3.scale(this.nodes[this.index].velocity, this.nodes[this.index].distance, vec3.create());
                var endVel = vec3.scale(this.nodes[this.index + 1].velocity, this.nodes[this.index].distance, vec3.create());
                var position = Numeric.cubicInterpolation(t, startPos, startVel, endPos, endVel);
                var direction = Numeric.cubicInterpolationDerivative(t, startPos, startVel, endPos, endVel);
                this.valueSetter(position, direction);
            }
            else if (this.index === this.nodes.length - 1) {
                this.valueSetter(this.nodes[this.index].position, this.nodes[this.index].velocity);
            }
            else {
                this.stop();
            }
        };

        /**************************************************************************************************************/

        return PathAnimation;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Mizar is able to create different types of animation on a globe :
 * <ul>
 *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}: Animation simulating inertia for camera navigation</li>
 *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation} : Generic animation to interpolate arbitrary values</li>
 *     <li>{@link module:Animation.PathAnimation PathAnimation} : Animation defined with a path</li>
 *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation} : Animation defined with segments</li>
 * </ul>
 *
 * In addition to the classes, a {@link module:Animation.AnimationFactory factory} is available to help for creating
 * animation. Once the animation is created, the client can handle it by the use of its {@link Animation interface}.
 *
 * @module Animation
 * @implements {Animation}
 * @todo Describes here and link to the tutos about Animation
 */
define('Animation/InertiaAnimation',['../Utils/Utils', './AbstractAnimation'], function (Utils, AbstractAnimation) {

    /**************************************************************************************************************/

    /**
     * @constant
     * @type {float}
     * @default
     */
    const EPSILON = 0.1;

    /**
     * Default panFactor value
     * @constant
     * @type {number}
     * @default
     */
    const PAN_FACTOR = 0.95;

    /**
     * Default rotateFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ROTATE_FACTOR = 0.95;

    /**
     * Default zoomFactor value
     * @constant
     * @type {number}
     * @default
     */
    const ZOOM_FACTOR = 0.50;

    /**
     * Inertia animation configuration
     * @typedef {Object} AbstractAnimation.inertia_configuration
     * @property {Navigation} nav - Navigation object that applies the transformations.
     * @property {float} [panFactor=0.95] - Pan Factor which is included in [0..1]. - 1 is sensible to the pan
     * @property {float} [zoomFactor=0.50] - Zoom Factor which is included in [0..1]. - 1 is sensible to the zoom
     * @property {float} [rotateFactor=0.95] - Rotate Factor which is included in [0..1]. - 1 is sensible to the rotation
     */

    /**
     * @name InertiaAnimation
     * @class
     * Animation simulating inertia for camera's navigation.
     * Inertia is its tendency to retain its velocity: in the absence of external influence, the camera's motion
     * persists in an uniform rectilinear motion.
     * @augments AbstractAnimation
     * @param {AbstractAnimation.inertia_configuration} options Configuration of the Inertia animation
     * @constructor
     * @memberOf module:Animation
     */
    var InertiaAnimation = function (options) {
        AbstractAnimation.prototype.constructor.call(this);
        if (options) {
            this.panFactor = options.hasOwnProperty('panFactor') ? options.panFactor : PAN_FACTOR;
            this.rotateFactor = options.hasOwnProperty('rotateFactor') ? options.rotateFactor : ROTATE_FACTOR;
            this.zoomFactor = options.hasOwnProperty('zoomFactor') ? options.zoomFactor : ZOOM_FACTOR;
        }

        this.type = null;
        this.dx = 0;
        this.dy = 0;
        this.navigation = options.nav;
        this.renderContext = options.nav.getRenderContext();
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InertiaAnimation);

    /**************************************************************************************************************/

    /**
     * Updates the inertia.
     * @function update
     * @memberOf InertiaAnimation#
     */
    InertiaAnimation.prototype.update = function (now) {
        var hasToStop = false;

        switch (this.type) {
            case "pan":
                this.navigation.pan(this.dx, this.dy);
                this.dx *= this.panFactor;
                this.dy *= this.panFactor;
                hasToStop = (Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON);
                break;
            case "rotate":
                this.navigation.rotate(this.dx, this.dy);
                this.dx *= this.rotateFactor;
                this.dy *= this.rotateFactor;
                hasToStop = (Math.abs(this.dx) < EPSILON && Math.abs(this.dy) < EPSILON);
                break;
            case "zoom":
                this.navigation.zoom(this.dx);
                this.dx *= this.zoomFactor;
                hasToStop = (Math.abs(this.dx) < EPSILON);
                break;
            default:
        }
        this.navigation.getRenderContext().requestFrame();

        if (hasToStop) {
            this.stop();
        }
    };

    /**************************************************************************************************************/

    /**
     * Launches the animation.
     * @function launch
     * @param {String} type Type of inertia
     * <ul>
     *   <li>pan</li>
     *   <li>rotate</li>
     *   <li>zoom</li>
     * </ul>
     * @param {int} dx x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @param {int} dy x of inertiaVector Vector of movement in window coordinates(for pan and rotate inertia)
     * @memberOf InertiaAnimation#
     */
    InertiaAnimation.prototype.launch = function (type, dx, dy) {
        // Set first value
        this.type = type;
        this.dx = dx;
        this.dy = dy;

        this.start();
    };

    /**************************************************************************************************************/

    return InertiaAnimation;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Animation/InterpolatedAnimation',['../Utils/Utils', './AbstractAnimation'], function (Utils, AbstractAnimation) {

    /**
     * Interpolated animation configuration
     * @typedef {Object} AbstractAnimation.interpolated_configuration
     * @property {float} startValue - Starting point of the interpolation.
     * @property {float} endValue - Ending point of the interpolation.
     * @property {float} duration - Duration of the animation in seconds
     * @property {Function} interpolationFunction-  Interpolation function
     * @property {Function} setFunction - Setter of the Interpolation function
     */
    
    /**
     * @name InterpolatedAnimation
     * @class
     * Generic animation to interpolate arbitrary values
     * The animation will interpolate between startValue and endValue, using the
     * interpolateFunction(t, startValue, endValue) (t [0,1])
     * The interpolated value is then given to the setFunction(value)
     * @augments AbstractAnimation
     * @param {AbstractAnimation.interpolated_configuration} options Configuration of the InterpolatedAnimation
     * @constructor
     * @memberOf module:Animation
     * @todo Create a tutorial with a simple InterpolatedAnimation on Mars
     */
    var InterpolatedAnimation = function (options) {
        // Call ancestor constructor
        AbstractAnimation.prototype.constructor.call(this);

        this.values = [[0.0, options.startValue], [1.0, options.endValue]];
        this.duration = options.duration;
        this.interpolationFunction = options.interpolationFunction;
        this.setFunction = options.setFunction;
    };

    /**************************************************************************************************************/

    Utils.inherits(AbstractAnimation, InterpolatedAnimation);

    /**************************************************************************************************************/

    /**
     * Adds a new value to the animation.
     * @function addValue
     * @memberOf InterpolatedAnimation#
     * @param {float} t Value at [0,1]
     * @param {float} value Value to reach
     */
    InterpolatedAnimation.prototype.addValue = function (t, value) {
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        // Insert new value at position 'upper'
        this.values.splice(upper, 0, [t, value]);
    };


    /**
     * Starts the animation.
     * @function start
     * @memberOf InterpolatedAnimation#
     */
    InterpolatedAnimation.prototype.start = function () {
        Animation.prototype.start.call(this);
        this.setFunction(this.startValue);
        //TODO this.startValue is a bug ?
    };


    /**
     * Stops the animation.
     * @function stop
     * @memberOf InterpolatedAnimation
     */
    InterpolatedAnimation.prototype.stop = function () {
        Animation.prototype.stop.call(this);
        this.setFunction(this.endValue);
        //TODO this.endValue is a bug ?
    };

    /**
     * Updates the Animation.
     * @function udate
     * @memberOf InterpolatedAnimation
     * @param {float} now Now
     */
    InterpolatedAnimation.prototype.update = function (now) {
        var t = Numeric.map01(now, this.startTime, this.startTime + this.duration);
        if (t >= 1) {
            this.stop();
            return;
        }

        // Find upper and lower bounds
        var count = this.values.length;
        var upper = 0;
        while (upper < count && this.values[upper][0] < t) {
            upper++;
        }
        upper = Math.min(upper, count - 1);
        var lower = Math.max(0, upper - 1);

        // Remap t between lower and upper bounds
        t = Numeric.map01(t, this.values[lower][0], this.values[upper][0]);
        // Interpolate value
        var value = this.interpolationFunction(t, this.values[lower][1], this.values[upper][1]);
        // Use interpolated value
        this.setFunction(value);
    };

    /**************************************************************************************************************/

    return InterpolatedAnimation;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name AnimationFactory
 * @class
 * Factory to create an animation
 * @memberOf module:Animation
 */
define('Animation/AnimationFactory',["../Utils/Constants", "./SegmentedAnimation", "./PathAnimation", "./InertiaAnimation", "./InterpolatedAnimation"],
    function (Constants, SegmentedAnimation, PathAnimation, InertiaAnimation, InterpolatedAnimation) {

        return {

            /**
             * Factory to create an animation.
             *
             * Creates an animation based on :
             * <ul>
             *     <li>the animation type {@link ANIMATION},</li>
             *     <li>the options for the specific animation</li>
             * </ul>
             *
             * Severals animations can be created :
             * <ul>
             *     <li>{@link module:Animation.InertiaAnimation InertiaAnimation}</li>
             *     <li>{@link module:Animation.InterpolatedAnimation InterpolatedAnimation}</li>
             *     <li>{@link module:Animation.PathAnimation PathAnimation}</li>
             *     <li>{@link module:Animation.SegmentedAnimation SegmentedAnimation}</li>
             * </ul>
             * @param {ANIMATION} type - Type of animation.
             * @param {AbstractAnimation.inertia_configuration|AbstractAnimation.interpolated_configuration|AbstractAnimation.path_configuration|AbstractAnimation.segmented_configuration} options - See the options for each animation for further information
             * @return {AbstractAnimation} - the interface to handle an animation
             * @throws {RangeError} Type not valid - a valid type is included in the list {@link ANIMATION}
             * @alias module:Animation.AnimationFactory.create
             * @see {@link module:Animation.InertiaAnimation InertiaAnimation} Animation simulating inertia for camera's navigation
             * @see {@link module:Animation.InterpolatedAnimation InterpolatedAnimation} Generic animation to interpolate arbitrary values
             * @see {@link module:Animation.PathAnimation PathAnimation} Defines an animation based on a path
             * @see {@link module:Animation.SegmentedAnimation SegmentedAnimation} Defines an animation based on segments
             *
             */
            create: function (type, options) {
                var obj;
                switch (type) {
                    case Constants.ANIMATION.Inertia :
                        obj = new InertiaAnimation(options);
                        break;
                    case Constants.ANIMATION.Interpolated :
                        obj = new InterpolatedAnimation(options);
                        break;
                    case Constants.ANIMATION.Path :
                        obj = new PathAnimation(options);
                        break;
                    case Constants.ANIMATION.Segmented :
                        obj = new SegmentedAnimation(options);
                        break;
                    default:
                        throw RangeError("The type "+type+" is not allowed, A valid type is included in the list Constants.ANIMATION", "AnimationFactory.js");
                }
                return obj;
            }

        }
    });


/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/AbstractNavigation',['../Utils/Utils', '../Utils/Event', '../Navigation/NavigationHandlerFactory', '../Animation/AnimationFactory', '../Utils/Numeric', '../Utils/Constants', '../Renderer/glMatrix'],
    function (Utils, Event, NavigationHandlerFactory, AnimationFactory, Numeric, Constants) {

        /**
         * Navigation configuration
         * @typedef {Object} AbstractNavigation.configuration
         * @property {boolean} [inertia = false] - Animation simulating inertia for camera's navigation
         * @property {AbstractAnimation.inertia_configuration} inertiaAnimation - Inertia Animation is used when <i>inertia</i> is true
         * @property {Object[]} [handlers = [{@link module:Navigation.MouseNavigationHandler MouseNavigationHandler},{@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler}[,{@link module:Navigation.TouchNavigationHandler TouchNavigationHandler}]]
         * @property {AbstractNavigation.mouse_configuration} [mouse] - Mouse navigation configuration when <i>handlers</i> is not defined
         * @property {AbstractNavigation.keyboard_configuration} [keyboard] - Keyboard navigation configuration when <i>handlers</i> is not defined
         * @property {boolean} [isMobile = false] - {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} configuration when <i>handlers</i> is not defined, sets to true this parameter to support mobile device
         */

        /**
         * @name AbstractNavigation
         * @class
         * The active navigation object can normally be obtained from the {@link Mizar#getNavigation} method of the Mizar instance.
         * Client implementations should not normally instantiate this class directly.
         * @augments Event
         * @param {NAVIGATION} type - type of navigation
         * @param {AbstractContext} ctx - context
         * @param {AbstractNavigation.configuration} [options = {}] - options for navigation
         * @constructor
         * @see {@link module:Navigation.NavigationHandlerFactory NavigationHandlerFactory} the possible handlers
         * @see {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler} for its options when it is set by default
         * @see {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} for its options when it is set by default
         * @see {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} for its options when isMobile is set to True
         * @implements {Navigation}
         *
         */
        var AbstractNavigation = function (type, ctx, options) {
            Event.prototype.constructor.call(this);
            this.type = type;
            this.ctx = ctx;
            this.renderContext = this.ctx.getRenderContext();
            this.options = options || {};

            // Create default handlers if none are created in options
            this.handlers = _createHandlers.call(this, this.options);

            // Inertia effect
            this.inertia = _addInertiaEffect.call(this, this.options);

            // ZoomTo animation
            this.zoomToAnimation = null;

            // Automatically start
            this.start();
        };

        /**
         * Adds inertia effect
         * @param {Object} options
         * @returns {InertiaAnimation|null} inertia
         * @private
         */
        function _addInertiaEffect(options) {
            var inertia;
            if (options.inertia) {
                var inertiaOptions = options.inertiaAnimation || {};
                inertiaOptions.nav = this;
                inertia = AnimationFactory.create(Constants.ANIMATION.Inertia, inertiaOptions);
            } else {
                inertia = null;
            }
            return inertia;
        }

        /**
         * Creates handlers :
         * <ul>
         *     <li>Provided in options</li>
         *     <li>Create default handlers</li>
         * </ul>
         * @param {Object} options
         * @returns {Object[]} handlers
         * @private
         */
        function _createHandlers(options) {
            var handlers;
            // Create default handlers if none are created in options
            if (options.handlers) {
                handlers = options.handlers;
            }
            else {
                // Use mouse & keyboard as default handlers
                handlers = _addDefaultHandlers.call(this, options);
            }
            return handlers
        }

        /**
         * Add default handlers :
         * <ul>
         *     <li>MouseNavigationHandler</li>
         *     <li>KeyboardNavigationHandler</li>
         *     <li>TouchNavigationHandler is isMobile is true</li>
         * </ul>
         * @param {Object} options - options
         * @returns {Object[]} An array of handlers
         * @private
         */
        function _addDefaultHandlers(options) {
            var defaultHandlers = [
                NavigationHandlerFactory.create(Constants.HANDLER.Mouse, options ? options.mouse : null),
                NavigationHandlerFactory.create(Constants.HANDLER.Keyboard, options ? options.keyboard : null)
            ];
            if (options.isMobile) {
                defaultHandlers.push(NavigationHandlerFactory.create(Constants.HANDLER.Touch, options ? options.touch : null));
            }
            return defaultHandlers
        }

        /**************************************************************************************************************/

        Utils.inherits(Event, AbstractNavigation);

        /**************************************************************************************************************/

        /**
         * Returns the {@link TYPE type} of navigation.
         * The type can take one of the following value : AstroNavigation, FlatNavigation, PlanetNavigation
         * @function getType
         * @return {string} the name of the navigation class, which is used
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.getType = function () {
            return this.type;
        };

        /**
         * Returns the navigation's options given at the initialisation.
         * @function getOptions
         * @return {Object} Options
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.getOptions = function () {
            return this.options;
        };

        /**
         * Starts the navigation.
         * @function start
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.start = function () {
            // Install handlers
            for (var i = 0; i < this.handlers.length; i++) {
                this.handlers[i].install(this);
            }
        };

        /**
         * Stops the navigation.
         * @function stop
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.stop = function () {
            // Uninstall handlers
            for (var i = 0; i < this.handlers.length; i++) {
                this.handlers[i].uninstall();
            }
        };

        /**
         * Stops the animations.
         * @function stopAnimations
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.stopAnimations = function () {
            if (this.inertia) {
                this.inertia.stop();
            }
            if (this.zoomToAnimation) {
                this.zoomToAnimation.stop();
                this.zoomToAnimation = null;
            }
        };

        /**
         * Returns the field of view in decimal degree.
         * @function getFov
         * @return {float[]} the Field of view [fov along width, fov along height]
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.getFov = function () {
            var aspect = this.renderContext.getCanvas().width / this.renderContext.getCanvas().height;
            return [aspect * this.renderContext.getFov(), this.renderContext.getFov()];
        };

        /**
         * Moves up vector.
         * @function moveUpTo
         * @memberOf AstroNavigation#
         * @param {float[]} vec Vector
         * @param {int} [duration = 1000] - Duration of animation in milliseconds
         * @abstract
         */
        AbstractNavigation.prototype.moveUpTo = function (vec, duration) {
            throw new SyntaxError("moveUpTo not implemented", "AbstractNavigation.js");
        };

        /**
         * Returns the center of the field of view.
         * @function getCenter
         * @return {float[]} the center in decimal degree of the field of view [longitude, latitude]
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.getCenter = function () {
            return this.ctx.getLonLatFromPixel(this.renderContext.getCanvas().width * 0.5, this.renderContext.getCanvas().height * 0.5)
        };

        /**
         * Rotates the camera.
         * @function rotate
         * @param {float} dx Window delta x
         * @param {float} dy Window delta y
         * @abstract
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.rotate = function(dx, dy) {
            throw new SyntaxError("rotate is not implemented", "AbstractNavigation.js");
        };

        /**
         * Pans the camera to a direction up/down or left/right with the same distance from the object
         * @function pan
         * @param {float} dx Window direction left/right
         * @param {float} dy Window direction up/down
         * @abstract
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.pan = function(dx, dy) {
            throw new SyntaxError("pan is not implemented", "AbstractNavigation.js");
        };

        /**
         * Applies zooming.
         * @function zoom
         * @param {float} delta Delta zoom
         * @param {float} scale Scale
         * @abstract
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.zoom = function(delta, scale) {
            throw new SyntaxError("zoom is not implemented", "AbstractNavigation.js");
        };

        /**
         * Zooms to a 2D position (longitude, latitude).
         * @function zoomTo
         * @param {float[]} geoPos - spatial position in decimal degree [longitude, latitude]
         * @param {Object} options - options for zoomTo
         * @abstract
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.zoomTo = function(geoPos, options) {
            throw new SyntaxError("zoomTo is not implemented", "AbstractNavigation.js");
        };


        /**
         * Computes the view matrix
         * @function computeViewMatrix
         * @memberOf AbstractNavigation#
         * @abstract
         */
        AbstractNavigation.prototype.computeViewMatrix = function() {
            throw new SyntaxError("computeViewMatrix not implemented", "AbstractNavigation.js");
        };

        /**
         * Callback at the end of animation (when stop method is called).
         * @callback navigationCallback
         */

        /**
         * Basic animation from current view matrix to the given one
         * @function toViewMatrix
         * @param {Object[]} mat Destination view matrix (array of 16)
         * @param {int} fov Final zooming fov in degrees
         * @param {int} duration Duration of animation in milliseconds
         * @param {navigationCallback} callback Callback at the end of animation
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.toViewMatrix = function (mat, fov, duration, callback) {
            var navigation = this;
            var vm = this.renderContext.getViewMatrix();

            var srcViewMatrix = mat4.toMat3(vm);
            var srcQuat = quat4.fromRotationMatrix(srcViewMatrix);
            var destViewMatrix = mat4.toMat3(mat);
            var destQuat = quat4.fromRotationMatrix(destViewMatrix);
            var destFov = fov || 45;
            duration = duration || 1000;

            // Animate rotation matrix(with quaternion support), translation and fov
            var startValue = [srcQuat, [vm[12], vm[13], vm[14]], navigation.getRenderContext().getFov()];
            var endValue = [destQuat, [mat[12], mat[13], mat[14]], destFov];
            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": duration,
                    "valueSetter": function (value) {
                        // Update rotation matrix
                        var newRotationMatrix = quat4.toMat4(value[0]);

                        // Need to transpose the new rotation matrix due to bug in glMatrix
                        var viewMatrix = mat4.transpose(newRotationMatrix);

                        // Update translation
                        viewMatrix[12] = value[1][0];
                        viewMatrix[13] = value[1][1];
                        viewMatrix[14] = value[1][2];

                        // sets the new matrix
                        navigation.renderContext.setViewMatrix(viewMatrix);

                        // Update fov
                        navigation.renderContext.setFov(value[2]);

                        navigation.renderContext.requestFrame();
                    }
                });

            // Add segment
            animation.addSegment(
                0.0, startValue,
                1.0, endValue,
                function (t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    var resQuat = quat4.create();
                    quat4.slerp(a[0], b[0], pt, resQuat);

                    var resTranslate = vec3.create();
                    vec3.lerp(a[1], b[1], pt, resTranslate);

                    var resFov = Numeric.lerp(pt, a[2], b[2]);
                    return [
                        resQuat,		// quaternions
                        resTranslate,	// translate
                        resFov          // fov
                    ];
                }
            );

            animation.onstop = function () {
                if (callback) {
                    callback();
                }
            };

            this.ctx.addAnimation(animation);
            animation.start();
        };

        /**
         * Returns the rendering context.
         * @function getRenderContext
         * @returns {RenderContext} the rendering context
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.getRenderContext = function () {
            return this.renderContext;
        };

        /**
         * Sets the rendering context
         * @function setRenderContext
         * @param {RenderContext} renderContext - the rendering context to set
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.setRenderContext = function (renderContext) {
            this.renderContext = renderContext;
        };

        /**
         * Destroys the navigation.
         * @function destroy
         * @memberOf AbstractNavigation#
         */
        AbstractNavigation.prototype.destroy = function () {
            this.type = null;
            this.options = null;
            this.zoomToAnimation = null;
            this.stop();
            this.ctx = null;
            this.renderContext = null;
        };


        /**************************************************************************************************************/

        return AbstractNavigation;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/PlanetNavigation',['../Utils/Utils', '../Utils/Constants', './AbstractNavigation', '../Animation/AnimationFactory', '../Utils/Numeric', '../Renderer/glMatrix'],
    function (Utils, Constants, AbstractNavigation, AnimationFactory, Numeric) {

        /**
         * Flat navigation configuration
         * @typedef {AbstractNavigation.configuration} AbstractNavigation.planet_configuration
         * @property {float[]} [initTarget=[0, 0, 3.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
         * at initialisation. distance in meter is optional.
         * @property {int} [minDistance=0] the minimum distance sets to 60 Km by default or options.initTarget[2]
         * when this one is inferior to options.minDistance
         * @property {int} [maxDistance=3*RADIUS_PLANET] the maximum distance sets to 3*RADIUS_PLANET by default or
         * options.initTarget[2] when this one is superior to options.maxDistance
         * @property {boolean} [updateViewMatrix=false] indicating if view matrix must be updated on initialization.
         */

        /**
         * 1km epsilon error for elevation
         * @type {number}
         */
        const OFFSET_ELEVATION = 1000.0;

        /**
         * @name PlanetNavigation
         * @augments AbstractNavigation
         * @class
         * <table border="0">
         *     <tr>
         *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
         *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
         *     </tr>
         * </table>
         * At initialisation, the distance of the camera is maxDistance
         * @param {PlanetContext} ctx -  Planet context
         * @param {AbstractNavigation.planet_configuration} options - Planet navigation configuration
         * @memberOf module:Navigation
         */
        var PlanetNavigation = function (ctx, options) {
            AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.PlanetNavigation, ctx, options);

            // Default values for min and max distance (in meter)
            this.minDistance = (this.options.minDistance) || 0;
            this.maxDistance = (this.options.maxDistance) || 3.0 * this.ctx.getCoordinateSystem().getGeoide().getRadius() / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
            
            // Scale min and max distance from meter to internal ratio
            this.minDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
            this.maxDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale();

            // Initialize the navigation
            this.geoCenter = [0.0, 0.0, 0.0];
            this.heading = 0.0;
            this.tilt = 90.0;
            this.distance = this.maxDistance;

            this.inverseViewMatrix = mat4.create();

            var updateViewMatrix = (this.options.hasOwnProperty('updateViewMatrix') ? this.options.updateViewMatrix : true);

            _setInitTarget.call(this, this.options.initTarget);

            // Update the view matrix if needed(true by default)
            if (updateViewMatrix) {
                this.computeViewMatrix();
            }

        };

        /**
         * Defines the position where the camera looks at and the distance of the camera regarding to the planet's surface
         * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
         * @private
         */
        function _setInitTarget(initTarget) {
            if (initTarget) {
                this.geoCenter[0] = initTarget[0];
                this.geoCenter[1] = initTarget[1];
                this.distance = (initTarget.length === 3) ? initTarget[2] * this.ctx.getCoordinateSystem().getGeoide().getHeightScale() : this.distance;
                if(this.distance < this.minDistance) {
                    this.minDistance = this.distance;
                }
                if(this.distance > this.maxDistance) {
                    this.maxDistance = this.distance;
                }
            }
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractNavigation, PlanetNavigation);

        /**************************************************************************************************************/

        /**
         * Saves the current navigation state.
         * @function save
         * @memberOf PlanetNavigation#
         * @return {{geoCenter: *, heading: *, tilt: *, distance: *}} a JS object containing the navigation state
         */
        PlanetNavigation.prototype.save = function () {
            return {
                geoCenter: this.geoCenter,
                heading: this.heading,
                tilt: this.tilt,
                distance: this.distance
            };
        };

        /**
         * Restores the navigation state.
         * @function restore
         * @memberOf PlanetNavigation#
         * @param {Object} state - a JS object containing the navigation state
         * @param {float[]} state.geoCenter - Target of the camera (longitude, latitude)
         * @param state.heading
         * @param {float} state.tilt - tilt of the camera in decimal degree
         * @param {float} state.distance - Distance from the surface of the globe in meter.
         */
        PlanetNavigation.prototype.restore = function (state) {
            this.geoCenter = state.geoCenter;
            this.heading = state.heading;
            this.tilt = state.tilt;
            this.distance = state.distance;
            this.computeViewMatrix();
        };

        /**
         * Zoom to a geographic position
         * @function zoomTo
         * @memberOf PlanetNavigation#
         * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
         * @param {Object} options - Options
         * @param {int} [options.distance] - Final zooming distance in meters - if not set, this is the current distance
         * @param {int} [options.duration = 5000] - Duration of animation in milliseconds
         * @param {int} [options.tilt = 90] - Defines the tilt in the end of animation
         * @param {navigationCallback} [options.callback] - Callback at the end of animation
         */
        PlanetNavigation.prototype.zoomTo = function (geoPos, options) {
            var navigation = this;

            var destDistance = (options && options.distance) ? options.distance : this.distance / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
            var duration = (options && options.duration) ? options.duration : 5000;
            var destTilt = (options && options.tilt) ? options.tilt :  90;

            // Create a single animation to animate geoCenter, distance and tilt
            var startValue = [this.geoCenter[0], this.geoCenter[1], this.distance, this.tilt];
            var endValue = [geoPos[0], geoPos[1], destDistance * this.ctx.getCoordinateSystem().getGeoide().getHeightScale(), destTilt];
            this.zoomToAnimation = new AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": duration,
                    "valueSetter": function (value) {
                        navigation.geoCenter[0] = value[0];
                        navigation.geoCenter[1] = value[1];
                        navigation.distance = value[2];
                        navigation.tilt = value[3];
                        navigation.computeViewMatrix();
                    }
                });

            // Compute a max altitude for the animation
            var worldStart = this.ctx.getCoordinateSystem().get3DFromWorld(this.geoCenter);
            var worldEnd = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
            var vec = vec3.subtract(worldStart, worldEnd);
            var len = vec3.length(vec);
            var canvas = this.ctx.getRenderContext().canvas;
            var minFov = Math.min(Numeric.toRadian(45.0),
                Numeric.toRadian(45.0 * canvas.width / canvas.height));
            var maxAltitude = 1.1 * ((len / 2.0) / Math.tan(minFov / 2.0));
            if (maxAltitude > this.distance) {
                // Compute the middle value
                var midValue = [startValue[0] * 0.5 + endValue[0] * 0.5,
                    startValue[1] * 0.5 + endValue[1] * 0.5,
                    maxAltitude, destTilt];

                // Add two segments
                this.zoomToAnimation.addSegment(
                    0.0, startValue,
                    0.5, midValue,
                    function (t, a, b) {
                        var pt = Numeric.easeInQuad(t);
                        var dt = Numeric.easeOutQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2]), // distance
                            Numeric.lerp(t, a[3], b[3])]; // tilt
                    });

                this.zoomToAnimation.addSegment(
                    0.5, midValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2]), // distance
                            Numeric.lerp(t, a[3], b[3])]; // tilt
                    });
            }
            else {
                // Add only one segments
                this.zoomToAnimation.addSegment(
                    0.0, startValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2]),  // distance
                            Numeric.lerp(t, a[3], b[3])]; // tilt
                    });
            }

            var self = this;
            this.zoomToAnimation.onstop = function () {
                if (options && options.callback) {
                    options.callback();
                }
                self.zoomToAnimation = null;
            };

            this.ctx.addAnimation(this.zoomToAnimation);
            this.zoomToAnimation.start();
        };
        
        /**
         * Applies to rotation matrix
         * @function applyLocalRotation
         * @memberOf Navigation#
         */
        PlanetNavigation.prototype.applyLocalRotation = function (matrix) {
            mat4.rotate(matrix, (this.heading) * Math.PI / 180.0, [0.0, 0.0, 1.0]);
            mat4.rotate(matrix, (90 - this.tilt) * Math.PI / 180.0, [1.0, 0.0, 0.0]);
        };
        
        /**
         * Computes the view matrix
         * @function computeViewMatrix
         * @memberOf Navigation#
         */
        PlanetNavigation.prototype.computeViewMatrix = function () {
            this.computeInverseViewMatrix();
            mat4.inverse(this.inverseViewMatrix, this.renderContext.viewMatrix);
            this.ctx.publish("modifiedNavigation");
            this.renderContext.requestFrame();
        };


        /**
         * Compute the inverse view matrix
         * @function computeInverseViewMatrix
         * @memberOf PlanetNavigation#
         */
        PlanetNavigation.prototype.computeInverseViewMatrix = function () {
            this.ctx.getCoordinateSystem().getLHVTransform(this.geoCenter, this.inverseViewMatrix);
            this.applyLocalRotation(this.inverseViewMatrix);
            mat4.translate(this.inverseViewMatrix, [0.0, 0.0, this.distance]);
        };

        /**
         * Zoom to the current observed location
         * @function zoom
         * @memberOf PlanetNavigation#
         * @param {float} delta Delta zoom
         * @param {float} scale Scale
         */
        PlanetNavigation.prototype.zoom = function (delta, scale) {
            var previousDistance = this.distance;

            // TODO : improve zoom, using scale or delta ? We should use scale always
            if (scale) {
                this.distance *= scale;
            } else {
                this.distance *= (1 + delta * 0.1);
            }

            if (this.distance > this.maxDistance) {
                this.distance = this.maxDistance;
            }
            if (this.distance < this.minDistance) {
                this.distance = this.minDistance;
            }

            // compute the view matrix with new values
            this.computeViewMatrix();

            if (this.hasCollision()) {
                this.distance = previousDistance;
                this.computeViewMatrix();
            }
            

        };

        /**
         * Check for collision
         * @function hasCollision
         * @memberOf PlanetNavigation#
         * @return {Boolean} collision detected ?
         */
        PlanetNavigation.prototype.hasCollision = function () {
            var eye = [this.inverseViewMatrix[12], this.inverseViewMatrix[13], this.inverseViewMatrix[14]];
            var geoEye = vec3.create();
            this.ctx.getCoordinateSystem().getWorldFrom3D(eye, geoEye);
            var elevation = this.ctx.getElevation(geoEye[0], geoEye[1]);
            return geoEye[2] < elevation + OFFSET_ELEVATION;
        };

        /**
         * Pans the camera
         * @function pan
         * @memberOf PlanetNavigation#
         * @param {int} dx Window delta x
         * @param {int} dy Window delta y
         */
        PlanetNavigation.prototype.pan = function (dx, dy) {
            var previousGeoCenter = vec3.create();
            vec3.set(this.geoCenter, previousGeoCenter);

            // Get geographic frame
            var local2World = mat4.create();
            var coordinateSystem = this.ctx.getCoordinateSystem();
            coordinateSystem.getLocalTransform(this.geoCenter, local2World);
            // Then corresponding vertical axis and north
            var z = vec3.create();
            var previousNorth = vec3.create([0.0, 1.0, 0.0]);
            coordinateSystem.getUpVector(local2World, z);
            //coordinateSystem.getFrontVector( local2World, previousNorth );
            mat4.multiplyVec3(local2World, previousNorth, previousNorth);

            // Then apply local transform
            this.applyLocalRotation(local2World);
            // Retrieve corresponding axes
            var x = vec3.create();
            var y = vec3.create();
            coordinateSystem.getSideVector(local2World, x);
            coordinateSystem.getFrontVector(local2World, y);
            // According to our local configuration, up is y and side is x

            // Compute direction axes
            vec3.cross(z, x, y);
            vec3.cross(y, z, x);
            vec3.normalize(x, x);
            vec3.normalize(y, y);

            //Normalize dx and dy
            dx = dx / this.renderContext.getCanvas().width;
            dy = dy / this.renderContext.getCanvas().height;

            // Move accordingly
            var position = vec3.create();
            coordinateSystem.get3DFromWorld(this.geoCenter, position);
            vec3.scale(x, dx * this.distance, x);
            vec3.scale(y, dy * this.distance, y);
            vec3.subtract(position, x, position);
            vec3.add(position, y, position);

            // Clamp onto sphere
            vec3.normalize(position);
            vec3.scale(position, coordinateSystem.getGeoide().getRadius());

            // Update geographic center
            coordinateSystem.getWorldFrom3D(position, this.geoCenter);

            // Compute new north axis
            var newNorth = vec3.create([0.0, 1.0, 0.0]);
            coordinateSystem.getLocalTransform(this.geoCenter, local2World);
            mat4.multiplyVec3(local2World, newNorth, newNorth);

            // Take care if we traverse the pole, ie the north is inverted
            if (vec3.dot(previousNorth, newNorth) < 0) {
                this.heading = (this.heading + 180.0) % 360.0;
            }

            this.computeViewMatrix();

            // Check for collision with terrain
            if (this.hasCollision()) {
                this.geoCenter = previousGeoCenter;
                this.computeViewMatrix();
            }


        };

        /**
         * Rotates the navigation
         * @function rotate
         * @memberOf PlanetNavigation#
         * @param {int} dx Window delta x
         * @param {int} dy Window delta y
         */
        PlanetNavigation.prototype.rotate = function (dx, dy) {
            var previousHeading = this.heading;
            var previousTilt = this.tilt;

            this.heading += dx * 0.1;
            this.tilt += dy * 0.1;

            this.computeViewMatrix();

            if (this.hasCollision()) {
                this.heading = previousHeading;
                this.tilt = previousTilt;
                this.computeViewMatrix();
            }
        };

        /**
         * Returns the distance in meters.
         * @return {float} the distance in meters from the surface of the globe
         */
        PlanetNavigation.prototype.getDistance = function() {
            return this.distance*this.ctx.getCoordinateSystem().getGeoide().getRealPlanetRadius();
        };

        /**
         * Destroy
         * @function destroy
         * @memberOf PlanetNavigation#
         */
        PlanetNavigation.prototype.destroy = function () {
            AbstractNavigation.prototype.destroy.call(this);
            this.minDistance = null;
            this.maxDistance = null;
            this.geoCenter = null;
            this.heading = null;
            this.tilt = null;
            this.distance = null;
            this.inverseViewMatrix = null;
        };

        /**************************************************************************************************************/

        return PlanetNavigation;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/
/**
 * Mizar owns different types of navigation to control the camera on the WebGL scene.
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
 *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
 *         It is used to view the sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
 *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
 *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
 *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
 *     </tr>
 * </table>
 *
 * The camera is automatically instantiated by the context {@link AbstractContext}, which is created by client.
 * Usually, the navigation is in 3D (AstroNavigation or PlanetNavigation). However, in a particular case, when
 * the client selects a  {@link module:Crs.CoordinateSystemFactory Coordinate Reference System} with a
 * {@link module:Crs.ProjectedCrs projection}, the {@link module:Navigation.FlatNavigation FlatNavigation} is selected.<br/>
 *
 * Then the client can control the navigation by its {@link Navigation interface}
 *
 * <p><p>
 * In addition, the navigation is controlled by the user with the help of devices : keyboard, touch, mouse.
 * When creating the Mizar instance, the user can define a list of supported devices to be able to control the
 * navigation by these devices. By default, the {@link module:Navigation.MouseNavigationHandler MouseNavigationHandler}
 * and {@link module:Navigation.KeyboardNavigationHandler KeyboardNavigationHandler} are set up.
 * When the parameter <i>isMobile</i> is set to true in {@link Mizar} options, then the
 * {@link module:Navigation.TouchNavigationHandler TouchNavigationHandler} is set up
 *
 * <p>
 * @todo Créer un tuto pour montrer les principales méthodes de Navigation et le changement de 3D <--> 2D
 * @module Navigation
 * @implements {Navigation}
 */
define('Navigation/AstroNavigation',['../Utils/Utils', '../Utils/Constants',
        './AbstractNavigation', '../Animation/AnimationFactory',
        '../Utils/Numeric', '../Renderer/Ray', '../Renderer/glMatrix'],
    function (Utils, Constants, AbstractNavigation, AnimationFactory, Numeric, Ray) {

        /**
         * Astro navigation configuration
         * @typedef {AbstractNavigation.configuration} AbstractNavigation.astro_configuration
         * @property {float[]} [initTarget = [0,0]] - initial target of the camera in decimal degree (longitude, latitude)
         * @property {float} [initFov = 0.001] - initial field of view of the camera in decimal degree
         * @property {float} [minFov = 0.001] - Minimal field of view of the camera in decimal degree
         * @property {float} [maxFov = 100] - Maximal field of view of the camera in decimal degree
         * @property {float[]} [up = [0.0, 0.0, 1.0]] - Up vector that defines the north
         */

        /**
         * @name AstroNavigation
         * @class
         * <table border="0">
         *     <tr>
         *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
         *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
         *         It is used to view the sky.</td>
         *     </tr>
         * </table>
         * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
         * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
         * @augments AbstractNavigation
         * @param {SkyContext} ctx - Sky context
         * @param {AbstractNavigation.astro_configuration} options - navigation configuration
         * @constructor
         * @memberOf module:Navigation
         */
        var AstroNavigation = function (ctx, options) {
            AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.AstroNavigation, ctx, options);

            // Default values for fov (in degrees)
            this.minFov = (this.options.minFov) || 0.001;
            this.maxFov = (this.options.maxFov) || 100;

            // Initialize the navigation
            this.center3d = [1.0, 0.0, 0.0];
            this.up = [0.0, 0.0, 1.0];
            _setInitTarget.call(this, this.options.initTarget);
            _setInitFov.call(this, this.options.initFov);
            _setUpVector.call(this, this.options.up);

            // Update the view matrix now
            this.computeViewMatrix();
        };

        /**
         * Defines the Up vector.
         * @param up
         * @private
         */
        function _setUpVector(up) {
            if(up) {
                this.up = up;
            }
        }

        /**
         * Defines the field of view of the camera at initialisation.<br/>
         * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
         * @param {float|undefined} initFov
         * @private
         */
        function _setInitFov(initFov) {
            if (initFov) {
                if (this.minFov > initFov) {
                    this.minFov = initFov;
                } else if (this.maxFov < initFov) {
                    this.maxFov = initFov;
                }
                this.renderContext.setFov(initFov);
                this._clampFov();
            }
        }

        /**
         * Defines the position where the camera looks at.
         * @param {float[]|undefined} initTarget
         * @private
         */
        function _setInitTarget(initTarget) {
            if (initTarget) {
                this.ctx.getCoordinateSystem().get3DFromWorld(initTarget, this.center3d);
            }
        }


        /**************************************************************************************************************/

        Utils.inherits(AbstractNavigation, AstroNavigation);

        /**************************************************************************************************************/


        /**
         * ZoomTo a position
         * @function zoomTo
         * @param {float[]} geoPos - target of the camera
         * @param {Object} options - options
         * @param {float} [options.fov = 2.0] - field of view in degree
         * @param {int} [options.duration = 2000] - duration of the animation in milliseconds
         * @param {navigationCallback} [options.callback] - Called at the end of navigation
         * @memberOf AstroNavigation#
         */
        AstroNavigation.prototype.zoomTo = function (geoPos, options) {
            var navigation = this;

            // default values
            var destFov = (options && options.fov) ? options.fov : 2.0;
            var duration = (options && options.duration) ? options.duration : 2000;

            // Create a single animation to animate center3d and fov
            var geoStart = [];
            var middleFov = 25.0;	// arbitrary middle fov value which determines if the animation needs two segments

            this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geoStart);
            var startValue = [geoStart[0], geoStart[1], this.renderContext.getFov()];
            var endValue = [geoPos[0], geoPos[1], destFov];

            // Compute the shortest path if needed
            //TODO : not sure it is work for all cases, better to use scalar product
            if (Math.abs(geoPos[0] - geoStart[0]) > 180.0) {
                if (geoStart[0] < geoPos[0]) {
                    startValue[0] += 360;
                } else {
                    endValue[0] += 360;
                }
            }
            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": duration,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.center3d[0] = position3d[0];
                        navigation.center3d[1] = position3d[1];
                        navigation.center3d[2] = position3d[2];
                        navigation.ctx.getRenderContext().setFov(value[2]);
                        navigation.computeViewMatrix();
                    }
                });

            // TODO : maybe improve it ?
            // End point which is out of frustum invokes two steps animation, one step otherwise
            var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
            if (middleFov > this.renderContext.getFov() && this.renderContext.getWorldFrustum().containsSphere(end3DValue, 0.005) < 0) {
                // Two steps animation, 'rising' & 'falling'

                // Compute the middle value
                var midValue = [
                    startValue[0] * 0.5 + endValue[0] * 0.5,
                    startValue[1] * 0.5 + endValue[1] * 0.5,
                    middleFov
                ];

                // Add two segments
                animation.addSegment(
                    0.0, startValue,
                    0.5, midValue,
                    function (t, a, b) {
                        var pt = Numeric.easeInQuad(t);
                        var dt = Numeric.easeOutQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // fov
                    });

                animation.addSegment(
                    0.5, midValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // fov
                    });
            }
            else {
                // One step animation, 'falling' only

                // Add only one segment
                animation.addSegment(
                    0.0, startValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])];  // fov
                    });
            }

            animation.onstop = function () {
                if (options && options.callback) {
                    options.callback();
                }
                navigation.zoomToAnimation = null;
            };

            this.ctx.addAnimation(animation);
            animation.start();
            this.zoomToAnimation = animation;
        };

        /**
         * Moves to a 3d position
         * @function moveTo
         * @memberof AstroNavigation#
         * @param {float[]} geoPos - Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
         * @param {int} [duration = 5000] - Duration of animation in milliseconds
         * @param {Function} [callback] - Callback on the end of animation
         */
        AstroNavigation.prototype.moveTo = function (geoPos, duration, callback) {
            var navigation = this;

            var durationTime = duration || 5000;

            // Create a single animation to animate center3d
            var geoStart = [];
            this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geoStart);

            var startValue = [geoStart[0], geoStart[1]];
            var endValue = [geoPos[0], geoPos[1]];

            // Compute the shortest path if needed
            if (Math.abs(geoPos[0] - geoStart[0]) > 180.0) {
                if (geoStart[0] < geoPos[0]) {
                    startValue[0] += 360;
                } else {
                    endValue[0] += 360;
                }
            }

            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": durationTime,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.center3d[0] = position3d[0];
                        navigation.center3d[1] = position3d[1];
                        navigation.center3d[2] = position3d[2];
                        navigation.computeViewMatrix();
                    }
                });

            animation.addSegment(
                0.0, startValue,
                1.0, endValue,
                function (t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                        Numeric.lerp(pt, a[1], b[1])   // geoPos.lat
                    ];
                }
            );

            animation.onstop = function () {
                if (callback) {
                    callback();
                }
            };

            this.ctx.addAnimation(animation);
            animation.start();
        };

        /**
         * Moves up vector.
         * @function moveUpTo
         * @memberOf AstroNavigation#
         * @param {float[]} vec Vector
         * @param {int} [duration = 1000] - Duration of animation in milliseconds
         */
        AstroNavigation.prototype.moveUpTo = function (vec, duration) {
            // Create a single animation to animate up
            var startValue = [];
            var endValue = [];
            this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, startValue);
            this.ctx.getCoordinateSystem().getWorldFrom3D(vec, endValue);
            var durationTime = duration || 1000;

            var navigation = this;
            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": durationTime,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.up[0] = position3d[0];
                        navigation.up[1] = position3d[1];
                        navigation.up[2] = position3d[2];
                        navigation.computeViewMatrix();
                    }
                });

            animation.addSegment(
                0.0, startValue,
                1.0, endValue,
                function (t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                        Numeric.lerp(pt, a[1], b[1])   // geoPos.lat
                    ];
                }
            );

            this.ctx.addAnimation(animation);
            animation.start();
        };

        /**
         * Computes the view matrix
         * @function computeViewMatrix
         * @memberOf AstroNavigation#
         */
        AstroNavigation.prototype.computeViewMatrix = function () {
            vec3.normalize(this.center3d);

            var vm = this.renderContext.getViewMatrix();

            mat4.lookAt([0.0, 0.0, 0.0], this.center3d, this.up, vm);
            // mat4.inverse( vm );
            // mat4.rotate(vm, this.heading * Math.PI/180., [1., 0., 0.])
            // mat4.inverse( vm );

            this.up = [vm[1], vm[5], vm[9]];
            this.ctx.publish("modifiedNavigation");
            this.renderContext.requestFrame();
        };

        /**
         * Event handler for mouse wheel
         * @function zoom
         * @memberof AstroNavigation#
         * @param {float} delta Delta zoom
         * @param {float} scale Scale
         */
        AstroNavigation.prototype.zoom = function (delta, scale) {

            // TODO : improve zoom, using scale or delta ? We should use scale always
            if (scale) {
                this.renderContext.setFov(this.renderContext.getFov() * 1 / scale);
            }
            else {
                // Arbitrary value for smooth zooming
                this.renderContext.setFov(this.renderContext.getFov() * (1 + delta * 0.1));
            }

            this._clampFov();
            this.computeViewMatrix();
        };

        /**
         * Pan the navigation by computing the difference between 3D centers
         * @function pan
         * @memberOf AstroNavigation#
         * @param {int} dx Window delta x
         * @param {int} dy Window delta y
         */
        AstroNavigation.prototype.pan = function (dx, dy) {
            var x = this.renderContext.getCanvas().width / 2.0;
            var y = this.renderContext.getCanvas().height / 2.0;
            var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
            this.center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.ctx.getCoordinateSystem().getGeoide().getRadius()));
            this.computeViewMatrix();
        };

        /**
         * Rotates the navigation
         * @function rotate
         * @memberOf AstroNavigation#
         * @param {float} dx Window delta x
         * @param {float} dy Window delta y
         */
        AstroNavigation.prototype.rotate = function (dx, dy) {
            // constant tiny angle
            var angle = dx * 0.1 * Math.PI / 180.0;

            var rot = quat4.fromAngleAxis(angle, this.center3d);
            quat4.multiplyVec3(rot, this.up);

            this.computeViewMatrix();
        };

        /**
         * Clamping of fov
         * @function _clampFov
         * @memberOf AstroNavigation#
         * @private
         */
        AstroNavigation.prototype._clampFov = function () {
            if (this.renderContext.getFov() > this.maxFov) {
                this.renderContext.setFov(this.maxFov);
            }
            if (this.renderContext.getFov() < this.minFov) {
                this.renderContext.setFov(this.minFov);
            }
        };

        /**
         * Destroy
         * @function destroy
         * @memberOf AstroNavigation#
         */
        AstroNavigation.prototype.destroy = function () {
            AbstractNavigation.prototype.destroy.call(this);
            this.minFov = null;
            this.maxFov = null;
            this.center3d = null;
            this.up = null;
        };

        /**************************************************************************************************************/

        return AstroNavigation;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/FlatNavigation',['../Utils/Utils', '../Utils/Constants', './AbstractNavigation', '../Animation/AnimationFactory', '../Utils/Numeric', '../Renderer/Ray', '../Renderer/glMatrix'],
    function (Utils, Constants, AbstractNavigation, AnimationFactory, Numeric, Ray) {

        /**
         * Flat navigation configuration
         * @typedef {AbstractNavigation.configuration} AbstractNavigation.flat_configuration
         * @property {float[]} [initTarget = [0, 0, 5.0 * RADIUS_PLANET]] - Target in decimal degree (longitude, latitude, distance in meter)
         * at initialisation. distance in meter is optional.
         * @property {float} [minDistance = 60000] - The minimum distance in meters from the surface of the globe
         * or options.initTarget[2] when this one is inferior to options.minDistance
         * @property {float} [maxDistance = 5.0 * RADIUS_PLANET] - The maximum distance in meters or
         * options.initTarget[2] when this one is superior to options.maxDistance
         */
        
        /**
         * @name FlatNavigation
         * @class
         * <table border="0">
         *     <tr>
         *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
         *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
         *     </tr>
         * </table>         
         * @augments AbstractNavigation
         * @param {PlanetContext} ctx - Planet context
         * @param {AbstractNavigation.flat_configuration} options - Flat navigation configuration
         * @constructor
         * @memberOf module:Navigation
         */
        var FlatNavigation = function (ctx, options) {

            AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.FlatNavigation, ctx, options);

            // Default values for min and max distance (in meter)
            this.minDistance = (this.options.minDistance) || 60000;
            this.maxDistance = (this.options.maxDistance) || 5.0 * this.ctx.getCoordinateSystem().getGeoide().getRadius() / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();

            // Scale min and max distance from meter to internal ratio
            this.minDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
            this.maxDistance *= this.ctx.getCoordinateSystem().getGeoide().getHeightScale();

            // Initialize the navigation
            this.center = [0.0, 0.0, 0.0];
            this.distance = this.maxDistance;
            this.up = [0.0, 1.0, 0.0];
            _setInitTarget.call(this, this.options.initTarget);

            this.computeViewMatrix();

        };
        /**
         * Defines the position where the camera looks at and the distance of the camera regarding to the planet's surface
         * @param {float[]|undefined} initTarget as [longitude, latitude[, distance in meter]]
         * @private
         */
        function _setInitTarget(initTarget) {
            if (initTarget) {
                var pos = this.ctx.getCoordinateSystem().get3DFromWorld(initTarget);
                this.center[0] = pos[0];
                this.center[1] = pos[1];
                this.distance = (initTarget.length === 3) ? initTarget[2] * this.ctx.getCoordinateSystem().getGeoide().getHeightScale() : this.distance;
                if(this.distance < this.minDistance) {
                    this.minDistance = this.distance;
                }
                if(this.distance > this.maxDistance) {
                    this.maxDistance = this.distance;
                }
            }
        }


        /**************************************************************************************************************/

        Utils.inherits(AbstractNavigation, FlatNavigation);

        /**************************************************************************************************************/

        /**
         * Saves the current navigation state.
         * @function save
         * @memberOf FlatNavigation#
         * @return {{center: *, distance: *, up: *}} a JS object containing the navigation state
         */
        FlatNavigation.prototype.save = function () {
            return {
                center: this.center,
                distance: this.distance,
                up: this.up
            };
        };

        /**
         * Restores the navigation state.
         * @function save
         * @memberOf FlatNavigation#
         * @param {Object} state a JS object containing the navigation state
         * @param {float[]} state.center - Center of the camera's field of view in decimal degree as [longitude, latitude]
         * @param {int} state.distance - Distance in meters from the surface of the globe to the camera
         */
        FlatNavigation.prototype.restore = function (state) {
            this.center = state.center;
            this.distance = state.distance;
            this.up = state.up;
            this.computeViewMatrix();
        };
        
        /**
         * Computes the view matrix
         * @function computeViewMatrix
         * @memberOf FlatNavigation#
         */
        FlatNavigation.prototype.computeViewMatrix = function () {
            var eye = [];
            //vec3.normalize(this.geoCenter);
            var vm = this.renderContext.getViewMatrix();

            eye = [this.center[0], this.center[1], this.distance];

            mat4.lookAt(eye, this.center, this.up, vm);
            this.up = [vm[1], vm[5], vm[9]];
            this.ctx.publish("modifiedNavigation");
            this.renderContext.requestFrame();
        };
        
        /**
         * Zooms to a geographic position
         * @function zoomTo
         * @memberOf FlatNavigation#
         * @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
         * @param {Object} options - options
         * @param {int} [options.distance] - Final zooming distance in meters. By default, the distance does not change
         * @param {int} [options.duration = 5000] -  Duration of animation in milliseconds
         * @param {navigationCallback} options.callback - Callback at the end of animation
         */
        FlatNavigation.prototype.zoomTo = function (geoPos, options) {
            var navigation = this;

            var destDistance = (options && options.distance) ? options.distance : this.distance / this.ctx.getCoordinateSystem().getGeoide().getHeightScale();
            var duration = (options && options.duration) ? options.duration : 5000;

            var pos = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);

            // Create a single animation to animate geoCenter, distance and tilt
            var startValue = [this.center[0], this.center[1], this.distance];
            var endValue = [pos[0], pos[1], destDistance * this.ctx.getCoordinateSystem().getGeoide().getHeightScale()];
            this.zoomToAnimation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": duration,
                    "valueSetter": function (value) {
                        navigation.center[0] = value[0];
                        navigation.center[1] = value[1];
                        navigation.distance = value[2];
                        navigation.computeViewMatrix();
                    }
                });

            // Compute a max altitude for the animation
            var worldStart = this.center;
            var worldEnd = pos;
            var vec = vec3.subtract(worldStart, worldEnd);
            var len = vec3.length(vec);
            var canvas = this.ctx.getRenderContext().getCanvas();
            var minFov = Math.min(Numeric.toRadian(45.0), Numeric.toRadian(45.0 * canvas.width / canvas.height));
            var maxAltitude = 1.1 * ((len / 2.0) / Math.tan(minFov / 2.0));
            if (maxAltitude > this.distance) {
                // Compute the middle value
                var midValue = [startValue[0] * 0.5 + endValue[0] * 0.5,
                    startValue[1] * 0.5 + endValue[1] * 0.5,
                    maxAltitude];

                // Add two segments
                this.zoomToAnimation.addSegment(
                    0.0, startValue,
                    0.5, midValue,
                    function (t, a, b) {
                        var pt = Numeric.easeInQuad(t);
                        var dt = Numeric.easeOutQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // distance
                    });

                this.zoomToAnimation.addSegment(
                    0.5, midValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // distance
                    });
            }
            else {
                // Add only one segments
                this.zoomToAnimation.addSegment(
                    0.0, startValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])];  // distance
                    });
            }

            var self = this;
            this.zoomToAnimation.onstop = function () {
                if (options && options.callback) {
                    options.callback();
                }
                self.zoomToAnimation = null;
            };

            this.ctx.addAnimation(this.zoomToAnimation);
            this.zoomToAnimation.start();
        };

        /**
         * Zoom to the current observed location
         * @function zoom
         * @memberOf FlatNavigation#
         * @param {float} delta Delta zoom
         * @param {float} scale Scale
         */
        FlatNavigation.prototype.zoom = function (delta, scale) {
            var previousDistance = this.distance;

            // TODO : improve zoom, using scale or delta ? We should use scale always
            if (scale) {
                this.distance *= scale;
            } else {
                this.distance *= (1 + delta * 0.1);
            }

            if (this.distance > this.maxDistance) {
                this.distance = previousDistance;
            }
            if (this.distance < this.minDistance) {
                this.distance = previousDistance;
            }
            
            //TODO : add the collision algorithm because of the elevation

            this.computeViewMatrix();
        };

        /**
         * Pans the camera
         * @function pan
         * @memberOf FlatNavigation#
         * @param {int} dx Window delta x
         * @param {int} dy Window delta y
         */
        FlatNavigation.prototype.pan = function (dx, dy) {
            var x = this.renderContext.getCanvas().width / 2.0;
            var y = this.renderContext.getCanvas().height / 2.0;

            // Get the most-left point
            var ptLeft = this.ctx.getLonLatFromPixel(0, y);
            if ((ptLeft === null) && (dx > 0)) {
                dx = 0;
            }

            // Get the most-right point
            var ptRight = this.ctx.getLonLatFromPixel(this.renderContext.getCanvas().width, y);
            if ((ptRight === null) && (dx < 0)) {
                dx = 0;
            }

            // Get the most-top point
            var ptTop = this.ctx.getLonLatFromPixel(x, 0);
            if ((ptTop === null) && (dy > 0)) {
                dy = 0;
            }

            // Get the most-bottom point
            var ptBottom = this.ctx.getLonLatFromPixel(x, this.renderContext.getCanvas().height);
            if ((ptBottom === null) && (dy < 0)) {
                dy = 0;
            }

            if ((dx === 0) && (dy === 0)) {
                return;
            }

            var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);

            this.center = ray.computePoint(ray.planeIntersect([0, 0, 0], [0, 0, 1]));

            this.computeViewMatrix();
        };

        
        /**
         * Rotates the camera
         * @function rotate
         * @memberOf FlatNavigation#
         * @param {int} dx Window delta x
         * @param {int} dy Window delta y
         */
        FlatNavigation.prototype.rotate = function (dx, dy) {
            // Constant tiny angle
            var angle = -dx * 0.1 * Math.PI / 180.0;

            var rot = quat4.fromAngleAxis(angle, [0, 0, 1]);
            quat4.multiplyVec3(rot, this.up);

            this.computeViewMatrix();
        };

        /**
         * Returns the distance in meters.
         * @return {float} the distance in meters from the surface of the globe
         */
        FlatNavigation.prototype.getDistance = function() {
            return this.distance*this.ctx.getCoordinateSystem().getGeoide().getRealPlanetRadius();
        };

        /**
         * Destroy
         * @function destroy
         * @memberOf FlatNavigation#
         */
        FlatNavigation.prototype.destroy = function () {
            AbstractNavigation.prototype.destroy.call(this);
            this.up = null;
            this.minDistance = null;
            this.maxDistance = null;
            this.center = null;
            this.distance = null;
        };


        /**************************************************************************************************************/

        return FlatNavigation;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Navigation/GroundNavigation',['../Utils/Utils', '../Utils/Constants',
        './AbstractNavigation', '../Animation/SegmentedAnimation','../Animation/AnimationFactory',
        '../Utils/Numeric', '../Renderer/Ray', '../Renderer/glMatrix'],
    function (Utils, Constants, AbstractNavigation, SegmentedAnimation, AnimationFactory, Numeric, Ray) {
        /**************************************************************************************************************/

        /**
         * @name GroundNavigation
         * @class
         * When an <i>initFov</i> is provided out the range [<i>minFov</i>, <i>maxFov</i>], the range
         * [<i>minFov</i>, <i>maxFov</i>] is updated with the value of <i>initFov</i>.
         * @augments AstroNavigation
         * @param {GroundContext} ctx - ground context
         * @param {AbstractNavigation.astro_configuration} options - navigation configuration
         * @constructor
         * @memberOf module:Navigation
         */
        var GroundNavigation = function (ctx, options) {
            AbstractNavigation.prototype.constructor.call(this, Constants.NAVIGATION.GroundNavigation, ctx, options);

            // Default values for fov (in degrees)
            this.minFov = (this.options.minFov) || 1;
            this.maxFov = (this.options.maxFov) || 70;

            // Initialize the navigation
            this.center3d = [1.0, 0.0, 0.0];
            this.up = [0.0, 0.0, 1.0];
            _setInitTarget.call(this, this.options.initTarget);
            _setInitFov.call(this, this.options.initFov);
            _setUpVector.call(this, this.options.up);

            // Update the view matrix now
            this.computeViewMatrix();
        };

        /**
         * Defines the position where the camera looks at.
         * @param {float[]|undefined} initTarget
         * @private
         */
        function _setInitTarget(initTarget) {
            if (initTarget) {
                this.ctx.getCoordinateSystem().get3DFromWorld(initTarget, this.center3d);
            }
        }

        /**
         * Defines the field of view of the camera at initialisation.<br/>
         * When the initFov outside the range [minFov, maxFov], the range is extented to include the initFov
         * @param {float|undefined} initFov
         * @private
         */
        function _setInitFov(initFov) {
            if (initFov) {
                if (this.minFov > initFov) {
                    this.minFov = initFov;
                } else if (this.maxFov < initFov) {
                    this.maxFov = initFov;
                }
                this.renderContext.setFov(initFov);
                this._clampFov();
            }
        }

        /**
         * Defines the Up vector.
         * @param up
         * @private
         */
        function _setUpVector(up) {
            if (up) {
                this.up = up;
            }
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractNavigation, GroundNavigation);

        /**************************************************************************************************************/

        /**
         Zoom to a 3d position
         @function zoomTo
         @param {float[]} geoPos Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
         @param {int} fov Final zooming fov in degrees
         @param {int} duration Duration of animation in milliseconds
         @param {Function} callback Callback on the end of animation
         @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.zoomTo = function (geoPos, options) {
            var navigation = this;

            // default values
            var destFov = (options && options.fov) ? options.fov : 2.0;
            var duration = (options && options.duration) ? options.duration : 2000;

            // Create a single animation to animate center3d and fov
            var geoStart = [];
            var middleFov = 25.0;	// arbitrary middle fov value which determines if the animation needs two segments

            this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geoStart);
            var startValue = [geoStart[0], geoStart[1], this.renderContext.getFov()];
            var endValue = [geoPos[0], geoPos[1], destFov];

            // Compute the shortest path if needed
            //TODO : not sure it is work for all cases, better to use scalar product
            if (Math.abs(geoPos[0] - geoStart[0]) > 180.0) {
                if (geoStart[0] < geoPos[0]) {
                    startValue[0] += 360;
                } else {
                    endValue[0] += 360;
                }
            }
            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": duration,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.center3d[0] = position3d[0];
                        navigation.center3d[1] = position3d[1];
                        navigation.center3d[2] = position3d[2];
                        navigation.ctx.getRenderContext().setFov(value[2]);
                        navigation.computeViewMatrix();
                    }
                });

            // TODO : maybe improve it ?
            // End point which is out of frustum invokes two steps animation, one step otherwise
            var end3DValue = this.ctx.getCoordinateSystem().get3DFromWorld(geoPos);
            if (middleFov > this.renderContext.getFov() && this.renderContext.getWorldFrustum().containsSphere(end3DValue, 0.005) < 0) {
                // Two steps animation, 'rising' & 'falling'

                // Compute the middle value
                var midValue = [
                    startValue[0] * 0.5 + endValue[0] * 0.5,
                    startValue[1] * 0.5 + endValue[1] * 0.5,
                    middleFov
                ];

                // Add two segments
                animation.addSegment(
                    0.0, startValue,
                    0.5, midValue,
                    function (t, a, b) {
                        var pt = Numeric.easeInQuad(t);
                        var dt = Numeric.easeOutQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // fov
                    });

                animation.addSegment(
                    0.5, midValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]), // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]), // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])]; // fov
                    });
            }
            else {
                // One step animation, 'falling' only

                // Add only one segment
                animation.addSegment(
                    0.0, startValue,
                    1.0, endValue,
                    function (t, a, b) {
                        var pt = Numeric.easeOutQuad(t);
                        var dt = Numeric.easeInQuad(t);
                        return [Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                            Numeric.lerp(pt, a[1], b[1]),  // geoPos.lat
                            Numeric.lerp(dt, a[2], b[2])];  // fov
                    });
            }

            animation.onstop = function () {
                if (options && options.callback) {
                    options.callback();
                }
                navigation.zoomToAnimation = null;
            };

            this.ctx.addAnimation(animation);
            animation.start();
            this.zoomToAnimation = animation;
        };

        /**************************************************************************************************************/

        /**
         * Moves to a 3d position
         * @function moveTo
         * @memberOf GroundNavigation#
         * @param {float[]} geoPos - Array of two floats corresponding to final Longitude and Latitude(in this order) to zoom
         * @param {int} [duration = 5000] - Duration of animation in milliseconds
         * @param {Function} [callback] - Callback on the end of animation
         */
        GroundNavigation.prototype.moveTo = function (geoPos, duration, callback) {
            var navigation = this;

            var durationTime = duration || 5000;

            // Create a single animation to animate center3d
            var geoStart = [];
            this.ctx.getCoordinateSystem().getWorldFrom3D(this.center3d, geoStart);

            var startValue = [geoStart[0], geoStart[1]];
            var endValue = [geoPos[0], geoPos[1]];

            // Compute the shortest path if needed
            if (Math.abs(geoPos[0] - geoStart[0]) > 180.0) {
                if (geoStart[0] < geoPos[0]) {
                    startValue[0] += 360;
                } else {
                    endValue[0] += 360;
                }
            }

            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": durationTime,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.center3d[0] = position3d[0];
                        navigation.center3d[1] = position3d[1];
                        navigation.center3d[2] = position3d[2];
                        navigation.computeViewMatrix();
                    }
                });

            animation.addSegment(
                0.0, startValue,
                1.0, endValue,
                function (t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                        Numeric.lerp(pt, a[1], b[1])   // geoPos.lat
                    ];
                }
            );

            animation.onstop = function () {
                if (callback) {
                    callback();
                }
            };

            this.ctx.addAnimation(animation);
            animation.start();
        };

        /**************************************************************************************************************/

        /**
         *    Move up vector
         *    @function moveUpTo
         *    @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.moveUpTo = function (vec, duration) {
            // Create a single animation to animate up
            var startValue = [];
            var endValue = [];
            this.ctx.getCoordinateSystem().getWorldFrom3D(this.up, startValue);
            this.ctx.getCoordinateSystem().getWorldFrom3D(vec, endValue);
            var durationTime = duration || 1000;

            var navigation = this;
            var animation = AnimationFactory.create(
                Constants.ANIMATION.Segmented,
                {
                    "duration": durationTime,
                    "valueSetter": function (value) {
                        var position3d = navigation.ctx.getCoordinateSystem().get3DFromWorld([value[0], value[1]]);
                        navigation.up[0] = position3d[0];
                        navigation.up[1] = position3d[1];
                        navigation.up[2] = position3d[2];
                        navigation.computeViewMatrix();
                    }
                });

            animation.addSegment(
                0.0, startValue,
                1.0, endValue,
                function (t, a, b) {
                    var pt = Numeric.easeOutQuad(t);
                    return [
                        Numeric.lerp(pt, a[0], b[0]),  // geoPos.long
                        Numeric.lerp(pt, a[1], b[1])   // geoPos.lat
                    ];
                }
            );

            this.ctx.addAnimation(animation);
            animation.start();
        };

        /**************************************************************************************************************/

        /**
         Compute the view matrix
         @function computeViewMatrix
         @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.computeViewMatrix = function () {
            var eye = [];
            vec3.normalize(this.center3d);

            var vm = this.renderContext.viewMatrix;

            mat4.lookAt([0., 0., 0.], this.center3d, this.up, vm);
            // mat4.inverse( vm );
            // mat4.rotate(vm, this.heading * Math.PI/180., [1., 0., 0.])
            // mat4.inverse( vm );

            this.up = [0, 0, vm[9]];
            this.ctx.publish("modifiedNavigation");
            this.renderContext.requestFrame();
        };

        /**************************************************************************************************************/

        /**
         Event handler for mouse wheel
         @function zoom
         @param delta Delta zoom
         @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.zoom = function (delta, scale) {

            // TODO : improve zoom, using scale or delta ? We should use scale always
            if (scale) {
                this.renderContext.setFov(this.renderContext.getFov() * 1 / scale);
            }
            else {
                // Arbitrary value for smooth zooming
                this.renderContext.setFov(this.renderContext.getFov() * (1 + delta * 0.1));
            }

            this._clampFov();
            this.computeViewMatrix();
        };

        /**************************************************************************************************************/

        /**
         Pan the navigation by computing the difference between 3D centers
         @function pan
         @param dx Window delta x
         @param dy Window delta y
         @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.pan = function (dx, dy) {
            var x = this.renderContext.canvas.width / 2.;
            var y = this.renderContext.canvas.height / 2.;
            var ray = Ray.createFromPixel(this.renderContext, x - dx, y - dy);
            this.center3d = ray.computePoint(ray.sphereIntersect([0, 0, 0], this.ctx.getCoordinateSystem().getGeoide().getRadius()));
            this.computeViewMatrix();
        };

        /**************************************************************************************************************/

        /**
         Rotate the navigation
         @function rotate
         @param dx Window delta x
         @param dy Window delta y
         @memberOf GroundNavigation#
         */
        GroundNavigation.prototype.rotate = function (dx, dy) {
            // constant tiny angle
            var angle = dx * 0.1 * Math.PI / 180.;

            var rot = quat4.fromAngleAxis(angle, this.center3d);
            quat4.multiplyVec3(rot, this.up);
            this.computeViewMatrix();
        };

        /**************************************************************************************************************/

        /**
         *    Clamping of fov
         */
        GroundNavigation.prototype._clampFov = function () {
            if (this.renderContext.getFov() > this.maxFov) {
                this.renderContext.setFov(this.maxFov);
            }
            if (this.renderContext.getFov() < this.minFov) {
                this.renderContext.setFov(this.minFov);
            }
        };

        /**************************************************************************************************************/

        return GroundNavigation;

    });
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name NavigationFactory
 * @class
 * Factory to control the camera.
 * @memberOf module:Navigation
 */
define('Navigation/NavigationFactory',[ "./PlanetNavigation","./AstroNavigation","./FlatNavigation", "./GroundNavigation", "../Utils/Constants"],
    function (PlanetNavigation,AstroNavigation,FlatNavigation, GroundNavigation, Constants) {

        return {
            /**
             * Mizar owns different types of navigation to control the camera on the WebGL scene.
             * This class allows to create a navigation based on its type (e.g Astro, Flat, Sky).
             * <table border="1">
             *     <tr>
             *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
             *         <td>{@link module:Navigation.AstroNavigation AstroNavigation}</td>
             *         <td>Provides a camera located at the center of the scene. The camera is inside the globe.
             *         It is used to view the sky</td>
             *     </tr>
             *     <tr>
             *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
             *         <td>{@link module:Navigation.PlanetNavigation PlanetNavigation}</td>
             *         <td>Provides a camera, located outside the globe and looking at the globe. It is used to view a planet</td>
             *     </tr>
             *     <tr>
             *         <td><img src="../doc/images/nav_flat.png" width="200px"/></td>
             *         <td>{@link module:Navigation.FlatNavigation FlatNavigation}</td>
             *         <td>Provides a camera to navigate on a 2D map - Only available in a Planet context</td>
             *     </tr>
             * </table>
             * @param {NAVIGATION} type - the type of navigation
             * @param {AbstractContext} ctx - The context where the camera look at
             * @param {AbstractNavigation.astro_configuration|AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} options - see the navigations.
             * @return {Navigation} navigation
             * @alias module:Navigation.NavigationFactory.create
             * @see {@link module:Navigation.PlanetNavigation PlanetNavigation} - Control the camera and turn around the globe, wich is located
             * at the center of the webGL scene.
             * @see {@link module:Navigation.AstroNavigation AstroNavigation} - Control the camera at the center of the scene. The camera is inside the globe
             * @see {@link module:Navigation.FlatNavigation FlatNavigation} - Control the camera. The camera look at the 2D projection
             * @see {@link module:Navigation.GroundNavigation GroundNavigation} - Control the camera. The camera look at the 3D projection of the ground
             * @throws {RangeError} Type not valid - a valid type is included in the list {@link NAVIGATION}
             */
            create : function(type, ctx, options) {
                var obj;
                switch(type) {
                    case Constants.NAVIGATION.AstroNavigation:
                        obj = new AstroNavigation(ctx,options);
                        break;
                    case Constants.NAVIGATION.PlanetNavigation:
                        obj = new PlanetNavigation(ctx, options);
                        break;
                    case Constants.NAVIGATION.FlatNavigation:
                        obj = new FlatNavigation(ctx,options);
                        break;
                    case Constants.NAVIGATION.GroundNavigation:
                        obj = new GroundNavigation(ctx,options);
                        break;
                    default:
                        throw new RangeError("The type "+type+" is not allowed, A valid type is included in the list NAVIGATION", "NavigationFactory.js");
                }
                return obj;
            }

    }});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * Mizar is able to handle different types of context.
 * <p>
 * A context is a concept that brings together :
 * <ul>
 *     <li>a webGL {@link AbstractGlobe globe}</li>
 *     <li>a {@link AbstractCrs coordinate reference system}</li>
 *     <li>a {@link AbstractNavigation navigation}</li>
 * </ul>
 * <table border="1">
 *     <tr>
 *         <td><img src="../doc/images/nav_astro.png" width="200px"/></td>
 *         <td>{@link module:Context.SkyContext SkyContext}</td>
 *         <td>A context representing a sky</td>
 *     </tr>
 *     <tr>
 *         <td><img src="../doc/images/nav_planet.png" width="200px"/></td>
 *         <td>{@link module:Context.PlanetContext PlanetContext}</td>
 *         <td>A context representing a planet</td>
 *     </tr>
 *     <tr>
 *         <td></td>
 *         <td>{@link module:Context.GroundContext GroundContext}</td>
 *         <td>A context representing a planet's ground</td>
 *     </tr>
 * </table>
 *
 * The context is automatically instantiated by the method createContext from {@link Mizar}.
 * <br/>
 * In addition to the classes, a {@link module:Context.ContextFactory factory} and a {@link ContextManager context manager}
 * are availables to help for creating context. Once the context is created, the client can handle it by the use of its
 * {@link Context interface}.
 *
 * @module Context
 * @implements {Context}
 */
define('Context/PlanetContext',["jquery", "underscore-min", "../Utils/Utils", "./AbstractContext", "../Utils/Constants",
        "../Globe/GlobeFactory", "../Navigation/NavigationFactory", "../Services/ServiceFactory"],
    function ($, _, Utils, AbstractContext, Constants,
              GlobeFactory, NavigationFactory, ServiceFactory) {

        /**
         * Planet context configuration
         * @typedef {Object} AbstractContext.planetContext
         * @property {float} [tileErrorTreshold=3]
         * @property {float} [continuousRendering=false]
         * @property {RenderContext} [renderContext] - Context rendering
         * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
         * @property {AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigation - navigation configuration
         */

        /**
         * @name PlanetContext
         * @class
         * Virtual globe where the camera is outside the globe.
         * When an error happens at the initialisation, a message is displayed
         * @augments AbstractContext
         * @param {Mizar.configuration} mizarConfiguration - mizar configuration
         * @param {AbstractContext.planetContext} options - planet context configuration
         * @constructor
         * @memberOf module:Context
         */
        var PlanetContext = function (mizarConfiguration, options) {
            AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Planet, options);
            var self = this;

            this.components = {
                "posTrackerInfo": true,
                "posTracker": true,
                "elevTracker": true,
                "compassDiv": false
            };

            var planetOptions = _createPlanetConfiguration.call(this, options);


            // Initialize planet
            try {
                this.globe = GlobeFactory.create(Constants.GLOBE.Planet, planetOptions);
                this.initGlobeEvents(this.globe);

                this.navigation = _createNavigation.call(this, this.getCoordinateSystem().isFlat(), options.navigation);

                ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);
            }
            catch (err) {
                this._showUpError(this, err);
            }

        };

        /**
         * Planet configuration data model
         * @typedef {Object} AbstractGlobe.dm_planet
         * @property {Object} canvas - canvas object
         * @property {int} tileErrorTreshold - tile error treshold
         * @property {boolean} continuousRendering - continuous rendering
         * @property {renderContext|null} renderContext - Rendering context
         * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
         * @property {string} shadersPath = "../../shaders/" - Shaders location
         * @property {boolean} lighting = false - Lighting
         * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
         * @property {int} minFar = 0
         * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
         * @property {boolean} renderTileWithoutTexture = true
         * @property {function} publishEvent - Callback
         */

        /**
         * Create the navigation according to the isFlat parameter.
         * @param {boolean} isFlat - The globe is projected or in 3D
         * @param {{AbstractNavigation.planet_configuration|AbstractNavigation.flat_configuration} navigationOpts - Options for navigation
         * @returns {FlatNavigation|PlanetNavigation} navigation
         * @private
         */
        function _createNavigation(isFlat, navigationOpts) {
            var navigationType;
            if (isFlat) {
                navigationType = Constants.NAVIGATION.FlatNavigation;
            } else {
                navigationType = Constants.NAVIGATION.PlanetNavigation;
            }

            return  NavigationFactory.create(navigationType, this, navigationOpts);
        }

        /**
         * Creates planet configuration
         * @param {Object} options
         * @param {int} [options.tileErrorTreshold = 3] - Tile error treshold
         * @param {boolean} [options.continuousRendering = false] - continuous rendering
         * @param {renderContext} [options.renderContext] - Rendering context
         * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet
         * @returns {AbstractGlobe.dm_planet} Planet data model.
         * @private
         */
        function _createPlanetConfiguration(options) {
            var self = this;
            return {
                tileErrorTreshold: options.tileErrorTreshold || 3,
                continuousRendering: options.continuousRendering || false,
                renderContext: options.renderContext,
                canvas: this.canvas,
                coordinateSystem: options.coordinateSystem,
                shadersPath: this.mizarConfiguration['mizarAPIUrl']+'shaders/',
                lighting: false,
                backgroundColor: [0.0, 0.0, 0.0, 1.0],
                minFar: 0,
                defaultColor: [200, 200, 200, 255],
                renderTileWithoutTexture: true,
                //todofl : redondance car params identiques
                publishEvent: function (message, object) {
                    self.publish(message, object);
                }
            }
        }

        /**
         * Computes GeoCenter according to the coordinate reference system.
         * @param {Crs} crs - coordinate reference system
         * @returns {float[]} geocenter
         * @private
         */
        function _computeGeoCenter(crs) {
            var geoCenter;
            if (crs.isFlat()) {
                geoCenter = crs.getWorldFrom3D(this.navigation.center);
            } else {
                geoCenter = this.navigation.geoCenter;
            }
            return geoCenter;
        }

        /**
         * Propagates navigation options (inertia and mouse) when the coordinate reference system changes.
         * @param {AbstractNavigation.configuration} options - Navigation configuration
         * @private
         * @returns {Object} navigation options
         */
        function _propagateNavOptions(options) {
            var navOptions = {};
            navOptions.inertia = options.hasOwnProperty("inertia") ? options.inertia : false;
            if(options.hasOwnProperty('mouse')) {
                navOptions.mouse = options.mouse;
            }
            return navOptions;
        }

        /**
         * Updates the navigation according to the new coordinate reference system and the current settings
         * of the previous coordinate reference system
         * @param {Crs} newCrs -  the new coordinate reference system
         * @param geoCenter - Current geo center of the camera in the previous coordinate reference system
         * @param geoDistance - Distance from the globe's surface of the camera in the previous coordinate reference system
         * @param {Object} navOptions - Navigation's options
         * @param {boolean} [navOptions.inertia=false] - Inertia
         * @param {Object} [navOptions.mouse] - Mouse's configuration
         * @private
         */
        function _updateNavForNewCrs(newCrs, geoCenter, geoDistance, navOptions) {
            if (newCrs.isFlat()) {
                this.navigation = NavigationFactory.create(Constants.NAVIGATION.FlatNavigation, this, navOptions);
                this.navigation.center = newCrs.get3DFromWorld(geoCenter);
            } else {
                this.navigation = NavigationFactory.create(Constants.NAVIGATION.PlanetNavigation, this, navOptions);
                this.navigation.geoCenter = geoCenter;
            }
            this.navigation.distance = geoDistance * newCrs.getGeoide().getHeightScale();
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractContext, PlanetContext);

        /**************************************************************************************************************/

        /**
         * @function setCompassVisible
         * @memberOf PlanetContext#
         */
        PlanetContext.prototype.setCompassVisible = function (divName, visible) {
        };

        /**
         * @function setBaseElevation
         * @memberOf PlanetContext#
         */
        PlanetContext.prototype.setBaseElevation = function (layer) {
            this.globe.setBaseElevation(layer);
            this.elevationTracker.setScaleLayer(layer);
        };

        /**
         * @function setBaseElevationByID
         * @memberOf PlanetContext#
         */
        PlanetContext.prototype.setBaseElevationByID = function (layerID) {
            // Find the layer by name among all the layers
            var layer = this.getLayerByID(layerID);
            if (layer) {
                this.setBaseElevation(layer);
            }
            return layer;
        };

        /**
         * @function setCoordinateSystem
         * @memberOf PlanetContext#
         */
        PlanetContext.prototype.setCoordinateSystem = function (newCrs) {
            if (newCrs.getType() !== this.getMode()) {
                throw new RangeError("incompatible coordinate reference system with Planet context", "PlanetContext.js");
            }
            // Change navigation
            var geoCenter;
            var geoDistance;

            var self = this;
            $(self.canvas.parentElement).find('#loading').show();

            // Compute current position and distance in order to set them in the new navigation related to the
            // new coordinate reference system
            geoCenter = _computeGeoCenter.call(this, this.globe.getCoordinateSystem());
            geoDistance = this.navigation.distance / this.globe.getCoordinateSystem().getGeoide().getHeightScale();

            // Update the coordinate reference system
            this.globe.setCoordinateSystem(newCrs);
            this.navigation.stop();

            // Creates the options for the new navigation related to the new coordinate reference system.
            // We only keep the inertia and the options for the mouse
            var navOptions = _propagateNavOptions.call(this, this.navigation.getOptions());

            try {
                // Create a new navigation related to the new coordinate reference system
                _updateNavForNewCrs.call(this, newCrs, geoCenter, geoDistance, navOptions);
            } catch (err) {
                this._showUpError(this, err);
            }

            this.positionTracker.detach();
            this.positionTracker.attachTo(this.globe);
            this.elevationTracker.detach();
            this.elevationTracker.attachTo(this.globe);

            this.navigation.computeViewMatrix();
            this.publish("modifiedCrs", this);
        };

        /**
         * @function destroy
         * @memberOf PlanetContext#
         */
        PlanetContext.prototype.destroy = function () {
            AbstractContext.prototype.destroy.call(this);
        };

        /**************************************************************************************************************/
        return PlanetContext;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" component
 */
define('Gui/CompassCore',["jquery","../Utils/Constants"], function ($, Constants) {

    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var svgDoc;

    /**************************************************************************************************************/

    /**
     * Aligns with north.
     * @param {object} event
     * @private
     */
    function _alignWithNorth(event) {
        var up = [0, 0, 1];
        var coordinateSystem = ctx.getCoordinateSystem();
        var temp = [];
        coordinateSystem.from3DToGeo(up, temp, false);
        temp = coordinateSystem.convert(temp, coordinateSystem.getGeoideName(), Constants.CRS.Equatorial);
        coordinateSystem.fromGeoTo3D(temp, up, false);
        ctx.getNavigation().moveUpTo(up);
    }

    /**************************************************************************************************************/

    /**
     * Function updating the north position on compass
     */
    function updateNorth() {
        var geo = [];
        var coordinateSystem = ctx.getCoordinateSystem();
        coordinateSystem.from3DToGeo(ctx.getNavigation().center3d, geo, false);
        geo = coordinateSystem.convert(geo, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());

        var LHV = [];
        coordinateSystem.getLHVTransform(geo, LHV);

        var temp = [];
        var north = [LHV[4], LHV[5], LHV[6]];
        var vertical = [LHV[8], LHV[9], LHV[10]];

        var up = vec3.create(ctx.getNavigation().up);
        coordinateSystem.from3DToGeo(up, temp, false);
        temp = coordinateSystem.convert(temp, Constants.CRS.Equatorial, coordinateSystem.getGeoideName());
        coordinateSystem.fromGeoTo3D(temp, up, false);
        vec3.normalize(up);

        // Find angle between up and north
        var cosNorth = vec3.dot(up, north) / (vec3.length(up) * vec3.length(north));
        var radNorth = Math.acos(cosNorth);
        if (isNaN(radNorth)) {
            return;
        }
        var degNorth = radNorth * 180 / Math.PI;

        // Find sign between up and north
        var sign;
        vec3.cross(up, north, temp);
        sign = vec3.dot(temp, [vertical[0], vertical[1], vertical[2]]);
        if (sign < 0) {
            degNorth *= -1;
        }

        var northText = svgDoc.getElementById("NorthText");
        northText.setAttribute("transform", "rotate(" + degNorth + " 40 40)");
    }

    /**************************************************************************************************************/

    /**
     *    Remove compass element
     *    
     */
    function remove() {
        ctx.unsubscribe("modifiedNavigation", updateNorth);
        document.getElementById(parentElement).innerHTML = '';
    }

    /**************************************************************************************************************/

    return {
        init: function (options) {
            parentElement = options.element;
            ctx = options.ctx;
            svgDoc = options.svgDoc;
        },
        updateNorth: updateNorth,
        _alignWithNorth: _alignWithNorth,
        remove: remove

    };
});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/*global define: false */

/**
 * Compass module : map control with "north" composant
 */
define('Gui/Compass',["jquery", "./CompassCore"], function ($, CompassCore) {

    /**
     *    Private variables
     */
    var parentElement = null;
    var ctx = null;
    var svgDoc;

    /**
     * Create a compass Widget
     * @param options
     * @constructor
     * @fires AbstractContext#modifiedNavigation
     */
    var Compass = function (options) {

        parentElement = options.element;
        ctx = options.ctx;

        // Add compass object to parent element
        // Don't use <object> HTML tag due to cross-origin nature of svg
        if (document.getElementById(parentElement) === null) {
            console.log("Warning, the div specified (" + parentElement + ") do not exist");
            return;
        }

        document.getElementById(parentElement).innerHTML = '<div id="objectCompass"></div>';

        $.get("data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiIHN0YW5kYWxvbmU9Im5vIj8+Cjw/eG1sLXN0eWxlc2hlZXQgdHlwZT0idGV4dC9jc3MiIGhyZWY9ImNvbXBhc3MuY3NzIj8+PHN2ZwogICB4bWxuczpkYz0iaHR0cDovL3B1cmwub3JnL2RjL2VsZW1lbnRzLzEuMS8iCiAgIHhtbG5zOmNjPSJodHRwOi8vY3JlYXRpdmVjb21tb25zLm9yZy9ucyMiCiAgIHhtbG5zOnJkZj0iaHR0cDovL3d3dy53My5vcmcvMTk5OS8wMi8yMi1yZGYtc3ludGF4LW5zIyIKICAgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIKICAgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIgogICB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIKICAgeG1sbnM6c29kaXBvZGk9Imh0dHA6Ly9zb2RpcG9kaS5zb3VyY2Vmb3JnZS5uZXQvRFREL3NvZGlwb2RpLTAuZHRkIgogICB4bWxuczppbmtzY2FwZT0iaHR0cDovL3d3dy5pbmtzY2FwZS5vcmcvbmFtZXNwYWNlcy9pbmtzY2FwZSIKICAgd2lkdGg9IjUyMCIKICAgaGVpZ2h0PSI1MjAiCiAgIGlkPSJzdmcyIgogICB2ZXJzaW9uPSIxLjEiCiAgIGlua3NjYXBlOnZlcnNpb249IjAuNDguMSByOTc2MCIKICAgc29kaXBvZGk6ZG9jbmFtZT0iY29tcGFzc05vcnRoMi5zdmciCiAgIHZpZXdCb3g9Ii0yMjAgLTIyMCA1MjAgNTIwIj4KICA8bWV0YWRhdGEKICAgICBpZD0ibWV0YWRhdGE0NSI+CiAgICA8cmRmOlJERj4KICAgICAgPGNjOldvcmsKICAgICAgICAgcmRmOmFib3V0PSIiPgogICAgICAgIDxkYzpmb3JtYXQ+aW1hZ2Uvc3ZnK3htbDwvZGM6Zm9ybWF0PgogICAgICAgIDxkYzp0eXBlCiAgICAgICAgICAgcmRmOnJlc291cmNlPSJodHRwOi8vcHVybC5vcmcvZGMvZGNtaXR5cGUvU3RpbGxJbWFnZSIgLz4KICAgICAgICA8ZGM6dGl0bGUgLz4KICAgICAgPC9jYzpXb3JrPgogICAgPC9yZGY6UkRGPgogIDwvbWV0YWRhdGE+CiAgPGRlZnMKICAgICBpZD0iZGVmczQzIj4KICAgIDxyYWRpYWxHcmFkaWVudAogICAgICAgaWQ9ImdyYWQxIgogICAgICAgY3g9IjAiCiAgICAgICBjeT0iMCIKICAgICAgIHI9IjIwNyIKICAgICAgIGZ4PSIwIgogICAgICAgZnk9IjAiCiAgICAgICBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CiAgICAgIDxzdG9wCiAgICAgICAgIG9mZnNldD0iMC43NSIKICAgICAgICAgaWQ9InN0b3A2IgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjojZmZmZmZmO3N0b3Atb3BhY2l0eTowIiAvPgogICAgICA8c3RvcAogICAgICAgICBvZmZzZXQ9IjAuOTQ5OTk5OTkiCiAgICAgICAgIGlkPSJzdG9wOCIKICAgICAgICAgc3R5bGU9InN0b3AtY29sb3I6I2ZmOTkwMDtzdG9wLW9wYWNpdHk6MSIgLz4KICAgICAgPHN0b3AKICAgICAgICAgb2Zmc2V0PSIxMDAlIgogICAgICAgICBzdHlsZT0ic3RvcC1jb2xvcjpyZ2IoMjU1LCAyNTUsIDI1NSk7c3RvcC1vcGFjaXR5OjAiCiAgICAgICAgIGlkPSJzdG9wMTAiIC8+CiAgICA8L3JhZGlhbEdyYWRpZW50PgogIDwvZGVmcz4KICA8c29kaXBvZGk6bmFtZWR2aWV3CiAgICAgcGFnZWNvbG9yPSIjZmZmZmZmIgogICAgIGJvcmRlcmNvbG9yPSIjNjY2NjY2IgogICAgIGJvcmRlcm9wYWNpdHk9IjEiCiAgICAgb2JqZWN0dG9sZXJhbmNlPSIxMCIKICAgICBncmlkdG9sZXJhbmNlPSIxMCIKICAgICBndWlkZXRvbGVyYW5jZT0iMTAiCiAgICAgaW5rc2NhcGU6cGFnZW9wYWNpdHk9IjAiCiAgICAgaW5rc2NhcGU6cGFnZXNoYWRvdz0iMiIKICAgICBpbmtzY2FwZTp3aW5kb3ctd2lkdGg9IjEyODAiCiAgICAgaW5rc2NhcGU6d2luZG93LWhlaWdodD0iMTAwMCIKICAgICBpZD0ibmFtZWR2aWV3NDEiCiAgICAgc2hvd2dyaWQ9ImZhbHNlIgogICAgIGlua3NjYXBlOnpvb209IjAuNDEzMTgxODMiCiAgICAgaW5rc2NhcGU6Y3g9IjEwMy43NDIwNiIKICAgICBpbmtzY2FwZTpjeT0iNDguNTQ5MDc0IgogICAgIGlua3NjYXBlOndpbmRvdy14PSIwIgogICAgIGlua3NjYXBlOndpbmRvdy15PSIyNCIKICAgICBpbmtzY2FwZTp3aW5kb3ctbWF4aW1pemVkPSIxIgogICAgIGlua3NjYXBlOmN1cnJlbnQtbGF5ZXI9IkVhc3QiCiAgICAgc2hvd2d1aWRlcz0idHJ1ZSIKICAgICBpbmtzY2FwZTpndWlkZS1iYm94PSJ0cnVlIj4KICAgIDxpbmtzY2FwZTpncmlkCiAgICAgICB0eXBlPSJ4eWdyaWQiCiAgICAgICBpZD0iZ3JpZDMwMTAiCiAgICAgICBlbXBzcGFjaW5nPSI1IgogICAgICAgdmlzaWJsZT0idHJ1ZSIKICAgICAgIGVuYWJsZWQ9InRydWUiCiAgICAgICBzbmFwdmlzaWJsZWdyaWRsaW5lc29ubHk9InRydWUiIC8+CiAgPC9zb2RpcG9kaTpuYW1lZHZpZXc+CiAgPGcKICAgICBpZD0iT3V0ZXJDaXJjbGUiCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMS4xNDI4MTM4LDAsMCwxLjEwNTc4OCwwLjMwODI3MzYsNC42MTQ3ODQpIj4KICAgIDxnCiAgICAgICBpZD0iZzMyNjciCiAgICAgICBzdHlsZT0ib3BhY2l0eTowLjYiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOnJ4PSIyMDciCiAgICAgICAgIHNvZGlwb2RpOmN5PSIwIgogICAgICAgICBzb2RpcG9kaTpjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJtIDIwNywwIGMgMCwxMTQuMzIyOTQgLTkyLjY3NzA2LDIwNyAtMjA3LDIwNyAtMTE0LjMyMjk0LDAgLTIwNywtOTIuNjc3MDYgLTIwNywtMjA3IDAsLTExNC4zMjI5NCA5Mi42NzcwNiwtMjA3IDIwNywtMjA3IDExNC4zMjI5NCwwIDIwNyw5Mi42NzcwNiAyMDcsMjA3IHoiCiAgICAgICAgIGlkPSJjaXJjbGUyNCIKICAgICAgICAgcj0iMjA3IgogICAgICAgICBzdHlsZT0ib3BhY2l0eTowLjc1O2ZpbGw6dXJsKCNncmFkMSkiCiAgICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDEuMTA1MjI3OSwwLDAsMS4xMDUyMjc5LDM0LDMyKSIgLz4KICAgIDwvZz4KICAgIDxnCiAgICAgICBpZD0iZzE4IgogICAgICAgc3R5bGU9InN0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxMCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KDAuOTY1NTg4OTksMCwwLDAuOTcxMzI0MTUsMzQsMzIpIj4KICAgICAgPGNpcmNsZQogICAgICAgICByPSIyMTEiCiAgICAgICAgIGlkPSJjaXJjbGUyMCIKICAgICAgICAgZD0ibSAyMTEsMCBjIDAsMTE2LjUzMjA4IC05NC40Njc5MiwyMTEgLTIxMSwyMTEgLTExNi41MzIwOCwwIC0yMTEsLTk0LjQ2NzkyIC0yMTEsLTIxMSAwLC0xMTYuNTMyMDggOTQuNDY3OTIsLTIxMSAyMTEsLTIxMSAxMTYuNTMyMDgsMCAyMTEsOTQuNDY3OTIgMjExLDIxMSB6IgogICAgICAgICBjeD0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6cng9IjIxMSIKICAgICAgICAgc29kaXBvZGk6cnk9IjIxMSIgLz4KICAgIDwvZz4KICA8L2c+CiAgPGcKICAgICBpZD0iU291dGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0idHJhbnNsYXRlKDM5LjU3ODM4MywzNi45NzA0MzUpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ciCiAgICAgICBkPSJNIDM5LjQxNiw5NS4xNiBDIDMzLjY1LDEwMy45NSAzMC43NiwxMTAuNSAyOC45MywxMTcuMTggMTUuMjQsMTEzLjQzIDEzLjU0LDEyNy4xNSAyMy4wNCwxMzEgMTMuNzEsMTQ1LjggNy44NCwxNzMuOTMgMCwyMTIgTCAwLDEwMyBhIDEwMywxMDMgMCAwIDAgMzkuNDE2LC03Ljg0IHoiIC8+CiAgICA8dXNlCiAgICAgICBoZWlnaHQ9IjQ0MCIKICAgICAgIHdpZHRoPSI0NDAiCiAgICAgICB5PSIwIgogICAgICAgeD0iMCIKICAgICAgIGlkPSJzb3V0aCIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93IiAvPgogIDwvZz4KICA8ZwogICAgIGlkPSJFYXN0IgogICAgIGNsYXNzPSJhcnJvdyIKICAgICB0cmFuc2Zvcm09Im1hdHJpeCgwLDEsLTEsMCwzOC44MDYyMSwzNy4yMjA0MjkpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNiIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgc3R5bGU9ImZpbGw6I2ZmZmZmZiIKICAgICAgIGlkPSJzb3V0aC01IgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNiIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iTm9ydGgiCiAgICAgY2xhc3M9ImFycm93IgogICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwtMSw0MS45MDI3OCw0My43ODMzNzYpIj4KICAgIDxwYXRoCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmO3N0cm9rZTojZmZmZmZmO3N0cm9rZS13aWR0aDoxIgogICAgICAgaW5rc2NhcGU6Y29ubmVjdG9yLWN1cnZhdHVyZT0iMCIKICAgICAgIGlkPSJIYWxmQXJyb3ctNi0wIgogICAgICAgZD0iTSAzOS40MTYsOTUuMTYgQyAzMy42NSwxMDMuOTUgMzAuNzYsMTEwLjUgMjguOTMsMTE3LjE4IDE1LjI0LDExMy40MyAxMy41NCwxMjcuMTUgMjMuMDQsMTMxIDEzLjcxLDE0NS44IDcuODQsMTczLjkzIDAsMjEyIEwgMCwxMDMgYSAxMDMsMTAzIDAgMCAwIDM5LjQxNiwtNy44NCB6IiAvPgogICAgPHVzZQogICAgICAgaGVpZ2h0PSI0NDAiCiAgICAgICB3aWR0aD0iNDQwIgogICAgICAgeT0iMCIKICAgICAgIHg9IjAiCiAgICAgICBzdHlsZT0iZmlsbDojZmZmZmZmIgogICAgICAgaWQ9InNvdXRoLTUtNiIKICAgICAgIHRyYW5zZm9ybT0ibWF0cml4KC0xLDAsMCwxLDIsMCkiCiAgICAgICB4bGluazpocmVmPSIjSGFsZkFycm93LTYtMCIgLz4KICA8L2c+CiAgPGcKICAgICBpZD0iV2VzdCIKICAgICBjbGFzcz0iYXJyb3ciCiAgICAgdHJhbnNmb3JtPSJtYXRyaXgoMCwtMSwxLDAsMzcuMzc0NzU4LDM5LjU0NzAyMykiPgogICAgPHBhdGgKICAgICAgIHN0eWxlPSJmaWxsOiNmZmZmZmY7c3Ryb2tlOiNmZmZmZmY7c3Ryb2tlLXdpZHRoOjEiCiAgICAgICBpbmtzY2FwZTpjb25uZWN0b3ItY3VydmF0dXJlPSIwIgogICAgICAgaWQ9IkhhbGZBcnJvdy02LTAtNSIKICAgICAgIGQ9Ik0gMzkuNDE2LDk1LjE2IEMgMzMuNjUsMTAzLjk1IDMwLjc2LDExMC41IDI4LjkzLDExNy4xOCAxNS4yNCwxMTMuNDMgMTMuNTQsMTI3LjE1IDIzLjA0LDEzMSAxMy43MSwxNDUuOCA3Ljg0LDE3My45MyAwLDIxMiBMIDAsMTAzIGEgMTAzLDEwMyAwIDAgMCAzOS40MTYsLTcuODQgeiIgLz4KICAgIDx1c2UKICAgICAgIGhlaWdodD0iNDQwIgogICAgICAgd2lkdGg9IjQ0MCIKICAgICAgIHk9IjAiCiAgICAgICB4PSIwIgogICAgICAgaWQ9InNvdXRoLTUtNi0yIgogICAgICAgdHJhbnNmb3JtPSJtYXRyaXgoLTEsMCwwLDEsMiwwKSIKICAgICAgIHhsaW5rOmhyZWY9IiNIYWxmQXJyb3ctNi0wLTUiIC8+CiAgPC9nPgogIDx0ZXh0CiAgICAgeG1sOnNwYWNlPSJwcmVzZXJ2ZSIKICAgICBzdHlsZT0iZm9udC1zaXplOjkwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO2xldHRlci1zcGFjaW5nOjBweDt3b3JkLXNwYWNpbmc6MHB4O3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7ZmlsbC1vcGFjaXR5OjE7c3Ryb2tlOm5vbmU7Zm9udC1mYW1pbHk6VGltZXMgTmV3IFJvbWFuOy1pbmtzY2FwZS1mb250LXNwZWNpZmljYXRpb246J1RpbWVzIE5ldyBSb21hbiwgQm9sZCciCiAgICAgeD0iMTkuMjU0ODc1IgogICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgaWQ9Ik5vcnRoVGV4dCIKICAgICBzb2RpcG9kaTpsaW5lc3BhY2luZz0iMTMwJSIKICAgICB0cmFuc2Zvcm09InNjYWxlKDEuMDA4MzY2NSwwLjk5MTcwMjkyKSI+PHRzcGFuCiAgICAgICBzb2RpcG9kaTpyb2xlPSJsaW5lIgogICAgICAgaWQ9InRzcGFuMzAyNCIKICAgICAgIHg9IjE5LjI1NDg3NSIKICAgICAgIHk9Ii0xNjMuMDY2NzYiCiAgICAgICBzdHlsZT0iZm9udC1zaXplOjgwcHg7Zm9udC1zdHlsZTpub3JtYWw7Zm9udC12YXJpYW50Om5vcm1hbDtmb250LXdlaWdodDpib2xkO2ZvbnQtc3RyZXRjaDpub3JtYWw7dGV4dC1hbGlnbjpzdGFydDtsaW5lLWhlaWdodDoxMjkuOTk5OTk1MjMlO3dyaXRpbmctbW9kZTpsci10Yjt0ZXh0LWFuY2hvcjpzdGFydDtmaWxsOiNmZjdmMmE7c3Ryb2tlOiMwMDAwMDA7c3Ryb2tlLXdpZHRoOjFweDtmb250LWZhbWlseTpUaW1lcyBOZXcgUm9tYW47LWlua3NjYXBlLWZvbnQtc3BlY2lmaWNhdGlvbjonVGltZXMgTmV3IFJvbWFuLCBCb2xkJyI+TjwvdHNwYW4+PC90ZXh0PgogIDxnCiAgICAgaWQ9IklubmVyQ2lyY2xlIgogICAgIHN0eWxlPSJvcGFjaXR5OjAuNiIKICAgICB0cmFuc2Zvcm09InRyYW5zbGF0ZSgzOS4yNjA3MjYsNDEuMjEwMTIxKSI+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6I2ZmZmZmZjtzdHJva2Utd2lkdGg6OCIKICAgICAgIGlkPSJnNyI+CiAgICAgIDxjaXJjbGUKICAgICAgICAgc29kaXBvZGk6cng9Ijc1IgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgY3k9IjAiCiAgICAgICAgIGN4PSIwIgogICAgICAgICBkPSJNIDc1LDAgQyA3NSw0MS40MjEzNTYgNDEuNDIxMzU2LDc1IDAsNzUgLTQxLjQyMTM1Niw3NSAtNzUsNDEuNDIxMzU2IC03NSwwIGMgMCwtNDEuNDIxMzU2IDMzLjU3ODY0NCwtNzUgNzUsLTc1IDQxLjQyMTM1NiwwIDc1LDMzLjU3ODY0NCA3NSw3NSB6IgogICAgICAgICBpZD0iY2lyY2xlOSIKICAgICAgICAgcj0iNzUiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBzb2RpcG9kaTpyeT0iNzUiIC8+CiAgICA8L2c+CiAgICA8ZwogICAgICAgc3R5bGU9ImZpbGw6bm9uZTtzdHJva2U6IzFiMWIxYjtzdHJva2Utd2lkdGg6MSIKICAgICAgIGlkPSJnMTEiPgogICAgICA8Y2lyY2xlCiAgICAgICAgIHNvZGlwb2RpOnJ5PSI3MSIKICAgICAgICAgc29kaXBvZGk6cng9IjcxIgogICAgICAgICBzb2RpcG9kaTpjeT0iMCIKICAgICAgICAgc29kaXBvZGk6Y3g9IjAiCiAgICAgICAgIGN5PSIwIgogICAgICAgICBjeD0iMCIKICAgICAgICAgZD0iTSA3MSwwIEMgNzEsMzkuMjEyMjE3IDM5LjIxMjIxNyw3MSAwLDcxIC0zOS4yMTIyMTcsNzEgLTcxLDM5LjIxMjIxNyAtNzEsMCBjIDAsLTM5LjIxMjIxNyAzMS43ODc3ODMsLTcxIDcxLC03MSAzOS4yMTIyMTcsMCA3MSwzMS43ODc3ODMgNzEsNzEgeiIKICAgICAgICAgaWQ9ImNpcmNsZTEzIgogICAgICAgICByPSI3MSIgLz4KICAgICAgPGNpcmNsZQogICAgICAgICBzb2RpcG9kaTpyeT0iNzkiCiAgICAgICAgIHNvZGlwb2RpOnJ4PSI3OSIKICAgICAgICAgc29kaXBvZGk6Y3k9IjAiCiAgICAgICAgIHNvZGlwb2RpOmN4PSIwIgogICAgICAgICBjeT0iMCIKICAgICAgICAgY3g9IjAiCiAgICAgICAgIGQ9Ik0gNzksMCBDIDc5LDQzLjYzMDQ5NSA0My42MzA0OTUsNzkgMCw3OSAtNDMuNjMwNDk1LDc5IC03OSw0My42MzA0OTUgLTc5LDAgYyAwLC00My42MzA0OTUgMzUuMzY5NTA1LC03OSA3OSwtNzkgNDMuNjMwNDk1LDAgNzksMzUuMzY5NTA1IDc5LDc5IHoiCiAgICAgICAgIGlkPSJjaXJjbGUxNSIKICAgICAgICAgcj0iNzkiIC8+CiAgICA8L2c+CiAgPC9nPgo8L3N2Zz4K",
            function (response) {
                // Import contents of the svg document into this document
                svgDoc = document.importNode(response.documentElement, true);

                // Update width/height
                svgDoc.height.baseVal.value = 100;
                svgDoc.width.baseVal.value = 100;
                // Append the imported SVG root element to the appropriate HTML element
                $("#objectCompass").append(svgDoc);

                options.svgDoc = svgDoc;
                CompassCore.init(options);

                initialize();
                // Publish modified event to update compass north
                ctx.publish('modifiedNavigation');
                $('#' + parentElement).css("display", "block");
            },
            "xml");

        /**
         *    Initialize interactive events
         */
        var initialize = function () {
            /* Svg interactive elements */

            var east = svgDoc.getElementById("East"); //get the inner element by id
            var west = svgDoc.getElementById("West"); //get the inner element by id
            var south = svgDoc.getElementById("South"); //get the inner element by id
            var north = svgDoc.getElementById("North"); //get the inner element by id
            var northText = svgDoc.getElementById("NorthText");
            var outerCircle = svgDoc.getElementById("OuterCircle");

            var panFactor = options.panFactor ? options.panFactor : 30;

            var _lastMouseX = -1;
            var _lastMouseY = -1;
            var _dx = 0;
            var _dy = 0;
            var dragging = false;
            var _outerCircleRadius = outerCircle.ownerSVGElement.clientWidth / 2;

            var _handleMouseDown = function (event) {
                event.preventDefault();
                if (event.type.search("touch") >= 0) {
                    event.layerX = event.changedTouches[0].clientX;
                    event.layerY = event.changedTouches[0].clientY;
                }

                dragging = true;
                _lastMouseX = event.layerX - _outerCircleRadius;
                _lastMouseY = event.layerY - _outerCircleRadius;
                _dx = 0;
                _dy = 0;
            };

            svgDoc.addEventListener('mousedown', _handleMouseDown);


            var _handleMouseMove = function (event) {
                event.preventDefault();
                if (event.type.search("touch") >= 0) {
                    event.layerX = event.changedTouches[0].clientX;
                    event.layerY = event.changedTouches[0].clientY;
                }

                if (!dragging) {
                    return;
                }

                var c = _lastMouseX * (event.layerY - _outerCircleRadius) - _lastMouseY * (event.layerX - _outerCircleRadius); // c>0 -> clockwise, counterclockwise otherwise
                ctx.getNavigation().rotate(c, 0);

                _lastMouseX = event.layerX - _outerCircleRadius;
                _lastMouseY = event.layerY - _outerCircleRadius;

                CompassCore.updateNorth();
            };

            svgDoc.addEventListener('mousemove', _handleMouseMove);

            var _handleMouseUp = function (event) {
                event.preventDefault();
                dragging = false;
                // TODO add inertia
            };

            svgDoc.addEventListener('mouseup', _handleMouseUp);

            east.addEventListener("click", function () {
                ctx.getNavigation().pan(panFactor, 0.0);
                CompassCore.updateNorth();
            });

            west.addEventListener("click", function () {
                ctx.getNavigation().pan(-panFactor, 0.0);
                CompassCore.updateNorth();
            });

            north.addEventListener("click", function () {
                ctx.getNavigation().pan(0, panFactor);
                CompassCore.updateNorth();
            });

            south.addEventListener("click", function () {
                ctx.getNavigation().pan(0, -panFactor);
                CompassCore.updateNorth();
            });

            northText.addEventListener("click", CompassCore._alignWithNorth);

            if (options.isMobile) {
                svgDoc.addEventListener('touchstart', _handleMouseDown);
                svgDoc.addEventListener('touchup', _handleMouseUp);
                svgDoc.addEventListener('touchmove', _handleMouseMove);
                northText.addEventListener("touchstart", CompassCore._alignWithNorth);
            }

            // Update fov when moving
            ctx.subscribe("modifiedNavigation", CompassCore.updateNorth);
            ctx.subscribe("modifiedCrs", CompassCore.updateNorth);
        };
    };

    /**************************************************************************************************************/

    /**
     *    Remove compass element
     */
    Compass.prototype.remove = CompassCore.remove;

    /**************************************************************************************************************/

    return Compass;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Context/SkyContext',["underscore-min", "../Utils/Utils",
        "./AbstractContext", "../Globe/GlobeFactory", "../Navigation/NavigationFactory", "../Services/ServiceFactory",
        "../Gui/Compass", "../Utils/Constants"],
    function (_, Utils,
              AbstractContext, GlobeFactory, NavigationFactory, ServiceFactory,
              Compass, Constants) {

        /**
         * sky context configuration
         * @typedef {Object} AbstractContext.skyContext
         * @property {float} [tileErrorTreshold=1.5]
         * @property {float} [continuousRendering=true]
         * @property {float} [radius = 10.0] - Vector distance of the sky
         * @property {int} [minFar = 15]
         * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
         * @property {RenderContext} [renderContext] - Context rendering
         * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
         * @property {string} [compass="compassDiv"] - div element where compass is displayed
         */

        /**
         * @name SkyContext
         * @class
         * Virtual globe where the camera is inside the globe.<br/>
         * When an error happens at the initialisation, a message is displayed
         * @augments AbstractContext
         * @param {Mizar.configuration} mizarConfiguration - mizar configuration
         * @param {AbstractContext.skyContext} options - skyContext configuration
         * @constructor
         * @memberOf module:Context
         */
        var SkyContext = function (mizarConfiguration, options) {
            AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Sky, options);

            var self = this;
            this.components = {
                "posTrackerInfo": true,
                "posTracker": true,
                "elevTracker": false,
                "compassDiv": true
            };
            var skyOptions = _createSkyConfiguration.call(this, options);

            // Initialize sky
            try {
                // Create the sky
                this.globe = GlobeFactory.create(Constants.GLOBE.Sky, skyOptions);
                this.initGlobeEvents(this.globe);

                this.navigation = NavigationFactory.create(Constants.NAVIGATION.AstroNavigation, this, options.navigation ? options.navigation : options);

                ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

                this.setCompassVisible(options.compass && this.components.compassDiv ? options.compass : "compassDiv", true);

            }
            catch (err) {
                this._showUpError(this, err);
            }

        };

        /**
         * Planet configuration data model
         * @typedef {Object} AbstractGlobe.dm_sky
         * @property {Object} canvas - canvas object
         * @property {int} tileErrorTreshold - tile error treshold
         * @property {boolean} continuousRendering - continuous rendering
         * @property {renderContext} [renderContext] - Rendering context
         * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
         * @property {boolean} lighting = false - Lighting
         * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
         * @property {int} minFar
         * @property {float} radius
         * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
         * @property {string} shadersPath = "../../shaders/" - Shaders location
         * @property {boolean} renderTileWithoutTexture = false
         * @property {function} publishEvent - Callback
         */

        /**
         * Creates planet configuration
         * @param {Object} options
         * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
         * @param {boolean} [options.continuousRendering = true] - continuous rendering
         * @param {renderContext} [options.renderContext] - Rendering context
         * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet
         * @param {float} [options.radius = 10.0] - Radius object in vector length
         * @returns {AbstractGlobe.dm_sky} Planet data model.
         * @private
         */
        function _createSkyConfiguration(options) {
            var self = this;
            var skyOptions = {
                canvas: this.canvas,
                tileErrorTreshold: options.tileErrorTreshold || 1.5,
                continuousRendering: options.continuousRendering || true,
                renderTileWithoutTexture: false,
                radius: options.radius || 10.0,
                minFar: options.minFar || 15,		// Fix problem with far buffer, with planet rendering
                coordinateSystem: options.coordinateSystem,
                lighting: false,
                backgroundColor: [0.0, 0.0, 0.0, 1.0],
                defaultColor: [200, 200, 200, 255],
                shadersPath: this.mizarConfiguration['mizarAPIUrl']+'shaders/',
                publishEvent: function (message, object) {
                    self.publish(message, object);
                }
            };
            if (options.renderContext) {
                skyOptions.renderContext = options.renderContext;
            }
            return skyOptions;
        }
        

        /**************************************************************************************************************/

        Utils.inherits(AbstractContext, SkyContext);

        /**************************************************************************************************************/

        /**
         * @function setCompassVisible
         * @memberOf SkyContext#
         */
        SkyContext.prototype.setCompassVisible = function (divName, visible) {
            if (visible) {
                this.compass = new Compass({
                    element: divName,
                    ctx: this
                });
            } else {
                if (this.compass) {
                    this.compass.remove();
                }
            }
            this.setComponentVisibility(divName, visible);
        };


        /**
         * @function setCoordinateSystem
         * @memberOf SkyContext#
         * @throws ReferenceError - incompatible coordinate reference system with Sky context
         */
        SkyContext.prototype.setCoordinateSystem = function (cs) {
            if (cs.getType() !== this.getMode()) {
                throw ReferenceError("incompatible coordinate reference system with Sky context", "SkyContex.js");
            }
            this.globe.setCoordinateSystem(cs);
            this.publish("modifiedCrs", this);
        };

        /**
         * @function destroy
         * @memberOf SkyContext#
         */
        SkyContext.prototype.destroy = function () {
            this.setCompassVisible(false);
            AbstractContext.prototype.destroy.call(this);
        };

        /**************************************************************************************************************/

        return SkyContext;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/

define('Context/GroundContext',["jquery", "underscore-min", "../Utils/Utils", "./AbstractContext", "../Utils/Constants",
        "../Globe/GlobeFactory", "../Navigation/NavigationFactory", "../Services/ServiceFactory"],
    function ($, _, Utils, AbstractContext, Constants,
              GlobeFactory, NavigationFactory, ServiceFactory) {

        /**
         * ground context configuration
         * @typedef {Object} AbstractContext.groundContext
         * @property {float} [tileErrorTreshold=1.5]
         * @property {float} [continuousRendering=true]
         * @property {float} [radius = 10.0] - Vector distance of the sky
         * @property {int} [minFar = 15]
         * @property {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - CRS configuration
         * @property {RenderContext} [renderContext] - Context rendering
         * @property {AbstractNavigation.astro_configuration} navigation - navigation configuration
         * @property {string} [compass="compassDiv"] - div element where compass is displayed
         */

        /**
         * @name GroundContext
         * @class
         * Virtual globe where the camera is inside the globe and having the horizontal coordinate as .<br/>
         * When an error happens at the initialisation, a message is displayed
         * @augments AbstractContext
         * @param {Mizar.configuration} mizarConfiguration - mizar configuration
         * @param {AbstractContext.skyContext} options - skyContext configuration
         * @constructor
         * @memberOf module:Context
         */
        var GroundContext = function (mizarConfiguration, options) {
            AbstractContext.prototype.constructor.call(this, mizarConfiguration, Constants.CONTEXT.Ground, options);
            var self = this;

            this.components = {
                "posTrackerInfo": true,
                "posTracker": true,
                "elevTracker": false,
                "compassDiv": false
            };

            var groundOptions = _createGroundConfiguration.call(this, options);

            // Initialize sky
            try {
                // Create the sky
                this.globe = GlobeFactory.create(Constants.GLOBE.Sky, groundOptions);
                this.initGlobeEvents(this.globe);

                this.navigation = NavigationFactory.create(Constants.NAVIGATION.GroundNavigation, this, options.navigation ? options.navigation : options);

                ServiceFactory.create(Constants.SERVICE.PickingManager).init(this);

                //this.setCompassVisible(options.compass && this.components.compassDiv ? options.compass : "compassDiv", true);

            }
            catch (err) {
                this._showUpError(this, err);
            }
        };


        /**
         * Ground configuration data model
         * @typedef {Object} AbstractGlobe.dm_ground
         * @property {Object} canvas - canvas object
         * @property {int} tileErrorTreshold - tile error treshold
         * @property {boolean} continuousRendering - continuous rendering
         * @property {renderContext} [renderContext] - Rendering context
         * @property {AbstractCrs.crsFactory} coordinateSystem - Coordinate reference system of the planet
         * @property {boolean} lighting = false - Lighting
         * @property {float[]} backgroundColor = [0.0, 0.0, 0.0, 1.0] - Background color
         * @property {int} minFar
         * @property {float} radius
         * @property {int[]} defaultColor = [200, 200, 200, 255] - Default color
         * @property {string} shadersPath = "../../shaders/" - Shaders location
         * @property {boolean} renderTileWithoutTexture = false
         * @property {function} publishEvent - Callback
         */

        /**
         * Creates planet configuration
         * @param {Object} options
         * @param {int} [options.tileErrorTreshold = 1.5] - Tile error treshold
         * @param {boolean} [options.continuousRendering = true] - continuous rendering
         * @param {renderContext} [options.renderContext] - Rendering context
         * @param {AbstractCrs.crsFactory} options.coordinateSystem - Coordinate reference system of the planet' ground
         * @param {float} [options.radius = 10.0] - Radius object in vector length
         * @returns {AbstractGlobe.dm_ground} Ground data model.
         * @private
         */
        function _createGroundConfiguration(options) {
            var self = this;
            return {
                tileErrorTreshold: options.tileErrorTreshold || 3,
                continuousRendering: options.continuousRendering || false,
                renderContext: options.renderContext,
                canvas: this.canvas,
                coordinateSystem: options.coordinateSystem,
                shadersPath: this.mizarConfiguration['mizarAPIUrl']+'shaders/',
                lighting: false,
                backgroundColor: [0.0, 0.0, 0.0, 1.0],
                minFar: 0,
                defaultColor: [200, 200, 200, 255],
                renderTileWithoutTexture: true,
                publishEvent: function (message, object) {
                    self.publish(message, object);
                }
            }
        }

        /**************************************************************************************************************/

        Utils.inherits(AbstractContext, GroundContext);

        /**************************************************************************************************************/

        /**
         * @function setCoordinateSystem
         * @memberOf GroundContext#
         * @throws RangeError - "incompatible coordinate reference system with Sky context"
         */
        GroundContext.prototype.setCoordinateSystem = function (cs) {
            if (cs.getType() !== this.getMode()) {
                throw new RangeError("incompatible coordinate reference system with Sky context", "GroundContext.js");
            }
            this.globe.setCoordinateSystem(cs);
            this.publish("modifiedCrs", this);
        };

        /**
         * @function destroy
         * @memberOf GroundContext#
         */
        GroundContext.prototype.destroy = function () {
            //this.setCompassVisible(false);
            AbstractContext.prototype.destroy.call(this);
        };

        /**************************************************************************************************************/

        return GroundContext;

    });
/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @name ContextFactory
 * @class
 * Factory to create a context
 * @memberOf module:Context
 */
define('Context/ContextFactory',["../Utils/Constants", "./PlanetContext", "./SkyContext", "./GroundContext"],
    function (Constants, PlanetContext, SkyContext, GroundContext) {

        return {
            /**
             * Factory to create a context.
             *
             * Creates a context based on :
             * <ul>
             *     <li>the context type {@link CONTEXT},</li>
             *     <li>the global Mizar's configuration,</li>
             *     <li>the options for the specific context</li>
             * </ul>
             * @param {CONTEXT} type - Type of animation.
             * @param {Object} configuration - see options.configuration for {@link Mizar}
             * @param {Object} options - See options.planetContext or options.skyContext configuration for {@link Mizar}
             * @return {Context} - the object to handle an animation
             * @throws {RangeError} Type not valid - a valid type is included in the list {@link CONTEXT}
             * @alias module:Context.ContextFactory.create
             *
             */
            create : function(type, configuration, options) {
                var obj;
                switch (type) {
                    case Constants.CONTEXT.Planet :
                        obj =  new PlanetContext(configuration, options);
                        break;
                    case Constants.CONTEXT.Sky :
                        obj = new SkyContext(configuration, options);
                        break;
                    case Constants.CONTEXT.Ground :
                        obj = new GroundContext(configuration, options);
                        break;
                    default:
                        throw RangeError("The type "+type+" is not allowed, A valid type is included in the list Constants.CONTEXT", "ContextFactory.js");
                        
                }
                return obj;
            }

        }});


/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

/**
 * Provider
 * @module Provider
 * @implements {Provider}
 */
define('Provider/AbstractProvider',["jquery"],
    function ($) {

      /**************************************************************************************************************/

      /**
       * @name AbstractProvider
       * @class
       *  Abstract Provider constructor
       * @param {object} options
       * @constructor
       * @memberOf module:Provider
       */
        var AbstractProvider = function (options) {
            this.options = options;
        };


        /**
         * @function loadFiles
         * @memberOf Provider#
         * @abstract
         */
        AbstractProvider.prototype.loadFiles = function (layer, configuration) {
        };


        /**
         * @function handleFeatures
         * @memberOf Provider#
         */
        AbstractProvider.prototype.handleFeatures = function (layer) {
        };

        /**************************************************************************************************************/

        return AbstractProvider;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/ConstellationProvider',["jquery", "./AbstractProvider", "../Renderer/FeatureStyle", "../Utils/Utils","../Utils/Constants"],
    function ($, AbstractProvider, FeatureStyle, Utils, Constants) {

        /**************************************************************************************************************/

        var namesFile;
        var catalogueFile;

        var constellations = {};
        var self;

        /**
         *    Extract information in "constellation" variables
         */
        function extractDatabase(mizarLayer) {
            var constellationNamesTab = namesFile.split("\n");
            var catalogueTab = catalogueFile.split("\n");

            // For each constellation point
            for (var i = 0; i < catalogueTab.length; i++) {
                var word = catalogueTab[i].replace("  ", " ");
                word = word.split(" "); // word = "RA Decl Abbreviation "I"/"O"(Inerpolated/Original(Corner))"
                var RA = parseFloat(word[0]);
                var Decl = parseFloat(word[1]);
                var currentAbb = word[2];
                var IO = word[3];

                // Convert hours to degrees
                RA *= 15;

                // If abbreviation doesn't exist
                if (!constellations[currentAbb]) {
                    // Find constellation name
                    for (var j = 0; j < constellationNamesTab.length; j++) {
                        word = constellationNamesTab[j].split(";"); // word[0] = abbreviation, word[1] = name;
                        var abb = word[0];

                        if (abb === currentAbb) {
                            var name = word[1];

                            // Add new constellation as a property
                            constellations[currentAbb] = {
                                coord: [],
                                name: name,

                                // Values used to calculate the position of the center of constellation
                                x: 0.0,
                                y: 0.0,
                                z: 0.0,
                                nbStars: 0
                            };
                            break;
                        }
                    }
                }

                // Convert to default coordinate system
                var posGeo = [RA, Decl];

                // Calculate the center of constillation
                var pos3d = [];
                // Need to convert to 3D because of 0h -> 24h notation
                mizarLayer.globe.getCoordinateSystem().get3DFromWorldInCrs(posGeo, Constants.CRS.Equatorial, pos3d);
                constellations[currentAbb].x += pos3d[0];
                constellations[currentAbb].y += pos3d[1];
                constellations[currentAbb].z += pos3d[2];
                constellations[currentAbb].nbStars++;

                constellations[currentAbb].coord.push(posGeo);
            }
        }

        /*
         * 	Failure function
         */
        function failure() {
            console.error("Failed to load files");
        }
        
        /**
         * @name ConstellationProvider
         * @class
         *   ConstellationProvider context constructor
         * @param {object} options
         * @augments AbstractProvider
         * @constructor
         * @memberOf module:Provider
         */
        var ConstellationProvider = function (options) {
            AbstractProvider.prototype.constructor.call(this, options);
            self = this;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProvider, ConstellationProvider);

        /**************************************************************************************************************/

        /**
         * Asynchronous request to load constellation data
         * @function loadFiles
         * @memberOf ConstellationProvider#
         * @param {Layer} layer - Mizar layer
         * @param {Object} configuration - Configuration options
         * @param {string} configuration.nameUrl - Url providing the constellations name data
         * @param {string} configuration.catalogueUrl - Url providing all information about each constellation
         * @see http://vizier.cfa.harvard.edu/viz-bin/ftp-index?VI/49
         */
        ConstellationProvider.prototype.loadFiles = function (layer, configuration) {
            var mizarLayer = layer;
            if (configuration.nameUrl && configuration.catalogueUrl) {
                // loadFiles( configuration.nameUrl, configuration.catalogueUrl );
                var nameRequest = {
                    type: "GET",
                    url: configuration.nameUrl,
                    success: function (response) {
                        namesFile = response;
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        console.error(xhr.responseText);
                    }
                };

                var catalogueRequest = {
                    type: "GET",
                    url: configuration.catalogueUrl,
                    success: function (response) {
                        catalogueFile = response;
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        console.error(xhr.responseText);
                    }
                };

                // Synchronizing two asynchronious requests with the same callback
                $.when($.ajax(nameRequest), $.ajax(catalogueRequest))
                    .then(function () {
                        extractDatabase(mizarLayer);
                        self.handleFeatures(mizarLayer);
                    }, failure);
            }
            else {
                console.error("Not valid options");
                return false;
            }
        };

        
        ConstellationProvider.prototype.handleFeatures = function (mizarLayer) {

            var constellationNamesFeatures = [];
            var constellationShapesFeatures = [];

            // Fill constellationShapes & constellationNames
            for (var i in constellations) {
                if (constellations.hasOwnProperty(i)) {
                    var current = constellations[i];

                    // Close the polygon
                    current.coord.push(current.coord[0]);

                    var constellationShape = {
                        geometry: {
                            type: Constants.GEOMETRY.Polygon,
                            gid: "constellationShape_" + current.name,
                            coordinates: [current.coord],
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            name: current.name
                        }
                    };

                    constellationShapesFeatures.push(constellationShape);

                    // Compute mean value to show the constellation name in the center of constellation..
                    // .. sometimes out of constellation's perimeter because of the awkward constellation's shape(ex. "Hydra" or "Draco" constellations)
                    var geoPos = [];
                    mizarLayer.globe.getCoordinateSystem().getWorldFrom3D([current.x / current.nbStars, current.y / current.nbStars, current.z / current.nbStars], geoPos);

                    var constellationName = {
                        geometry: {
                            type: Constants.GEOMETRY.Point,
                            gid: "constellationName_" + current.name,
                            coordinates: [geoPos[0], geoPos[1]],
                            crs: {
                                type: "name",
                                properties: {
                                    name: Constants.CRS.Equatorial
                                }
                            }
                        },
                        properties: {
                            name: current.name,
                            style: new FeatureStyle({
                                textColor: '#083BA8',
                                fillColor: [1.0, 1.0, 1.0, 1.0],
                                label: current.name
                            })
                        }
                    };
                    constellationNamesFeatures.push(constellationName);
                }
            }

            // Create feature collections
            var constellationShapesFeatureCollection = {
                type: "FeatureCollection",
                features: constellationShapesFeatures
            };
            var constellationNameFeatureCollection = {
                type: "FeatureCollection",
                features: constellationNamesFeatures
            };

            // Add shapes&names to the layer
            mizarLayer.addFeatureCollection(constellationShapesFeatureCollection);
            mizarLayer.addFeatureCollection(constellationNameFeatureCollection);
        };

        /**************************************************************************************************************/

        return ConstellationProvider;

    });

/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/OpenSearchProvider',["jquery", "./AbstractProvider", "../Parser/JsonProcessor"],
    function ($, AbstractProvider, JsonProcessor) {

        var self;

         /**
          * @name OpenSearchProvider
          * @class
          *   OpenSearchProvider context constructor
          * @param {object} options
          * @augments AbstractProvider
          * @constructor
          * @memberOf module:Provider
          */
        var OpenSearchProvider = function (options) {
            self = this;
            AbstractProvider.prototype.constructor.call(this, options);
        };

        /***************************************************************************************************/

        /**
         * Load JSON file and call handleFeatures
         * @function loadFiles
         * @memberOf OpenSearchProvider.prototype
         * @param mizarLayer Mizar layer
         * @param configuration Url to JSON containing feature collection in equatorial coordinates
         */
        OpenSearchProvider.prototype.loadFiles = function (mizarLayer, configuration, startIndex) {
            $.ajax({
                type: "GET",
                url: configuration.url + "startIndex=" + startIndex + "&count=500",
                success: function (response) {
                    self.handleFeatures(mizarLayer, configuration, startIndex, response)
                },
                error: function (xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            });
        };

        /***************************************************************************************************/

        /**
         * Transform response into GeoJSON format and add to the layer
         * @function handleFeatures
         * @memberOf OpenSearchProvider.prototype
         * @param {object} mizarLayer
         * @param {object} response
         */
        OpenSearchProvider.prototype.handleFeatures = function (mizarLayer, configuration, startIndex, response) {
            JsonProcessor.handleFeatureCollection(mizarLayer, response);
            mizarLayer.addFeatureCollection(response);
            if (startIndex + response.features.length < response.totalResults) {
                self.loadFiles(mizarLayer, configuration.url, startIndex + response.features.length);
            }
        };

        /***************************************************************************************************/

        return OpenSearchProvider;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/PlanetProvider',["jquery", "./AbstractProvider", "../Renderer/FeatureStyle", "../Utils/Constants"],
    function ($, AbstractProvider, FeatureStyle, Constants) {

        var self;
        var interval;
        var poiFeatureCollection;
        var DEGS = 180 / Math.PI;                  // convert radians to degrees
        var RADS = Math.PI / 180;                  // convert degrees to radians
        var EPS = 1.0e-12;                        // machine error constant
        var pname = new Array("Mercury", "Venus", "Sun",
            "Mars", "Jupiter", "Saturn",
            "Uranus", "Neptune", "Pluto");

        function frealstr(num, width, fract) {
            var str = num.toFixed(fract);
            var len = str.length;
            var real = "";
            var i;

            for (i = 0; i < width - len; i++) {   // append leading spaces
                real += ' ';
            }

            for (i = 0; i < len; i++) {            // append digits
                real += str.charAt(i);
            }

            return real;
        }

        /*
         * Json template for a point
         */
        function poiDesc(mizarLayer, type, name, obj) {
            var style;
            if (type === Constants.GEOMETRY.Point) {
                style = new FeatureStyle({
                    iconUrl: mizarLayer.style.iconUrl,
                    strokeColor: FeatureStyle.fromStringToColor(obj.color),
                    fillColor: FeatureStyle.fromStringToColor(obj.color)
                });
            } else {
                style = new FeatureStyle({
                    label: name,
                    strokeColor: FeatureStyle.fromStringToColor(obj.color),
                    fillColor: FeatureStyle.fromStringToColor(obj.color)
                });
            }
            return {
                geometry: {
                    type: Constants.GEOMETRY.Point,
                    gid: "planet" + type + "_" + name,
                    coordinates: [obj.ra, obj.dec],
                    crs: {
                        type: "name",
                        properties: {
                            name: Constants.CRS.Equatorial
                        }
                    }
                },
                properties: {
                    name: name,
                    distance: frealstr(obj.rvec, 9, 6) + " AU",
                    style: style
                }
            };
        }

        // right ascension, declination coordinate structure
        function Coord() {
            this.ra = parseFloat("0");              // right ascension [deg]
            this.dec = parseFloat("0");              // declination [deg]
            this.rvec = parseFloat("0");              // distance [AU]
        }


        // day number to/from J2000 (Jan 1.5, 2000)
        function day_number(y, m, d, hour, mins) {
            var h = hour + mins / 60;
            return 367 * y - Math.floor(7 * (y + Math.floor((m + 9) / 12)) / 4) + Math.floor(275 * m / 9) + d - 730531.5 + h / 24;
        }

        /**************************************************************************************************************/

        // orbital element structure
        function Elem() {
            this.color = "";				 // color of the planet
            this.a = parseFloat("0");                 // semi-major axis [AU]
            this.e = parseFloat("0");                 // eccentricity of orbit
            this.i = parseFloat("0");                 // inclination of orbit [deg]
            this.O = parseFloat("0");                 // longitude of the ascending node [deg]
            this.w = parseFloat("0");                 // longitude of perihelion [deg]
            this.L = parseFloat("0");                 // mean longitude [deg]
        }

        // return the integer part of a number
        function abs_floor(x) {
            var r;
            if (x >= 0.0) {
                r = Math.floor(x);
            }
            else {
                r = Math.ceil(x);
            }
            return r;
        }

        // return an angle in the range 0 to 2pi radians
        function mod2pi(x) {
            var b = x / (2 * Math.PI);
            var a = (2 * Math.PI) * (b - abs_floor(b));
            if (a < 0) {
                a = (2 * Math.PI) + a;
            }
            return a;
        }

        // compute the true anomaly from mean anomaly using iteration
        //  M - mean anomaly in radians
        //  e - orbit eccentricity
        function true_anomaly(M, e) {
            var V, E1;

            // initial approximation of eccentric anomaly
            var E = M + e * Math.sin(M) * (1.0 + e * Math.cos(M));

            do                                   // iterate to improve accuracy
            {
                E1 = E;
                E = E1 - (E1 - e * Math.sin(E1) - M) / (1 - e * Math.cos(E1));
            }
            while (Math.abs(E - E1) > EPS);

            // convert eccentric anomaly to true anomaly
            V = 2 * Math.atan(Math.sqrt((1 + e) / (1 - e)) * Math.tan(0.5 * E));

            if (V < 0) {
                V = V + (2 * Math.PI);
            }      // modulo 2pi

            return V;
        }
        
        /**
         * Computes the elements of the orbit for planet-i at day number-d
         * @param p - result
         * @param i - planet-i
         * @param d - day number
         * @throws {RangeError} function mean_elements() failed!
         */
        function mean_elements(p, i, d) {
            var cy = d / 36525;                    // centuries since J2000

            switch (i) {
                case 0: // Mercury
                    p.color = "rgb(170,150,170)";
                    p.a = 0.38709893 + 0.00000066 * cy;
                    p.e = 0.20563069 + 0.00002527 * cy;
                    p.i = ( 7.00487 - 23.51 * cy / 3600) * RADS;
                    p.O = (48.33167 - 446.30 * cy / 3600) * RADS;
                    p.w = (77.45645 + 573.57 * cy / 3600) * RADS;
                    p.L = mod2pi((252.25084 + 538101628.29 * cy / 3600) * RADS);
                    break;
                case 1: // Venus
                    p.color = "rgb(245,222,179)";
                    p.a = 0.72333199 + 0.00000092 * cy;
                    p.e = 0.00677323 - 0.00004938 * cy;
                    p.i = (  3.39471 - 2.86 * cy / 3600) * RADS;
                    p.O = ( 76.68069 - 996.89 * cy / 3600) * RADS;
                    p.w = (131.53298 - 108.80 * cy / 3600) * RADS;
                    p.L = mod2pi((181.97973 + 210664136.06 * cy / 3600) * RADS);
                    break;
                case 2: // Earth/Sun
                    p.color = "rgb(255,193,37)";
                    p.a = 1.00000011 - 0.00000005 * cy;
                    p.e = 0.01671022 - 0.00003804 * cy;
                    p.i = (  0.00005 - 46.94 * cy / 3600) * RADS;
                    p.O = (-11.26064 - 18228.25 * cy / 3600) * RADS;
                    p.w = (102.94719 + 1198.28 * cy / 3600) * RADS;
                    p.L = mod2pi((100.46435 + 129597740.63 * cy / 3600) * RADS);
                    break;
                case 3: // Mars
                    p.color = "rgb(255,50,50)";
                    p.a = 1.52366231 - 0.00007221 * cy;
                    p.e = 0.09341233 + 0.00011902 * cy;
                    p.i = (  1.85061 - 25.47 * cy / 3600) * RADS;
                    p.O = ( 49.57854 - 1020.19 * cy / 3600) * RADS;
                    p.w = (336.04084 + 1560.78 * cy / 3600) * RADS;
                    p.L = mod2pi((355.45332 + 68905103.78 * cy / 3600) * RADS);
                    break;
                case 4: // Jupiter
                    p.color = "rgb(255,150,150)";
                    p.a = 5.20336301 + 0.00060737 * cy;
                    p.e = 0.04839266 - 0.00012880 * cy;
                    p.i = (  1.30530 - 4.15 * cy / 3600) * RADS;
                    p.O = (100.55615 + 1217.17 * cy / 3600) * RADS;
                    p.w = ( 14.75385 + 839.93 * cy / 3600) * RADS;
                    p.L = mod2pi((34.40438 + 10925078.35 * cy / 3600) * RADS);
                    break;
                case 5: // Saturn
                    p.color = "rgb(200,150,150)";
                    p.a = 9.53707032 - 0.00301530 * cy;
                    p.e = 0.05415060 - 0.00036762 * cy;
                    p.i = (  2.48446 + 6.11 * cy / 3600) * RADS;
                    p.O = (113.71504 - 1591.05 * cy / 3600) * RADS;
                    p.w = ( 92.43194 - 1948.89 * cy / 3600) * RADS;
                    p.L = mod2pi((49.94432 + 4401052.95 * cy / 3600) * RADS);
                    break;
                case 6: // Uranus
                    p.color = "rgb(130,150,255)";
                    p.a = 19.19126393 + 0.00152025 * cy;
                    p.e = 0.04716771 - 0.00019150 * cy;
                    p.i = (  0.76986 - 2.09 * cy / 3600) * RADS;
                    p.O = ( 74.22988 - 1681.40 * cy / 3600) * RADS;
                    p.w = (170.96424 + 1312.56 * cy / 3600) * RADS;
                    p.L = mod2pi((313.23218 + 1542547.79 * cy / 3600) * RADS);
                    break;
                case 7: // Neptune
                    p.color = "rgb(100,100,255)";
                    p.a = 30.06896348 - 0.00125196 * cy;
                    p.e = 0.00858587 + 0.00002510 * cy;
                    p.i = (  1.76917 - 3.64 * cy / 3600) * RADS;
                    p.O = (131.72169 - 151.25 * cy / 3600) * RADS;
                    p.w = ( 44.97135 - 844.43 * cy / 3600) * RADS;
                    p.L = mod2pi((304.88003 + 786449.21 * cy / 3600) * RADS);
                    break;
                case 8: // Pluto
                    p.color = "rgb(100,100,255)";
                    p.a = 39.48168677 - 0.00076912 * cy;
                    p.e = 0.24880766 + 0.00006465 * cy;
                    p.i = ( 17.14175 + 11.07 * cy / 3600) * RADS;
                    p.O = (110.30347 - 37.33 * cy / 3600) * RADS;
                    p.w = (224.06676 - 132.25 * cy / 3600) * RADS;
                    p.L = mod2pi((238.92881 + 522747.90 * cy / 3600) * RADS);
                    break;
                default:
                    throw RangeError("function mean_elements() failed!", "PlanetProvider.js");
            }
        }

        // compute RA, DEC, and distance of planet-p for day number-d
        // result returned in structure obj in degrees and astronomical units
        function get_coord(obj, p, d) {
            var planet = new Elem();
            mean_elements(planet, p, d);
            var ap = planet.a;
            var ep = planet.e;
            var ip = planet.i;
            var op = planet.O;
            var pp = planet.w;
            var lp = planet.L;

            var earth = new Elem();
            mean_elements(earth, 2, d);
            var ae = earth.a;
            var ee = earth.e;
            //var ie = earth.i;
            //var oe = earth.O;
            var pe = earth.w;
            var le = earth.L;

            // position of Earth in its orbit
            var me = mod2pi(le - pe);
            var ve = true_anomaly(me, ee);
            var re = ae * (1 - ee * ee) / (1 + ee * Math.cos(ve));

            // heliocentric rectangular coordinates of Earth
            var xe = re * Math.cos(ve + pe);
            var ye = re * Math.sin(ve + pe);
            var ze = 0.0;

            // position of planet in its orbit
            var mp = mod2pi(lp - pp);
            var vp = true_anomaly(mp, planet.e);
            var rp = ap * (1 - ep * ep) / (1 + ep * Math.cos(vp));

            // heliocentric rectangular coordinates of planet
            var xh = rp * (Math.cos(op) * Math.cos(vp + pp - op) - Math.sin(op) * Math.sin(vp + pp - op) * Math.cos(ip));
            var yh = rp * (Math.sin(op) * Math.cos(vp + pp - op) + Math.cos(op) * Math.sin(vp + pp - op) * Math.cos(ip));
            var zh = rp * (Math.sin(vp + pp - op) * Math.sin(ip));

            if (p === 2)                          // earth --> compute sun
            {
                xh = 0;
                yh = 0;
                zh = 0;
            }

            // convert to geocentric rectangular coordinates
            var xg = xh - xe;
            var yg = yh - ye;
            var zg = zh - ze;

            // rotate around x axis from ecliptic to equatorial coords
            var ecl = 23.439281 * RADS;            //value for J2000.0 frame
            var xeq = xg;
            var yeq = yg * Math.cos(ecl) - zg * Math.sin(ecl);
            var zeq = yg * Math.sin(ecl) + zg * Math.cos(ecl);

            // find the RA and DEC from the rectangular equatorial coords
            obj.ra = mod2pi(Math.atan2(yeq, xeq)) * DEGS;
            obj.dec = Math.atan(zeq / Math.sqrt(xeq * xeq + yeq * yeq)) * DEGS;
            obj.rvec = Math.sqrt(xeq * xeq + yeq * yeq + zeq * zeq);
            obj.color = planet.color;
        }

        /**
         *    Handle features on layer
         */
        var computePositions = function (mizarLayer) {
            var pois = [];
            var now = new Date();
            var year = now.getUTCFullYear();
            var month = now.getUTCMonth() + 1;
            var day = now.getUTCDate();
            var hour = now.getUTCHours();
            var mins = now.getUTCMinutes();
            var secs = now.getUTCSeconds();

            // compute day number for date/time
            var dn = day_number(year, month, day, hour, mins + secs / 60);
            var obj = new Coord();
            // compute location of objects
            for (var p = 0; p < 9; p++) {
                get_coord(obj, p, dn);
                // Add label
                var poi_label = poiDesc(mizarLayer, "Label", pname[p], obj);
                pois.push(poi_label);

                // Add point itself
                var poi_point = poiDesc(mizarLayer, Constants.GEOMETRY.Point, pname[p], obj);
                pois.push(poi_point);

            }

            // Create feature collection
            poiFeatureCollection = {
                type: "FeatureCollection",
                features: pois
            };

            mizarLayer.addFeatureCollection(poiFeatureCollection);
        };


        /**************************************************************************************************************/

        /**
         * @name PlanetProvider
         * @class
         *    Providing planet positions based on ephemeris computations
         * @param {Object} options
         * @augments AbstractProvider
         * @constructor
         * @memberOf module:Provider
         * @see http://www.abecedarical.com/javascript/script_planet_orbits.html
         */

        var PlanetProvider = function (options) {
            AbstractProvider.prototype.constructor.call(this, options);
            self = this;
        };


        /**
         * Loads files
         * @param {Layer} layer - Mizar layer
         * @param {Object} configuration - configuration
         * @param {int} [configuration.interval = 60000] - Recomputes planet position every minute if not defined
         * @memberOf PlanetProvider#
         */
        PlanetProvider.prototype.loadFiles = function (layer, configuration) {
            interval = configuration.interval ? configuration.interval : 60000;
            self.handleFeatures(layer);
        };

        /**
         * Calculate planets position and add them to the passed layer
         * @function handleFeatures
         * @memberOf PlanetProvider#
         * @param {Layer} layer
         */
        PlanetProvider.prototype.handleFeatures = function (layer) {
            computePositions(layer);
            setInterval(function () {
                layer.removeFeatureCollection(poiFeatureCollection);
                computePositions(layer);
            }, interval);
        };

        return PlanetProvider;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Provider/StarProvider',["jquery", "./AbstractProvider", "../Renderer/FeatureStyle", "../Utils/Utils","../Utils/Constants"],
    function ($, AbstractProvider, FeatureStyle, Utils, Constants) {

        var namesFile;
        var catalogueFile;
        var self;

        /*
         * 	Failure function
         */
        function failure() {
            console.error("Failed to load files");
        }

         /**
          * @name StarProvider
          * @class
          *    Specific star catalogue provider of the Brightest Stars (Ochsenbein+ 1988) from VizieR database
          * @param {object} options
          * @augments AbstractProvider
          * @constructor
          * @memberOf module:Provider
          * @see Search Catalogue of the Brightest Stars (Ochsenbein+ 1988) in VizieR database for more details
          */
        var StarProvider = function (options) {
            AbstractProvider.prototype.constructor.call(this, options);
            self = this;
        };

        /**************************************************************************************************************/

        Utils.inherits(AbstractProvider, StarProvider);

        /**************************************************************************************************************/

        /**
         * Asynchronous requests to load star database
         * @function loadFiles
         * @memberOf StarProvider.prototype
         * @param {Layer} mizarLayer - Mizar layer
         * @param {Object} configuration - Configuration options
         * @param {string} configuration.nameUrl - Url providing the stars name data
         * @param {string} configuration.catalogueUrl - Url providing all information about each star
         */
        StarProvider.prototype.loadFiles = function (mizarLayer, configuration) {
            if (configuration.nameUrl && configuration.catalogueUrl) {
                var nameRequest = {
                    type: "GET",
                    url: configuration.nameUrl,
                    success: function (response) {
                        namesFile = response;
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        console.error(xhr.responseText);
                    }
                };

                var catalogueRequest = {
                    type: "GET",
                    url: configuration.catalogueUrl,
                    success: function (response) {
                        catalogueFile = response;
                    },
                    error: function (xhr, ajaxOptions, thrownError) {
                        console.error(xhr.responseText);
                    }
                };

                // Synchronizing two asynchronious requests with the same callback
                $.proxy($.when($.ajax(nameRequest), $.ajax(catalogueRequest))
                    .then(function () {
                        self.handleFeatures(mizarLayer);
                    }, failure));
            }
            else {
                console.error("Not valid options");
                return null;
            }
        };


        /**
         * Handle features on layer
         * @function handleFeatures
         * @memberOf StarProvider#
         * @param {Layer} mizarLayer
         */
        StarProvider.prototype.handleFeatures = function (mizarLayer) {
            // Extract the table data
            var tmpTab = namesFile.slice(namesFile.indexOf("897;Acamar"), namesFile.indexOf('1231;Zaurak') + 11);
            var namesTab = tmpTab.split("\n");
            tmpTab = catalogueFile.slice(catalogueFile.indexOf("001."), catalogueFile.indexOf("4.98;K3Ibv") + 10);
            var catalogueTab = tmpTab.split("\n");
            var pois = [];

            // For each known star
            for (var i = 0; i < namesTab.length; i++) {
                var word = namesTab[i].split(";"); // word[0] = HR, word[1] = name;
                var HR = parseInt(word[0], 10);
                var starName = word[1];

                // Search corresponding HR in catalogue
                for (var j = 0; j < catalogueTab.length; j++) {
                    word = catalogueTab[j].split(";");
                    if (parseInt(word[2], 10) === HR) {
                        // Star found in the catalogue

                        var raString = word[6];   // right ascension format : "hours minutes seconds"
                        var declString = word[7]; // declinaton format : "degrees minutes seconds"

                        var geo = [];
                        mizarLayer.globe.getCoordinateSystem().getDecimalDegFromSexagesimal([raString, declString], geo);

                        // Add poi layer
                        var poi = {
                            geometry: {
                                type: Constants.GEOMETRY.Point,
                                gid: "star_" + starName,
                                coordinates: [geo[0], geo[1]],
                                crs: {
                                    type: "name",
                                    properties: {
                                        name: Constants.CRS.Equatorial
                                    }
                                }
                            },
                            properties: {
                                name: starName,
                                style: new FeatureStyle({label: starName, fillColor: [1.0, 1.0, 1.0, 1.0]})
                            }
                        };
                        pois.push(poi);
                    }
                }
            }

            // Create feature collection
            var poiFeatureCollection = {
                type: "FeatureCollection",
                features: pois
            };

            mizarLayer.addFeatureCollection(poiFeatureCollection);
        };

        /**************************************************************************************************************/

        return StarProvider;

    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Provider/CraterProvider',['jquery', './AbstractProvider', '../Utils/Utils', '../Renderer/FeatureStyle'],
    function ($, AbstractProvider, Utils, FeatureStyle) {

        var self;
        var featureCollection;

        /**
         * @name CraterProvider
         * @class
         *   Displays the name of the crater
         * @param {object} options
         * @augments AbstractProvider
         * @constructor
         * @memberOf module:Provider
         */
        var CraterProvider = function (options) {
            AbstractProvider.prototype.constructor.call(this, options);
            self = this;
        };

        /*******************************************************************************/
        Utils.inherits(AbstractProvider, CraterProvider);
        /*******************************************************************************/

        /**
         * @function loadFiles
         * @param {Layer} layer - mizar Layer
         * @param {Object} configuration - configuration
         * @param {string} configuration.url - URL of the GeoJSON file
         * @memberOf CraterProvider#
         */
        CraterProvider.prototype.loadFiles = function (layer, configuration) {
            $.ajax({
                type: "GET",
                url: configuration.url,
                success: function (response) {
                    featureCollection = response;
                    self.handleFeatures(layer);
                },
                error: function (xhr, ajaxOptions, thrownError) {
                    console.error(xhr.responseText);
                }
            });

        };

        /**
         * @function handleFeatures
         * @param {Layer} layer - mizar layer
         * @memberOf CraterProvider#
         */
        CraterProvider.prototype.handleFeatures = function (layer) {
            var crs = featureCollection.crs;
            var features = featureCollection.features;
            var ptMaxSize = (layer.options.pointMaxSize) ? layer.options.pointMaxSize : 20;
            for (var i = 0; i < features.length; i++) {
                var currentFeature = features[i];
                currentFeature.geometry['crs'] = crs;
                var craterName = currentFeature.properties.name;
                currentFeature.properties['style'] =  new FeatureStyle(
                    {
                        label: craterName,
                        fillColor: [1.0, 1.0, 1.0, 1.0],
                        pointMaxSize : ptMaxSize
                    }
                );
            }
            layer.addFeatureCollection(featureCollection);
        };

        return CraterProvider;
    });

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
define('Provider/ProviderFactory',["./ConstellationProvider","./OpenSearchProvider","./PlanetProvider","./StarProvider","./CraterProvider","../Utils/Constants"],
    function(ConstellationProvider, OpenSearchProvider, PlanetProvider, StarProvider, CraterProvider, Constants) {
        

    return {
        
        create : function(type, options) {

            var obj;
            switch(type) {
                case Constants.PROVIDER.Constellation:
                    obj = new ConstellationProvider(options);
                    break;
                case Constants.PROVIDER.Crater:
                    obj = new CraterProvider(options);
                    break;
                case Constants.PROVIDER.OpenSearch:
                    obj = new OpenSearchProvider(options);
                    break;
                case Constants.PROVIDER.Planet:
                    obj = new PlanetProvider(options);
                    break;
                case Constants.PROVIDER.Star:
                    obj = new StarProvider(options);
                    break;
                default:
                    throw new RangeError("unable to create the provider "+type, "ProviderFactory.js");
            }
            return obj;
        }
        
    }
    
});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/***************************************
 * Copyright 2011, 2012 GlobWeb contributors.
 *
 * This file is part of GlobWeb.
 *
 * GlobWeb is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, version 3 of the License, or
 * (at your option) any later version.
 *
 * GlobWeb is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GlobWeb. If not, see <http://www.gnu.org/licenses/>.
 ***************************************/

define('Utils/Stats',[],function () {
    /**
     @name Stats
     @class
         Display some rendering statistics in a HTML element
     @param {Context} Context
     @param {Object} options - Configuration properties for Stats.
     @param {Object} [options.element] - the HTML element to receivce statistcs, can be a string (the ID) or the DOM element itself
     @param {boolean] {[options.verbose=false] - the verbosity of the stats, default is false
     @constructor
    */
    var Stats = function (context, options) {
        this.type = null;
        context.getRenderContext().stats = this;
        //context.globe.renderContext.stats = this;
        this.context = context;
        var elt = options ? options.element : undefined;
        if (elt) {
            if (typeof elt === "string") {
                this.element = document.getElementById(elt);
                this.type = "dom";
            }
            else {
                this.element = elt;
                this.type = "jquery";
            }
        }



        this.showFPS = this.context.globe.continuousRendering;
        this.verbose = options && options.verbose ? options.verbose : false;
        this.numFrames = 0;

        var self = this;
        window.setInterval(function () {
            self.print();
        }, 1000);
    };

    /**************************************************************************************************************/

    /**
     Start measuring time
     */
    Stats.prototype.start = function (name) {
        this[name] = Date.now();
    };

    /**************************************************************************************************************/

    /**
     End measuring time
     */
    Stats.prototype.end = function (name) {
        var time = Date.now() - this[name];

        var max = this["max_" + name] || -1;
        if (max < time) {
          max = time;
        }

        var sum = this["sum_" + name] || 0;
        sum += time;

        this[name] = time;
        this["max_" + name] = max;
        this["sum_" + name] = sum;
        if (name === "globalRenderTime") {
            this.numFrames++;
        }
    };

    /**************************************************************************************************************/

    /**
     Print stats in an HTML element
     */
    Stats.prototype.print = function () {
        if (this.numFrames > 0) {
            var content = "";

            if (this.showFPS) {
                content += "FPS : " + this.numFrames + "<br>";
            }

            content += "Average render time : " + (this.sum_globalRenderTime / this.numFrames).toFixed(2) + " ms";
            // FIXME: currently count stats for the first renderer in render context
            /*if (this.context.globe.renderContext.renderers[0].getRenderStats) {
                content += "<br>" + this.renderContext.renderers[0].getRenderStats();
            }
            */
            if (this.verbose) {
                content += "<br>Average traverse tiles time : " + (this.sum_traverseTime / this.numFrames).toFixed(2) + " ms";
                content += "<br>Average render tiles time : " + (this.sum_renderTime / this.numFrames).toFixed(2) + " ms";
                content += "<br>Average generate tiles time : " + (this.sum_generateTime / this.numFrames).toFixed(2) + " ms";
                content += "<br>Average request tiles time : " + (this.sum_requestTime / this.numFrames).toFixed(2) + " ms";
                content += "<br>Max render time : " + this.max_globalRenderTime + " ms";
                content += "<br>Max traverse tiles time : " + this.max_traverseTime + " ms";
                content += "<br>Max render tiles time : " + this.max_renderTime + " ms";
                content += "<br>Max generate tiles time : " + this.max_generateTime + " ms";
                content += "<br>Max request tiles time : " + this.max_requestTime + " ms";
            }

            if (this.element) {
              if (this.type === "dom") {
                this.element.innerHTML = content;
              } else if (this.type === "jquery") {
                this.element.html(content);
              }
            }

            this.sum_globalRenderTime = 0;
            this.sum_traverseTime = 0;
            this.sum_renderTime = 0;
            this.sum_generateTime = 0;
            this.sum_requestTime = 0;
            this.max_globalRenderTime = 0;
            this.max_traverseTime = 0;
            this.max_renderTime = 0;
            this.max_generateTime = 0;
            this.max_requestTime = 0;
            this.numFrames = 0;
        }
    };

    /**************************************************************************************************************/

    return Stats;

});

/*******************************************************************************
 * Copyright 2017 CNES - CENTRE NATIONAL d'ETUDES SPATIALES
 *
 * This file is part of MIZAR.
 *
 * MIZAR is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * MIZAR is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with MIZAR. If not, see <http://www.gnu.org/licenses/>.
 ******************************************************************************/
/**
 * @fileOverview Entry point for the {@link Mizar MIZAR API}
 * @version 1.0 (beta)
 * @author CNES
 */
define('Mizar',["jquery", "underscore-min",
        "./Context/ContextFactory", "./Navigation/NavigationFactory", "./Layer/LayerFactory", "./Crs/CoordinateSystemFactory",
        "./Animation/AnimationFactory", "./Utils/UtilityFactory", "./Services/ServiceFactory", "./Provider/ProviderFactory",
        "./Utils/Utils", "./Utils/Event", "./Utils/Stats", "./Utils/Constants", "./Gui/dialog/ErrorDialog", "./Layer/HipsMetadata"],
    function ($, _,
              ContextFactory, NavigationFactory, LayerFactory, CoordinateSystemFactory,
              AnimationFactory, UtilityFactory, ServiceFactory, ProviderFactory,
              Utils, Event, Stats, Constants, ErrorDialog, HipsMetadata) {

        //TODO bug : shortest path
        //TODO : charger cratere Mars et l'afficher à un certain niveau de zoom => fonctionne par FeatureStyle
        //TODO : calculer le getFov pour la navigation de type "Planet" pour en déduire le FOV en fonction du level de Geotiling
        //TODO : Elevation KO quand projection 2D

        /**
         * @constant
         * @type {string}
         */
        const API_VERSION = "1.0.0";

        /**
         * @constant
         * @type {number}
         */
        const ANGLE_CAMERA_POLE = 30.0;

        /**
         * @constant
         * @type {string}
         */
        const MIZAR_NAME_PROD = "Mizar.min";

        /**
         * @constant
         * @type {string}
         */
        const MIZAR_NAME_DEV = "Mizar.";

        /**
         * Input Mizar parameters
         * @typedef {Object} Mizar.inputParameters
         * @property {Object|string} canvas - div ID or div element
         * @property {Mizar.inputConfiguration} [configuration] - Mizar global configuration
         * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
         * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
         * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
         */

        /**
         * Mizar parameters
         * @typedef {Object} Mizar.parameters
         * @property {Object|string} canvas - div ID or div element
         * @property {Mizar.configuration} [configuration] - Mizar global configuration
         * @property {AbstractContext.skyContext} [skyContext] - Sky context configuration
         * @property {AbstractContext.planetContext} [planetContext] - Planet context configuration
         * @property {AbstractContext.groundContext} [groundContext] - Ground context configuration
         */

        /**
         * Mizar configuration
         * @typedef {Object} Mizar.inputConfiguration
         * @property {string} [mizarBaseUrl] - Used to access to MizarWidget resources
         * @property {boolean} [debug = false] - Debug mode
         * @property {boolean} [isMobile = false] - Mobile support
         * @property {AbstractTracker.position_configuration} [positionTracker] - Position tracker configuration
         * @property {AbstractTracker.elevation_configuration} [elevationTracker] - Elevation tracker configuration
         * @property {Object} [registry] - Hips service registry
         * @property {string} registry.hips - Hips Registry
         * @property {boolean} [proxyUse=False] - Uses a proxy to send request
         * @property {string} [proxyUrl] - Proxy URL to use when proxyUse is true. This is used to avoid CORS errors.
         */

        /**
         * Mizar configuration
         * @typedef {Mizar.inputConfiguration} Mizar.configuration
         * @property {string} mizarAPIUrl - URL of this script, used to reference shaders and CSS of Mizar API
         */

        /**
         * @name Mizar
         * @class
         * Creates an instance of the Mizar API.
         * @param {Mizar.inputParameters} options - Configuration for Mizar
         * @throws {ReferenceError} No option found
         * @throws {TypeError} Canvas not defined
         * @constructor
         */
        var Mizar = function (options) {
            Event.prototype.constructor.call(this);

            _checkConfiguration(options);
            this.options = _createConfiguration(options);

            // Init all factories
            /**
             * Creates a {@link module:Context.ContextFactory Context}
             * @name ContextFactory
             * @memberOf Mizar#
             * @private
             */
            this.ContextFactory = ContextFactory;

            /**
             * Creates a {@link module:Layer.LayerFactory Layer}
             * @name LayerFactory
             * @memberOf Mizar#
             * @private
             */
            this.LayerFactory = LayerFactory;

            // Set proxy parameters to Layer factory
            this.LayerFactory.proxy = {
                url: this.options.configuration.proxyUrl,
                // Sets to false when proxyUse is undefined or null
                use: this.options.configuration.proxyUse == null ? false : this.options.configuration.proxyUse
            };

            proxy = this.LayerFactory.proxy;

            /**
             * Creates an {@link module:Animation.AnimationFactory animation}
             * @name AnimationFactory
             * @memberOf Mizar#
             */
            this.AnimationFactory = AnimationFactory;

            /**
             * Creates a service
             * @name ServiceFactory
             * @memberOf Mizar#
             */
            this.ServiceFactory = ServiceFactory;

            /**
             * Creates an utility
             * @name UtilityFactory
             * @memberOf Mizar#
             * @private
             */
            this.UtilityFactory = UtilityFactory;

            /**
             * Creates a provider
             * @name ProviderFactory
             * @memberOf Mizar#
             */
            this.ProviderFactory = ProviderFactory;

            this.skyContext = null;
            this.planetContext = null;
            this.groundContext = null;
            this.activatedContext = null;
            this.renderContext = null;
            this.dataProviders = {};

            if (options.skyContext) {
                this.createContext(Mizar.CONTEXT.Sky, options.skyContext);
                this.setActivatedContext(Mizar.CONTEXT.Sky);
            }

            if (options.planetContext) {
                this.createContext(Mizar.CONTEXT.Planet, options.planetContext);
                this.setActivatedContext(Mizar.CONTEXT.Planet)
            }

            if (options.groundContext) {
                this.createContext(Mizar.CONTEXT.Ground, options.planetContext);
                this.setActivatedContext(Mizar.CONTEXT.Ground);
            }

        };

        /**********************************************************************************************************
         *                                      Static variables
         **********************************************************************************************************/

        /**
         * Static variable, API version.<br/>
         * [SemVer]{@link http://semver.org/} concept is used for versioning
         * @name VERSION
         * @memberOf Mizar#
         */
        Mizar.VERSION = API_VERSION;

        /**
         * Static variable, supported {@link ANIMATION animation} type
         * @name ANIMATION
         * @memberOf Mizar#
         */
        Mizar.ANIMATION = Constants.ANIMATION;

        /**
         * Static variable, supported {@link LAYER layer} type
         * @name LAYER
         * @memberOf Mizar#
         */
        Mizar.LAYER = Constants.LAYER;

        /**
         * Static variable, supported {@link GEOMETRY geometry} type
         * @name GEOMETRY
         * @memberOf Mizar#
         */
        Mizar.GEOMETRY = Constants.GEOMETRY;

        /**
         * Static variable, supported {@link NAVIGATION navigation} type
         * @name NAVIGATION
         * @memberOf Mizar#
         */
        Mizar.NAVIGATION = Constants.NAVIGATION;

        /**
         * Static variable, supported {@link CONTEXT context} type
         * @name CONTEXT
         * @memberOf Mizar#
         */
        Mizar.CONTEXT = Constants.CONTEXT;

        /**
         * Static variable, supported {@link PROJECTION projection} type
         * @name PROJECTION
         * @memberOf Mizar#
         */
        Mizar.PROJECTION = Constants.PROJECTION;

        /**
         * Static variable, supported {@link CRS coordinate reference system} type
         * @name CRS
         * @memberOf Mizar#
         */
        Mizar.CRS = Constants.CRS;

        /**
         * Static variable, supported {@link SERVICE service} type
         * @name SERVICE
         * @memberOf Mizar#
         */
        Mizar.SERVICE = Constants.SERVICE;

        /**
         * Static variable, supported {@link UTILITY utility} type
         * @name UTILITY
         * @memberOf Mizar#
         */
        Mizar.UTILITY = Constants.UTILITY;

        /**
         * Static variable, supported {@link PROVIDER provider} type
         * @name PROVIDER
         * @memberOf Mizar#
         */
        Mizar.PROVIDER = Constants.PROVIDER;


        /**********************************************************************************************************
         *                                      Private methods
         **********************************************************************************************************/

        /**
         * Returns the script object that contains the URL of this script
         * @param {Object[]} scripts - All the scripts from the document where Mizar is imported
         * @param {MIZAR_NAME_PROD|MIZAR_NAME_DEV} scriptName - production or dev script name
         * @param {int} index - Number of range '/' to remove from the end of the URL
         * @private
         */
        function _extractURLFrom(scripts, scriptName, index) {
            var mizarSrc = _.find(scripts, function (script) {
                return (script.src.indexOf(scriptName) !== -1);
            });
            if (mizarSrc) {
                mizarSrc = mizarSrc.src.split('/').slice(0, index).join('/') + '/';
            }
            return mizarSrc;
        }

        /**
         * Return the base URL of this script.
         * @returns {string} the base URL
         * @private
         */
        function _getMizarAPIBaseURL() {
            var scripts = document.getElementsByTagName('script');
            return _extractURLFrom.call(this, scripts, MIZAR_NAME_PROD, -1) || _extractURLFrom.call(this, scripts, MIZAR_NAME_DEV, -2);
        }

        /**
         * Checks inputs
         * @param {Object} options - Mizar configuration
         * @throws {ReferenceError} No option found
         * @throws {TypeError} Canvas not defined
         * @function _checkConfiguration
         * @memberOf Mizar#
         * @private
         */
        function _checkConfiguration(options) {
            if (typeof options === 'undefined') {
                throw new ReferenceError('No option found', 'Mizar.js');
            } else if (typeof options.canvas === 'undefined') {
                throw new TypeError('Canvas not defined', 'Mizar.js');
            } else {
                // do nothing
            }
        }

        /**
         * Checks inputs from user and creates the mizar configuration
         * @param {Mizar.inputParameters} options inputs from user
         * @returns {Mizar.parameters} mizar configuration.
         * @function _createConfiguration
         * @memberOf Mizar#
         * @private
         */
        function _createConfiguration(options) {

            var mizarAPIUrl = _getMizarAPIBaseURL();
            var mizarOptions = {
                canvas: typeof options.canvas === "string" ? document.getElementById(options.canvas) : options.canvas
            };
            if (options.hasOwnProperty('configuration')) {
                mizarOptions['configuration'] = options.configuration;
            } else {
                mizarOptions['configuration'] = {};
            }
            mizarOptions['configuration']['mizarAPIUrl'] = mizarAPIUrl;
            if (options.hasOwnProperty('skyContext')) {
                mizarOptions['skyContext'] = options.skyContext;
            }
            if (options.hasOwnProperty('planetContext')) {
                mizarOptions['planetContext'] = options.planetContext;
            }
            if (options.hasOwnProperty('groundContext')) {
                mizarOptions['groundContext'] = options.groundContext;
            }
            return mizarOptions;
        }

        /**
         * Switch to a context
         * @param {AbstractContext} context - Target context
         * @param {Object} [options] - options management for the source context
         * @param {boolean} options.mustBeDestroyed=false - options management for the source context
         * @function _switchToContext
         * @memberOf Mizar#
         * @private
         */
        function _switchToContext(context, options) {
            var self = this;
            options = options || {};
            var mustBeDestroyed = options.hasOwnProperty("mustBeDestroyed") ? options.mustBeDestroyed : false;

            // Hide sky
            this.getActivatedContext().hide();

            // Hide all additional layers
            this.getActivatedContext().hideAdditionalLayers();

            var viewMatrix;
            var fov;
            if (context.hasOwnProperty("_oldVM") && context.hasOwnProperty("_oldFov")) {
                viewMatrix = context._oldVM;
                fov = context._oldFov;
            } else if (context.getNavigation().inverseViewMatrix === undefined) {
                this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
                this.getActivatedContext()._oldFov = this.renderContext.getFov();
                viewMatrix = context.getNavigation().getRenderContext().getViewMatrix();
                fov = 90;
            } else {
                this.getActivatedContext()._oldVM = this.renderContext.getViewMatrix();
                this.getActivatedContext()._oldFov = this.renderContext.getFov();
                viewMatrix = mat4.create();
                context.getNavigation().computeInverseViewMatrix();
                mat4.inverse(context.getNavigation().inverseViewMatrix, viewMatrix);
                fov =  90;
            }
            if(mustBeDestroyed) {
                this.getActivatedContext().destroy();
            } //else {
              //  this.getActivatedContext().trackerDestroy();
            //}
            context.positionTracker.detach();
            context.positionTracker.attachTo(context.globe);
            context.elevationTracker.detach();
            context.elevationTracker.attachTo(context.globe);
            this.activatedContext = context;
            context.getNavigation().toViewMatrix(viewMatrix, fov, 2000, function() {
                if(context) {
                    context.enable();
                }
                context.showAdditionalLayers();
                self.publish("mizarMode:toggle", context);
                self.getActivatedContext().show();
                self.getActivatedContext().refresh();
                if(self.getRenderContext().viewMatrix[0] !== "undefined") {
                    self.getActivatedContext().getNavigation().computeViewMatrix();
                }
            });
        }

        /**
         * Saves the atmosphere state and disable it when 2D is used
         * @function _disableAtmosphere
         * @memberOf Mizar#
         * @private
         */
        function _disableAtmosphere() {
            if (this.getActivatedContext()._atmosphereLayer !== undefined) {
                if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                    this.getActivatedContext()._saveAtmosphereVisible = this.getActivatedContext()._atmosphereLayer.visible;
                    this.getActivatedContext()._atmosphereLayer.setVisible(false);
                    this.render();
                }
            }
        }

        /**
         * Retrieves the atmosphere and enable it when 3D is used
         * @function _enableAtmosphere
         * @memberOf Mizar#
         * @private
         */
        function _enableAtmosphere() {
            if (this.getActivatedContext()._atmosphereLayer !== undefined) {
                if (this.getActivatedContext()._atmosphereLayer.globe !== null) {
                    this.getActivatedContext()._atmosphereLayer.setVisible(this.getActivatedContext()._saveAtmosphereVisible);
                    this.render();
                }
            }
        }

        /**
         * Switch 2D to 3D.
         * @function _switch2Dto3D
         * @memberOf Mizar#
         * @private
         */
        function _switch2Dto3D() {
            _enableAtmosphere.call(this);

            // Enable skyContext behind the planet
            if(this.skyContext) {
                this.skyContext.enable();
            }

            this.setCrs({geoideName: this.getCrs().getGeoideName()});

            // Check zoom level
            this.planetContext.navigation.zoom(0);
        }

        /**
         * Switch 3D to 2D.
         * @function _switch3Dto2D
         * @memberOf Mizar#
         * @private
         */
        function _switch3Dto2D() {
            _disableAtmosphere.call(this);

            // Disable skyContext
            if(this.skyContext) {
                this.skyContext.disable();
            }

            // If a pole is closed to the center of the canvas, this should mean that
            // the user is interested to the pole, so we switch to azimuth projection
            // instead of plate carrée projection
            _project2AzimuthOrPlate.call(this, this.getActivatedContext().navigation.getCenter());
        }

        /**
         * Selects the right projection according to the target of the camera.<br/>
         * When the angle of the target of the camera with a pole (north or south)
         * is inferior to ANGLE_CAMERA_POLE, then the azimuthal projection is selected
         * otherwise plate carrée is selected
         * @param {float[]} lookAt - target of the camera [longitude, latitude] in decimal degree
         * @function _project2AzimuthOrPlate
         * @memberOf Mizar#
         * @private
         */
        function _project2AzimuthOrPlate(lookAt) {
            if (lookAt !== null && 90 - Math.abs(lookAt[1]) <= ANGLE_CAMERA_POLE) {
                this.setCrs({
                    geoideName: this.getCrs().getGeoideName(),
                    projectionName: Mizar.PROJECTION.Azimuth,
                    pole: (Math.sign(lookAt[1]) > 0) ? "north" : "south"
                });
            } else {
                this.setCrs({
                    geoideName: this.getCrs().getGeoideName(),
                    projectionName: Mizar.PROJECTION.Plate
                });
            }
        }

        /**
         * Skip if sky mode
         * @function _skipIfSkyMode
         * @memberOf Mizar#
         * @throws {RangeError} Toggle Dimension is not implemented for Sky
         * @private
         */
        function _skipIfSkyMode() {
            if (this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky) {
                throw new RangeError("Toggle Dimension is not implemented for Sky", "Mizar.js");
            }
        }

        /**
         * Get service url from HIPS Layer
         * @function _getHipsServiceUrlArray
         * @memberOf Mizar#
         * @param hipsLayer
         * @returns {Array}
         * @private
         */
        function _getHipsServiceUrlArray(hipsLayer) {
            var hipsServiceUrlArray = [];

            if (hipsLayer.hips_service_url) {
                hipsServiceUrlArray.push(hipsLayer.hips_service_url);
            }
            if (hipsLayer.hips_service_url_1) {
                hipsServiceUrlArray.push(hipsLayer.hips_service_url_1);
            }
            if (hipsLayer.hips_service_url_2) {
                hipsServiceUrlArray.push(hipsLayer.hips_service_url_2);
            }
            return hipsServiceUrlArray;
        }

        /**
         * Proxify an url
         * @function _proxify
         * @memberOf Mizar#
         * @param {string} url - URL
         * @return {string} Url proxified
         * @private
         */
        function _proxify(url) {
            var proxifyUrl;
            if (proxy.use === true) {
                proxifyUrl = proxy.url + url;
            } else {
                proxifyUrl = url;
            }
            return proxifyUrl;
        }

        /**
         * Loads HIPS layers from passed service url
         * @function _checkHipsServiceIsAvailable
         * @memberOf Mizar#
         * @param {Array} hipsServiceUrlArray - HIPS service URL
         * @param {serviceRegistryCallback} callback - The callback that handles the response
         * @private
         */
        function _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback) {
            if (hipsServiceUrlArray.length === 0) {
                return callback(undefined);
            }
            var url = hipsServiceUrlArray.shift();

            $.ajax({
                type: 'GET',
                url: _proxify(url) + "/properties",
                dataType: 'text'
                //context: layerManager,
                //timeout: 10000
            }).done(function (data, status, xhr) {
                if (xhr.status === 200) {
                    return callback(url);
                }
            }).error(function () {
                _checkHipsServiceIsAvailable(hipsServiceUrlArray, callback);
            });
        }

        /**
         * Loads HIPS layers from passed service url
         * @function _loadHIPSLayers
         * @memberOf Mizar#
         * @param {Mizar} Mizar - Mizar API
         * @param {Options} [options] - Options
         * @param {string} [options.registry] - Registry
         * @param {string} [options.registry.hips] - Hips Registry
         * @private
         */
        function _loadHIPSLayers(Mizar, options) {
            if (typeof options !== 'undefined' && options.hasOwnProperty('registry') && options.registry.hasOwnProperty('hips')) {
                $.ajax({
                    type: 'GET',
                    url: _proxify(options.registry.hips),
                    context: Mizar,
                    dataType: 'json'

                }).fail(function(XMLHttpRequest, textStatus, errorThrown) {
                    ErrorDialog.open("<font style='color:orange'>Warning : Cannot connect to <b>" + options.registry.hips + "</b></font>");
                }).done(function (hipsLayersJSON) {
                    _.each(hipsLayersJSON, function (hipsLayer) {
                        var hipsServiceUrlArray = _getHipsServiceUrlArray(hipsLayer);
                        var hipsUrl = _checkHipsServiceIsAvailable(hipsServiceUrlArray, function (hipsServiceUrl) {
                            if (typeof hipsServiceUrl === 'undefined') {
                                var text = "";
                                if (typeof hipsLayer.obs_title === 'undefined') {
                                    text = "with ID <b>" + hipsLayer.ID + "</b>";
                                } else {
                                    text = "with title <b>" + hipsLayer.obs_title + "</b>";
                                }
                                ErrorDialog.open("<font style='color:orange'>Warning : Cannot add layer <b>" + text + "</b> no mirror available</font>");
                                return;
                            }
                            $.proxy(_createHips, Mizar)(hipsLayer, hipsServiceUrl);
                        });
                    }, Mizar);
                });
            }
        }


        /**
         * Creates a HIPS layer from registry
         * @function _createHips
         * @memberOf Mizar#
         * @param hipsLayer
         * @param hipsServiceUrl
         * @private
         */
        function _createHips(hipsLayer, hipsServiceUrl) {
            if (hipsLayer.hasOwnProperty("hips_status") && !hipsLayer.hips_status.match('public') === null) {
                return;
            }
            hipsLayer.hips_service_url = hipsServiceUrl;
            this.addLayer({type: Mizar.LAYER.Hips, hipsMetadata: new HipsMetadata(hipsLayer)});
        }

        /**************************************************************************************************************/

        Utils.inherits(Event, Mizar);

        /**************************************************************************************************************/

        /**************************************************************************************************************
         *                                          Public methods
         **************************************************************************************************************/

        //               ***************************** Members *****************************

        /**
         * Returns the sky context.
         * @returns {SkyContext|null}
         * @function getSkyContext
         * @memberOf Mizar#
         */
        Mizar.prototype.getSkyContext = function () {
            return this.skyContext;
        };

        /**
         * Returns the planet context.
         * @returns {PlanetContext|null}
         * @function getPlanetContext
         * @memberOf Mizar#
         */
        Mizar.prototype.getPlanetContext = function () {
            return this.planetContext;
        };

        /**
         * Returns the ground context.
         * @returns {GroundContext|null}
         * @function getGroundContext
         * @memberOf Mizar#
         */
        Mizar.prototype.getGroundContext = function () {
            return this.groundContext;
        };

        /**
         * Returns the context according to the mode.
         * @function _getContext
         * @param {CONTEXT|undefined} mode - the selected mode
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @returns {Context} the context
         * @private
         */
        function _getContext(mode) {
            var context;
            switch (mode) {
                case undefined:
                    context = this.getActivatedContext();
                    break;
                case Mizar.CONTEXT.Sky:
                    context = this.getSkyContext();
                    break;
                case Mizar.CONTEXT.Planet:
                    context = this.getPlanetContext();
                    break;
                case Mizar.CONTEXT.Ground:
                    context = this.getGroundContext();
                    break;
                default:
                    throw new RangeError("The mode " + mode + " is not allowed, A valid mode is included in the list CONTEXT", "Mizar.js");
            }
            return context;
        }

        /**
         * Returns the selected context.
         * When activatedContext is not set, it is set automatically to the created context
         * (in the following order : sky, planet, ground). When no context is created,
         * an  exception "No created context" is send.
         * @returns {PlanetContext|SkyContext|GroundContext|null}
         * @function getActivatedContext
         * @memberOf Mizar#
         */
        Mizar.prototype.getActivatedContext = function () {
            try {
                if (this.activatedContext == null) {
                    if (this.skyContext != null) {
                        this.activatedContext = this.skyContext;
                    } else if (this.planetContext != null) {
                        this.activatedContext = this.planetContext;
                    } else if (this.groundContext != null) {
                        this.activatedContext = this.groundContext;
                    } else {
                        throw new ReferenceError("No created context", "Mizar.js");
                    }
                }
            } catch(e) {
                ErrorDialog.open("Cannot get the context : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return this.activatedContext;
        };

        /**
         * Selects the context as default context according to the {@link CONTEXT context mode}.<br/>
         * Once a context is selected, methods can be applied to it.
         * @param {CONTEXT} contextMode - select one context among {@link CONTEXT context}
         * @returns {boolean} True when the contextMode is known otherwise False
         * @function setActivatedContext
         * @memberOf Mizar#
         * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
         */
        Mizar.prototype.setActivatedContext = function (contextMode) {
            var result;
            switch (contextMode) {
                case Mizar.CONTEXT.Planet:
                    this.activatedContext = this.planetContext;
                    result = true;
                    break;
                case Mizar.CONTEXT.Sky:
                    this.activatedContext = this.skyContext;
                    result = true;
                    break;
                case Mizar.CONTEXT.Ground:
                    this.activatedContext = this.groundContext;
                    result = true;
                    break;
                default:
                    result = false;
                    ErrorDialog.open("Cannot set the context : <font style='color:orange'><b>" + contextMode + " is not supported</b></font>", true);
            }
        };

        /**
         * Returns the mode in which the active context is set.
         * @function getMode
         * @memberOf Mizar#
         * @returns {CONTEXT|null} Returns the mode otherwise null when no created context
         */
        Mizar.prototype.getMode = function() {
            var result;
            var context = this.getActivatedContext();
            if(context) {
                result = context.getMode();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Returns the rendering context.
         * @returns {RenderContext|null} the rendering context
         * @function getRenderContext
         * @memberOf Mizar#
         */
        Mizar.prototype.getRenderContext = function () {
            var result;
            var context = this.getActivatedContext();
            if(context) {
                result = context.getRenderContext();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Returns the options
         * @function getOptions
         * @memberOf Mizar#
         * @throws ReferenceError - Will throw an exception when no context has been created.
         * @returns {Mizar.parameters} - Mizar's options
         */
        Mizar.prototype.getOptions = function () {
            return this.options;
        };


        //               ***************************** coordinate reference *****************************

        /**
         * Returns the coordinate reference system related to the selected {@link CONTEXT context}
         * @returns {Crs|null} the coordinate reference system or null when no created context
         * @function getCrs
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.getCrs = function () {
            var result;
            var context = this.getActivatedContext();
            if(context) {
                result = context.getCoordinateSystem();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Sets the coordinate reference system related to the selected {@link CONTEXT context}
         * @param {AbstractProjection.configuration|AbstractProjection.azimuth_configuration|AbstractProjection.mercator_configuration} coordinateSystem - coordinate system description
         * @returns {boolean} True when the coordinate system is set otherwise False when an error occurs
         * @function setCrs
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.setCrs = function (coordinateSystem) {
            var result;
            var context = this.getActivatedContext();
            if(context) {
                var crs = CoordinateSystemFactory.create(coordinateSystem);
                context.setCoordinateSystem(crs);
                result = true;
            } else {
                result = false;
            }
            return result;
        };

        //               ***************************** context management *****************************

        /**
         * Creates a context according to the {@link CONTEXT context mode}.<br/>
         * @param {CONTEXT} contextMode - Select on context among {@link CONTEXT context}
         * @param {AbstractContext.skyContext|AbstractContext.planetContext|AbstractContext.groundContext} options - Options for the context, See options.planetContext or options.skycontext configuration for {@link Mizar}
         * @retuns {boolean} True when the context is created otherwise false when the contextMode is unknown
         * @throws {RangeError} contextMode not valid - a valid contextMode is included in the list {@link CONTEXT}
         * @function createContext
         * @memberOf Mizar#
         */
        Mizar.prototype.createContext = function (contextMode, options) {
            var result;
            try {
                options.renderContext = this.renderContext;
                var ctx = this.ContextFactory.create(contextMode, this.getOptions(), options);
                switch (contextMode) {
                    case Mizar.CONTEXT.Sky:
                        this.skyContext = ctx;
                        _loadHIPSLayers(this, this.getOptions().configuration);
                        break;
                    case Mizar.CONTEXT.Planet:
                        this.planetContext = ctx;
                        break;
                    case Mizar.CONTEXT.Ground:
                        this.groundContext = ctx;
                        break;
                    default:
                        throw new RangeError("Unknown contextMode '" + contextMode + "'", "Mizar.js");
                }
                this.renderContext = ctx.getRenderContext();
                result = true;
            } catch (e) {
                result = false;
                ErrorDialog.open("Cannot create the context : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Switches 2D <--> 3D, only for planetary context. <br/>
         * When this method is used in a sky context, and exception is thrown
         * @returns {boolean} True when toggle works otherwise False
         * @function toggleDimension
         * @memberOf Mizar#
         */
        Mizar.prototype.toggleDimension = function () {
            var result;
            try {
                _skipIfSkyMode.call(this);
                if (this.getCrs().isFlat()) {
                    // we are in 2D and we are going to 3D
                    _switch2Dto3D.call(this);
                } else {
                    // we are in 3D and we are goint to 2D
                    _switch3Dto2D.call(this);
                }
                this.render();
                result = true;
            } catch (e) {
                result = false;
                ErrorDialog.open("Cannot toggle the dimension : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Switches To a context.
         * @param {AbstractContext} context - target context
         * @param {Object} [options] - options management for the source context
         * @param {boolean} options.mustBeDestroyed=false - options management for the source context
         * @param {Function} callback - Call at the end of the toggle
         * @fires Mizar#mizarMode:toggle
         * @function toggleToContext
         * @memberOf Mizar#
         */
        Mizar.prototype.toggleToContext = function (context, options, callback) {
            var result;
            try {
                var toggleMode = (this.getActivatedContext().getMode() === Mizar.CONTEXT.Sky) ? Mizar.CONTEXT.Planet : Mizar.CONTEXT.Sky;
                var self = this;
                _switchToContext.call(this, context, options);
                if (callback) {
                    callback.call(self);
                }
                result = true;
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot toggle the context : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        //               ***************************** layer management *****************************

        /**
         * Returns the sky layers, which have been added by {@link Mizar#addLayer}.
         * @function getSkyLayers
         * @returns {Layer[]|null} the layers
         * @memberOf Mizar#
         */
        Mizar.prototype.getSkyLayers = function () {
            var result;
            var context = this.getSkyContext();
            if(context) {
                result = context.getLayers();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Returns the planet layers, which have been added by {@link Mizar#addLayer}
         * @function getPlanetLayers
         * @returns {Layer[]|null} the layers
         * @memberOf Mizar#
         */
        Mizar.prototype.getPlanetLayers = function () {
            var result;
            var context = this.getPlanetContext();
            if(context) {
                result = context.getLayers();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Returns the grounds layers, which have been added by {@link Mizar#addLayer}
         * @function getGroundLayers
         * @returns {Layer[]|null} the layers
         * @memberOf Mizar#
         */
        Mizar.prototype.getGroundLayers = function () {
            var result;
            var context = this.getGroundContext();
            if(context) {
                result = context.getLayers();
            } else {
                result = null;
            }
            return result;
        };

        /**
         * Returns the layers for a specific context.<br/>
         * When no context is specified, the layers from the selected context are returned.
         * @function getLayers
         * @param {CONTEXT|null} mode - Context on which the function is applied
         * @returns {Layer[]} the layers
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.getLayers = function (mode) {
            var result;
            try {
                result = _getContext.call(this, mode).getLayers();
            } catch(e) {
                result = null;
                ErrorDialog.open("Cannot get the layers : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Returns all the layers regardless of the {@link CONTEXT context}.
         * @function getAllLayers
         * @return {Layer[]} the layers
         * @memberOf Mizar#
         */
        Mizar.prototype.getAllLayers = function () {
            return _.union(this.getSkyLayers(), this.getPlanetLayers());
        };

        /**
         * Returns the layer by its ID according to the {@link CONTEXT context}.<br/>
         * When no context is specified, the layer from the selected context is returned.<br/>
         * The ID is a unique layer identifier, which is returned when the layer description is {@link Mizar#addLayer added}
         * to Mizar
         * @function getLayerByID
         * @param {string} layerID - Layer's ID
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {Layer|undefined|null} The layer or undefined when the layer is not found
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.getLayerByID = function (layerID, mode) {
            var result;
            try {
                result = _getContext.call(this, mode).getLayerByID(layerID);
            } catch(e) {
                result = null;
                ErrorDialog.open("Cannot get the layer by ID : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Returns the layer by its name according to the {@link CONTEXT context}.<br/>
         * When no context is specified, the layer from the selected context is returned.<br/>
         * <b>Note:</b> The name may not be unique. In this case, the first layer having this name is returned
         * @function getLayerByName
         * @param {string} layerName - Layer's name, provided in the layer description when the layer is {@link Mizar#addLayer added}
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {Layer|undefined|null} the layer or undefined when the layer is not found
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.getLayerByName = function (layerName, mode) {
            var result;
            try {
                result = _getContext.call(this, mode).getLayerByName(layerName);
            } catch(e) {
                result = null;
                ErrorDialog.open("Cannot get the layer by name : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };


        /**
         * Adds a layer according to the selected {@link CONTEXT context}.<br/>
         * When layerPlanet is not provided, then the layer is added to the selected context otherwise the layer
         * is added to the layerPlanet.
         *
         * @function addLayer
         * @param {Object} layerDescription - See the base properties {@link AbstractLayer.configuration} and a specific layer for specific properties
         * @returns {string|null} a unique identifier or null when a problem happens
         * @memberOf Mizar#
         * @listens AbstractLayer#visibility:changed
         * @see {@link module:Layer.AtmosphereLayer AtmosphereLayer} : A layer to create an atmosphere on a planet.
         * @see {@link module:Layer.BingLayer BingLayer}: The Microsoft service proving a WMTS server.
         * @see {@link module:Layer.CoordinateGridLayer CoordinateGridLayer} : A layer to create a grid on the sky
         * @see {@link module:Layer.GeoJsonLayer GeoJSONLayer} : A layer to add a GeoJSON on the globe
         * @see {@link module:Layer.GroundOverlayLayer GroundOverlayLayer} : A layer to draw an image overlay draped onto the terrain
         * @see {@link module:Layer.HipsCatLayer HipsCatLayer} : A layer to draw a HIPS catalogue
         * @see {@link module:Layer.HipsFitsLayer HipsFitsLayer} : A layer to draw an Hips Fits
         * @see {@link module:Layer.HipsGraphicLayer HipsGraphicLayer} : A layer to draw a Hips JPEG/PNG
         * @see {@link module:Layer.MocLayer MocLayer} : A layer to draw a multi-order-coverage index
         * @see {@link module:Layer.OpenSearchLayer OpenSearchLayer} : A layer to draw the result from an open search service
         * @see {@link module:Layer.OSMLayer OSMLayer} : A layer to display data coming from OpenStreetMap server
         * @see {@link module:Layer.TileWireframeLayer TileWireframeLayer} : A layer to draw a grid on the planet
         * @see {@link module:Layer.VectorLayer VectorLayer} : A layer to draw a vector
         * @see {@link module:Layer.WCSElevationLayer WCSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.WMSElevationLayer WMSElevationLayer} : A layer to draw the elevation
         * @see {@link module:Layer.WMSLayer WMSLayer} : A layer to draw images coming from the WMS server
         * @see {@link module:Layer.WMTSLayer WMTSLayer} : A layer to draw predefined tiles coming from a WMTS server
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.addLayer = function (layerDescription) {
            var result;
            try {
                var layer = this.getActivatedContext().addLayer(layerDescription);
                result = layer.ID;
            } catch(e) {
                result = false;
                var prefixe;
                var text;
                var hipsLayer = layerDescription.hipsMetadata;
                if(hipsLayer != null) {
                    if (typeof hipsLayer.hipsMetadata.obs_title === 'undefined') {
                        prefixe = "ID ";
                        text = hipsLayer.hipsMetadata.ID;
                    } else {
                        prefixe = "";
                        text = hipsLayer.hipsMetadata.obs_title;
                    }
                    ErrorDialog.open("Hips layer " + prefixe + "<font style='color:yellow'><b>" + text + "</b></font> not valid in Hips registry <font color='grey'><i>(" + hipsLayer.hipsMetadata.hips_service_url + " - reason : "+ e.message +")</i></font>.");
                } else {
                    ErrorDialog.open("Cannot add the layer <font style='color:yellow'><b>" + JSON.stringify(layerDescription) + "</b></font><font color='grey'><i>(reason : "+ e.message +")</i></font>.");
                }
            }
            return result;
        };

        /**
         * Removes a layer by its ID according to the {@link CONTEXT context}.<br/>
         * When no context is specified, then the function is applied on the selected context.
         * @function removeLayer
         * @param {string} layerID - Layer's ID
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {boolean} True when the layer is added otherwise False
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.removeLayer = function (layerID, mode) {
            var result;
            try {
                var removedLayer = _getContext.call(this, mode).removeLayer(layerID);
                result = typeof removedLayer !== 'undefined';
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot remove the layer : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Sets the background layer according to the selected context.<br/>
         * When no context is specified, then the function is applied on the selected context.<br/>
         * <b>Note 1:</b> The name is not a unique identifier. The first layer matching at this name is returned<br/>
         * <b>Note 2:</b> The layer must be {@link Mizar#addLayer added} before
         * @function setBackgroundLayer
         * @param {string} layerName - Layer's name, which has been provided in the layer description
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {boolean} True when the layer is set as background otherwise False
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.setBackgroundLayer = function (layerName, mode) {
            var result;
            try {
                var gwLayer = _getContext.call(this, mode).setBackgroundLayer(layerName);
                result = typeof gwLayer !== 'undefined';
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot set the background : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Sets the background layer by ID according to the {@link CONTEXT context}.<br/>
         * When no context is specified, then the function is applied on the selected context.
         * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
         * @function setBackgroundLayerByID
         * @param {string} layerID - Unique layer identifier.
         * @param {CONTEXT|undefined} mode - Context on which the function is applied.
         * @returns {boolean} True when the layer is set as background otherwise False
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.setBackgroundLayerByID = function (layerID, mode) {
            var result;
            try {
                var gwLayer = _getContext.call(this, mode).setBackgroundLayerByID(layerID);
                result = typeof gwLayer !== 'undefined';
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot set the backgorund by ID : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Sets the base elevation by its layer's name according to the {@link CONTEXT context}.<br/>
         * When no context is specified, then the function is applied on the selected context.
         * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
         * @function setBaseElevation
         * @param {string} layerName - Name of the layer
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {boolean} True when the base elevation is set otherwise false
         * @memberOf Mizar#
         * @throws {RangeError} Will throw an error when the mode is not part of {@link CONTEXT}
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.setBaseElevation = function (layerName, mode) {
            var result;
            try {
                var layer = this.getLayerByName(layerName, mode);
                var gwLayer = _getContext.call(this, mode).setBaseElevation(layer);
                result = typeof gwLayer !== 'undefined';
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot set the base elevation : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Sets the base elevation by its layer's ID according to the {@link CONTEXT context}.<br/>
         * When no context is specified, then the function is applied on the selected context.
         * <b>Note:</b> The layer must be {@link Mizar#addLayer added} before
         * @function setBaseElevation
         * @param {string} layerID - ID of the layer
         * @param {CONTEXT|undefined} mode - Context on which the function is applied
         * @returns {boolean} True when the base elevation is set otherwise false
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.setBaseElevationByID = function (layerID, mode) {
            var result;
            try {
                var gwLayer = _getContext.call(this, mode).setBaseElevationByID(layerID);
                result =  typeof gwLayer !== 'undefined';
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot set the base elevation by ID : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Looks through each value in the list according to the context, returning an array of all the values that match the query.<br/>
         * The query is performed on the name and the description of each layer.<br/>
         * When no context is specified, the function is applied on the selected context.
         * @function searchOnLayerDescription
         * @param {string} query - query on the layer'name or description
         * @param {CONTEXT|undefined} mode - Context on which the query is run.
         * @returns {Layer[]}
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         */
        Mizar.prototype.searchOnLayerDescription = function (query, mode) {
            var layers = this.getLayers(mode);
            return _.filter(layers, function (layer) {
                return (  (String(layer.name).indexOf(query) >= 0) || (String(layer.description || "").indexOf(query) >= 0) );
            });
        };

        /**
         * Looks through each value in the sky layers, returning an array of all the values that match the query.<br/>
         * The query is performed on the name and the description of each layer
         * @function searchSkyLayer
         * @param {string} query - query on the layer's name or description
         * @returns {Layer[]} An array of layers matching the constraint
         * @memberOf Mizar#
         */
        Mizar.prototype.searchSkyLayer = function (query) {
            var layers = this.getSkyLayers();
            return _.filter(layers, function (layer) {
                return (  (String(layer.name).indexOf(query) >= 0) || (String(layer.description || "").indexOf(query) >= 0) );
            });
        };

        /**
         * Looks through each value in the planets layers, returning an array of all the values that match the query.<br/>
         * The query is performed on the name and the description of each layer
         * @function searchPlanetLayer
         * @param {string} query - query on the layer'name or description
         * @returns {Layer[]} An array of layers matching the constraint
         * @memberOf Mizar#
         */
        Mizar.prototype.searchPlanetLayer = function (query) {
            var layers = this.getPlanetLayers();
            //Search by name
            return _.filter(layers, function (layer) {
                return ( (String(layer.name).indexOf(query) >= 0) || (String(layer.description || "").indexOf(query) >= 0) );
            });
        };

        //               ***************************** Utility management *****************************

        /**
         * Registers no standard data provider in a predefined context.<br/>
         * When no context is specified, the function is applied to the selected context.
         * @function registerNoStandardDataProvider
         * @param {string} type - data provider key
         * @param {Function} loadFunc - Function to convert the data
         * @param {CONTEXT|undefined} mode - Context
         * @returns {boolean} True when data provider is registered otherwise False
         * @memberOf Mizar#
         * @see {@link Mizar#setActivatedContext}
         * @see {@link Mizar#createContext}
         * @example <caption>Registers planets on the sky</caption>
         *   var planetProvider = ProviderFactory.create(Mizar.PROVIDER.Planet);
         *   this.registerNoStandardDataProvider("planets", planetProvider.loadFiles);
         */
        Mizar.prototype.registerNoStandardDataProvider = function (type, loadFunc, mode) {
            var result;
            try {
                _getContext.call(this, mode).registerNoStandardDataProvider(type, loadFunc);
                result = true;
            } catch(e) {
                result = false;
                ErrorDialog.open("Cannot register the data provider : <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };

        /**
         * Apply proxy to url if needed
         * @function _getUrl
         * @memberOf Mizar#
         * @private
         */
        Mizar.prototype._getUrl = function (url) {
            var result;
            if (this.options.configuration.proxyUse === true) {
                result = this.options.configuration.proxyUrl + url;
            } else {
                result = url;
            }
            return result;
        };


        /**
         * Returns the service based on its name
         * @param {SERVICE} serviceName
         * @param {Object} options - options for the service
         * @memberOf Mizar#
         * @returns {Object|null} - the service
         */
        Mizar.prototype.getServiceByName = function (serviceName, options) {
            var result;
            try {
                result = ServiceFactory.create(serviceName, options);
            } catch(e) {
                result = null;
                ErrorDialog.open("Cannot get the service by name: <font style='color:orange'><b>" + e.message + "</b></font>", true);
            }
            return result;
        };


        /**
         * Creates and get Stats Object
         * @function createStats
         * @param {Object} options - Configuration properties for stats. See {@link Stats} for options
         * @returns {boolean} True when context fors tats exist otherwise False
         * @return {Stats}
         * @memberOf Mizar#

         */
        Mizar.prototype.createStats = function (options) {
            var result;
            if (this.skyContext) {
                this.Stats = new Stats(this.skyContext, options);
                result = true;
            } else if (this.planetContext) {
                this.Stats = new Stats(this.planetContext, options);
                result = true;
            } else if (this.groundContext) {
                this.Stats = new Stats(this.groundContext, options);
                result = true;
            } else {
                result = false;
                ErrorDialog.open("Cannot create the stats", true);
            }
            return result;
        };

        //               ***************************** Rendering management *****************************


        /**
         * Renders the canvas.
         * @returns {boolean} True when the canvas is rendered otherwise False
         * @function render
         * @memberOf Mizar#
         */
        Mizar.prototype.render = function () {
            var result;
            var renderContext = this.getRenderContext();
            if(renderContext) {
                this.getRenderContext().frame();
                result = true;
            } else {
                result = false;
            }
            return result;
        };

        //               ***************************** Memory management *****************************

        /**
         * Disposes the Mizar's contexts (planet, sky and ground)
         * @function dispose
         * @memberOf Mizar#
         */
        Mizar.prototype.dispose = function () {
            if (this.planetContext) {
                this.planetContext.dispose();
            }
            if (this.skyContext) {
                this.skyContext.dispose();
            }
            if(this.groundContext) {
                this.groundContext.dispose();
            }
        };


        /**
         * Destroys Mizar
         * @function destroy
         * @memberOf Mizar#
         */
        Mizar.prototype.destroy = function () {
            if (this.planetContext) {
                this.planetContext.destroy();
            }
            if (this.skyContext) {
                this.skyContext.destroy();
            }
            if(this.groundContext) {
                this.groundContext.destroy();
            }
            this.activatedContext = null;
            this.renderContext = null;
            this.ContextFactory = null;
            this.LayerFactory = null;
            this.AnimationFactory = null;
            this.ServiceFactory = null;
            this.UtilityFactory = null;
        };


        // Make object MIZAR available in caller web page
        window.Mizar = Mizar;

        return Mizar;
    });

//The modules for your project will be inlined above
//this snippet. Ask almond to synchronously require the
//module value for 'main' here and return it as the
//value to use for the public API for the built file.
return require('Mizar');
}));
